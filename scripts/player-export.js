/*!
 * 
 *                                                                       
 *                              ::;;;;                                   
 *    ::,,,,::    ::,,  ,,,,::::::11ii::,,::,,,,::      ::::,,::,,,,::   
 *  ,,111111ii,,::1111::111111ii::111111::111111ii,,    ii11,,ii111111,, 
 *  11ii::;;11;;ii11::iiii::;;11;;11ii::ii11::::11ii    ii11;;11;;::ii11 
 *  11;;  ::11ii11;;::11ii  ::11ii11ii,,iiii..  iiii    ii11;;11::  ;;11 
 *  1111;;ii11;;11;;,,ii11::ii11;;ii11;;;;11;;;;11;;;;;;ii11::11ii;;11ii 
 *  11111111;;::11;;  ::ii1111;;  ::ii11::ii1111ii::11ii;;11,,;;1111ii:: 
 *  11;;,,::  ,,::,,      ::,,        ::::  ::::    ,,,,::::    ::,,     
 *  ;;;;                                                                 
 *                                                                       
 *  Build: 6/3/2019, 6:11:05 PM
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/features/player/export.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/plugins/DOMPurify/purify.min.js":
/*!********************************************!*\
  !*** ./js/plugins/DOMPurify/purify.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (e, t) {
  "object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (t),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
}(this, function () {
  "use strict";

  function e(e, t) {
    for (var n = t.length; n--;) {
      "string" == typeof t[n] && (t[n] = t[n].toLowerCase()), e[t[n]] = !0;
    }

    return e;
  }

  function t(e) {
    var t = {},
        n = void 0;

    for (n in e) {
      Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
    }

    return t;
  }

  function n(e) {
    if (Array.isArray(e)) {
      for (var t = 0, n = Array(e.length); t < e.length; t++) {
        n[t] = e[t];
      }

      return n;
    }

    return Array.from(e);
  }

  function o() {
    var h = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p(),
        g = function g(e) {
      return o(e);
    };

    if (g.version = "1.0.2", g.removed = [], !h || !h.document || 9 !== h.document.nodeType) return g.isSupported = !1, g;
    var y = h.document,
        v = !1,
        b = !1,
        T = h.document,
        A = h.DocumentFragment,
        x = h.HTMLTemplateElement,
        S = h.Node,
        k = h.NodeFilter,
        w = h.NamedNodeMap,
        E = void 0 === w ? h.NamedNodeMap || h.MozNamedAttrMap : w,
        O = h.Text,
        M = h.Comment,
        N = h.DOMParser,
        L = h.XMLHttpRequest,
        D = void 0 === L ? h.XMLHttpRequest : L,
        _ = h.encodeURI,
        R = void 0 === _ ? h.encodeURI : _;

    if ("function" == typeof x) {
      var C = T.createElement("template");
      C.content && C.content.ownerDocument && (T = C.content.ownerDocument);
    }

    var F = T,
        z = F.implementation,
        H = F.createNodeIterator,
        I = F.getElementsByTagName,
        j = F.createDocumentFragment,
        U = y.importNode,
        q = {};
    g.isSupported = z && void 0 !== z.createHTMLDocument && 9 !== T.documentMode;

    var W = null,
        B = e({}, [].concat(n(r), n(i), n(a), n(l), n(s))),
        G = null,
        P = e({}, [].concat(n(c), n(d), n(u), n(m))),
        V = null,
        X = null,
        Y = !0,
        K = !0,
        $ = !1,
        J = !1,
        Q = !1,
        Z = /\{\{[\s\S]*|[\s\S]*\}\}/gm,
        ee = /<%[\s\S]*|[\s\S]*%>/gm,
        te = !1,
        ne = !1,
        oe = !1,
        re = !1,
        ie = !1,
        ae = !1,
        le = !0,
        se = !0,
        ce = {},
        de = e({}, ["audio", "head", "math", "script", "style", "template", "svg", "video"]),
        ue = e({}, ["audio", "video", "img", "source", "image"]),
        me = e({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "summary", "title", "value", "style", "xmlns"]),
        fe = null,
        pe = T.createElement("form"),
        he = function he(o) {
      "object" !== (void 0 === o ? "undefined" : f(o)) && (o = {}), W = "ALLOWED_TAGS" in o ? e({}, o.ALLOWED_TAGS) : B, G = "ALLOWED_ATTR" in o ? e({}, o.ALLOWED_ATTR) : P, V = "FORBID_TAGS" in o ? e({}, o.FORBID_TAGS) : {}, X = "FORBID_ATTR" in o ? e({}, o.FORBID_ATTR) : {}, ce = "USE_PROFILES" in o && o.USE_PROFILES, Y = !1 !== o.ALLOW_ARIA_ATTR, K = !1 !== o.ALLOW_DATA_ATTR, $ = o.ALLOW_UNKNOWN_PROTOCOLS || !1, J = o.SAFE_FOR_JQUERY || !1, Q = o.SAFE_FOR_TEMPLATES || !1, te = o.WHOLE_DOCUMENT || !1, re = o.RETURN_DOM || !1, ie = o.RETURN_DOM_FRAGMENT || !1, ae = o.RETURN_DOM_IMPORT || !1, oe = o.FORCE_BODY || !1, le = !1 !== o.SANITIZE_DOM, se = !1 !== o.KEEP_CONTENT, Q && (K = !1), ie && (re = !0), ce && (W = e({}, [].concat(n(s))), G = [], !0 === ce.html && (e(W, r), e(G, c)), !0 === ce.svg && (e(W, i), e(G, d), e(G, m)), !0 === ce.svgFilters && (e(W, a), e(G, d), e(G, m)), !0 === ce.mathMl && (e(W, l), e(G, u), e(G, m))), o.ADD_TAGS && (W === B && (W = t(W)), e(W, o.ADD_TAGS)), o.ADD_ATTR && (G === P && (G = t(G)), e(G, o.ADD_ATTR)), o.ADD_URI_SAFE_ATTR && e(me, o.ADD_URI_SAFE_ATTR), se && (W["#text"] = !0), Object && "freeze" in Object && Object.freeze(o), fe = o;
    },
        ge = function ge(e) {
      g.removed.push({
        element: e
      });

      try {
        e.parentNode.removeChild(e);
      } catch (t) {
        e.outerHTML = "";
      }
    },
        ye = function ye(e, t) {
      g.removed.push({
        attribute: t.getAttributeNode(e),
        from: t
      }), t.removeAttribute(e);
    },
        ve = function ve(e) {
      var t = void 0,
          n = void 0;

      if (oe && (e = "<remove></remove>" + e), b) {
        try {
          e = R(e);
        } catch (e) {}

        var o = new D();
        o.responseType = "document", o.open("GET", "data:text/html;charset=utf-8," + e, !1), o.send(null), t = o.response;
      }

      if (v) try {
        t = new N().parseFromString(e, "text/html");
      } catch (e) {}
      return t && t.documentElement || ((n = (t = z.createHTMLDocument("")).body).parentNode.removeChild(n.parentNode.firstElementChild), n.outerHTML = e), I.call(t, te ? "html" : "body")[0];
    };

    g.isSupported && function () {
      var e = ve('<svg><g onload="this.parentNode.remove()"></g></svg>');
      e.querySelector("svg") || (b = !0);

      try {
        (e = ve('<svg><p><style><img src="</style><img src=x onerror=alert(1)//">')).querySelector("svg img") && (v = !0);
      } catch (e) {}
    }();

    var be = function be(e) {
      return H.call(e.ownerDocument || e, e, k.SHOW_ELEMENT | k.SHOW_COMMENT | k.SHOW_TEXT, function () {
        return k.FILTER_ACCEPT;
      }, !1);
    },
        Te = function Te(e) {
      return !(e instanceof O || e instanceof M) && !("string" == typeof e.nodeName && "string" == typeof e.textContent && "function" == typeof e.removeChild && e.attributes instanceof E && "function" == typeof e.removeAttribute && "function" == typeof e.setAttribute);
    },
        Ae = function Ae(e) {
      return "object" === (void 0 === S ? "undefined" : f(S)) ? e instanceof S : e && "object" === (void 0 === e ? "undefined" : f(e)) && "number" == typeof e.nodeType && "string" == typeof e.nodeName;
    },
        xe = function xe(e, t, n) {
      q[e] && q[e].forEach(function (e) {
        e.call(g, t, n, fe);
      });
    },
        Se = function Se(e) {
      var t = void 0;
      if (xe("beforeSanitizeElements", e, null), Te(e)) return ge(e), !0;
      var n = e.nodeName.toLowerCase();

      if (xe("uponSanitizeElement", e, {
        tagName: n,
        allowedTags: W
      }), !W[n] || V[n]) {
        if (se && !de[n] && "function" == typeof e.insertAdjacentHTML) try {
          e.insertAdjacentHTML("AfterEnd", e.innerHTML);
        } catch (e) {}
        return ge(e), !0;
      }

      return !J || e.firstElementChild || e.content && e.content.firstElementChild || !/</g.test(e.textContent) || (g.removed.push({
        element: e.cloneNode()
      }), e.innerHTML = e.textContent.replace(/</g, "&lt;")), Q && 3 === e.nodeType && (t = (t = (t = e.textContent).replace(Z, " ")).replace(ee, " "), e.textContent !== t && (g.removed.push({
        element: e.cloneNode()
      }), e.textContent = t)), xe("afterSanitizeElements", e, null), !1;
    },
        ke = /^data-[\-\w.\u00B7-\uFFFF]/,
        we = /^aria-[\-\w]+$/,
        Ee = /^(?:(?:(?:f|ht)tps?|mailto|tel):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
        Oe = /^(?:\w+script|data):/i,
        Me = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
        Ne = function Ne(e) {
      var t = void 0,
          n = void 0,
          o = void 0,
          r = void 0,
          i = void 0,
          a = void 0,
          l = void 0;

      if (xe("beforeSanitizeAttributes", e, null), a = e.attributes) {
        var s = {
          attrName: "",
          attrValue: "",
          keepAttr: !0,
          allowedAttributes: G
        };

        for (l = a.length; l--;) {
          if (t = a[l], n = t.name, o = t.value.trim(), r = n.toLowerCase(), s.attrName = r, s.attrValue = o, s.keepAttr = !0, xe("uponSanitizeAttribute", e, s), o = s.attrValue, "name" === r && "IMG" === e.nodeName && a.id) i = a.id, a = Array.prototype.slice.apply(a), ye("id", e), ye(n, e), a.indexOf(i) > l && e.setAttribute("id", i.value);else {
            if ("INPUT" === e.nodeName && "type" === r && "file" === o && (G[r] || !X[r])) continue;
            "id" === n && e.setAttribute(n, ""), ye(n, e);
          }

          if (s.keepAttr && (!le || "id" !== r && "name" !== r || !(o in h || o in T || o in pe))) {
            if (Q && (o = (o = o.replace(Z, " ")).replace(ee, " ")), K && ke.test(r)) ;else if (Y && we.test(r)) ;else {
              if (!G[r] || X[r]) continue;
              if (me[r]) ;else if (Ee.test(o.replace(Me, ""))) ;else if ("src" !== r && "xlink:href" !== r || 0 !== o.indexOf("data:") || !ue[e.nodeName.toLowerCase()]) {
                if ($ && !Oe.test(o.replace(Me, ""))) ;else if (o) continue;
              } else ;
            }

            try {
              e.setAttribute(n, o), g.removed.pop();
            } catch (e) {}
          }
        }

        xe("afterSanitizeAttributes", e, null);
      }
    },
        Le = function e(t) {
      var n = void 0,
          o = be(t);

      for (xe("beforeSanitizeShadowDOM", t, null); n = o.nextNode();) {
        xe("uponSanitizeShadowNode", n, null), Se(n) || (n.content instanceof A && e(n.content), Ne(n));
      }

      xe("afterSanitizeShadowDOM", t, null);
    };

    return g.sanitize = function (e, t) {
      var n = void 0,
          o = void 0,
          r = void 0,
          i = void 0,
          a = void 0;

      if (e || (e = "\x3c!--\x3e"), "string" != typeof e && !Ae(e)) {
        if ("function" != typeof e.toString) throw new TypeError("toString is not a function");
        e = e.toString();
      }

      if (!g.isSupported) {
        if ("object" === f(h.toStaticHTML) || "function" == typeof h.toStaticHTML) {
          if ("string" == typeof e) return h.toStaticHTML(e);
          if (Ae(e)) return h.toStaticHTML(e.outerHTML);
        }

        return e;
      }

      if (ne || he(t), g.removed = [], e instanceof S) 1 === (o = (n = ve("\x3c!--\x3e")).ownerDocument.importNode(e, !0)).nodeType && "BODY" === o.nodeName ? n = o : n.appendChild(o);else {
        if (!re && !te && -1 === e.indexOf("<")) return e;
        if (!(n = ve(e))) return re ? null : "";
      }
      oe && ge(n.firstChild);

      for (var l = be(n); r = l.nextNode();) {
        3 === r.nodeType && r === i || Se(r) || (r.content instanceof A && Le(r.content), Ne(r), i = r);
      }

      if (re) {
        if (ie) for (a = j.call(n.ownerDocument); n.firstChild;) {
          a.appendChild(n.firstChild);
        } else a = n;
        return ae && (a = U.call(y, a, !0)), a;
      }

      return te ? n.outerHTML : n.innerHTML;
    }, g.setConfig = function (e) {
      he(e), ne = !0;
    }, g.clearConfig = function () {
      fe = null, ne = !1;
    }, g.addHook = function (e, t) {
      "function" == typeof t && (q[e] = q[e] || [], q[e].push(t));
    }, g.removeHook = function (e) {
      q[e] && q[e].pop();
    }, g.removeHooks = function (e) {
      q[e] && (q[e] = []);
    }, g.removeAllHooks = function () {
      q = {};
    }, g;
  }

  var r = ["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"],
      i = ["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "audio", "canvas", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "video", "view", "vkern"],
      a = ["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "feSpecularLighting", "feTile", "feTurbulence"],
      l = ["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmuliscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mpspace", "msqrt", "mystyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"],
      s = ["#text"],
      c = ["accept", "action", "align", "alt", "autocomplete", "background", "bgcolor", "border", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "coords", "datetime", "default", "dir", "disabled", "download", "enctype", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "ismap", "label", "lang", "list", "loop", "low", "max", "maxlength", "media", "method", "min", "multiple", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "span", "srclang", "start", "src", "step", "style", "summary", "tabindex", "title", "type", "usemap", "valign", "value", "width", "xmlns"],
      d = ["accent-height", "accumulate", "additivive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"],
      u = ["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"],
      m = ["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"],
      f = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
    return _typeof(e);
  } : function (e) {
    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);
  },
      p = function p() {
    return "undefined" == typeof window ? null : window;
  };

  return o();
});

/***/ }),

/***/ "./js/plugins/bezier-easing/bezier-easing.js":
/*!***************************************************!*\
  !*** ./js/plugins/bezier-easing/bezier-easing.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * BezierEasing - use bezier curve for transition easing function
 * is based on Firefox's nsSMILKeySpline.cpp
 * Usage:
 * var spline = BezierEasing(0.25, 0.1, 0.25, 1.0)
 * spline(x) => returns the easing value | x must be in [0, 1] range
 *
 */
(function (definition) {
  if (( false ? undefined : _typeof(exports)) === "object") {
    module.exports = definition();
  } else if (typeof window.define === 'function' && window.define.amd) {
    window.define([], definition);
  } else {
    window.BezierEasing = definition();
  }
})(function () {
  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === "function";

  function BezierEasing(mX1, mY1, mX2, mY2) {
    // Validate arguments
    if (arguments.length !== 4) {
      throw new Error("BezierEasing requires 4 arguments.");
    }

    for (var i = 0; i < 4; ++i) {
      if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
        throw new Error("BezierEasing arguments should be integers.");
      }
    }

    if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
      throw new Error("BezierEasing x values must be in [0, 1] range.");
    }

    var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

    function A(aA1, aA2) {
      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }

    function B(aA1, aA2) {
      return 3.0 * aA2 - 6.0 * aA1;
    }

    function C(aA1) {
      return 3.0 * aA1;
    } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


    function calcBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


    function getSlope(aT, aA1, aA2) {
      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function newtonRaphsonIterate(aX, aGuessT) {
      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) return aGuessT;
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }

      return aGuessT;
    }

    function calcSampleValues() {
      for (var i = 0; i < kSplineTableSize; ++i) {
        mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function binarySubdivide(aX, aA, aB) {
      var currentX,
          currentT,
          i = 0;

      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;

        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

      return currentT;
    }

    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample; // Interpolate to provide an initial guess for t

      var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT);
      } else if (initialSlope == 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
      }
    }

    if (mX1 != mY1 || mX2 != mY2) calcSampleValues();

    var f = function f(aX) {
      if (mX1 === mY1 && mX2 === mY2) return aX; // linear
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.

      if (aX === 0) return 0;
      if (aX === 1) return 1;
      return calcBezier(getTForX(aX), mY1, mY2);
    };

    var str = "BezierEasing(" + [mX1, mY1, mX2, mY2] + ")";

    f.toString = function () {
      return str;
    };

    return f;
  } // CSS mapping


  BezierEasing.css = {
    "ease": BezierEasing(0.25, 0.1, 0.25, 1.0),
    "linear": BezierEasing(0.00, 0.0, 1.00, 1.0),
    "ease-in": BezierEasing(0.42, 0.0, 1.00, 1.0),
    "ease-out": BezierEasing(0.00, 0.0, 0.58, 1.0),
    "ease-in-out": BezierEasing(0.42, 0.0, 0.58, 1.0)
  };
  return BezierEasing;
});

/***/ }),

/***/ "./js/plugins/greensock/AttrPlugin.js":
/*!********************************************!*\
  !*** ./js/plugins/greensock/AttrPlugin.js ***!
  \********************************************/
/*! exports provided: AttrPlugin, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttrPlugin", function() { return AttrPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AttrPlugin; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/*!
 * VERSION: 0.6.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */

var AttrPlugin = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.plugin({
  propName: "attr",
  API: 2,
  version: "0.6.1",
  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
  init: function (target, value, tween, index) {
    var p, end;

    if (typeof target.setAttribute !== "function") {
      return false;
    }

    for (p in value) {
      end = value[p];

      if (typeof end === "function") {
        end = end(index, target);
      }

      this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);

      this._overwriteProps.push(p);
    }

    return true;
  }
});


/***/ }),

/***/ "./js/plugins/greensock/BezierPlugin.js":
/*!**********************************************!*\
  !*** ./js/plugins/greensock/BezierPlugin.js ***!
  \**********************************************/
/*! exports provided: BezierPlugin, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BezierPlugin", function() { return BezierPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BezierPlugin; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/*!
 * VERSION: 1.3.8
 * DATE: 2018-05-30
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/


var _RAD2DEG = 180 / Math.PI,
    _r1 = [],
    _r2 = [],
    _r3 = [],
    _corProps = {},
    _globals = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.globals,
    Segment = function (a, b, c, d) {
  if (c === d) {
    //if c and d match, the final autoRotate value could lock at -90 degrees, so differentiate them slightly.
    c = d - (d - b) / 1000000;
  }

  if (a === b) {
    //if a and b match, the starting autoRotate value could lock at -90 degrees, so differentiate them slightly.
    b = a + (c - a) / 1000000;
  }

  this.a = a;
  this.b = b;
  this.c = c;
  this.d = d;
  this.da = d - a;
  this.ca = c - a;
  this.ba = b - a;
},
    _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
    cubicToQuadratic = function (a, b, c, d) {
  var q1 = {
    a: a
  },
      q2 = {},
      q3 = {},
      q4 = {
    c: d
  },
      mab = (a + b) / 2,
      mbc = (b + c) / 2,
      mcd = (c + d) / 2,
      mabc = (mab + mbc) / 2,
      mbcd = (mbc + mcd) / 2,
      m8 = (mbcd - mabc) / 8;
  q1.b = mab + (a - mab) / 4;
  q2.b = mabc + m8;
  q1.c = q2.a = (q1.b + q2.b) / 2;
  q2.c = q3.a = (mabc + mbcd) / 2;
  q3.b = mbcd - m8;
  q4.b = mcd + (d - mcd) / 4;
  q3.c = q4.a = (q3.b + q4.b) / 2;
  return [q1, q2, q3, q4];
},
    _calculateControlPoints = function (a, curviness, quad, basic, correlate) {
  var l = a.length - 1,
      ii = 0,
      cp1 = a[0].a,
      i,
      p1,
      p2,
      p3,
      seg,
      m1,
      m2,
      mm,
      cp2,
      qb,
      r1,
      r2,
      tl;

  for (i = 0; i < l; i++) {
    seg = a[ii];
    p1 = seg.a;
    p2 = seg.d;
    p3 = a[ii + 1].d;

    if (correlate) {
      r1 = _r1[i];
      r2 = _r2[i];
      tl = (r2 + r1) * curviness * 0.25 / (basic ? 0.5 : _r3[i] || 0.5);
      m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : r1 !== 0 ? tl / r1 : 0);
      m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : r2 !== 0 ? tl / r2 : 0);
      mm = p2 - (m1 + ((m2 - m1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
    } else {
      m1 = p2 - (p2 - p1) * curviness * 0.5;
      m2 = p2 + (p3 - p2) * curviness * 0.5;
      mm = p2 - (m1 + m2) / 2;
    }

    m1 += mm;
    m2 += mm;
    seg.c = cp2 = m1;

    if (i !== 0) {
      seg.b = cp1;
    } else {
      seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
    }

    seg.da = p2 - p1;
    seg.ca = cp2 - p1;
    seg.ba = cp1 - p1;

    if (quad) {
      qb = cubicToQuadratic(p1, cp1, cp2, p2);
      a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
      ii += 4;
    } else {
      ii++;
    }

    cp1 = m2;
  }

  seg = a[ii];
  seg.b = cp1;
  seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.

  seg.da = seg.d - seg.a;
  seg.ca = seg.c - seg.a;
  seg.ba = cp1 - seg.a;

  if (quad) {
    qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
    a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
  }
},
    _parseAnchors = function (values, p, correlate, prepend) {
  var a = [],
      l,
      i,
      p1,
      p2,
      p3,
      tmp;

  if (prepend) {
    values = [prepend].concat(values);
    i = values.length;

    while (--i > -1) {
      if (typeof (tmp = values[i][p]) === "string") if (tmp.charAt(1) === "=") {
        values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
      }
    }
  }

  l = values.length - 2;

  if (l < 0) {
    a[0] = new Segment(values[0][p], 0, 0, values[0][p]);
    return a;
  }

  for (i = 0; i < l; i++) {
    p1 = values[i][p];
    p2 = values[i + 1][p];
    a[i] = new Segment(p1, 0, 0, p2);

    if (correlate) {
      p3 = values[i + 2][p];
      _r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
      _r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
    }
  }

  a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
  return a;
},
    bezierThrough = function (values, curviness, quadratic, basic, correlate, prepend) {
  var obj = {},
      props = [],
      first = prepend || values[0],
      i,
      p,
      a,
      j,
      r,
      l,
      seamless,
      last;
  correlate = typeof correlate === "string" ? "," + correlate + "," : _correlate;

  if (curviness == null) {
    curviness = 1;
  }

  for (p in values[0]) {
    props.push(p);
  } //check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)


  if (values.length > 1) {
    last = values[values.length - 1];
    seamless = true;
    i = props.length;

    while (--i > -1) {
      p = props[i];

      if (Math.abs(first[p] - last[p]) > 0.05) {
        //build in a tolerance of +/-0.05 to accommodate rounding errors.
        seamless = false;
        break;
      }
    }

    if (seamless) {
      values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens

      if (prepend) {
        values.unshift(prepend);
      }

      values.push(values[1]);
      prepend = values[values.length - 3];
    }
  }

  _r1.length = _r2.length = _r3.length = 0;
  i = props.length;

  while (--i > -1) {
    p = props[i];
    _corProps[p] = correlate.indexOf("," + p + ",") !== -1;
    obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
  }

  i = _r1.length;

  while (--i > -1) {
    _r1[i] = Math.sqrt(_r1[i]);
    _r2[i] = Math.sqrt(_r2[i]);
  }

  if (!basic) {
    i = props.length;

    while (--i > -1) {
      if (_corProps[p]) {
        a = obj[props[i]];
        l = a.length - 1;

        for (j = 0; j < l; j++) {
          r = a[j + 1].da / _r2[j] + a[j].da / _r1[j] || 0;
          _r3[j] = (_r3[j] || 0) + r * r;
        }
      }
    }

    i = _r3.length;

    while (--i > -1) {
      _r3[i] = Math.sqrt(_r3[i]);
    }
  }

  i = props.length;
  j = quadratic ? 4 : 1;

  while (--i > -1) {
    p = props[i];
    a = obj[p];

    _calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties


    if (seamless) {
      a.splice(0, j);
      a.splice(a.length - j, j);
    }
  }

  return obj;
},
    _parseBezierData = function (values, type, prepend) {
  type = type || "soft";
  var obj = {},
      inc = type === "cubic" ? 3 : 2,
      soft = type === "soft",
      props = [],
      a,
      b,
      c,
      d,
      cur,
      i,
      j,
      l,
      p,
      cnt,
      tmp;

  if (soft && prepend) {
    values = [prepend].concat(values);
  }

  if (values == null || values.length < inc + 1) {
    throw "invalid Bezier data";
  }

  for (p in values[0]) {
    props.push(p);
  }

  i = props.length;

  while (--i > -1) {
    p = props[i];
    obj[p] = cur = [];
    cnt = 0;
    l = values.length;

    for (j = 0; j < l; j++) {
      a = prepend == null ? values[j][p] : typeof (tmp = values[j][p]) === "string" && tmp.charAt(1) === "=" ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
      if (soft) if (j > 1) if (j < l - 1) {
        cur[cnt++] = (a + cur[cnt - 2]) / 2;
      }
      cur[cnt++] = a;
    }

    l = cnt - inc + 1;
    cnt = 0;

    for (j = 0; j < l; j += inc) {
      a = cur[j];
      b = cur[j + 1];
      c = cur[j + 2];
      d = inc === 2 ? 0 : cur[j + 3];
      cur[cnt++] = tmp = inc === 3 ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
    }

    cur.length = cnt;
  }

  return obj;
},
    _addCubicLengths = function (a, steps, resolution) {
  var inc = 1 / resolution,
      j = a.length,
      d,
      d1,
      s,
      da,
      ca,
      ba,
      p,
      i,
      inv,
      bez,
      index;

  while (--j > -1) {
    bez = a[j];
    s = bez.a;
    da = bez.d - s;
    ca = bez.c - s;
    ba = bez.b - s;
    d = d1 = 0;

    for (i = 1; i <= resolution; i++) {
      p = inc * i;
      inv = 1 - p;
      d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
      index = j * resolution + i - 1;
      steps[index] = (steps[index] || 0) + d * d;
    }
  }
},
    _parseLengthData = function (obj, resolution) {
  resolution = resolution >> 0 || 6;
  var a = [],
      lengths = [],
      d = 0,
      total = 0,
      threshold = resolution - 1,
      segments = [],
      curLS = [],
      //current length segments array
  p,
      i,
      l,
      index;

  for (p in obj) {
    _addCubicLengths(obj[p], a, resolution);
  }

  l = a.length;

  for (i = 0; i < l; i++) {
    d += Math.sqrt(a[i]);
    index = i % resolution;
    curLS[index] = d;

    if (index === threshold) {
      total += d;
      index = i / resolution >> 0;
      segments[index] = curLS;
      lengths[index] = total;
      d = 0;
      curLS = [];
    }
  }

  return {
    length: total,
    lengths: lengths,
    segments: segments
  };
},
    BezierPlugin = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.plugin({
  propName: "bezier",
  priority: -1,
  version: "1.3.8",
  API: 2,
  global: true,
  //gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
  init: function (target, vars, tween) {
    this._target = target;

    if (vars instanceof Array) {
      vars = {
        values: vars
      };
    }

    this._func = {};
    this._mod = {};
    this._props = [];
    this._timeRes = vars.timeResolution == null ? 6 : parseInt(vars.timeResolution, 10);
    var values = vars.values || [],
        first = {},
        second = values[0],
        autoRotate = vars.autoRotate || tween.vars.orientToBezier,
        p,
        isFunc,
        i,
        j,
        prepend;
    this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [["x", "y", "rotation", autoRotate === true ? 0 : Number(autoRotate) || 0]] : null;

    for (p in second) {
      this._props.push(p);
    }

    i = this._props.length;

    while (--i > -1) {
      p = this._props[i];

      this._overwriteProps.push(p);

      isFunc = this._func[p] = typeof target[p] === "function";
      first[p] = !isFunc ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]();
      if (!prepend) if (first[p] !== values[0][p]) {
        prepend = first;
      }
    }

    this._beziers = vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft" ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, vars.type === "thruBasic", vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
    this._segCount = this._beziers[p].length;

    if (this._timeRes) {
      var ld = _parseLengthData(this._beziers, this._timeRes);

      this._length = ld.length;
      this._lengths = ld.lengths;
      this._segments = ld.segments;
      this._l1 = this._li = this._s1 = this._si = 0;
      this._l2 = this._lengths[0];
      this._curSeg = this._segments[0];
      this._s2 = this._curSeg[0];
      this._prec = 1 / this._curSeg.length;
    }

    if (autoRotate = this._autoRotate) {
      this._initialRotations = [];

      if (!(autoRotate[0] instanceof Array)) {
        this._autoRotate = autoRotate = [autoRotate];
      }

      i = autoRotate.length;

      while (--i > -1) {
        for (j = 0; j < 3; j++) {
          p = autoRotate[i][j];
          this._func[p] = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)] : false;
        }

        p = autoRotate[i][2];
        this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;

        this._overwriteProps.push(p);
      }
    }

    this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.

    return true;
  },
  //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
  set: function (v) {
    var segments = this._segCount,
        func = this._func,
        target = this._target,
        notStart = v !== this._startRatio,
        curIndex,
        inv,
        i,
        p,
        b,
        t,
        val,
        l,
        lengths,
        curSeg;

    if (!this._timeRes) {
      curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0;
      t = (v - curIndex * (1 / segments)) * segments;
    } else {
      lengths = this._lengths;
      curSeg = this._curSeg;
      v *= this._length;
      i = this._li; //find the appropriate segment (if the currently cached one isn't correct)

      if (v > this._l2 && i < segments - 1) {
        l = segments - 1;

        while (i < l && (this._l2 = lengths[++i]) <= v) {}

        this._l1 = lengths[i - 1];
        this._li = i;
        this._curSeg = curSeg = this._segments[i];
        this._s2 = curSeg[this._s1 = this._si = 0];
      } else if (v < this._l1 && i > 0) {
        while (i > 0 && (this._l1 = lengths[--i]) >= v) {}

        if (i === 0 && v < this._l1) {
          this._l1 = 0;
        } else {
          i++;
        }

        this._l2 = lengths[i];
        this._li = i;
        this._curSeg = curSeg = this._segments[i];
        this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
        this._s2 = curSeg[this._si];
      }

      curIndex = i; //now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)

      v -= this._l1;
      i = this._si;

      if (v > this._s2 && i < curSeg.length - 1) {
        l = curSeg.length - 1;

        while (i < l && (this._s2 = curSeg[++i]) <= v) {}

        this._s1 = curSeg[i - 1];
        this._si = i;
      } else if (v < this._s1 && i > 0) {
        while (i > 0 && (this._s1 = curSeg[--i]) >= v) {}

        if (i === 0 && v < this._s1) {
          this._s1 = 0;
        } else {
          i++;
        }

        this._s2 = curSeg[i];
        this._si = i;
      }

      t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
    }

    inv = 1 - t;
    i = this._props.length;

    while (--i > -1) {
      p = this._props[i];
      b = this._beziers[p][curIndex];
      val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;

      if (this._mod[p]) {
        val = this._mod[p](val, target);
      }

      if (func[p]) {
        target[p](val);
      } else {
        target[p] = val;
      }
    }

    if (this._autoRotate) {
      var ar = this._autoRotate,
          b2,
          x1,
          y1,
          x2,
          y2,
          add,
          conv;
      i = ar.length;

      while (--i > -1) {
        p = ar[i][2];
        add = ar[i][3] || 0;
        conv = ar[i][4] === true ? 1 : _RAD2DEG;
        b = this._beziers[ar[i][0]];
        b2 = this._beziers[ar[i][1]];

        if (b && b2) {
          //in case one of the properties got overwritten.
          b = b[curIndex];
          b2 = b2[curIndex];
          x1 = b.a + (b.b - b.a) * t;
          x2 = b.b + (b.c - b.b) * t;
          x1 += (x2 - x1) * t;
          x2 += (b.c + (b.d - b.c) * t - x2) * t;
          y1 = b2.a + (b2.b - b2.a) * t;
          y2 = b2.b + (b2.c - b2.b) * t;
          y1 += (y2 - y1) * t;
          y2 += (b2.c + (b2.d - b2.c) * t - y2) * t;
          val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

          if (this._mod[p]) {
            val = this._mod[p](val, target); //for modProps
          }

          if (func[p]) {
            target[p](val);
          } else {
            target[p] = val;
          }
        }
      }
    }
  }
}),
    p = BezierPlugin.prototype;

BezierPlugin.bezierThrough = bezierThrough;
BezierPlugin.cubicToQuadratic = cubicToQuadratic;
BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite

BezierPlugin.quadraticToCubic = function (a, b, c) {
  return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
};

BezierPlugin._cssRegister = function () {
  var CSSPlugin = _globals.CSSPlugin;

  if (!CSSPlugin) {
    return;
  }

  var _internals = CSSPlugin._internals,
      _parseToProxy = _internals._parseToProxy,
      _setPluginRatio = _internals._setPluginRatio,
      CSSPropTween = _internals.CSSPropTween;

  _internals._registerComplexSpecialProp("bezier", {
    parser: function (t, e, prop, cssp, pt, plugin) {
      if (e instanceof Array) {
        e = {
          values: e
        };
      }

      plugin = new BezierPlugin();
      var values = e.values,
          l = values.length - 1,
          pluginValues = [],
          v = {},
          i,
          p,
          data;

      if (l < 0) {
        return pt;
      }

      for (i = 0; i <= l; i++) {
        data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i);
        pluginValues[i] = data.end;
      }

      for (p in e) {
        v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
      }

      v.values = pluginValues;
      pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
      pt.data = data;
      pt.plugin = plugin;
      pt.setRatio = _setPluginRatio;

      if (v.autoRotate === 0) {
        v.autoRotate = true;
      }

      if (v.autoRotate && !(v.autoRotate instanceof Array)) {
        i = v.autoRotate === true ? 0 : Number(v.autoRotate);
        v.autoRotate = data.end.left != null ? [["left", "top", "rotation", i, false]] : data.end.x != null ? [["x", "y", "rotation", i, false]] : false;
      }

      if (v.autoRotate) {
        if (!cssp._transform) {
          cssp._enableTransforms(false);
        }

        data.autoRotate = cssp._target._gsTransform;
        data.proxy.rotation = data.autoRotate.rotation || 0;

        cssp._overwriteProps.push("rotation");
      }

      plugin._onInitTween(data.proxy, v, cssp._tween);

      return pt;
    }
  });
};

p._mod = function (lookup) {
  var op = this._overwriteProps,
      i = op.length,
      val;

  while (--i > -1) {
    val = lookup[op[i]];

    if (val && typeof val === "function") {
      this._mod[op[i]] = val;
    }
  }
};

p._kill = function (lookup) {
  var a = this._props,
      p,
      i;

  for (p in this._beziers) {
    if (p in lookup) {
      delete this._beziers[p];
      delete this._func[p];
      i = a.length;

      while (--i > -1) {
        if (a[i] === p) {
          a.splice(i, 1);
        }
      }
    }
  }

  a = this._autoRotate;

  if (a) {
    i = a.length;

    while (--i > -1) {
      if (lookup[a[i][2]]) {
        a.splice(i, 1);
      }
    }
  }

  return this._super._kill.call(this, lookup);
};



/***/ }),

/***/ "./js/plugins/greensock/CSSPlugin.js":
/*!*******************************************!*\
  !*** ./js/plugins/greensock/CSSPlugin.js ***!
  \*******************************************/
/*! exports provided: CSSPlugin, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return CSSPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CSSPlugin; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */


_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function () {
  /** @constructor **/
  var CSSPlugin = function () {
    _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenPlugin"].call(this, "css");
    this._overwriteProps.length = 0;
    this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
  },
      _globals = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.globals,
      _hasPriority,
      //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
  _suffixMap,
      //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
  _cs,
      //computed style (we store this in a shared variable to conserve memory and make minification tighter
  _overwriteProps,
      //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
  _specialProps = {},
      p = CSSPlugin.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenPlugin"]("css");

  p.constructor = CSSPlugin;
  CSSPlugin.version = "2.0.2";
  CSSPlugin.API = 2;
  CSSPlugin.defaultTransformPerspective = 0;
  CSSPlugin.defaultSkewType = "compensated";
  CSSPlugin.defaultSmoothOrigin = true;
  p = "px"; //we'll reuse the "p" variable to keep file size down

  CSSPlugin.suffixMap = {
    top: p,
    right: p,
    bottom: p,
    left: p,
    width: p,
    height: p,
    fontSize: p,
    padding: p,
    margin: p,
    perspective: p,
    lineHeight: ""
  };

  var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
      _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
      _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
      //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
  _NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
      //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
  _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
      _opacityExp = /opacity *= *([^)]*)/i,
      _opacityValExp = /opacity:([^;]*)/i,
      _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
      _rgbhslExp = /^(rgb|hsl)/,
      _capsExp = /([A-Z])/g,
      _camelExp = /-([a-z])/gi,
      _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
      //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
  _camelFunc = function (s, g) {
    return g.toUpperCase();
  },
      _horizExp = /(?:Left|Right|Width)/i,
      _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
      _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
      _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
      //finds any commas that are not within parenthesis
  _complexExp = /[\s,\(]/i,
      //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
  _DEG2RAD = Math.PI / 180,
      _RAD2DEG = 180 / Math.PI,
      _forcePT = {},
      _dummyElement = {
    style: {}
  },
      _doc = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].document || {
    createElement: function () {
      return _dummyElement;
    }
  },
      _createElement = function (type, ns) {
    return _doc.createElementNS ? _doc.createElementNS(ns || "http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
  },
      _tempDiv = _createElement("div"),
      _tempImg = _createElement("img"),
      _internals = CSSPlugin._internals = {
    _specialProps: _specialProps
  },
      //provides a hook to a few internal methods that we need to access from inside other plugins
  _agent = (_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].navigator || {}).userAgent || "",
      _autoRound,
      _reqSafariFix,
      //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).
  _isSafari,
      _isFirefox,
      //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
  _isSafariLT6,
      //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
  _ieVers,
      _supportsOpacity = function () {
    //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
    var i = _agent.indexOf("Android"),
        a = _createElement("a");

    _isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || parseFloat(_agent.substr(i + 8, 2)) > 3);
    _isSafariLT6 = _isSafari && parseFloat(_agent.substr(_agent.indexOf("Version/") + 8, 2)) < 6;
    _isFirefox = _agent.indexOf("Firefox") !== -1;

    if (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) {
      _ieVers = parseFloat(RegExp.$1);
    }

    if (!a) {
      return false;
    }

    a.style.cssText = "top:1px;opacity:.55;";
    return /^0.55/.test(a.style.opacity);
  }(),
      _getIEOpacity = function (v) {
    return _opacityExp.test(typeof v === "string" ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
  },
      _log = function (s) {
    //for logging messages, but in a way that won't throw errors in old versions of IE.
    if (_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].console) {
      console.log(s);
    }
  },
      _target,
      //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params
  _index,
      //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params
  _prefixCSS = "",
      //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
  _prefix = "",
      //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".
  // @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
  _checkPropPrefix = function (p, e) {
    e = e || _tempDiv;
    var s = e.style,
        a,
        i;

    if (s[p] !== undefined) {
      return p;
    }

    p = p.charAt(0).toUpperCase() + p.substr(1);
    a = ["O", "Moz", "ms", "Ms", "Webkit"];
    i = 5;

    while (--i > -1 && s[a[i] + p] === undefined) {}

    if (i >= 0) {
      _prefix = i === 3 ? "ms" : a[i];
      _prefixCSS = "-" + _prefix.toLowerCase() + "-";
      return _prefix + p;
    }

    return null;
  },
      _getComputedStyle = (typeof window !== "undefined" ? window : _doc.defaultView || {
    getComputedStyle: function () {}
  }).getComputedStyle,

  /**
   * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
   * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
   *
   * @param {!Object} t Target element whose style property you want to query
   * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
   * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
   * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
   * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
   * @return {?string} The current property value
   */
  _getStyle = CSSPlugin.getStyle = function (t, p, cs, calc, dflt) {
    var rv;
    if (!_supportsOpacity) if (p === "opacity") {
      //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
      return _getIEOpacity(t);
    }

    if (!calc && t.style[p]) {
      rv = t.style[p];
    } else if (cs = cs || _getComputedStyle(t)) {
      rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
    } else if (t.currentStyle) {
      rv = t.currentStyle[p];
    }

    return dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto") ? dflt : rv;
  },

  /**
   * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
   * @param {!Object} t Target element
   * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
   * @param {!number} v Value
   * @param {string=} sfx Suffix (like "px" or "%" or "em")
   * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
   * @return {number} value in pixels
   */
  _convertToPixels = _internals.convertToPixels = function (t, p, v, sfx, recurse) {
    if (sfx === "px" || !sfx && p !== "lineHeight") {
      return v;
    }

    if (sfx === "auto" || !v) {
      return 0;
    }

    var horiz = _horizExp.test(p),
        node = t,
        style = _tempDiv.style,
        neg = v < 0,
        precise = v === 1,
        pix,
        cache,
        time;

    if (neg) {
      v = -v;
    }

    if (precise) {
      v *= 100;
    }

    if (p === "lineHeight" && !sfx) {
      //special case of when a simple lineHeight (without a unit) is used. Set it to the value, read back the computed value, and then revert.
      cache = _getComputedStyle(t).lineHeight;
      t.style.lineHeight = v;
      pix = parseFloat(_getComputedStyle(t).lineHeight);
      t.style.lineHeight = cache;
    } else if (sfx === "%" && p.indexOf("border") !== -1) {
      pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
    } else {
      style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";

      if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
        node = t.parentNode || _doc.body;

        if (_getStyle(node, "display").indexOf("flex") !== -1) {
          //Edge and IE11 have a bug that causes offsetWidth to report as 0 if the container has display:flex and the child is position:relative. Switching to position: absolute solves it.
          style.position = "absolute";
        }

        cache = node._gsCache;
        time = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].ticker.frame;

        if (cache && horiz && cache.time === time) {
          //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
          return cache.width * v / 100;
        }

        style[horiz ? "width" : "height"] = v + sfx;
      } else {
        style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
      }

      node.appendChild(_tempDiv);
      pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
      node.removeChild(_tempDiv);

      if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
        cache = node._gsCache = node._gsCache || {};
        cache.time = time;
        cache.width = pix / v * 100;
      }

      if (pix === 0 && !recurse) {
        pix = _convertToPixels(t, p, v, sfx, true);
      }
    }

    if (precise) {
      pix /= 100;
    }

    return neg ? -pix : pix;
  },
      _calculateOffset = _internals.calculateOffset = function (t, p, cs) {
    //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
    if (_getStyle(t, "position", cs) !== "absolute") {
      return 0;
    }

    var dim = p === "left" ? "Left" : "Top",
        v = _getStyle(t, "margin" + dim, cs);

    return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
  },
      // @private returns at object containing ALL of the style properties in camelCase and their associated values.
  _getAllStyles = function (t, cs) {
    var s = {},
        i,
        tr,
        p;

    if (cs = cs || _getComputedStyle(t, null)) {
      if (i = cs.length) {
        while (--i > -1) {
          p = cs[i];

          if (p.indexOf("-transform") === -1 || _transformPropCSS === p) {
            //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
            s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
          }
        }
      } else {
        //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
        for (i in cs) {
          if (i.indexOf("Transform") === -1 || _transformProp === i) {
            //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
            s[i] = cs[i];
          }
        }
      }
    } else if (cs = t.currentStyle || t.style) {
      for (i in cs) {
        if (typeof i === "string" && s[i] === undefined) {
          s[i.replace(_camelExp, _camelFunc)] = cs[i];
        }
      }
    }

    if (!_supportsOpacity) {
      s.opacity = _getIEOpacity(t);
    }

    tr = _getTransform(t, cs, false);
    s.rotation = tr.rotation;
    s.skewX = tr.skewX;
    s.scaleX = tr.scaleX;
    s.scaleY = tr.scaleY;
    s.x = tr.x;
    s.y = tr.y;

    if (_supports3D) {
      s.z = tr.z;
      s.rotationX = tr.rotationX;
      s.rotationY = tr.rotationY;
      s.scaleZ = tr.scaleZ;
    }

    if (s.filters) {
      delete s.filters;
    }

    return s;
  },
      // @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic2 object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
  _cssDif = function (t, s1, s2, vars, forceLookup) {
    var difs = {},
        style = t.style,
        val,
        p,
        mpt;

    for (p in s2) {
      if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p]) if (p.indexOf("Origin") === -1) if (typeof val === "number" || typeof val === "string") {
        difs[p] = val === "auto" && (p === "left" || p === "top") ? _calculateOffset(t, p) : (val === "" || val === "auto" || val === "none") && typeof s1[p] === "string" && s1[p].replace(_NaNExp, "") !== "" ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.

        if (style[p] !== undefined) {
          //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
          mpt = new MiniPropTween(style, p, style[p], mpt);
        }
      }
    }

    if (vars) {
      for (p in vars) {
        //copy properties (except className)
        if (p !== "className") {
          difs[p] = vars[p];
        }
      }
    }

    return {
      difs: difs,
      firstMPT: mpt
    };
  },
      _dimensions = {
    width: ["Left", "Right"],
    height: ["Top", "Bottom"]
  },
      _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],

  /**
   * @private Gets the width or height of an element
   * @param {!Object} t Target element
   * @param {!string} p Property name ("width" or "height")
   * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
   * @return {number} Dimension (in pixels)
   */
  _getDimension = function (t, p, cs) {
    if ((t.nodeName + "").toLowerCase() === "svg") {
      //Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
      return (cs || _getComputedStyle(t))[p] || 0;
    } else if (t.getCTM && _isSVG(t)) {
      return t.getBBox()[p] || 0;
    }

    var v = parseFloat(p === "width" ? t.offsetWidth : t.offsetHeight),
        a = _dimensions[p],
        i = a.length;
    cs = cs || _getComputedStyle(t, null);

    while (--i > -1) {
      v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
      v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
    }

    return v;
  },
      // @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
  _parsePosition = function (v, recObj) {
    if (v === "contain" || v === "auto" || v === "auto auto") {
      //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
      return v + " ";
    }

    if (v == null || v === "") {
      v = "0 0";
    }

    var a = v.split(" "),
        x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
        y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1],
        i;

    if (a.length > 3 && !recObj) {
      //multiple positions
      a = v.split(", ").join(",").split(",");
      v = [];

      for (i = 0; i < a.length; i++) {
        v.push(_parsePosition(a[i]));
      }

      return v.join(",");
    }

    if (y == null) {
      y = x === "center" ? "50%" : "0";
    } else if (y === "center") {
      y = "50%";
    }

    if (x === "center" || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) {
      //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
      x = "50%";
    }

    v = x + " " + y + (a.length > 2 ? " " + a[2] : "");

    if (recObj) {
      recObj.oxp = x.indexOf("%") !== -1;
      recObj.oyp = y.indexOf("%") !== -1;
      recObj.oxr = x.charAt(1) === "=";
      recObj.oyr = y.charAt(1) === "=";
      recObj.ox = parseFloat(x.replace(_NaNExp, ""));
      recObj.oy = parseFloat(y.replace(_NaNExp, ""));
      recObj.v = v;
    }

    return recObj || v;
  },

  /**
   * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
   * @param {(number|string)} e End value which is typically a string, but could be a number
   * @param {(number|string)} b Beginning value which is typically a string but could be a number
   * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
   */
  _parseChange = function (e, b) {
    if (typeof e === "function") {
      e = e(_index, _target);
    }

    return typeof e === "string" && e.charAt(1) === "=" ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b) || 0;
  },

  /**
   * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @return {number} Parsed value
   */
  _parseVal = function (v, d) {
    if (typeof v === "function") {
      v = v(_index, _target);
    }

    var isRelative = typeof v === "string" && v.charAt(1) === "=";

    if (typeof v === "string" && v.charAt(v.length - 2) === "v") {
      //convert vw and vh into px-equivalents.
      v = (isRelative ? v.substr(0, 2) : 0) + window["inner" + (v.substr(-2) === "vh" ? "Height" : "Width")] * (parseFloat(isRelative ? v.substr(2) : v) / 100);
    }

    return v == null ? d : isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
  },

  /**
   * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
   * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
   * @return {number} parsed angle in radians
   */
  _parseAngle = function (v, d, p, directionalEnd) {
    var min = 0.000001,
        cap,
        split,
        dif,
        result,
        isRelative;

    if (typeof v === "function") {
      v = v(_index, _target);
    }

    if (v == null) {
      result = d;
    } else if (typeof v === "number") {
      result = v;
    } else {
      cap = 360;
      split = v.split("_");
      isRelative = v.charAt(1) === "=";
      dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (isRelative ? 0 : d);

      if (split.length) {
        if (directionalEnd) {
          directionalEnd[p] = d + dif;
        }

        if (v.indexOf("short") !== -1) {
          dif = dif % cap;

          if (dif !== dif % (cap / 2)) {
            dif = dif < 0 ? dif + cap : dif - cap;
          }
        }

        if (v.indexOf("_cw") !== -1 && dif < 0) {
          dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
        } else if (v.indexOf("ccw") !== -1 && dif > 0) {
          dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
        }
      }

      result = d + dif;
    }

    if (result < min && result > -min) {
      result = 0;
    }

    return result;
  },
      _colorLookup = {
    aqua: [0, 255, 255],
    lime: [0, 255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, 255],
    navy: [0, 0, 128],
    white: [255, 255, 255],
    fuchsia: [255, 0, 255],
    olive: [128, 128, 0],
    yellow: [255, 255, 0],
    orange: [255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [255, 0, 0],
    pink: [255, 192, 203],
    cyan: [0, 255, 255],
    transparent: [255, 255, 255, 0]
  },
      _hue = function (h, m1, m2) {
    h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
  },

  /**
   * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
   * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
   * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
   * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
   */
  _parseColor = CSSPlugin.parseColor = function (v, toHSL) {
    var a, r, g, b, h, s, l, max, min, d, wasHSL;

    if (!v) {
      a = _colorLookup.black;
    } else if (typeof v === "number") {
      a = [v >> 16, v >> 8 & 255, v & 255];
    } else {
      if (v.charAt(v.length - 1) === ",") {
        //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
        v = v.substr(0, v.length - 1);
      }

      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length === 4) {
          //for shorthand like #9F0
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b;
        }

        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & 255, v & 255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_numExp);

        if (!toHSL) {
          h = Number(a[0]) % 360 / 360;
          s = Number(a[1]) / 100;
          l = Number(a[2]) / 100;
          g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;

          if (a.length > 3) {
            a[3] = Number(a[3]);
          }

          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (v.indexOf("=") !== -1) {
          //if relative values are found, just return the raw strings with the relative prefixes in place.
          return v.match(_relNumExp);
        }
      } else {
        a = v.match(_numExp) || _colorLookup.transparent;
      }

      a[0] = Number(a[0]);
      a[1] = Number(a[1]);
      a[2] = Number(a[2]);

      if (a.length > 3) {
        a[3] = Number(a[3]);
      }
    }

    if (toHSL && !wasHSL) {
      r = a[0] / 255;
      g = a[1] / 255;
      b = a[2] / 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }

      a[0] = h + 0.5 | 0;
      a[1] = s * 100 + 0.5 | 0;
      a[2] = l * 100 + 0.5 | 0;
    }

    return a;
  },
      _formatColors = function (s, toHSL) {
    var colors = s.match(_colorExp) || [],
        charIndex = 0,
        parsed = "",
        i,
        color,
        temp;

    if (!colors.length) {
      return s;
    }

    for (i = 0; i < colors.length; i++) {
      color = colors[i];
      temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
      charIndex += temp.length + color.length;
      color = _parseColor(color, toHSL);

      if (color.length === 3) {
        color.push(1);
      }

      parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
    }

    return parsed + s.substr(charIndex);
  },
      _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.


  for (p in _colorLookup) {
    _colorExp += "|" + p + "\\b";
  }

  _colorExp = new RegExp(_colorExp + ")", "gi");

  CSSPlugin.colorStringFilter = function (a) {
    var combined = a[0] + " " + a[1],
        toHSL;

    if (_colorExp.test(combined)) {
      toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
      a[0] = _formatColors(a[0], toHSL);
      a[1] = _formatColors(a[1], toHSL);
    }

    _colorExp.lastIndex = 0;
  };

  if (!_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].defaultStringFilter) {
    _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].defaultStringFilter = CSSPlugin.colorStringFilter;
  }
  /**
   * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
   * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
   * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
   * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
   * @return {Function} formatter function
   */


  var _getFormatter = function (dflt, clr, collapsible, multi) {
    if (dflt == null) {
      return function (v) {
        return v;
      };
    }

    var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
        dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
        pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
        sfx = dflt.charAt(dflt.length - 1) === ")" ? ")" : "",
        delim = dflt.indexOf(" ") !== -1 ? " " : ",",
        numVals = dVals.length,
        dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "",
        formatter;

    if (!numVals) {
      return function (v) {
        return v;
      };
    }

    if (clr) {
      formatter = function (v) {
        var color, vals, i, a;

        if (typeof v === "number") {
          v += dSfx;
        } else if (multi && _commasOutsideParenExp.test(v)) {
          a = v.replace(_commasOutsideParenExp, "|").split("|");

          for (i = 0; i < a.length; i++) {
            a[i] = formatter(a[i]);
          }

          return a.join(",");
        }

        color = (v.match(_colorExp) || [dColor])[0];
        vals = v.split(color).join("").match(_valuesExp) || [];
        i = vals.length;

        if (numVals > i--) {
          while (++i < numVals) {
            vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
          }
        }

        return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
      };

      return formatter;
    }

    formatter = function (v) {
      var vals, a, i;

      if (typeof v === "number") {
        v += dSfx;
      } else if (multi && _commasOutsideParenExp.test(v)) {
        a = v.replace(_commasOutsideParenExp, "|").split("|");

        for (i = 0; i < a.length; i++) {
          a[i] = formatter(a[i]);
        }

        return a.join(",");
      }

      vals = v.match(_valuesExp) || [];
      i = vals.length;

      if (numVals > i--) {
        while (++i < numVals) {
          vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
        }
      }

      return pfx + vals.join(delim) + sfx;
    };

    return formatter;
  },

  /**
   * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
   * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
   * @return {Function} a formatter function
   */
  _getEdgeParser = function (props) {
    props = props.split(",");
    return function (t, e, p, cssp, pt, plugin, vars) {
      var a = (e + "").split(" "),
          i;
      vars = {};

      for (i = 0; i < 4; i++) {
        vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
      }

      return cssp.parse(t, vars, pt, plugin);
    };
  },
      // @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
  _setPluginRatio = _internals._setPluginRatio = function (v) {
    this.plugin.setRatio(v);
    var d = this.data,
        proxy = d.proxy,
        mpt = d.firstMPT,
        min = 0.000001,
        val,
        pt,
        i,
        str,
        p;

    while (mpt) {
      val = proxy[mpt.v];

      if (mpt.r) {
        val = mpt.r(val);
      } else if (val < min && val > -min) {
        val = 0;
      }

      mpt.t[mpt.p] = val;
      mpt = mpt._next;
    }

    if (d.autoRotate) {
      d.autoRotate.rotation = d.mod ? d.mod.call(this._tween, proxy.rotation, this.t, this._tween) : proxy.rotation; //special case for ModifyPlugin to hook into an auto-rotating bezier
    } //at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.


    if (v === 1 || v === 0) {
      mpt = d.firstMPT;
      p = v === 1 ? "e" : "b";

      while (mpt) {
        pt = mpt.t;

        if (!pt.type) {
          pt[p] = pt.s + pt.xs0;
        } else if (pt.type === 1) {
          str = pt.xs0 + pt.s + pt.xs1;

          for (i = 1; i < pt.l; i++) {
            str += pt["xn" + i] + pt["xs" + (i + 1)];
          }

          pt[p] = str;
        }

        mpt = mpt._next;
      }
    }
  },

  /**
   * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
   * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
   * @param {!string} p property name
   * @param {(number|string|object)} v value
   * @param {MiniPropTween=} next next MiniPropTween in the linked list
   * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
   */
  MiniPropTween = function (t, p, v, next, r) {
    this.t = t;
    this.p = p;
    this.v = v;
    this.r = r;

    if (next) {
      next._prev = this;
      this._next = next;
    }
  },

  /**
   * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic2 proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
   * This method returns an object that has the following properties:
   *  - proxy: a generic2 object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
   *  - end: a generic2 object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
   *  - firstMPT: the first MiniPropTween in the linked list
   *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
   * @param {!Object} t target object to be tweened
   * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
   * @param {!CSSPlugin} cssp The CSSPlugin instance
   * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
   * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
   * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
   */
  _parseToProxy = _internals._parseToProxy = function (t, vars, cssp, pt, plugin, shallow) {
    var bpt = pt,
        start = {},
        end = {},
        transform = cssp._transform,
        oldForce = _forcePT,
        i,
        p,
        xp,
        mpt,
        firstPT;
    cssp._transform = null;
    _forcePT = vars;
    pt = firstPT = cssp.parse(t, vars, pt, plugin);
    _forcePT = oldForce; //break off from the linked list so the new ones are isolated.

    if (shallow) {
      cssp._transform = transform;

      if (bpt) {
        bpt._prev = null;

        if (bpt._prev) {
          bpt._prev._next = null;
        }
      }
    }

    while (pt && pt !== bpt) {
      if (pt.type <= 1) {
        p = pt.p;
        end[p] = pt.s + pt.c;
        start[p] = pt.s;

        if (!shallow) {
          mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
          pt.c = 0;
        }

        if (pt.type === 1) {
          i = pt.l;

          while (--i > 0) {
            xp = "xn" + i;
            p = pt.p + "_" + xp;
            end[p] = pt.data[xp];
            start[p] = pt[xp];

            if (!shallow) {
              mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
            }
          }
        }
      }

      pt = pt._next;
    }

    return {
      proxy: start,
      end: end,
      firstMPT: mpt,
      pt: firstPT
    };
  },

  /**
   * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
   * CSSPropTweens have the following optional properties as well (not defined through the constructor):
   *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
   *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
   *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
   *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic2 object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
   *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
   * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
   * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
   * @param {number} s Starting numeric value
   * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
   * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
   * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
   * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
   * @param {boolean=} r If true, the value(s) should be rounded
   * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
   * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
   * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
   */
  CSSPropTween = _internals.CSSPropTween = function (t, p, s, c, next, type, n, r, pr, b, e) {
    this.t = t; //target

    this.p = p; //property

    this.s = s; //starting value

    this.c = c; //change value

    this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)

    if (!(t instanceof CSSPropTween)) {
      _overwriteProps.push(this.n);
    }

    this.r = !r ? r : typeof r === "function" ? r : Math.round; //round (boolean)

    this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work

    if (pr) {
      this.pr = pr;
      _hasPriority = true;
    }

    this.b = b === undefined ? s : b;
    this.e = e === undefined ? s + c : e;

    if (next) {
      this._next = next;
      next._prev = this;
    }
  },
      _addNonTweeningNumericPT = function (target, prop, start, end, next, overwriteProp) {
    //cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
    var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
    pt.b = start;
    pt.e = pt.xs0 = end;
    return pt;
  },

  /**
   * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
   * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
   * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
   * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
   *
   * @param {!Object} t Target whose property will be tweened
   * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
   * @param {string} b Beginning value
   * @param {string} e Ending value
   * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
   * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
   * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
   * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
   * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
   * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
   */
  _parseComplex = CSSPlugin.parseComplex = function (t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
    //DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
    b = b || dflt || "";

    if (typeof e === "function") {
      e = e(_index, _target);
    }

    pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, false, pr, b, e);
    e += ""; //ensures it's a string

    if (clrs && _colorExp.test(e + b)) {
      //if colors are found, normalize the formatting to rgba() or hsla().
      e = [b, e];
      CSSPlugin.colorStringFilter(e);
      b = e[0];
      e = e[1];
    }

    var ba = b.split(", ").join(",").split(" "),
        //beginning array
    ea = e.split(", ").join(",").split(" "),
        //ending array
    l = ba.length,
        autoRound = _autoRound !== false,
        i,
        xi,
        ni,
        bv,
        ev,
        bnums,
        enums,
        bn,
        hasAlpha,
        temp,
        cv,
        str,
        useHSL;

    if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
      if ((e + b).indexOf("rgb") !== -1 || (e + b).indexOf("hsl") !== -1) {
        //keep rgb(), rgba(), hsl(), and hsla() values together! (remember, we're splitting on spaces)
        ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
        ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
      } else {
        ba = ba.join(" ").split(",").join(", ").split(" ");
        ea = ea.join(" ").split(",").join(", ").split(" ");
      }

      l = ba.length;
    }

    if (l !== ea.length) {
      //DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
      ba = (dflt || "").split(" ");
      l = ba.length;
    }

    pt.plugin = plugin;
    pt.setRatio = setRatio;
    _colorExp.lastIndex = 0;

    for (i = 0; i < l; i++) {
      bv = ba[i];
      ev = ea[i] + "";
      bn = parseFloat(bv); //if the value begins with a number (most common). It's fine if it has a suffix like px

      if (bn || bn === 0) {
        pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1 ? Math.round : false, true); //if the value is a color
      } else if (clrs && _colorExp.test(bv)) {
        str = ev.indexOf(")") + 1;
        str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.

        useHSL = ev.indexOf("hsl") !== -1 && _supportsOpacity;
        temp = ev; //original string value so we can look for any prefix later.

        bv = _parseColor(bv, useHSL);
        ev = _parseColor(ev, useHSL);
        hasAlpha = bv.length + ev.length > 6;

        if (hasAlpha && !_supportsOpacity && ev[3] === 0) {
          //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
          pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
          pt.e = pt.e.split(ea[i]).join("transparent");
        } else {
          if (!_supportsOpacity) {
            //old versions of IE don't support rgba().
            hasAlpha = false;
          }

          if (useHSL) {
            pt.appendXtra(temp.substr(0, temp.indexOf("hsl")) + (hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), hasAlpha ? "%," : "%" + str, false);
          } else {
            pt.appendXtra(temp.substr(0, temp.indexOf("rgb")) + (hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", Math.round, true).appendXtra("", bv[1], ev[1] - bv[1], ",", Math.round).appendXtra("", bv[2], ev[2] - bv[2], hasAlpha ? "," : str, Math.round);
          }

          if (hasAlpha) {
            bv = bv.length < 4 ? 1 : bv[3];
            pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, false);
          }
        }

        _colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.
      } else {
        bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array
        //if no number is found, treat it as a non-tweening value and just append the string to the current xs.

        if (!bnums) {
          pt["xs" + pt.l] += pt.l || pt["xs" + pt.l] ? " " + ev : ev; //loop through all the numbers that are found and construct the extra values on the pt.
        } else {
          enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5

          if (!enums || enums.length !== bnums.length) {
            //DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
            return pt;
          }

          ni = 0;

          for (xi = 0; xi < bnums.length; xi++) {
            cv = bnums[xi];
            temp = bv.indexOf(cv, ni);
            pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && bv.substr(temp + cv.length, 2) === "px" ? Math.round : false, xi === 0);
            ni = temp + cv.length;
          }

          pt["xs" + pt.l] += bv.substr(ni);
        }
      }
    } //if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.


    if (e.indexOf("=") !== -1) if (pt.data) {
      str = pt.xs0 + pt.data.s;

      for (i = 1; i < pt.l; i++) {
        str += pt["xs" + i] + pt.data["xn" + i];
      }

      pt.e = str + pt["xs" + i];
    }

    if (!pt.l) {
      pt.type = -1;
      pt.xs0 = pt.e;
    }

    return pt.xfirst || pt;
  },
      i = 9;

  p = CSSPropTween.prototype;
  p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.

  while (--i > 0) {
    p["xn" + i] = 0;
    p["xs" + i] = "";
  }

  p.xs0 = "";
  p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;
  /**
   * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
   * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
   * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
   * @param {string=} pfx Prefix (if any)
   * @param {!number} s Starting value
   * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
   * @param {string=} sfx Suffix (if any)
   * @param {boolean=} r Round (if true).
   * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
   * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
   */

  p.appendXtra = function (pfx, s, c, sfx, r, pad) {
    var pt = this,
        l = pt.l;
    pt["xs" + l] += pad && (l || pt["xs" + l]) ? " " + pfx : pfx || "";
    if (!c) if (l !== 0 && !pt.plugin) {
      //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
      pt["xs" + l] += s + (sfx || "");
      return pt;
    }
    pt.l++;
    pt.type = pt.setRatio ? 2 : 1;
    pt["xs" + pt.l] = sfx || "";

    if (l > 0) {
      pt.data["xn" + l] = s + c;
      pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)

      pt["xn" + l] = s;

      if (!pt.plugin) {
        pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
        pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
      }

      return pt;
    }

    pt.data = {
      s: s + c
    };
    pt.rxp = {};
    pt.s = s;
    pt.c = c;
    pt.r = r;
    return pt;
  };
  /**
   * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
   * @param {!string} p Property name (like "boxShadow" or "throwProps")
   * @param {Object=} options An object containing any of the following configuration options:
   *                      - defaultValue: the default value
   *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
   *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
   *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
   *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
   *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
   *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
   *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
   *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
   */


  var SpecialProp = function (p, options) {
    options = options || {};
    this.p = options.prefix ? _checkPropPrefix(p) || p : p;
    _specialProps[p] = _specialProps[this.p] = this;
    this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);

    if (options.parser) {
      this.parse = options.parser;
    }

    this.clrs = options.color;
    this.multi = options.multi;
    this.keyword = options.keyword;
    this.dflt = options.defaultValue;
    this.pr = options.priority || 0;
  },
      //shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
  _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function (p, options, defaults) {
    if (typeof options !== "object") {
      options = {
        parser: defaults
      }; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
    }

    var a = p.split(","),
        d = options.defaultValue,
        i,
        temp;
    defaults = defaults || [d];

    for (i = 0; i < a.length; i++) {
      options.prefix = i === 0 && options.prefix;
      options.defaultValue = defaults[i] || d;
      temp = new SpecialProp(a[i], options);
    }
  },
      //creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
  _registerPluginProp = _internals._registerPluginProp = function (p) {
    if (!_specialProps[p]) {
      var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";

      _registerComplexSpecialProp(p, {
        parser: function (t, e, p, cssp, pt, plugin, vars) {
          var pluginClass = _globals.com.greensock.plugins[pluginName];

          if (!pluginClass) {
            _log("Error: " + pluginName + " js file not loaded.");

            return pt;
          }

          pluginClass._cssRegister();

          return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
        }
      });
    }
  };

  p = SpecialProp.prototype;
  /**
   * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
   * @param {!Object} t target element
   * @param {(string|number|object)} b beginning value
   * @param {(string|number|object)} e ending (destination) value
   * @param {CSSPropTween=} pt next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
   * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
   * @return {CSSPropTween=} First CSSPropTween in the linked list
   */

  p.parseComplex = function (t, b, e, pt, plugin, setRatio) {
    var kwd = this.keyword,
        i,
        ba,
        ea,
        l,
        bi,
        ei; //if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)

    if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
      ba = b.replace(_commasOutsideParenExp, "|").split("|");
      ea = e.replace(_commasOutsideParenExp, "|").split("|");
    } else if (kwd) {
      ba = [b];
      ea = [e];
    }

    if (ea) {
      l = ea.length > ba.length ? ea.length : ba.length;

      for (i = 0; i < l; i++) {
        b = ba[i] = ba[i] || this.dflt;
        e = ea[i] = ea[i] || this.dflt;

        if (kwd) {
          bi = b.indexOf(kwd);
          ei = e.indexOf(kwd);

          if (bi !== ei) {
            if (ei === -1) {
              //if the keyword isn't in the end value, remove it from the beginning one.
              ba[i] = ba[i].split(kwd).join("");
            } else if (bi === -1) {
              //if the keyword isn't in the beginning, add it.
              ba[i] += " " + kwd;
            }
          }
        }
      }

      b = ba.join(", ");
      e = ea.join(", ");
    }

    return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
  };
  /**
   * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
   * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
   * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
   * @param {!Object} t Target object whose property is being tweened
   * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
   * @param {!string} p Property name
   * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
   * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
   * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
   * @param {Object=} vars Original vars object that contains the data for parsing.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
   */


  p.parse = function (t, e, p, cssp, pt, plugin, vars) {
    return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
  };
  /**
   * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
   *  1) Target object whose property should be tweened (typically a DOM element)
   *  2) The end/destination value (could be a string, number, object, or whatever you want)
   *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
   *
   * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
   *
   * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
   *      var start = target.style.width;
   *      return function(ratio) {
   *              target.style.width = (start + value * ratio) + "px";
   *              console.log("set width to " + target.style.width);
   *          }
   * }, 0);
   *
   * Then, when I do this tween, it will trigger my special property:
   *
   * TweenLite.to(element, 1, {css:{myCustomProp:100}});
   *
   * In the example, of course, we're just changing the width, but you can do anything you want.
   *
   * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
   * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
   * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
   */


  CSSPlugin.registerSpecialProp = function (name, onInitTween, priority) {
    _registerComplexSpecialProp(name, {
      parser: function (t, e, p, cssp, pt, plugin, vars) {
        var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
        rv.plugin = plugin;
        rv.setRatio = onInitTween(t, e, cssp._tween, p);
        return rv;
      },
      priority: priority
    });
  }; //transform-related methods and properties


  CSSPlugin.useSVGTransformAttr = true; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).

  var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
      _transformProp = _checkPropPrefix("transform"),
      //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
  _transformPropCSS = _prefixCSS + "transform",
      _transformOriginProp = _checkPropPrefix("transformOrigin"),
      _supports3D = _checkPropPrefix("perspective") !== null,
      Transform = _internals.Transform = function () {
    this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
    this.force3D = CSSPlugin.defaultForce3D === false || !_supports3D ? false : CSSPlugin.defaultForce3D || "auto";
  },
      _SVGElement = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].SVGElement,
      _useSVGTransformAttr,
      //Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.
  _createSVG = function (type, container, attributes) {
    var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
        reg = /([a-z])([A-Z])/g,
        p;

    for (p in attributes) {
      element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
    }

    container.appendChild(element);
    return element;
  },
      _docElement = _doc.documentElement || {},
      _forceSVGTransformAttr = function () {
    //IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
    var force = _ieVers || /Android/i.test(_agent) && !_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].chrome,
        svg,
        rect,
        width;

    if (_doc.createElementNS && !force) {
      //IE8 and earlier doesn't support SVG anyway
      svg = _createSVG("svg", _docElement);
      rect = _createSVG("rect", svg, {
        width: 100,
        height: 50,
        x: 100
      });
      width = rect.getBoundingClientRect().width;
      rect.style[_transformOriginProp] = "50% 50%";
      rect.style[_transformProp] = "scaleX(0.5)";
      force = width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).

      _docElement.removeChild(svg);
    }

    return force;
  }(),
      _parseSVGOrigin = function (e, local, decoratee, absolute, smoothOrigin, skipRecord) {
    var tm = e._gsTransform,
        m = _getMatrix(e, true),
        v,
        x,
        y,
        xOrigin,
        yOrigin,
        a,
        b,
        c,
        d,
        tx,
        ty,
        determinant,
        xOriginOld,
        yOriginOld;

    if (tm) {
      xOriginOld = tm.xOrigin; //record the original values before we alter them.

      yOriginOld = tm.yOrigin;
    }

    if (!absolute || (v = absolute.split(" ")).length < 2) {
      b = e.getBBox();

      if (b.x === 0 && b.y === 0 && b.width + b.height === 0) {
        //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.
        b = {
          x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0,
          y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0,
          width: 0,
          height: 0
        };
      }

      local = _parsePosition(local).split(" ");
      v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
    }

    decoratee.xOrigin = xOrigin = parseFloat(v[0]);
    decoratee.yOrigin = yOrigin = parseFloat(v[1]);

    if (absolute && m !== _identity2DMatrix) {
      //if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
      a = m[0];
      b = m[1];
      c = m[2];
      d = m[3];
      tx = m[4];
      ty = m[5];
      determinant = a * d - b * c;

      if (determinant) {
        //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
        xOrigin = decoratee.xOrigin = v[0] = x;
        yOrigin = decoratee.yOrigin = v[1] = y;
      }
    }

    if (tm) {
      //avoid jump when transformOrigin is changed - adjust the x/y values accordingly
      if (skipRecord) {
        decoratee.xOffset = tm.xOffset;
        decoratee.yOffset = tm.yOffset;
        tm = decoratee;
      }

      if (smoothOrigin || smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false) {
        x = xOrigin - xOriginOld;
        y = yOrigin - yOriginOld; //originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
        //tm.x -= x - (x * m[0] + y * m[2]);
        //tm.y -= y - (x * m[1] + y * m[3]);

        tm.xOffset += x * m[0] + y * m[2] - x;
        tm.yOffset += x * m[1] + y * m[3] - y;
      } else {
        tm.xOffset = tm.yOffset = 0;
      }
    }

    if (!skipRecord) {
      e.setAttribute("data-svg-origin", v.join(" "));
    }
  },
      _getBBoxHack = function (swapIfPossible) {
    //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
    var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
        oldParent = this.parentNode,
        oldSibling = this.nextSibling,
        oldCSS = this.style.cssText,
        bbox;

    _docElement.appendChild(svg);

    svg.appendChild(this);
    this.style.display = "block";

    if (swapIfPossible) {
      try {
        bbox = this.getBBox();
        this._originalGetBBox = this.getBBox;
        this.getBBox = _getBBoxHack;
      } catch (e) {}
    } else if (this._originalGetBBox) {
      bbox = this._originalGetBBox();
    }

    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }

    _docElement.removeChild(svg);

    this.style.cssText = oldCSS;
    return bbox;
  },
      _getBBox = function (e) {
    try {
      return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
    } catch (error) {
      return _getBBoxHack.call(e, true);
    }
  },
      _isSVG = function (e) {
    //reports if the element is an SVG on which getBBox() actually works
    return !!(_SVGElement && e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  },
      _identity2DMatrix = [1, 0, 0, 1, 0, 0],
      _getMatrix = function (e, force2D) {
    var tm = e._gsTransform || new Transform(),
        rnd = 100000,
        style = e.style,
        isDefault,
        s,
        m,
        n,
        dec,
        none;

    if (_transformProp) {
      s = _getStyle(e, _transformPropCSS, null, true);
    } else if (e.currentStyle) {
      //for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
      s = e.currentStyle.filter.match(_ieGetMatrixExp);
      s = s && s.length === 4 ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : "";
    }

    isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";

    if (_transformProp && ((none = !_getComputedStyle(e) || _getComputedStyle(e).display === "none") || !e.parentNode)) {
      //note: Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
      if (none) {
        //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
        n = style.display;
        style.display = "block";
      }

      if (!e.parentNode) {
        dec = 1; //flag

        _docElement.appendChild(e);
      }

      s = _getStyle(e, _transformPropCSS, null, true);
      isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";

      if (n) {
        style.display = n;
      } else if (none) {
        _removeProp(style, "display");
      }

      if (dec) {
        _docElement.removeChild(e);
      }
    }

    if (tm.svg || e.getCTM && _isSVG(e)) {
      if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) {
        //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
        s = style[_transformProp];
        isDefault = 0;
      }

      m = e.getAttribute("transform");

      if (isDefault && m) {
        m = e.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

        s = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
        isDefault = 0;
      }
    }

    if (isDefault) {
      return _identity2DMatrix;
    } //split the matrix values out into an array (m for matrix)


    m = (s || "").match(_numExp) || [];
    i = m.length;

    while (--i > -1) {
      n = Number(m[i]);
      m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -0.5 : 0.5) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
    }

    return force2D && m.length > 6 ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
  },

  /**
   * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
   * @param {!Object} t target element
   * @param {Object=} cs computed style object (optional)
   * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
   * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
   * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
   */
  _getTransform = _internals.getTransform = function (t, cs, rec, parse) {
    if (t._gsTransform && rec && !parse) {
      return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
    }

    var tm = rec ? t._gsTransform || new Transform() : new Transform(),
        invX = tm.scaleX < 0,
        //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
    min = 0.00002,
        rnd = 100000,
        zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
        defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
        m,
        i,
        scaleX,
        scaleY,
        rotation,
        skewX;
    tm.svg = !!(t.getCTM && _isSVG(t));

    if (tm.svg) {
      _parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));

      _useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
    }

    m = _getMatrix(t);

    if (m !== _identity2DMatrix) {
      if (m.length === 16) {
        //we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
        var a11 = m[0],
            a21 = m[1],
            a31 = m[2],
            a41 = m[3],
            a12 = m[4],
            a22 = m[5],
            a32 = m[6],
            a42 = m[7],
            a13 = m[8],
            a23 = m[9],
            a33 = m[10],
            a14 = m[12],
            a24 = m[13],
            a34 = m[14],
            a43 = m[11],
            angle = Math.atan2(a32, a33),
            t1,
            t2,
            t3,
            t4,
            cos,
            sin; //we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari

        if (tm.zOrigin) {
          a34 = -tm.zOrigin;
          a14 = a13 * a34 - m[12];
          a24 = a23 * a34 - m[13];
          a34 = a33 * a34 + tm.zOrigin - m[14];
        } //note for possible future consolidation: rotationX: Math.atan2(a32, a33), rotationY: Math.atan2(-a31, Math.sqrt(a33 * a33 + a32 * a32)), rotation: Math.atan2(a21, a11), skew: Math.atan2(a12, a22). However, it doesn't seem to be quite as reliable as the full-on backwards rotation procedure.


        tm.rotationX = angle * _RAD2DEG; //rotationX

        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        } //rotationY


        angle = Math.atan2(-a31, a33);
        tm.rotationY = angle * _RAD2DEG;

        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a11 * cos - a13 * sin;
          t2 = a21 * cos - a23 * sin;
          t3 = a31 * cos - a33 * sin;
          a23 = a21 * sin + a23 * cos;
          a33 = a31 * sin + a33 * cos;
          a43 = a41 * sin + a43 * cos;
          a11 = t1;
          a21 = t2;
          a31 = t3;
        } //rotationZ


        angle = Math.atan2(a21, a11);
        tm.rotation = angle * _RAD2DEG;

        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a11 * cos + a21 * sin;
          t2 = a12 * cos + a22 * sin;
          t3 = a13 * cos + a23 * sin;
          a21 = a21 * cos - a11 * sin;
          a22 = a22 * cos - a12 * sin;
          a23 = a23 * cos - a13 * sin;
          a11 = t1;
          a12 = t2;
          a13 = t3;
        }

        if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
          //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
          tm.rotationX = tm.rotation = 0;
          tm.rotationY = 180 - tm.rotationY;
        } //skewX


        angle = Math.atan2(a12, a22); //scales

        tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31) * rnd + 0.5 | 0) / rnd;
        tm.scaleY = (Math.sqrt(a22 * a22 + a32 * a32) * rnd + 0.5 | 0) / rnd;
        tm.scaleZ = (Math.sqrt(a13 * a13 + a23 * a23 + a33 * a33) * rnd + 0.5 | 0) / rnd;
        a11 /= tm.scaleX;
        a12 /= tm.scaleY;
        a21 /= tm.scaleX;
        a22 /= tm.scaleY;

        if (Math.abs(angle) > min) {
          tm.skewX = angle * _RAD2DEG;
          a12 = 0; //unskews

          if (tm.skewType !== "simple") {
            tm.scaleY *= 1 / Math.cos(angle); //by default, we compensate the scale based on the skew so that the element maintains a similar proportion when skewed, so we have to alter the scaleY here accordingly to match the default (non-adjusted) skewing that CSS does (stretching more and more as it skews).
          }
        } else {
          tm.skewX = 0;
        }
        /* //for testing purposes
        var transform = "matrix3d(",
        	comma = ",",
        	zero = "0";
        a13 /= tm.scaleZ;
        a23 /= tm.scaleZ;
        a31 /= tm.scaleX;
        a32 /= tm.scaleY;
        a33 /= tm.scaleZ;
        transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
        transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
        transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
        transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
        transform += a14 + comma + a24 + comma + a34 + comma + (tm.perspective ? (1 + (-a34 / tm.perspective)) : 1) + ")";
        console.log(transform);
        document.querySelector(".test").style[_transformProp] = transform;
        */


        tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
        tm.x = a14;
        tm.y = a24;
        tm.z = a34;

        if (tm.svg) {
          tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
          tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
        }
      } else if (!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) {
        //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
        var k = m.length >= 6,
            a = k ? m[0] : 1,
            b = m[1] || 0,
            c = m[2] || 0,
            d = k ? m[3] : 1;
        tm.x = m[4] || 0;
        tm.y = m[5] || 0;
        scaleX = Math.sqrt(a * a + b * b);
        scaleY = Math.sqrt(d * d + c * c);
        rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

        skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
        tm.scaleX = scaleX;
        tm.scaleY = scaleY;
        tm.rotation = rotation;
        tm.skewX = skewX;

        if (_supports3D) {
          tm.rotationX = tm.rotationY = tm.z = 0;
          tm.perspective = defaultTransformPerspective;
          tm.scaleZ = 1;
        }

        if (tm.svg) {
          tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
          tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
        }
      }

      if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
        if (invX) {
          tm.scaleX *= -1;
          tm.skewX += tm.rotation <= 0 ? 180 : -180;
          tm.rotation += tm.rotation <= 0 ? 180 : -180;
        } else {
          tm.scaleY *= -1;
          tm.skewX += tm.skewX <= 0 ? 180 : -180;
        }
      }

      tm.zOrigin = zOrigin; //some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.

      for (i in tm) {
        if (tm[i] < min) if (tm[i] > -min) {
          tm[i] = 0;
        }
      }
    } //DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);


    if (rec) {
      t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)

      if (tm.svg) {
        //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
        if (_useSVGTransformAttr && t.style[_transformProp]) {
          _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].delayedCall(0.001, function () {
            //if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
            _removeProp(t.style, _transformProp);
          });
        } else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
          _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].delayedCall(0.001, function () {
            t.removeAttribute("transform");
          });
        }
      }
    }

    return tm;
  },
      //for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
  _setIETransformRatio = function (v) {
    var t = this.data,
        //refers to the element's _gsTransform object
    ang = -t.rotation * _DEG2RAD,
        skew = ang + t.skewX * _DEG2RAD,
        rnd = 100000,
        a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd,
        b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd,
        c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd,
        d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd,
        style = this.t.style,
        cs = this.t.currentStyle,
        filters,
        val;

    if (!cs) {
      return;
    }

    val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)

    b = -c;
    c = -val;
    filters = cs.filter;
    style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight

    var w = this.t.offsetWidth,
        h = this.t.offsetHeight,
        clip = cs.position !== "absolute",
        m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
        ox = t.x + w * t.xPercent / 100,
        oy = t.y + h * t.yPercent / 100,
        dx,
        dy; //if transformOrigin is being used, adjust the offset x and y

    if (t.ox != null) {
      dx = (t.oxp ? w * t.ox * 0.01 : t.ox) - w / 2;
      dy = (t.oyp ? h * t.oy * 0.01 : t.oy) - h / 2;
      ox += dx - (dx * a + dy * b);
      oy += dy - (dx * c + dy * d);
    }

    if (!clip) {
      m += ", sizingMethod='auto expand')";
    } else {
      dx = w / 2;
      dy = h / 2; //translate to ensure that transformations occur around the correct origin (default is center).

      m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
    }

    if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
      style.filter = filters.replace(_ieSetMatrixExp, m);
    } else {
      style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
    } //at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.


    if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf( true && filters.indexOf("Alpha")) === -1) {
      style.removeAttribute("filter");
    } //we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).

    if (!clip) {
      var mult = _ieVers < 8 ? 1 : -1,
          //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
      marg,
          prop,
          dif;
      dx = t.ieOffsetX || 0;
      dy = t.ieOffsetY || 0;
      t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
      t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);

      for (i = 0; i < 4; i++) {
        prop = _margins[i];
        marg = cs[prop]; //we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)

        val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;

        if (val !== t[prop]) {
          dif = i < 2 ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
        } else {
          dif = i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY;
        }

        style[prop] = (t[prop] = Math.round(val - dif * (i === 0 || i === 2 ? 1 : mult))) + "px";
      }
    }
  },

  /* translates a super small decimal to a string WITHOUT scientific notation
  _safeDecimal = function(n) {
  	var s = (n < 0 ? -n : n) + "",
  		a = s.split("e-");
  	return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
  },
  */
  _setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function (v) {
    var t = this.data,
        //refers to the element's _gsTransform object
    style = this.t.style,
        angle = t.rotation,
        rotationX = t.rotationX,
        rotationY = t.rotationY,
        sx = t.scaleX,
        sy = t.scaleY,
        sz = t.scaleZ,
        x = t.x,
        y = t.y,
        z = t.z,
        isSVG = t.svg,
        perspective = t.perspective,
        force3D = t.force3D,
        skewY = t.skewY,
        skewX = t.skewX,
        t1,
        a11,
        a12,
        a13,
        a21,
        a22,
        a23,
        a31,
        a32,
        a33,
        a41,
        a42,
        a43,
        zOrigin,
        min,
        cos,
        sin,
        t2,
        transform,
        comma,
        zero,
        skew,
        rnd;

    if (skewY) {
      //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
      skewX += skewY;
      angle += skewY;
    } //check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)


    if (((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1 || _useSVGTransformAttr && isSVG || !_supports3D) {
      //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.
      //2D
      if (angle || skewX || isSVG) {
        angle *= _DEG2RAD;
        skew = skewX * _DEG2RAD;
        rnd = 100000;
        a11 = Math.cos(angle) * sx;
        a21 = Math.sin(angle) * sx;
        a12 = Math.sin(angle - skew) * -sy;
        a22 = Math.cos(angle - skew) * sy;

        if (skew && t.skewType === "simple") {
          //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
          t1 = Math.tan(skew - skewY * _DEG2RAD);
          t1 = Math.sqrt(1 + t1 * t1);
          a12 *= t1;
          a22 *= t1;

          if (skewY) {
            t1 = Math.tan(skewY * _DEG2RAD);
            t1 = Math.sqrt(1 + t1 * t1);
            a11 *= t1;
            a21 *= t1;
          }
        }

        if (isSVG) {
          x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
          y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;

          if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) {
            //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
            min = this.t.getBBox();
            x += t.xPercent * 0.01 * min.width;
            y += t.yPercent * 0.01 * min.height;
          }

          min = 0.000001;
          if (x < min) if (x > -min) {
            x = 0;
          }
          if (y < min) if (y > -min) {
            y = 0;
          }
        }

        transform = (a11 * rnd | 0) / rnd + "," + (a21 * rnd | 0) / rnd + "," + (a12 * rnd | 0) / rnd + "," + (a22 * rnd | 0) / rnd + "," + x + "," + y + ")";

        if (isSVG && _useSVGTransformAttr) {
          this.t.setAttribute("transform", "matrix(" + transform);
        } else {
          //some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
          style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
        }
      } else {
        style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
      }

      return;
    }

    if (_isFirefox) {
      //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
      min = 0.0001;

      if (sx < min && sx > -min) {
        sx = sz = 0.00002;
      }

      if (sy < min && sy > -min) {
        sy = sz = 0.00002;
      }

      if (perspective && !t.z && !t.rotationX && !t.rotationY) {
        //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
        perspective = 0;
      }
    }

    if (angle || skewX) {
      angle *= _DEG2RAD;
      cos = a11 = Math.cos(angle);
      sin = a21 = Math.sin(angle);

      if (skewX) {
        angle -= skewX * _DEG2RAD;
        cos = Math.cos(angle);
        sin = Math.sin(angle);

        if (t.skewType === "simple") {
          //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
          t1 = Math.tan((skewX - skewY) * _DEG2RAD);
          t1 = Math.sqrt(1 + t1 * t1);
          cos *= t1;
          sin *= t1;

          if (t.skewY) {
            t1 = Math.tan(skewY * _DEG2RAD);
            t1 = Math.sqrt(1 + t1 * t1);
            a11 *= t1;
            a21 *= t1;
          }
        }
      }

      a12 = -sin;
      a22 = cos;
    } else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) {
      //if we're only translating and/or 2D scaling, this is faster...
      style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (sx !== 1 || sy !== 1 ? " scale(" + sx + "," + sy + ")" : "");
      return;
    } else {
      a11 = a22 = 1;
      a12 = a21 = 0;
    } // KEY  INDEX   AFFECTS a[row][column]
    // a11  0       rotation, rotationY, scaleX
    // a21  1       rotation, rotationY, scaleX
    // a31  2       rotationY, scaleX
    // a41  3       rotationY, scaleX
    // a12  4       rotation, skewX, rotationX, scaleY
    // a22  5       rotation, skewX, rotationX, scaleY
    // a32  6       rotationX, scaleY
    // a42  7       rotationX, scaleY
    // a13  8       rotationY, rotationX, scaleZ
    // a23  9       rotationY, rotationX, scaleZ
    // a33  10      rotationY, rotationX, scaleZ
    // a43  11      rotationY, rotationX, perspective, scaleZ
    // a14  12      x, zOrigin, svgOrigin
    // a24  13      y, zOrigin, svgOrigin
    // a34  14      z, zOrigin
    // a44  15
    // rotation: Math.atan2(a21, a11)
    // rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
    // rotationX: Math.atan2(a32, a33)


    a33 = 1;
    a13 = a23 = a31 = a32 = a41 = a42 = 0;
    a43 = perspective ? -1 / perspective : 0;
    zOrigin = t.zOrigin;
    min = 0.000001; //threshold below which browsers use scientific notation which won't work.

    comma = ",";
    zero = "0";
    angle = rotationY * _DEG2RAD;

    if (angle) {
      cos = Math.cos(angle);
      sin = Math.sin(angle);
      a31 = -sin;
      a41 = a43 * -sin;
      a13 = a11 * sin;
      a23 = a21 * sin;
      a33 = cos;
      a43 *= cos;
      a11 *= cos;
      a21 *= cos;
    }

    angle = rotationX * _DEG2RAD;

    if (angle) {
      cos = Math.cos(angle);
      sin = Math.sin(angle);
      t1 = a12 * cos + a13 * sin;
      t2 = a22 * cos + a23 * sin;
      a32 = a33 * sin;
      a42 = a43 * sin;
      a13 = a12 * -sin + a13 * cos;
      a23 = a22 * -sin + a23 * cos;
      a33 = a33 * cos;
      a43 = a43 * cos;
      a12 = t1;
      a22 = t2;
    }

    if (sz !== 1) {
      a13 *= sz;
      a23 *= sz;
      a33 *= sz;
      a43 *= sz;
    }

    if (sy !== 1) {
      a12 *= sy;
      a22 *= sy;
      a32 *= sy;
      a42 *= sy;
    }

    if (sx !== 1) {
      a11 *= sx;
      a21 *= sx;
      a31 *= sx;
      a41 *= sx;
    }

    if (zOrigin || isSVG) {
      if (zOrigin) {
        x += a13 * -zOrigin;
        y += a23 * -zOrigin;
        z += a33 * -zOrigin + zOrigin;
      }

      if (isSVG) {
        //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
        x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
        y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
      }

      if (x < min && x > -min) {
        x = zero;
      }

      if (y < min && y > -min) {
        y = zero;
      }

      if (z < min && z > -min) {
        z = 0; //don't use string because we calculate perspective later and need the number.
      }
    } //optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:


    transform = t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(";
    transform += (a11 < min && a11 > -min ? zero : a11) + comma + (a21 < min && a21 > -min ? zero : a21) + comma + (a31 < min && a31 > -min ? zero : a31);
    transform += comma + (a41 < min && a41 > -min ? zero : a41) + comma + (a12 < min && a12 > -min ? zero : a12) + comma + (a22 < min && a22 > -min ? zero : a22);

    if (rotationX || rotationY || sz !== 1) {
      //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
      transform += comma + (a32 < min && a32 > -min ? zero : a32) + comma + (a42 < min && a42 > -min ? zero : a42) + comma + (a13 < min && a13 > -min ? zero : a13);
      transform += comma + (a23 < min && a23 > -min ? zero : a23) + comma + (a33 < min && a33 > -min ? zero : a33) + comma + (a43 < min && a43 > -min ? zero : a43) + comma;
    } else {
      transform += ",0,0,0,0,1,0,";
    }

    transform += x + comma + y + comma + z + comma + (perspective ? 1 + -z / perspective : 1) + ")";
    style[_transformProp] = transform;
  };

  p = Transform.prototype;
  p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
  p.scaleX = p.scaleY = p.scaleZ = 1;

  _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
    parser: function (t, e, parsingProp, cssp, pt, plugin, vars) {
      if (cssp._lastParsedTransform === vars) {
        return pt;
      } //only need to parse the transform once, and only if the browser supports it.


      cssp._lastParsedTransform = vars;
      var scaleFunc = vars.scale && typeof vars.scale === "function" ? vars.scale : 0,
          //if there's a function-based "scale" value, swap in the resulting numeric value temporarily. Otherwise, if it's called for both scaleX and scaleY independently, they may not match (like if the function uses Math.random()).
      swapFunc;

      if (typeof vars[parsingProp] === "function") {
        //whatever property triggers the initial parsing might be a function-based value in which case it already got called in parse(), thus we don't want to call it again in here. The most efficient way to avoid this is to temporarily swap the value directly into the vars object, and then after we do all our parsing in this function, we'll swap it back again.
        swapFunc = vars[parsingProp];
        vars[parsingProp] = e;
      }

      if (scaleFunc) {
        vars.scale = scaleFunc(_index, t);
      }

      var originalGSTransform = t._gsTransform,
          style = t.style,
          min = 0.000001,
          i = _transformProps.length,
          v = vars,
          endRotations = {},
          transformOriginString = "transformOrigin",
          m1 = _getTransform(t, _cs, true, v.parseTransform),
          orig = v.transform && (typeof v.transform === "function" ? v.transform(_index, _target) : v.transform),
          m2,
          copy,
          has3D,
          hasChange,
          dr,
          x,
          y,
          matrix,
          p;

      m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;
      cssp._transform = m1;

      if ("rotationZ" in v) {
        v.rotation = v.rotationZ;
      }

      if (orig && typeof orig === "string" && _transformProp) {
        //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
        copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.

        copy[_transformProp] = orig;
        copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.

        copy.position = "absolute";

        if (orig.indexOf("%") !== -1) {
          //%-based translations will fail unless we set the width/height to match the original target...
          copy.width = _getStyle(t, "width");
          copy.height = _getStyle(t, "height");
        }

        _doc.body.appendChild(_tempDiv);

        m2 = _getTransform(_tempDiv, null, false);

        if (m1.skewType === "simple") {
          //the default _getTransform() reports the skewX/scaleY as if skewType is "compensated", thus we need to adjust that here if skewType is "simple".
          m2.scaleY *= Math.cos(m2.skewX * _DEG2RAD);
        }

        if (m1.svg) {
          //if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
          x = m1.xOrigin;
          y = m1.yOrigin;
          m2.x -= m1.xOffset;
          m2.y -= m1.yOffset;

          if (v.transformOrigin || v.svgOrigin) {
            //if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
            orig = {};

            _parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);

            x = orig.xOrigin;
            y = orig.yOrigin;
            m2.x -= orig.xOffset - m1.xOffset;
            m2.y -= orig.yOffset - m1.yOffset;
          }

          if (x || y) {
            matrix = _getMatrix(_tempDiv, true);
            m2.x -= x - (x * matrix[0] + y * matrix[2]);
            m2.y -= y - (x * matrix[1] + y * matrix[3]);
          }
        }

        _doc.body.removeChild(_tempDiv);

        if (!m2.perspective) {
          m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
        }

        if (v.xPercent != null) {
          m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
        }

        if (v.yPercent != null) {
          m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
        }
      } else if (typeof v === "object") {
        //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
        m2 = {
          scaleX: _parseVal(v.scaleX != null ? v.scaleX : v.scale, m1.scaleX),
          scaleY: _parseVal(v.scaleY != null ? v.scaleY : v.scale, m1.scaleY),
          scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
          x: _parseVal(v.x, m1.x),
          y: _parseVal(v.y, m1.y),
          z: _parseVal(v.z, m1.z),
          xPercent: _parseVal(v.xPercent, m1.xPercent),
          yPercent: _parseVal(v.yPercent, m1.yPercent),
          perspective: _parseVal(v.transformPerspective, m1.perspective)
        };
        dr = v.directionalRotation;

        if (dr != null) {
          if (typeof dr === "object") {
            for (copy in dr) {
              v[copy] = dr[copy];
            }
          } else {
            v.rotation = dr;
          }
        }

        if (typeof v.x === "string" && v.x.indexOf("%") !== -1) {
          m2.x = 0;
          m2.xPercent = _parseVal(v.x, m1.xPercent);
        }

        if (typeof v.y === "string" && v.y.indexOf("%") !== -1) {
          m2.y = 0;
          m2.yPercent = _parseVal(v.y, m1.yPercent);
        }

        m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : m1.rotation, m1.rotation, "rotation", endRotations);

        if (_supports3D) {
          m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
          m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
        }

        m2.skewX = _parseAngle(v.skewX, m1.skewX);
        m2.skewY = _parseAngle(v.skewY, m1.skewY);
      }

      if (_supports3D && v.force3D != null) {
        m1.force3D = v.force3D;
        hasChange = true;
      }

      has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective;

      if (!has3D && v.scale != null) {
        m2.scaleZ = 1; //no need to tween scaleZ.
      }

      while (--i > -1) {
        p = _transformProps[i];
        orig = m2[p] - m1[p];

        if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
          hasChange = true;
          pt = new CSSPropTween(m1, p, m1[p], orig, pt);

          if (p in endRotations) {
            pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
          }

          pt.xs0 = 0; //ensures the value stays numeric in setRatio()

          pt.plugin = plugin;

          cssp._overwriteProps.push(pt.n);
        }
      }

      orig = v.transformOrigin;

      if (m1.svg && (orig || v.svgOrigin)) {
        x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin

        y = m1.yOffset;

        _parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);

        pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.

        pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);

        if (x !== m1.xOffset || y !== m1.yOffset) {
          pt = _addNonTweeningNumericPT(m1, "xOffset", originalGSTransform ? x : m1.xOffset, m1.xOffset, pt, transformOriginString);
          pt = _addNonTweeningNumericPT(m1, "yOffset", originalGSTransform ? y : m1.yOffset, m1.yOffset, pt, transformOriginString);
        }

        orig = "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
      }

      if (orig || _supports3D && has3D && m1.zOrigin) {
        //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
        if (_transformProp) {
          hasChange = true;
          p = _transformOriginProp;
          orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors

          pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
          pt.b = style[p];
          pt.plugin = plugin;

          if (_supports3D) {
            copy = m1.zOrigin;
            orig = orig.split(" ");
            m1.zOrigin = (orig.length > 2 && !(copy !== 0 && orig[2] === "0px") ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.

            pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!

            pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)

            pt.b = copy;
            pt.xs0 = pt.e = m1.zOrigin;
          } else {
            pt.xs0 = pt.e = orig;
          } //for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).

        } else {
          _parsePosition(orig + "", m1);
        }
      }

      if (hasChange) {
        cssp._transformType = !(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3) ? 3 : 2; //quicker than calling cssp._enableTransforms();
      }

      if (swapFunc) {
        vars[parsingProp] = swapFunc;
      }

      if (scaleFunc) {
        vars.scale = scaleFunc;
      }

      return pt;
    },
    prefix: true
  });

  _registerComplexSpecialProp("boxShadow", {
    defaultValue: "0px 0px 0px 0px #999",
    prefix: true,
    color: true,
    multi: true,
    keyword: "inset"
  });

  _registerComplexSpecialProp("borderRadius", {
    defaultValue: "0px",
    parser: function (t, e, p, cssp, pt, plugin) {
      e = this.format(e);
      var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
          style = t.style,
          ea1,
          i,
          es2,
          bs2,
          bs,
          es,
          bn,
          en,
          w,
          h,
          esfx,
          bsfx,
          rel,
          hn,
          vn,
          em;
      w = parseFloat(t.offsetWidth);
      h = parseFloat(t.offsetHeight);
      ea1 = e.split(" ");

      for (i = 0; i < props.length; i++) {
        //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
        if (this.p.indexOf("border")) {
          //older browsers used a prefix
          props[i] = _checkPropPrefix(props[i]);
        }

        bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");

        if (bs.indexOf(" ") !== -1) {
          bs2 = bs.split(" ");
          bs = bs2[0];
          bs2 = bs2[1];
        }

        es = es2 = ea1[i];
        bn = parseFloat(bs);
        bsfx = bs.substr((bn + "").length);
        rel = es.charAt(1) === "=";

        if (rel) {
          en = parseInt(es.charAt(0) + "1", 10);
          es = es.substr(2);
          en *= parseFloat(es);
          esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
        } else {
          en = parseFloat(es);
          esfx = es.substr((en + "").length);
        }

        if (esfx === "") {
          esfx = _suffixMap[p] || bsfx;
        }

        if (esfx !== bsfx) {
          hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.

          vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number

          if (esfx === "%") {
            bs = hn / w * 100 + "%";
            bs2 = vn / h * 100 + "%";
          } else if (esfx === "em") {
            em = _convertToPixels(t, "borderLeft", 1, "em");
            bs = hn / em + "em";
            bs2 = vn / em + "em";
          } else {
            bs = hn + "px";
            bs2 = vn + "px";
          }

          if (rel) {
            es = parseFloat(bs) + en + esfx;
            es2 = parseFloat(bs2) + en + esfx;
          }
        }

        pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
      }

      return pt;
    },
    prefix: true,
    formatter: _getFormatter("0px 0px 0px 0px", false, true)
  });

  _registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
    defaultValue: "0px",
    parser: function (t, e, p, cssp, pt, plugin) {
      return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
    },
    prefix: true,
    formatter: _getFormatter("0px 0px", false, true)
  });

  _registerComplexSpecialProp("backgroundPosition", {
    defaultValue: "0 0",
    parser: function (t, e, p, cssp, pt, plugin) {
      var bp = "background-position",
          cs = _cs || _getComputedStyle(t, null),
          bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
          //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
      es = this.format(e),
          ba,
          ea,
          i,
          pct,
          overlap,
          src;

      if (bs.indexOf("%") !== -1 !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
        src = _getStyle(t, "backgroundImage").replace(_urlExp, "");

        if (src && src !== "none") {
          ba = bs.split(" ");
          ea = es.split(" ");

          _tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height


          i = 2;

          while (--i > -1) {
            bs = ba[i];
            pct = bs.indexOf("%") !== -1;

            if (pct !== (ea[i].indexOf("%") !== -1)) {
              overlap = i === 0 ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
              ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%";
            }
          }

          bs = ba.join(" ");
        }
      }

      return this.parseComplex(t.style, bs, es, pt, plugin);
    },
    formatter: _parsePosition
  });

  _registerComplexSpecialProp("backgroundSize", {
    defaultValue: "0 0",
    formatter: function (v) {
      v += ""; //ensure it's a string

      return v.substr(0, 2) === "co" ? v : _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v); //if set to something like "100% 100%", Safari typically reports the computed style as just "100%" (no 2nd value), but we should ensure that there are two values, so copy the first one. Otherwise, it'd be interpreted as "100% 0" (wrong). Also remember that it could be "cover" or "contain" which we can't tween but should be able to set.
    }
  });

  _registerComplexSpecialProp("perspective", {
    defaultValue: "0px",
    prefix: true
  });

  _registerComplexSpecialProp("perspectiveOrigin", {
    defaultValue: "50% 50%",
    prefix: true
  });

  _registerComplexSpecialProp("transformStyle", {
    prefix: true
  });

  _registerComplexSpecialProp("backfaceVisibility", {
    prefix: true
  });

  _registerComplexSpecialProp("userSelect", {
    prefix: true
  });

  _registerComplexSpecialProp("margin", {
    parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")
  });

  _registerComplexSpecialProp("padding", {
    parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")
  });

  _registerComplexSpecialProp("clip", {
    defaultValue: "rect(0px,0px,0px,0px)",
    parser: function (t, e, p, cssp, pt, plugin) {
      var b, cs, delim;

      if (_ieVers < 9) {
        //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
        cs = t.currentStyle;
        delim = _ieVers < 8 ? " " : ",";
        b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
        e = this.format(e).split(",").join(delim);
      } else {
        b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
        e = this.format(e);
      }

      return this.parseComplex(t.style, b, e, pt, plugin);
    }
  });

  _registerComplexSpecialProp("textShadow", {
    defaultValue: "0px 0px 0px #999",
    color: true,
    multi: true
  });

  _registerComplexSpecialProp("autoRound,strictUnits", {
    parser: function (t, e, p, cssp, pt) {
      return pt;
    }
  }); //just so that we can ignore these properties (not tween them)


  _registerComplexSpecialProp("border", {
    defaultValue: "0px solid #000",
    parser: function (t, e, p, cssp, pt, plugin) {
      var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
          end = this.format(e).split(" "),
          esfx = end[0].replace(_suffixExp, "");

      if (esfx !== "px") {
        //if we're animating to a non-px value, we need to convert the beginning width to that unit.
        bw = parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx) + esfx;
      }

      return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
    },
    color: true,
    formatter: function (v) {
      var a = v.split(" ");
      return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
    }
  });

  _registerComplexSpecialProp("borderWidth", {
    parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
  }); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).


  _registerComplexSpecialProp("float,cssFloat,styleFloat", {
    parser: function (t, e, p, cssp, pt, plugin) {
      var s = t.style,
          prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
      return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
    }
  }); //opacity-related


  var _setIEOpacityRatio = function (v) {
    var t = this.t,
        //refers to the element's style property
    filters = t.filter || _getStyle(this.data, "filter") || "",
        val = this.s + this.c * v | 0,
        skip;

    if (val === 100) {
      //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
      if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
        t.removeAttribute("filter");
        skip = !_getStyle(this.data, "filter"); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
      } else {
        t.filter = filters.replace(_alphaFilterExp, "");
        skip = true;
      }
    }

    if (!skip) {
      if (this.xn1) {
        t.filter = filters = filters || "alpha(opacity=" + val + ")"; //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
      }

      if (filters.indexOf("pacity") === -1) {
        //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
        if (val !== 0 || !this.xn1) {
          //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
          t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
        }
      } else {
        t.filter = filters.replace(_opacityExp, "opacity=" + val);
      }
    }
  };

  _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
    defaultValue: "1",
    parser: function (t, e, p, cssp, pt, plugin) {
      var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
          style = t.style,
          isAutoAlpha = p === "autoAlpha";

      if (typeof e === "string" && e.charAt(1) === "=") {
        e = (e.charAt(0) === "-" ? -1 : 1) * parseFloat(e.substr(2)) + b;
      }

      if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
        //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
        b = 0;
      }

      if (_supportsOpacity) {
        pt = new CSSPropTween(style, "opacity", b, e - b, pt);
      } else {
        pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
        pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.

        style.zoom = 1; //helps correct an IE issue.

        pt.type = 2;
        pt.b = "alpha(opacity=" + pt.s + ")";
        pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
        pt.data = t;
        pt.plugin = plugin;
        pt.setRatio = _setIEOpacityRatio;
      }

      if (isAutoAlpha) {
        //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
        pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, b !== 0 ? "inherit" : "hidden", e === 0 ? "hidden" : "inherit");
        pt.xs0 = "inherit";

        cssp._overwriteProps.push(pt.n);

        cssp._overwriteProps.push(p);
      }

      return pt;
    }
  });

  var _removeProp = function (s, p) {
    if (p) {
      if (s.removeProperty) {
        if (p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") {
          //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
          p = "-" + p;
        }

        s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
      } else {
        //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
        s.removeAttribute(p);
      }
    }
  },
      _setClassNameRatio = function (v) {
    this.t._gsClassPT = this;

    if (v === 1 || v === 0) {
      this.t.setAttribute("class", v === 0 ? this.b : this.e);
      var mpt = this.data,
          //first MiniPropTween
      s = this.t.style;

      while (mpt) {
        if (!mpt.v) {
          _removeProp(s, mpt.p);
        } else {
          s[mpt.p] = mpt.v;
        }

        mpt = mpt._next;
      }

      if (v === 1 && this.t._gsClassPT === this) {
        this.t._gsClassPT = null;
      }
    } else if (this.t.getAttribute("class") !== this.e) {
      this.t.setAttribute("class", this.e);
    }
  };

  _registerComplexSpecialProp("className", {
    parser: function (t, e, p, cssp, pt, plugin, vars) {
      var b = t.getAttribute("class") || "",
          //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
      cssText = t.style.cssText,
          difData,
          bs,
          cnpt,
          cnptLookup,
          mpt;
      pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
      pt.setRatio = _setClassNameRatio;
      pt.pr = -11;
      _hasPriority = true;
      pt.b = b;
      bs = _getAllStyles(t, _cs); //if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)

      cnpt = t._gsClassPT;

      if (cnpt) {
        cnptLookup = {};
        mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.

        while (mpt) {
          cnptLookup[mpt.p] = 1;
          mpt = mpt._next;
        }

        cnpt.setRatio(1);
      }

      t._gsClassPT = pt;
      pt.e = e.charAt(1) !== "=" ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + (e.charAt(0) === "+" ? " " + e.substr(2) : "");
      t.setAttribute("class", pt.e);
      difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
      t.setAttribute("class", b);
      pt.data = difData.firstMPT;
      t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).

      pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)

      return pt;
    }
  });

  var _setClearPropsRatio = function (v) {
    if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
      //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
      var s = this.t.style,
          transformParse = _specialProps.transform.parse,
          a,
          p,
          i,
          clearTransform,
          transform;

      if (this.e === "all") {
        s.cssText = "";
        clearTransform = true;
      } else {
        a = this.e.split(" ").join("").split(",");
        i = a.length;

        while (--i > -1) {
          p = a[i];

          if (_specialProps[p]) {
            if (_specialProps[p].parse === transformParse) {
              clearTransform = true;
            } else {
              p = p === "transformOrigin" ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
            }
          }

          _removeProp(s, p);
        }
      }

      if (clearTransform) {
        _removeProp(s, _transformProp);

        transform = this.t._gsTransform;

        if (transform) {
          if (transform.svg) {
            this.t.removeAttribute("data-svg-origin");
            this.t.removeAttribute("transform");
          }

          delete this.t._gsTransform;
        }
      }
    }
  };

  _registerComplexSpecialProp("clearProps", {
    parser: function (t, e, p, cssp, pt) {
      pt = new CSSPropTween(t, p, 0, 0, pt, 2);
      pt.setRatio = _setClearPropsRatio;
      pt.e = e;
      pt.pr = -10;
      pt.data = cssp._tween;
      _hasPriority = true;
      return pt;
    }
  });

  p = "bezier,throwProps,physicsProps,physics2D".split(",");
  i = p.length;

  while (i--) {
    _registerPluginProp(p[i]);
  }

  p = CSSPlugin.prototype;
  p._firstPT = p._lastParsedTransform = p._transform = null; //gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.

  p._onInitTween = function (target, vars, tween, index) {
    if (!target.nodeType) {
      //css is only for dom elements
      return false;
    }

    this._target = _target = target;
    this._tween = tween;
    this._vars = vars;
    _index = index;
    _autoRound = vars.autoRound;
    _hasPriority = false;
    _suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
    _cs = _getComputedStyle(target, "");
    _overwriteProps = this._overwriteProps;
    var style = target.style,
        v,
        pt,
        pt2,
        first,
        last,
        next,
        zIndex,
        tpt,
        threeD;
    if (_reqSafariFix) if (style.zIndex === "") {
      v = _getStyle(target, "zIndex", _cs);

      if (v === "auto" || v === "") {
        //corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
        this._addLazySet(style, "zIndex", 0);
      }
    }

    if (typeof vars === "string") {
      first = style.cssText;
      v = _getAllStyles(target, _cs);
      style.cssText = first + ";" + vars;
      v = _cssDif(target, v, _getAllStyles(target)).difs;

      if (!_supportsOpacity && _opacityValExp.test(vars)) {
        v.opacity = parseFloat(RegExp.$1);
      }

      vars = v;
      style.cssText = first;
    }

    if (vars.className) {
      //className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
      this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
    } else {
      this._firstPT = pt = this.parse(target, vars, null);
    }

    if (this._transformType) {
      threeD = this._transformType === 3;

      if (!_transformProp) {
        style.zoom = 1; //helps correct an IE issue.
      } else if (_isSafari) {
        _reqSafariFix = true; //if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).

        if (style.zIndex === "") {
          zIndex = _getStyle(target, "zIndex", _cs);

          if (zIndex === "auto" || zIndex === "") {
            this._addLazySet(style, "zIndex", 0);
          }
        } //Setting WebkitBackfaceVisibility corrects 3 bugs:
        // 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
        // 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
        // 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
        //Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.


        if (_isSafariLT6) {
          this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
        }
      }

      pt2 = pt;

      while (pt2 && pt2._next) {
        pt2 = pt2._next;
      }

      tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);

      this._linkCSSP(tpt, null, pt2);

      tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
      tpt.data = this._transform || _getTransform(target, _cs, true);
      tpt.tween = tween;
      tpt.pr = -1; //ensures that the transforms get applied after the components are updated.

      _overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.

    }

    if (_hasPriority) {
      //reorders the linked list in order of pr (priority)
      while (pt) {
        next = pt._next;
        pt2 = first;

        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }

        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }

        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }

        pt = next;
      }

      this._firstPT = first;
    }

    return true;
  };

  p.parse = function (target, vars, pt, plugin) {
    var style = target.style,
        p,
        sp,
        bn,
        en,
        bs,
        es,
        bsfx,
        esfx,
        isStr,
        rel;

    for (p in vars) {
      es = vars[p]; //ending value string

      if (typeof es === "function") {
        es = es(_index, _target);
      }

      sp = _specialProps[p]; //SpecialProp lookup.

      if (sp) {
        pt = sp.parse(target, es, p, this, pt, plugin, vars);
      } else if (p.substr(0, 2) === "--") {
        //for tweening CSS variables (which always start with "--"). To maximize performance and simplicity, we bypass CSSPlugin altogether and just add a normal property tween to the tween instance itself.
        this._tween._propLookup[p] = this._addTween.call(this._tween, target.style, "setProperty", _getComputedStyle(target).getPropertyValue(p) + "", es + "", p, false, p);
        continue;
      } else {
        bs = _getStyle(target, p, _cs) + "";
        isStr = typeof es === "string";

        if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es)) {
          //Opera uses background: to define color sometimes in addition to backgroundColor:
          if (!isStr) {
            es = _parseColor(es);
            es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")";
          }

          pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);
        } else if (isStr && _complexExp.test(es)) {
          pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);
        } else {
          bn = parseFloat(bs);
          bsfx = bn || bn === 0 ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

          if (bs === "" || bs === "auto") {
            if (p === "width" || p === "height") {
              bn = _getDimension(target, p, _cs);
              bsfx = "px";
            } else if (p === "left" || p === "top") {
              bn = _calculateOffset(target, p, _cs);
              bsfx = "px";
            } else {
              bn = p !== "opacity" ? 0 : 1;
              bsfx = "";
            }
          }

          rel = isStr && es.charAt(1) === "=";

          if (rel) {
            en = parseInt(es.charAt(0) + "1", 10);
            es = es.substr(2);
            en *= parseFloat(es);
            esfx = es.replace(_suffixExp, "");
          } else {
            en = parseFloat(es);
            esfx = isStr ? es.replace(_suffixExp, "") : "";
          }

          if (esfx === "") {
            esfx = p in _suffixMap ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
          }

          es = en || en === 0 ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.
          //if the beginning/ending suffixes don't match, normalize them...

          if (bsfx !== esfx) if (esfx !== "" || p === "lineHeight") if (en || en === 0) if (bn) {
            //note: if the beginning value (bn) is 0, we don't need to convert units!
            bn = _convertToPixels(target, p, bn, bsfx);

            if (esfx === "%") {
              bn /= _convertToPixels(target, p, 100, "%") / 100;

              if (vars.strictUnits !== true) {
                //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
                bs = bn + "%";
              }
            } else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
              bn /= _convertToPixels(target, p, 1, esfx); //otherwise convert to pixels.
            } else if (esfx !== "px") {
              en = _convertToPixels(target, p, en, esfx);
              esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
            }

            if (rel) if (en || en === 0) {
              es = en + bn + esfx; //the changes we made affect relative calculations, so adjust the end value here.
            }
          }

          if (rel) {
            en += bn;
          }

          if ((bn || bn === 0) && (en || en === 0)) {
            //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
            pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== false && (esfx === "px" || p === "zIndex"), 0, bs, es);
            pt.xs0 = esfx; //DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
          } else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
            _log("invalid " + p + " tween value: " + vars[p]);
          } else {
            pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
            pt.xs0 = es === "none" && (p === "display" || p.indexOf("Style") !== -1) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
            //DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
          }
        }
      }

      if (plugin) if (pt && !pt.plugin) {
        pt.plugin = plugin;
      }
    }

    return pt;
  }; //gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.


  p.setRatio = function (v) {
    var pt = this._firstPT,
        min = 0.000001,
        val,
        str,
        i; //at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).

    if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
      while (pt) {
        if (pt.type !== 2) {
          if (pt.r && pt.type !== -1) {
            val = pt.r(pt.s + pt.c);

            if (!pt.type) {
              pt.t[pt.p] = val + pt.xs0;
            } else if (pt.type === 1) {
              //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
              i = pt.l;
              str = pt.xs0 + val + pt.xs1;

              for (i = 1; i < pt.l; i++) {
                str += pt["xn" + i] + pt["xs" + (i + 1)];
              }

              pt.t[pt.p] = str;
            }
          } else {
            pt.t[pt.p] = pt.e;
          }
        } else {
          pt.setRatio(v);
        }

        pt = pt._next;
      }
    } else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
      while (pt) {
        val = pt.c * v + pt.s;

        if (pt.r) {
          val = pt.r(val);
        } else if (val < min) if (val > -min) {
          val = 0;
        }

        if (!pt.type) {
          pt.t[pt.p] = val + pt.xs0;
        } else if (pt.type === 1) {
          //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
          i = pt.l;

          if (i === 2) {
            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
          } else if (i === 3) {
            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
          } else if (i === 4) {
            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
          } else if (i === 5) {
            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
          } else {
            str = pt.xs0 + val + pt.xs1;

            for (i = 1; i < pt.l; i++) {
              str += pt["xn" + i] + pt["xs" + (i + 1)];
            }

            pt.t[pt.p] = str;
          }
        } else if (pt.type === -1) {
          //non-tweening value
          pt.t[pt.p] = pt.xs0;
        } else if (pt.setRatio) {
          //custom setRatio() for things like SpecialProps, external plugins, etc.
          pt.setRatio(v);
        }

        pt = pt._next;
      } //if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).

    } else {
      while (pt) {
        if (pt.type !== 2) {
          pt.t[pt.p] = pt.b;
        } else {
          pt.setRatio(v);
        }

        pt = pt._next;
      }
    }
  };
  /**
   * @private
   * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
   * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
   * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
   * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
   * doesn't have any transform-related properties of its own. You can call this method as many times as you
   * want and it won't create duplicate CSSPropTweens.
   *
   * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
   */


  p._enableTransforms = function (threeD) {
    this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.

    this._transformType = !(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3) ? 3 : 2;
  };

  var lazySet = function (v) {
    this.t[this.p] = this.e;

    this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.

  };
  /** @private Gives us a way to set a value on the first render (and only the first render). **/


  p._addLazySet = function (t, p, v) {
    var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
    pt.e = v;
    pt.setRatio = lazySet;
    pt.data = this;
  };
  /** @private **/


  p._linkCSSP = function (pt, next, prev, remove) {
    if (pt) {
      if (next) {
        next._prev = pt;
      }

      if (pt._next) {
        pt._next._prev = pt._prev;
      }

      if (pt._prev) {
        pt._prev._next = pt._next;
      } else if (this._firstPT === pt) {
        this._firstPT = pt._next;
        remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
      }

      if (prev) {
        prev._next = pt;
      } else if (!remove && this._firstPT === null) {
        this._firstPT = pt;
      }

      pt._next = next;
      pt._prev = prev;
    }

    return pt;
  };

  p._mod = function (lookup) {
    var pt = this._firstPT;

    while (pt) {
      if (typeof lookup[pt.p] === "function") {
        //only gets called by RoundPropsPlugin (ModifyPlugin manages all the rendering internally for CSSPlugin properties that need modification). Remember, we handle rounding a bit differently in this plugin for performance reasons, leveraging "r" as an indicator that the value should be rounded internally.
        pt.r = lookup[pt.p];
      }

      pt = pt._next;
    }
  }; //we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.


  p._kill = function (lookup) {
    var copy = lookup,
        pt,
        p,
        xfirst;

    if (lookup.autoAlpha || lookup.alpha) {
      copy = {};

      for (p in lookup) {
        //copy the lookup so that we're not changing the original which may be passed elsewhere.
        copy[p] = lookup[p];
      }

      copy.opacity = 1;

      if (copy.autoAlpha) {
        copy.visibility = 1;
      }
    }

    if (lookup.className && (pt = this._classNamePT)) {
      //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
      xfirst = pt.xfirst;

      if (xfirst && xfirst._prev) {
        this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev

      } else if (xfirst === this._firstPT) {
        this._firstPT = pt._next;
      }

      if (pt._next) {
        this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
      }

      this._classNamePT = null;
    }

    pt = this._firstPT;

    while (pt) {
      if (pt.plugin && pt.plugin !== p && pt.plugin._kill) {
        //for plugins that are registered with CSSPlugin, we should notify them of the kill.
        pt.plugin._kill(lookup);

        p = pt.plugin;
      }

      pt = pt._next;
    }

    return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenPlugin"].prototype._kill.call(this, copy);
  }; //used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.


  var _getChildStyles = function (e, props, targets) {
    var children, i, child, type;

    if (e.slice) {
      i = e.length;

      while (--i > -1) {
        _getChildStyles(e[i], props, targets);
      }

      return;
    }

    children = e.childNodes;
    i = children.length;

    while (--i > -1) {
      child = children[i];
      type = child.type;

      if (child.style) {
        props.push(_getAllStyles(child));

        if (targets) {
          targets.push(child);
        }
      }

      if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
        _getChildStyles(child, props, targets);
      }
    }
  };
  /**
   * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
   * and then compares the style properties of all the target's child elements at the tween's start and end, and
   * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
   * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
   * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
   * is because it creates entirely new tweens that may have completely different targets than the original tween,
   * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
   * and it would create other problems. For example:
   *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
   *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
   *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
   *
   * @param {Object} target object to be tweened
   * @param {number} Duration in seconds (or frames for frames-based tweens)
   * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
   * @return {Array} An array of TweenLite instances
   */


  CSSPlugin.cascadeTo = function (target, duration, vars) {
    var tween = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].to(target, duration, vars),
        results = [tween],
        b = [],
        e = [],
        targets = [],
        _reservedProps = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]._internals.reservedProps,
        i,
        difs,
        p,
        from;
    target = tween._targets || tween.target;

    _getChildStyles(target, b, targets);

    tween.render(duration, true, true);

    _getChildStyles(target, e);

    tween.render(0, true, true);

    tween._enabled(true);

    i = targets.length;

    while (--i > -1) {
      difs = _cssDif(targets[i], b[i], e[i]);

      if (difs.firstMPT) {
        difs = difs.difs;

        for (p in vars) {
          if (_reservedProps[p]) {
            difs[p] = vars[p];
          }
        }

        from = {};

        for (p in difs) {
          from[p] = b[i][p];
        }

        results.push(_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromTo(targets[i], duration, from, difs));
      }
    }

    return results;
  };

  _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenPlugin"].activate([CSSPlugin]);
  return CSSPlugin;
}, true);

var CSSPlugin = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].CSSPlugin;


/***/ }),

/***/ "./js/plugins/greensock/DirectionalRotationPlugin.js":
/*!***********************************************************!*\
  !*** ./js/plugins/greensock/DirectionalRotationPlugin.js ***!
  \***********************************************************/
/*! exports provided: DirectionalRotationPlugin, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalRotationPlugin", function() { return DirectionalRotationPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DirectionalRotationPlugin; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/*!
 * VERSION: 0.3.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/

var DirectionalRotationPlugin = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.plugin({
  propName: "directionalRotation",
  version: "0.3.1",
  API: 2,
  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
  init: function (target, value, tween, index) {
    if (typeof value !== "object") {
      value = {
        rotation: value
      };
    }

    this.finals = {};
    var cap = value.useRadians === true ? Math.PI * 2 : 360,
        min = 0.000001,
        p,
        v,
        start,
        end,
        dif,
        split;

    for (p in value) {
      if (p !== "useRadians") {
        end = value[p];

        if (typeof end === "function") {
          end = end(index, target);
        }

        split = (end + "").split("_");
        v = split[0];
        start = parseFloat(typeof target[p] !== "function" ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]());
        end = this.finals[p] = typeof v === "string" && v.charAt(1) === "=" ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
        dif = end - start;

        if (split.length) {
          v = split.join("_");

          if (v.indexOf("short") !== -1) {
            dif = dif % cap;

            if (dif !== dif % (cap / 2)) {
              dif = dif < 0 ? dif + cap : dif - cap;
            }
          }

          if (v.indexOf("_cw") !== -1 && dif < 0) {
            dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
          } else if (v.indexOf("ccw") !== -1 && dif > 0) {
            dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
          }
        }

        if (dif > min || dif < -min) {
          this._addTween(target, p, start, start + dif, p);

          this._overwriteProps.push(p);
        }
      }
    }

    return true;
  },
  //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
  set: function (ratio) {
    var pt;

    if (ratio !== 1) {
      this._super.setRatio.call(this, ratio);
    } else {
      pt = this._firstPT;

      while (pt) {
        if (pt.f) {
          pt.t[pt.p](this.finals[pt.p]);
        } else {
          pt.t[pt.p] = this.finals[pt.p];
        }

        pt = pt._next;
      }
    }
  }
});
DirectionalRotationPlugin._autoCSS = true;


/***/ }),

/***/ "./js/plugins/greensock/Draggable.js":
/*!*******************************************!*\
  !*** ./js/plugins/greensock/Draggable.js ***!
  \*******************************************/
/*! exports provided: Draggable, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Draggable", function() { return Draggable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Draggable; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./js/plugins/greensock/CSSPlugin.js");
/*!
 * VERSION: 0.16.5
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Requires TweenLite and CSSPlugin version 1.17.0 or later (TweenMax contains both TweenLite and CSSPlugin). ThrowPropsPlugin is required for momentum-based continuation of movement after the mouse/touch is released (ThrowPropsPlugin is a membership benefit of Club GreenSock - http://greensock.com/club/).
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */



_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine("utils.Draggable", ["events.EventDispatcher", "TweenLite", "plugins.CSSPlugin"], function () {
  var _tempVarsXY = {
    css: {},
    data: "_draggable"
  },
      //speed optimization - we reuse the same vars object for x/y TweenLite.set() calls to minimize garbage collection tasks and improve performance.
  _tempVarsX = {
    css: {},
    data: "_draggable"
  },
      _tempVarsY = {
    css: {},
    data: "_draggable"
  },
      _tempVarsRotation = {
    css: {}
  },
      _globals = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.globals,
      _tempEvent = {},
      //for populating with pageX/pageY in old versions of IE
  _emptyFunc = function () {
    return false;
  },
      _dummyElement = {
    style: {},
    appendChild: _emptyFunc,
    removeChild: _emptyFunc
  },
      _doc = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].document || {
    createElement: function () {
      return _dummyElement;
    }
  },
      _docElement = _doc.documentElement || {},
      _createElement = function (type) {
    return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
  },
      _tempDiv = _createElement("div"),
      _emptyArray = [],
      _RAD2DEG = 180 / Math.PI,
      _max = 999999999999999,
      _getTime = Date.now || function () {
    return new Date().getTime();
  },
      _isOldIE = !!(!_doc.addEventListener && _doc.all),
      _placeholderDiv = _doc.createElement("div"),
      _renderQueue = [],
      _lookup = {},
      //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.
  _lookupCount = 0,
      _clickableTagExp = /^(?:a|input|textarea|button|select)$/i,
      _dragCount = 0,
      //total number of elements currently being dragged
  _prefix,
      _isMultiTouching,
      _isAndroid = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].navigator && _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].navigator.userAgent.toLowerCase().indexOf("android") !== -1,
      //Android handles touch events in an odd way and it's virtually impossible to "feature test" so we resort to UA sniffing
  _lastDragTime = 0,
      _temp1 = {},
      // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.
  _windowProxy = {},
      //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.
  _slice = function (a) {
    //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
    if (typeof a === "string") {
      a = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].selector(a);
    }

    if (!a || a.nodeType) {
      //if it's not an array, wrap it in one.
      return [a];
    }

    var b = [],
        l = a.length,
        i;

    for (i = 0; i !== l; b.push(a[i++]));

    return b;
  },
      _copy = function (obj, factor) {
    var copy = {},
        p;

    if (factor) {
      for (p in obj) {
        copy[p] = obj[p] * factor;
      }
    } else {
      for (p in obj) {
        copy[p] = obj[p];
      }
    }

    return copy;
  },
      ThrowPropsPlugin,
      _renderQueueTick = function () {
    var i = _renderQueue.length;

    while (--i > -1) {
      _renderQueue[i]();
    }
  },
      _addToRenderQueue = function (func) {
    _renderQueue.push(func);

    if (_renderQueue.length === 1) {
      _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].ticker.addEventListener("tick", _renderQueueTick, this, false, 1);
    }
  },
      _removeFromRenderQueue = function (func) {
    var i = _renderQueue.length;

    while (--i > -1) {
      if (_renderQueue[i] === func) {
        _renderQueue.splice(i, 1);
      }
    }

    _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].to(_renderQueueTimeout, 0, {
      overwrite: "all",
      delay: 15,
      onComplete: _renderQueueTimeout,
      data: "_draggable"
    }); //remove the "tick" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).
  },
      _renderQueueTimeout = function () {
    if (!_renderQueue.length) {
      _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].ticker.removeEventListener("tick", _renderQueueTick);
    }
  },
      _extend = function (obj, defaults) {
    var p;

    for (p in defaults) {
      if (obj[p] === undefined) {
        obj[p] = defaults[p];
      }
    }

    return obj;
  },
      _getDocScrollTop = function () {
    return window.pageYOffset != null ? window.pageYOffset : _doc.scrollTop != null ? _doc.scrollTop : _docElement.scrollTop || _doc.body.scrollTop || 0;
  },
      _getDocScrollLeft = function () {
    return window.pageXOffset != null ? window.pageXOffset : _doc.scrollLeft != null ? _doc.scrollLeft : _docElement.scrollLeft || _doc.body.scrollLeft || 0;
  },
      _addScrollListener = function (e, callback) {
    _addListener(e, "scroll", callback);

    if (!_isRoot(e.parentNode)) {
      _addScrollListener(e.parentNode, callback);
    }
  },
      _removeScrollListener = function (e, callback) {
    _removeListener(e, "scroll", callback);

    if (!_isRoot(e.parentNode)) {
      _removeScrollListener(e.parentNode, callback);
    }
  },
      _isRoot = function (e) {
    return !!(!e || e === _docElement || e === _doc || e === _doc.body || e === window || !e.nodeType || !e.parentNode);
  },
      _getMaxScroll = function (element, axis) {
    var dim = axis === "x" ? "Width" : "Height",
        scroll = "scroll" + dim,
        client = "client" + dim,
        body = _doc.body;
    return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], body[scroll]) - (window["inner" + dim] || _docElement[client] || body[client]) : element[scroll] - element[client]);
  },
      _recordMaxScrolls = function (e) {
    //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.
    var isRoot = _isRoot(e),
        x = _getMaxScroll(e, "x"),
        y = _getMaxScroll(e, "y");

    if (isRoot) {
      e = _windowProxy;
    } else {
      _recordMaxScrolls(e.parentNode);
    }

    e._gsMaxScrollX = x;
    e._gsMaxScrollY = y;
    e._gsScrollX = e.scrollLeft || 0;
    e._gsScrollY = e.scrollTop || 0;
  },
      //just used for IE8 and earlier to normalize events and populate pageX/pageY
  _populateIEEvent = function (e, preventDefault) {
    e = e || window.event;
    _tempEvent.pageX = e.clientX + _doc.body.scrollLeft + _docElement.scrollLeft;
    _tempEvent.pageY = e.clientY + _doc.body.scrollTop + _docElement.scrollTop;

    if (preventDefault) {
      e.returnValue = false;
    }

    return _tempEvent;
  },
      //grabs the first element it finds (and we include the window as an element), so if it's selector text, it'll feed that value to TweenLite.selector, if it's a jQuery object or some other selector engine's result, it'll grab the first one, and same for an array. If the value doesn't contain a DOM element, it'll just return null.
  _unwrapElement = function (value) {
    if (!value) {
      return value;
    }

    if (typeof value === "string") {
      value = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].selector(value);
    }

    if (value.length && value !== window && value[0] && value[0].style && !value.nodeType) {
      value = value[0];
    }

    return value === window || value.nodeType && value.style ? value : null;
  },
      _checkPrefix = function (e, p) {
    var s = e.style,
        capped,
        i,
        a;

    if (s[p] === undefined) {
      a = ["O", "Moz", "ms", "Ms", "Webkit"];
      i = 5;
      capped = p.charAt(0).toUpperCase() + p.substr(1);

      while (--i > -1 && s[a[i] + capped] === undefined) {}

      if (i < 0) {
        return "";
      }

      _prefix = i === 3 ? "ms" : a[i];
      p = _prefix + capped;
    }

    return p;
  },
      _setStyle = function (e, p, value) {
    var s = e.style;

    if (!s) {
      return;
    }

    if (s[p] === undefined) {
      p = _checkPrefix(e, p);
    }

    if (value == null) {
      if (s.removeProperty) {
        s.removeProperty(p.replace(/([A-Z])/g, "-$1").toLowerCase());
      } else {
        //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
        s.removeAttribute(p);
      }
    } else if (s[p] !== undefined) {
      s[p] = value;
    }
  },
      _getCSFunc = (typeof window !== "undefined" ? window : _doc.defaultView || {
    getComputedStyle: function () {}
  }).getComputedStyle,
      _getComputedStyle = function (e, s) {
    return _getCSFunc(e instanceof Element ? e : e.host || (e.parentNode || {}).host || e, s); //the "host" stuff helps to accommodate ShadowDom objects.
  },
      _horizExp = /(?:Left|Right|Width)/i,
      _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
      _convertToPixels = function (t, p, v, sfx, recurse) {
    if (sfx === "px" || !sfx) {
      return v;
    }

    if (sfx === "auto" || !v) {
      return 0;
    }

    var horiz = _horizExp.test(p),
        node = t,
        style = _tempDiv.style,
        neg = v < 0,
        pix;

    if (neg) {
      v = -v;
    }

    if (sfx === "%" && p.indexOf("border") !== -1) {
      pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
    } else {
      style.cssText = "border:0 solid red;position:" + _getStyle(t, "position", true) + ";line-height:0;";

      if (sfx === "%" || !node.appendChild) {
        node = t.parentNode || _doc.body;
        style[horiz ? "width" : "height"] = v + sfx;
      } else {
        style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
      }

      node.appendChild(_tempDiv);
      pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
      node.removeChild(_tempDiv);

      if (pix === 0 && !recurse) {
        pix = _convertToPixels(t, p, v, sfx, true);
      }
    }

    return neg ? -pix : pix;
  },
      _calculateOffset = function (t, p) {
    //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
    if (_getStyle(t, "position", true) !== "absolute") {
      return 0;
    }

    var dim = p === "left" ? "Left" : "Top",
        v = _getStyle(t, "margin" + dim, true);

    return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), (v + "").replace(_suffixExp, "")) || 0);
  },
      _getStyle = function (element, prop, keepUnits) {
    var rv = (element._gsTransform || {})[prop],
        cs;

    if (rv || rv === 0) {
      return rv;
    } else if (element.style && element.style[prop]) {
      //shadow dom elements don't have "style".
      rv = element.style[prop];
    } else if (cs = _getComputedStyle(element)) {
      rv = cs.getPropertyValue(prop.replace(/([A-Z])/g, "-$1").toLowerCase());
      rv = rv || cs.length ? rv : cs[prop]; //Opera behaves VERY strangely - length is usually 0 and cs[prop] is the only way to get accurate results EXCEPT when checking for -o-transform which only works with cs.getPropertyValue()!
    } else if (element.currentStyle) {
      rv = element.currentStyle[prop];
    }

    if (rv === "auto" && (prop === "top" || prop === "left")) {
      rv = _calculateOffset(element, prop);
    }

    return keepUnits ? rv : parseFloat(rv) || 0;
  },
      _dispatchEvent = function (instance, type, callbackName) {
    var vars = instance.vars,
        callback = vars[callbackName],
        listeners = instance._listeners[type];

    if (typeof callback === "function") {
      callback.apply(vars[callbackName + "Scope"] || vars.callbackScope || instance, vars[callbackName + "Params"] || [instance.pointerEvent]);
    }

    if (listeners) {
      instance.dispatchEvent(type);
    }
  },
      _getBounds = function (obj, context) {
    //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.
    var e = _unwrapElement(obj),
        top,
        left,
        offset;

    if (!e) {
      if (obj.left !== undefined) {
        offset = _getOffsetTransformOrigin(context); //the bounds should be relative to the origin

        return {
          left: obj.left - offset.x,
          top: obj.top - offset.y,
          width: obj.width,
          height: obj.height
        };
      }

      left = obj.min || obj.minX || obj.minRotation || 0;
      top = obj.min || obj.minY || 0;
      return {
        left: left,
        top: top,
        width: (obj.max || obj.maxX || obj.maxRotation || 0) - left,
        height: (obj.max || obj.maxY || 0) - top
      };
    }

    return _getElementBounds(e, context);
  },
      _svgBorderFactor,
      _svgBorderScales,
      _svgScrollOffset,
      _hasBorderBug,
      _hasReparentBug,
      //some browsers, like Chrome 49, alter the offsetTop/offsetLeft/offsetParent of elements when a non-identity transform is applied.
  _setEnvironmentVariables = function () {
    //some browsers factor the border into the SVG coordinate space, some don't (like Firefox). Some apply transforms to them, some don't. We feature-detect here so we know how to handle the border(s). We can't do this immediately - we must wait for the document.body to exist.
    if (!_doc.createElementNS) {
      _svgBorderFactor = 0;
      _svgBorderScales = false;
      return;
    }

    var div = _createElement("div"),
        svg = _doc.createElementNS("http://www.w3.org/2000/svg", "svg"),
        wrapper = _createElement("div"),
        style = div.style,
        parent = _doc.body || _docElement,
        isFlex = _getStyle(parent, "display", true) === "flex",
        //Firefox bug causes getScreenCTM() to return null when parent is display:flex and the element isn't rendered inside the window (like if it's below the scroll position)
    matrix,
        e1,
        point,
        oldValue;

    if (_doc.body && _transformProp) {
      style.position = "absolute";
      parent.appendChild(wrapper);
      wrapper.appendChild(div);
      oldValue = div.offsetParent;
      wrapper.style[_transformProp] = "rotate(1deg)";
      _hasReparentBug = div.offsetParent === oldValue;
      wrapper.style.position = "absolute";
      style.height = "10px";
      oldValue = div.offsetTop;
      wrapper.style.border = "5px solid red";
      _hasBorderBug = oldValue !== div.offsetTop; //some browsers, like Firefox 38, cause the offsetTop/Left to be affected by a parent's border.

      parent.removeChild(wrapper);
    }

    style = svg.style;
    svg.setAttributeNS(null, "width", "400px");
    svg.setAttributeNS(null, "height", "400px");
    svg.setAttributeNS(null, "viewBox", "0 0 400 400");
    style.display = "block";
    style.boxSizing = "border-box";
    style.border = "0px solid red";
    style.transform = "none"; // in some browsers (like certain flavors of Android), the getScreenCTM() matrix is contaminated by the scroll position. We can run some logic here to detect that condition, but we ended up not needing this because we found another workaround using getBoundingClientRect().

    div.style.cssText = "width:100px;height:100px;overflow:scroll;-ms-overflow-style:none;";
    parent.appendChild(div);
    div.appendChild(svg);
    point = svg.createSVGPoint().matrixTransform(svg.getScreenCTM());
    e1 = point.y;
    div.scrollTop = 100;
    point.x = point.y = 0;
    point = point.matrixTransform(svg.getScreenCTM());
    _svgScrollOffset = e1 - point.y < 100.1 ? 0 : e1 - point.y - 150;
    div.removeChild(svg);
    parent.removeChild(div); // -- end _svgScrollOffset calculation.

    parent.appendChild(svg);

    if (isFlex) {
      parent.style.display = "block"; //Firefox bug causes getScreenCTM() to return null when parent is display:flex and the element isn't rendered inside the window (like if it's below the scroll position)
    }

    matrix = svg.getScreenCTM();
    e1 = matrix.e;
    style.border = "50px solid red";
    matrix = svg.getScreenCTM();

    if (e1 === 0 && matrix.e === 0 && matrix.f === 0 && matrix.a === 1) {
      //Opera has a bunch of bugs - it doesn't adjust the x/y of the matrix, nor does it scale when box-sizing is border-box but it does so elsewhere; to get the correct behavior we set _svgBorderScales to true.
      _svgBorderFactor = 1;
      _svgBorderScales = true;
    } else {
      _svgBorderFactor = e1 !== matrix.e ? 1 : 0;
      _svgBorderScales = matrix.a !== 1;
    }

    if (isFlex) {
      parent.style.display = "flex";
    }

    parent.removeChild(svg);
  },
      _supports3D = _checkPrefix(_tempDiv, "perspective") !== "",
      // start matrix and point conversion methods...
  _transformOriginProp = _checkPrefix(_tempDiv, "transformOrigin").replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
      _transformProp = _checkPrefix(_tempDiv, "transform"),
      _transformPropCSS = _transformProp.replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
      _point1 = {},
      //we reuse _point1 and _point2 objects inside matrix and point conversion methods to conserve memory and minimize garbage collection tasks.
  _point2 = {},
      _SVGElement = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].SVGElement,
      _isSVG = function (e) {
    return !!(_SVGElement && typeof e.getBBox === "function" && e.getCTM && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM));
  },
      _isIE10orBelow = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].navigator && (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].navigator.userAgent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].navigator.userAgent)) && parseFloat(RegExp.$1) < 11,
      //Ideally we'd avoid user agent sniffing, but there doesn't seem to be a way to feature-detect and sense a border-related bug that only affects IE10 and IE9.
  _tempTransforms = [],
      _tempElements = [],
      _getSVGOffsets = function (e) {
    //SVG elements don't always report offsetTop/offsetLeft/offsetParent at all (I'm looking at you, Firefox 29 and Android), so we have to do some work to manufacture those values. You can pass any SVG element and it'll spit back an object with offsetTop, offsetLeft, offsetParent, scaleX, and scaleY properties. We need the scaleX and scaleY to handle the way SVG can resize itself based on the container.
    if (!e.getBoundingClientRect || !e.parentNode || !_transformProp) {
      return {
        offsetTop: 0,
        offsetLeft: 0,
        scaleX: 1,
        scaleY: 1,
        offsetParent: _docElement
      };
    }

    if (Draggable.cacheSVGData !== false && e._dCache && e._dCache.lastUpdate === _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].ticker.frame) {
      //performance optimization. Assume that if the offsets are requested again on the same tick, we can just feed back the values we already calculated (no need to keep recalculating until another tick elapses).
      return e._dCache;
    }

    var curElement = e,
        cache = _cache(e),
        eRect,
        parentRect,
        offsetParent,
        cs,
        m,
        i,
        point1,
        point2,
        borderWidth,
        borderHeight,
        width,
        height;

    cache.lastUpdate = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].ticker.frame;

    if (e.getBBox && !cache.isSVGRoot) {
      //if it's a nested/child SVG element, we must find the parent SVG canvas and measure the offset from there.
      curElement = e.parentNode;
      eRect = e.getBBox();

      while (curElement && (curElement.nodeName + "").toLowerCase() !== "svg") {
        curElement = curElement.parentNode;
      }

      cs = _getSVGOffsets(curElement);
      cache.offsetTop = eRect.y * cs.scaleY;
      cache.offsetLeft = eRect.x * cs.scaleX;
      cache.scaleX = cs.scaleX;
      cache.scaleY = cs.scaleY;
      cache.offsetParent = curElement || _docElement;
      return cache;
    } //only root SVG elements continue here...


    offsetParent = cache.offsetParent;

    if (offsetParent === _doc.body) {
      offsetParent = _docElement; //avoids problems with margins/padding on the body
    } //walk up the ancestors and record any non-identity transforms (and reset them to "none") until we reach the offsetParent. We must do this so that the getBoundingClientRect() is accurate for measuring the offsetTop/offsetLeft. We'll revert the values later...


    _tempElements.length = _tempTransforms.length = 0;

    while (curElement) {
      m = _getStyle(curElement, _transformProp, true);

      if (m !== "matrix(1, 0, 0, 1, 0, 0)" && m !== "none" && m !== "translate3d(0px, 0px, 0px)") {
        _tempElements.push(curElement);

        _tempTransforms.push(curElement.style[_transformProp]);

        curElement.style[_transformProp] = "none";
      }

      if (curElement === offsetParent) {
        break;
      }

      curElement = curElement.parentNode;
    }

    parentRect = offsetParent.getBoundingClientRect();
    m = e.getScreenCTM();
    point2 = e.createSVGPoint();
    point1 = point2.matrixTransform(m);
    cache.scaleX = Math.sqrt(m.a * m.a + m.b * m.b);
    cache.scaleY = Math.sqrt(m.d * m.d + m.c * m.c);

    if (_svgBorderFactor === undefined) {
      _setEnvironmentVariables();
    }

    if (cache.borderBox && !_svgBorderScales && e.getAttribute("width")) {
      //some browsers (like Safari) don't properly scale the matrix to accommodate the border when box-sizing is border-box, so we must calculate it here...
      cs = _getComputedStyle(e) || {};
      borderWidth = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth) || 0;
      borderHeight = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth) || 0;
      width = parseFloat(cs.width) || 0;
      height = parseFloat(cs.height) || 0;
      cache.scaleX *= (width - borderWidth) / width;
      cache.scaleY *= (height - borderHeight) / height;
    }

    if (_svgScrollOffset) {
      //some browsers (like Chrome for Android) have bugs in the way getScreenCTM() is reported (it doesn't factor in scroll position), so we must revert to a more expensive technique for calculating offsetTop/Left.
      eRect = e.getBoundingClientRect();
      cache.offsetLeft = eRect.left - parentRect.left;
      cache.offsetTop = eRect.top - parentRect.top;
    } else {
      cache.offsetLeft = point1.x - parentRect.left;
      cache.offsetTop = point1.y - parentRect.top;
    }

    cache.offsetParent = offsetParent;
    i = _tempElements.length;

    while (--i > -1) {
      _tempElements[i].style[_transformProp] = _tempTransforms[i];
    }

    return cache;
  },
      _getOffsetTransformOrigin = function (e, decoratee) {
    //returns the x/y position of the transformOrigin of the element, in its own local coordinate system (pixels), offset from the top left corner.
    decoratee = decoratee || {};

    if (!e || e === _docElement || !e.parentNode || e === window) {
      return {
        x: 0,
        y: 0
      };
    }

    var cs = _getComputedStyle(e),
        v = _transformOriginProp && cs ? cs.getPropertyValue(_transformOriginProp) : "50% 50%",
        a = v.split(" "),
        x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
        y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1];

    if (y === "center" || y == null) {
      y = "50%";
    }

    if (x === "center" || isNaN(parseFloat(x))) {
      //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
      x = "50%";
    }

    if (e.getBBox && _isSVG(e)) {
      //SVG elements must be handled in a special way because their origins are calculated from the top left.
      if (!e._gsTransform) {
        _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].set(e, {
          x: "+=0",
          overwrite: false
        }); //forces creation of the _gsTransform where we store all the transform components including xOrigin and yOrigin for SVG elements, as of GSAP 1.15.0 which also takes care of calculating the origin from the upper left corner of the SVG canvas.

        if (e._gsTransform.xOrigin === undefined) {
          console.log("Draggable requires at least GSAP 1.17.0");
        }
      }

      v = e.getBBox();
      decoratee.x = e._gsTransform.xOrigin - v.x;
      decoratee.y = e._gsTransform.yOrigin - v.y;
    } else {
      if (e.getBBox && (x + y).indexOf("%") !== -1) {
        //Firefox doesn't report offsetWidth/height on <svg> elements.
        e = e.getBBox();
        e = {
          offsetWidth: e.width,
          offsetHeight: e.height
        };
      }

      decoratee.x = x.indexOf("%") !== -1 ? e.offsetWidth * parseFloat(x) / 100 : parseFloat(x);
      decoratee.y = y.indexOf("%") !== -1 ? e.offsetHeight * parseFloat(y) / 100 : parseFloat(y);
    }

    return decoratee;
  },
      _cache = function (e) {
    //computes some important values and stores them in a _dCache object attached to the element itself so that we can optimize performance
    if (Draggable.cacheSVGData !== false && e._dCache && e._dCache.lastUpdate === _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].ticker.frame) {
      //performance optimization. Assume that if the offsets are requested again on the same tick, we can just feed back the values we already calculated (no need to keep recalculating until another tick elapses).
      return e._dCache;
    }

    var cache = e._dCache = e._dCache || {},
        cs = _getComputedStyle(e),
        isSVG = e.getBBox && _isSVG(e),
        isSVGRoot = (e.nodeName + "").toLowerCase() === "svg",
        curSVG;

    cache.isSVG = isSVG;
    cache.isSVGRoot = isSVGRoot;
    cache.borderBox = cs.boxSizing === "border-box";
    cache.computedStyle = cs;

    if (isSVGRoot) {
      //some browsers don't report parentNode on SVG elements.
      curSVG = e.parentNode || _docElement;
      curSVG.insertBefore(_tempDiv, e);
      cache.offsetParent = _tempDiv.offsetParent || _docElement; //in some cases, Firefox still reports offsetParent as null.

      curSVG.removeChild(_tempDiv);
    } else if (isSVG) {
      curSVG = e.parentNode;

      while (curSVG && (curSVG.nodeName + "").toLowerCase() !== "svg") {
        //offsetParent is always the SVG canvas for SVG elements.
        curSVG = curSVG.parentNode;
      }

      cache.offsetParent = curSVG;
    } else {
      cache.offsetParent = e.offsetParent;
    }

    return cache;
  },
      _getOffset2DMatrix = function (e, offsetOrigin, parentOffsetOrigin, zeroOrigin, isBase) {
    //"isBase" helps us discern context - it should only be true when the element is the base one (the one at which we're starting to walk up the chain). It only matters in cases when it's an <svg> element itself because that's a case when we don't apply scaling.
    if (e === window || !e || !e.style || !e.parentNode) {
      return [1, 0, 0, 1, 0, 0];
    }

    var cache = e._dCache || _cache(e),
        parent = e.parentNode,
        parentCache = parent._dCache || _cache(parent),
        cs = cache.computedStyle,
        parentOffsetParent = cache.isSVG ? parentCache.offsetParent : parent.offsetParent,
        m,
        isRoot,
        offsets,
        rect,
        t,
        sx,
        sy,
        offsetX,
        offsetY,
        parentRect,
        borderTop,
        borderLeft,
        borderTranslateX,
        borderTranslateY;

    m = cache.isSVG && (e.style[_transformProp] + "").indexOf("matrix") !== -1 ? e.style[_transformProp] : cs ? cs.getPropertyValue(_transformPropCSS) : e.currentStyle ? e.currentStyle[_transformProp] : "1,0,0,1,0,0"; //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values

    if (e.getBBox && (e.getAttribute("transform") + "").indexOf("matrix") !== -1) {
      //SVG can store transform data in its "transform" attribute instead of the CSS, so look for that here (only accept matrix()).
      m = e.getAttribute("transform");
    }

    m = (m + "").match(/(?:\-|\.|\b)(\d|\.|e\-)+/g) || [1, 0, 0, 1, 0, 0];

    if (m.length > 6) {
      m = [m[0], m[1], m[4], m[5], m[12], m[13]];
    }

    if (zeroOrigin) {
      m[4] = m[5] = 0;
    } else if (cache.isSVG && (t = e._gsTransform) && (t.xOrigin || t.yOrigin)) {
      //SVGs handle origin very differently. Factor in GSAP's handling of origin values here:
      m[0] = parseFloat(m[0]);
      m[1] = parseFloat(m[1]);
      m[2] = parseFloat(m[2]);
      m[3] = parseFloat(m[3]);
      m[4] = parseFloat(m[4]) - (t.xOrigin - (t.xOrigin * m[0] + t.yOrigin * m[2]));
      m[5] = parseFloat(m[5]) - (t.yOrigin - (t.xOrigin * m[1] + t.yOrigin * m[3]));
    }

    if (offsetOrigin) {
      if (_svgBorderFactor === undefined) {
        _setEnvironmentVariables();
      }

      offsets = cache.isSVG || cache.isSVGRoot ? _getSVGOffsets(e) : e;

      if (cache.isSVG) {
        //don't just rely on "instanceof _SVGElement" because if the SVG is embedded via an object tag, it won't work (SVGElement is mapped to a different object))
        rect = e.getBBox();
        parentRect = parentCache.isSVGRoot ? {
          x: 0,
          y: 0
        } : parent.getBBox();
        offsets = {
          offsetLeft: rect.x - parentRect.x,
          offsetTop: rect.y - parentRect.y,
          offsetParent: cache.offsetParent
        };
      } else if (cache.isSVGRoot) {
        borderTop = parseInt(cs.borderTopWidth, 10) || 0;
        borderLeft = parseInt(cs.borderLeftWidth, 10) || 0;
        borderTranslateX = (m[0] - _svgBorderFactor) * borderLeft + m[2] * borderTop;
        borderTranslateY = m[1] * borderLeft + (m[3] - _svgBorderFactor) * borderTop;
        sx = offsetOrigin.x;
        sy = offsetOrigin.y;
        offsetX = sx - (sx * m[0] + sy * m[2]); //accommodate the SVG root's transforms when the origin isn't in the top left.

        offsetY = sy - (sx * m[1] + sy * m[3]);
        m[4] = parseFloat(m[4]) + offsetX;
        m[5] = parseFloat(m[5]) + offsetY;
        offsetOrigin.x -= offsetX;
        offsetOrigin.y -= offsetY;
        sx = offsets.scaleX;
        sy = offsets.scaleY;

        if (!isBase) {
          //when getting the matrix for a root <svg> element itself (NOT in the context of an SVG element that's nested inside of it like a <path>), we do NOT apply the scaling!
          offsetOrigin.x *= sx;
          offsetOrigin.y *= sy;
        }

        m[0] *= sx;
        m[1] *= sy;
        m[2] *= sx;
        m[3] *= sy;

        if (!_isIE10orBelow) {
          offsetOrigin.x += borderTranslateX;
          offsetOrigin.y += borderTranslateY;
        }

        if (parentOffsetParent === _doc.body && offsets.offsetParent === _docElement) {
          //to avoid issues with margin/padding on the <body>, we always set the offsetParent to _docElement in the _getSVGOffsets() function but there's a condition we check later in this function for (parentOffsetParent === offsets.offsetParent) which would fail if we don't run this logic. In other words, parentOffsetParent may be <body> and the <svg>'s offsetParent is also <body> but artificially set to _docElement to avoid margin/padding issues.
          parentOffsetParent = _docElement;
        }
      } else if (!_hasBorderBug && e.offsetParent) {
        offsetOrigin.x += parseInt(_getStyle(e.offsetParent, "borderLeftWidth"), 10) || 0;
        offsetOrigin.y += parseInt(_getStyle(e.offsetParent, "borderTopWidth"), 10) || 0;
      }

      isRoot = parent === _docElement || parent === _doc.body;
      m[4] = Number(m[4]) + offsetOrigin.x + (offsets.offsetLeft || 0) - parentOffsetOrigin.x - (isRoot ? 0 : parent.scrollLeft || 0);
      m[5] = Number(m[5]) + offsetOrigin.y + (offsets.offsetTop || 0) - parentOffsetOrigin.y - (isRoot ? 0 : parent.scrollTop || 0);

      if (parent && _getStyle(e, "position", cs) === "fixed") {
        //fixed position elements should factor in the scroll position of the document.
        m[4] += _getDocScrollLeft();
        m[5] += _getDocScrollTop();
      }

      if (parent && parent !== _docElement && parentOffsetParent === offsets.offsetParent && !parentCache.isSVG && (!_hasReparentBug || _getOffset2DMatrix(parent).join("") === "100100")) {
        offsets = parentCache.isSVGRoot ? _getSVGOffsets(parent) : parent;
        m[4] -= offsets.offsetLeft || 0;
        m[5] -= offsets.offsetTop || 0;

        if (!_hasBorderBug && parentCache.offsetParent && !cache.isSVG && !cache.isSVGRoot) {
          m[4] -= parseInt(_getStyle(parentCache.offsetParent, "borderLeftWidth"), 10) || 0;
          m[5] -= parseInt(_getStyle(parentCache.offsetParent, "borderTopWidth"), 10) || 0;
        }
      }
    }

    return m;
  },
      _getConcatenatedMatrix = function (e, invert) {
    if (!e || e === window || !e.parentNode) {
      return [1, 0, 0, 1, 0, 0];
    } //note: we keep reusing _point1 and _point2 in order to minimize memory usage and garbage collection chores.


    var originOffset = _getOffsetTransformOrigin(e, _point1),
        parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, _point2),
        m = _getOffset2DMatrix(e, originOffset, parentOriginOffset, false, !invert),
        a,
        b,
        c,
        d,
        tx,
        ty,
        m2,
        determinant;

    while ((e = e.parentNode) && e.parentNode && e !== _docElement) {
      originOffset = parentOriginOffset;
      parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, originOffset === _point1 ? _point2 : _point1);
      m2 = _getOffset2DMatrix(e, originOffset, parentOriginOffset);
      a = m[0];
      b = m[1];
      c = m[2];
      d = m[3];
      tx = m[4];
      ty = m[5];
      m[0] = a * m2[0] + b * m2[2];
      m[1] = a * m2[1] + b * m2[3];
      m[2] = c * m2[0] + d * m2[2];
      m[3] = c * m2[1] + d * m2[3];
      m[4] = tx * m2[0] + ty * m2[2] + m2[4];
      m[5] = tx * m2[1] + ty * m2[3] + m2[5];
    }

    if (invert) {
      a = m[0];
      b = m[1];
      c = m[2];
      d = m[3];
      tx = m[4];
      ty = m[5];
      determinant = a * d - b * c;
      m[0] = d / determinant;
      m[1] = -b / determinant;
      m[2] = -c / determinant;
      m[3] = a / determinant;
      m[4] = (c * ty - d * tx) / determinant;
      m[5] = -(a * ty - b * tx) / determinant;
    }

    return m;
  },
      _localToGlobal = function (e, p, fromTopLeft, decoratee, zeroOrigin) {
    e = _unwrapElement(e);

    var m = _getConcatenatedMatrix(e, false, zeroOrigin),
        x = p.x,
        y = p.y;

    if (fromTopLeft) {
      _getOffsetTransformOrigin(e, p);

      x -= p.x;
      y -= p.y;
    }

    decoratee = decoratee === true ? p : decoratee || {};
    decoratee.x = x * m[0] + y * m[2] + m[4];
    decoratee.y = x * m[1] + y * m[3] + m[5];
    return decoratee;
  },
      _localizePoint = function (p, localToGlobal, globalToLocal) {
    var x = p.x * localToGlobal[0] + p.y * localToGlobal[2] + localToGlobal[4],
        y = p.x * localToGlobal[1] + p.y * localToGlobal[3] + localToGlobal[5];
    p.x = x * globalToLocal[0] + y * globalToLocal[2] + globalToLocal[4];
    p.y = x * globalToLocal[1] + y * globalToLocal[3] + globalToLocal[5];
    return p;
  },
      _getElementBounds = function (e, context, fromTopLeft) {
    if (!(e = _unwrapElement(e))) {
      return null;
    }

    context = _unwrapElement(context);

    var isSVG = e.getBBox && _isSVG(e),
        origin,
        left,
        right,
        top,
        bottom,
        mLocalToGlobal,
        mGlobalToLocal,
        p1,
        p2,
        p3,
        p4,
        bbox,
        width,
        height,
        cache,
        borderLeft,
        borderTop,
        viewBox,
        viewBoxX,
        viewBoxY,
        computedDimensions,
        cs;

    if (e === window) {
      top = _getDocScrollTop();
      left = _getDocScrollLeft();
      right = left + (_docElement.clientWidth || e.innerWidth || _doc.body.clientWidth || 0);
      bottom = top + ((e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.
    } else if (context === undefined || context === window) {
      return e.getBoundingClientRect();
    } else {
      origin = _getOffsetTransformOrigin(e);
      left = -origin.x;
      top = -origin.y;

      if (isSVG) {
        bbox = e.getBBox();
        width = bbox.width;
        height = bbox.height;
      } else if ((e.nodeName + "").toLowerCase() !== "svg" && e.offsetWidth) {
        //Chrome dropped support for "offsetWidth" on SVG elements
        width = e.offsetWidth;
        height = e.offsetHeight;
      } else {
        computedDimensions = _getComputedStyle(e);
        width = parseFloat(computedDimensions.width);
        height = parseFloat(computedDimensions.height);
      }

      right = left + width;
      bottom = top + height;

      if (e.nodeName.toLowerCase() === "svg" && !_isOldIE) {
        //root SVG elements are a special beast because they have 2 types of scaling - transforms on themselves as well as the stretching of the SVG canvas itself based on the outer size and the viewBox. If, for example, the SVG's viewbox is "0 0 100 100" but the CSS is set to width:200px; height:200px, that'd make it appear at 2x scale even though the element itself has no CSS transforms but the offsetWidth/offsetHeight are based on that css, not the viewBox so we need to adjust them accordingly.
        cache = _getSVGOffsets(e);
        cs = cache.computedStyle || {};
        viewBox = (e.getAttribute("viewBox") || "0 0").split(" ");
        viewBoxX = parseFloat(viewBox[0]);
        viewBoxY = parseFloat(viewBox[1]);
        borderLeft = parseFloat(cs.borderLeftWidth) || 0;
        borderTop = parseFloat(cs.borderTopWidth) || 0;
        right -= width - (width - borderLeft) / cache.scaleX - viewBoxX;
        bottom -= height - (height - borderTop) / cache.scaleY - viewBoxY;
        left -= borderLeft / cache.scaleX - viewBoxX;
        top -= borderTop / cache.scaleY - viewBoxY;

        if (computedDimensions) {
          //when we had to use computed styles, factor in the border now.
          right += (parseFloat(cs.borderRightWidth) + borderLeft) / cache.scaleX;
          bottom += (borderTop + parseFloat(cs.borderBottomWidth)) / cache.scaleY;
        }
      }
    }

    if (e === context) {
      return {
        left: left,
        top: top,
        width: right - left,
        height: bottom - top
      };
    }

    mLocalToGlobal = _getConcatenatedMatrix(e);
    mGlobalToLocal = _getConcatenatedMatrix(context, true);
    p1 = _localizePoint({
      x: left,
      y: top
    }, mLocalToGlobal, mGlobalToLocal);
    p2 = _localizePoint({
      x: right,
      y: top
    }, mLocalToGlobal, mGlobalToLocal);
    p3 = _localizePoint({
      x: right,
      y: bottom
    }, mLocalToGlobal, mGlobalToLocal);
    p4 = _localizePoint({
      x: left,
      y: bottom
    }, mLocalToGlobal, mGlobalToLocal);
    left = Math.min(p1.x, p2.x, p3.x, p4.x);
    top = Math.min(p1.y, p2.y, p3.y, p4.y);
    _temp1.x = _temp1.y = 0;

    if (fromTopLeft) {
      _getOffsetTransformOrigin(context, _temp1);
    }

    return {
      left: left + _temp1.x,
      top: top + _temp1.y,
      width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,
      height: Math.max(p1.y, p2.y, p3.y, p4.y) - top
    };
  },
      // end matrix and point conversion methods
  _isArrayLike = function (e) {
    return e && e.length && e[0] && (e[0].nodeType && e[0].style && !e.nodeType || e[0].length && e[0][0]) ? true : false; //could be an array of jQuery objects too, so accommodate that.
  },
      _flattenArray = function (a) {
    var result = [],
        l = a.length,
        i,
        e,
        j;

    for (i = 0; i < l; i++) {
      e = a[i];

      if (_isArrayLike(e)) {
        j = e.length;

        for (j = 0; j < e.length; j++) {
          result.push(e[j]);
        }
      } else if (e && e.length !== 0) {
        result.push(e);
      }
    }

    return result;
  },
      _isTouchDevice = typeof window !== "undefined" && "ontouchstart" in _docElement && "orientation" in window,
      _touchEventLookup = function (types) {
    //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we're in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.
    var standard = types.split(","),
        // ANNAM PROTOIO temporarily disable pointer events
    // even though draggable itself works fine with pointer events, if we have a click event inside a draggable item (container) it propagates a pointer event (pointerdown presumably?) instead of mousedown and because we have
    // disabled pointerevents in hammer, which doesnt work well with them, the click event does not get triggered
    // converted = ((_tempDiv.onpointerdown !== undefined) ? "pointerdown,pointermove,pointerup,pointercancel" : (_tempDiv.onmspointerdown !== undefined) ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
    converted = types.split(","),
        obj = {},
        i = 4;

    while (--i > -1) {
      obj[standard[i]] = converted[i];
      obj[converted[i]] = standard[i];
    }

    return obj;
  }("touchstart,touchmove,touchend,touchcancel"),
      _addListener = function (element, type, func, capture) {
    if (element.addEventListener) {
      var touchType = _touchEventLookup[type];
      capture = capture || {
        passive: false
      };
      element.addEventListener(touchType || type, func, capture);

      if (touchType && type !== touchType) {
        //some browsers actually support both, so must we.
        element.addEventListener(type, func, capture);
      }
    } else if (element.attachEvent) {
      element.attachEvent("on" + type, func);
    }
  },
      _removeListener = function (element, type, func) {
    if (element.removeEventListener) {
      var touchType = _touchEventLookup[type];
      element.removeEventListener(touchType || type, func);

      if (touchType && type !== touchType) {
        element.removeEventListener(type, func);
      }
    } else if (element.detachEvent) {
      element.detachEvent("on" + type, func);
    }
  },
      _hasTouchID = function (list, ID) {
    var i = list.length;

    while (--i > -1) {
      if (list[i].identifier === ID) {
        return true;
      }
    }

    return false;
  },
      _onMultiTouchDocumentEnd = function (e) {
    _isMultiTouching = e.touches && _dragCount < e.touches.length;

    _removeListener(e.target, "touchend", _onMultiTouchDocumentEnd);
  },
      _onMultiTouchDocument = function (e) {
    _isMultiTouching = e.touches && _dragCount < e.touches.length;

    _addListener(e.target, "touchend", _onMultiTouchDocumentEnd);
  },
      _parseThrowProps = function (draggable, snap, max, min, factor, forceZeroVelocity) {
    var vars = {},
        a,
        i,
        l;

    if (snap) {
      if (factor !== 1 && snap instanceof Array) {
        //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.
        vars.end = a = [];
        l = snap.length;

        if (typeof snap[0] === "object") {
          //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we'll mess up the originals and the user may reuse it elsewhere.
          for (i = 0; i < l; i++) {
            a[i] = _copy(snap[i], factor);
          }
        } else {
          for (i = 0; i < l; i++) {
            a[i] = snap[i] * factor;
          }
        }

        max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if "snap:[-$('#menu').width(), 0]" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.

        min -= 1.1;
      } else if (typeof snap === "function") {
        vars.end = function (value) {
          var result = snap.call(draggable, value),
              copy,
              p;

          if (factor !== 1) {
            if (typeof result === "object") {
              copy = {};

              for (p in result) {
                copy[p] = result[p] * factor;
              }

              result = copy;
            } else {
              result *= factor;
            }
          }

          return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.
        };
      } else {
        vars.end = snap;
      }
    }

    if (max || max === 0) {
      vars.max = max;
    }

    if (min || min === 0) {
      vars.min = min;
    }

    if (forceZeroVelocity) {
      vars.velocity = 0;
    }

    return vars;
  },
      _isClickable = function (e) {
    //sometimes it's convenient to mark an element as clickable by adding a data-clickable="true" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).
    var data;
    return !e || !e.getAttribute || e.nodeName === "BODY" ? false : (data = e.getAttribute("data-clickable")) === "true" || data !== "false" && (e.onclick || _clickableTagExp.test(e.nodeName + "") || e.getAttribute("contentEditable") === "true") ? true : _isClickable(e.parentNode);
  },
      _setSelectable = function (elements, selectable) {
    var i = elements.length,
        e;

    while (--i > -1) {
      e = elements[i];
      e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;

      _setStyle(e, "userSelect", selectable ? "text" : "none");
    }
  },
      _addPaddingBR = function () {
    //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).
    var div = _doc.createElement("div"),
        child = _doc.createElement("div"),
        childStyle = child.style,
        parent = _doc.body || _tempDiv,
        val;

    childStyle.display = "inline-block";
    childStyle.position = "relative";
    div.style.cssText = child.innerHTML = "width:90px; height:40px; padding:10px; overflow:auto; visibility: hidden";
    div.appendChild(child);
    parent.appendChild(div);
    val = child.offsetHeight + 18 > div.scrollHeight; //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.

    parent.removeChild(div);
    return val;
  }(),
      //The ScrollProxy class wraps an element's contents into another div (we call it "content") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.
  ScrollProxy = function (element, vars) {
    element = _unwrapElement(element);
    vars = vars || {};

    var content = _doc.createElement("div"),
        style = content.style,
        node = element.firstChild,
        offsetTop = 0,
        offsetLeft = 0,
        prevTop = element.scrollTop,
        prevLeft = element.scrollLeft,
        scrollWidth = element.scrollWidth,
        scrollHeight = element.scrollHeight,
        extraPadRight = 0,
        maxLeft = 0,
        maxTop = 0,
        elementWidth,
        elementHeight,
        contentHeight,
        nextNode,
        transformStart,
        transformEnd;

    if (_supports3D && vars.force3D !== false) {
      transformStart = "translate3d(";
      transformEnd = "px,0px)";
    } else if (_transformProp) {
      transformStart = "translate(";
      transformEnd = "px)";
    }

    this.scrollTop = function (value, force) {
      if (!arguments.length) {
        return -this.top();
      }

      this.top(-value, force);
    };

    this.scrollLeft = function (value, force) {
      if (!arguments.length) {
        return -this.left();
      }

      this.left(-value, force);
    };

    this.left = function (value, force) {
      if (!arguments.length) {
        return -(element.scrollLeft + offsetLeft);
      }

      var dif = element.scrollLeft - prevLeft,
          oldOffset = offsetLeft;

      if ((dif > 2 || dif < -2) && !force) {
        //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
        prevLeft = element.scrollLeft;
        _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].killTweensOf(this, true, {
          left: 1,
          scrollLeft: 1
        });
        this.left(-prevLeft);

        if (vars.onKill) {
          vars.onKill();
        }

        return;
      }

      value = -value; //invert because scrolling works in the opposite direction

      if (value < 0) {
        offsetLeft = value - 0.5 | 0;
        value = 0;
      } else if (value > maxLeft) {
        offsetLeft = value - maxLeft | 0;
        value = maxLeft;
      } else {
        offsetLeft = 0;
      }

      if (offsetLeft || oldOffset) {
        if (transformStart) {
          if (!this._suspendTransforms) {
            style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
          }
        } else {
          style.left = -offsetLeft + "px";
        }

        if (offsetLeft + extraPadRight >= 0) {
          style.paddingRight = offsetLeft + extraPadRight + "px";
        }
      }

      element.scrollLeft = value | 0;
      prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjsut the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.
    };

    this.top = function (value, force) {
      if (!arguments.length) {
        return -(element.scrollTop + offsetTop);
      }

      var dif = element.scrollTop - prevTop,
          oldOffset = offsetTop;

      if ((dif > 2 || dif < -2) && !force) {
        //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
        prevTop = element.scrollTop;
        _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].killTweensOf(this, true, {
          top: 1,
          scrollTop: 1
        });
        this.top(-prevTop);

        if (vars.onKill) {
          vars.onKill();
        }

        return;
      }

      value = -value; //invert because scrolling works in the opposite direction

      if (value < 0) {
        offsetTop = value - 0.5 | 0;
        value = 0;
      } else if (value > maxTop) {
        offsetTop = value - maxTop | 0;
        value = maxTop;
      } else {
        offsetTop = 0;
      }

      if (offsetTop || oldOffset) {
        if (transformStart) {
          if (!this._suspendTransforms) {
            style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
          }
        } else {
          style.top = -offsetTop + "px";
        }
      }

      element.scrollTop = value | 0;
      prevTop = element.scrollTop;
    };

    this.maxScrollTop = function () {
      return maxTop;
    };

    this.maxScrollLeft = function () {
      return maxLeft;
    };

    this.disable = function () {
      node = content.firstChild;

      while (node) {
        nextNode = node.nextSibling;
        element.appendChild(node);
        node = nextNode;
      }

      if (element === content.parentNode) {
        //in case disable() is called when it's already disabled.
        element.removeChild(content);
      }
    };

    this.enable = function () {
      node = element.firstChild;

      if (node === content) {
        return;
      }

      while (node) {
        nextNode = node.nextSibling;
        content.appendChild(node);
        node = nextNode;
      }

      element.appendChild(content);
      this.calibrate();
    };

    this.calibrate = function (force) {
      var widthMatches = element.clientWidth === elementWidth,
          x,
          y;
      prevTop = element.scrollTop;
      prevLeft = element.scrollLeft;

      if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
        return; //no need to recalculate things if the width and height haven't changed.
      }

      if (offsetTop || offsetLeft) {
        x = this.left();
        y = this.top();
        this.left(-element.scrollLeft);
        this.top(-element.scrollTop);
      } //first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)


      if (!widthMatches || force) {
        style.display = "block";
        style.width = "auto";
        style.paddingRight = "0px";
        extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth); //if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.

        if (extraPadRight) {
          extraPadRight += _getStyle(element, "paddingLeft") + (_addPaddingBR ? _getStyle(element, "paddingRight") : 0);
        }
      }

      style.display = "inline-block";
      style.position = "relative";
      style.overflow = "visible";
      style.verticalAlign = "top";
      style.width = "100%";
      style.paddingRight = extraPadRight + "px"; //some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error

      if (_addPaddingBR) {
        style.paddingBottom = _getStyle(element, "paddingBottom", true);
      }

      if (_isOldIE) {
        style.zoom = "1";
      }

      elementWidth = element.clientWidth;
      elementHeight = element.clientHeight;
      scrollWidth = element.scrollWidth;
      scrollHeight = element.scrollHeight;
      maxLeft = element.scrollWidth - elementWidth;
      maxTop = element.scrollHeight - elementHeight;
      contentHeight = content.offsetHeight;
      style.display = "block";

      if (x || y) {
        this.left(x);
        this.top(y);
      }
    };

    this.content = content;
    this.element = element;
    this._suspendTransforms = false;
    this.enable();
  },
      Draggable = function (target, vars) {
    _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"].call(this, target);
    target = _unwrapElement(target); //in case the target is a selector object or selector text

    if (!ThrowPropsPlugin) {
      ThrowPropsPlugin = _globals.com.greensock.plugins.ThrowPropsPlugin;
    }

    this.vars = vars = _copy(vars || {});
    this.target = target;
    this.x = this.y = this.rotation = 0;
    this.dragResistance = parseFloat(vars.dragResistance) || 0;
    this.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
    this.lockAxis = vars.lockAxis;
    this.autoScroll = vars.autoScroll || 0;
    this.lockedAxis = null;
    this.allowEventDefault = !!vars.allowEventDefault;

    var type = (vars.type || (_isOldIE ? "top,left" : "x,y")).toLowerCase(),
        xyMode = type.indexOf("x") !== -1 || type.indexOf("y") !== -1,
        rotationMode = type.indexOf("rotation") !== -1,
        xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",
        yProp = xyMode ? "y" : "top",
        allowX = type.indexOf("x") !== -1 || type.indexOf("left") !== -1 || type === "scroll",
        allowY = type.indexOf("y") !== -1 || type.indexOf("top") !== -1 || type === "scroll",
        minimumMovement = vars.minimumMovement || 2,
        self = this,
        triggers = _slice(vars.trigger || vars.handle || target),
        killProps = {},
        dragEndTime = 0,
        checkAutoScrollBounds = false,
        autoScrollMarginTop = vars.autoScrollMarginTop || 40,
        autoScrollMarginRight = vars.autoScrollMarginRight || 40,
        autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,
        autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,
        isClickable = vars.clickableTest || _isClickable,
        clickTime = 0,
        enabled,
        scrollProxy,
        startPointerX,
        startPointerY,
        startElementX,
        startElementY,
        hasBounds,
        hasDragCallback,
        maxX,
        minX,
        maxY,
        minY,
        tempVars,
        cssVars,
        touch,
        touchID,
        rotationOrigin,
        dirty,
        old,
        snapX,
        snapY,
        snapXY,
        isClicking,
        touchEventTarget,
        matrix,
        interrupted,
        startScrollTop,
        startScrollLeft,
        applyObj,
        allowNativeTouchScrolling,
        touchDragAxis,
        isDispatching,
        clickDispatch,
        trustedClickDispatch,
        onContextMenu = function (e) {
      //used to prevent long-touch from triggering a context menu.
      if (self.isPressed && e.which < 2) {
        self.endDrag();
      } else {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    },
        //this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the "mousemove" or "touchmove" event handler which may get called many times inbetween refreshes.
    render = function (suppressEvents) {
      if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {
        var e = target,
            autoScrollFactor = self.autoScroll * 15,
            //multiplying by 15 just gives us a better "feel" speed-wise.
        parent,
            isRoot,
            rect,
            pointerX,
            pointerY,
            changeX,
            changeY,
            gap;
        checkAutoScrollBounds = false;
        _windowProxy.scrollTop = window.pageYOffset != null ? window.pageYOffset : _docElement.scrollTop != null ? _docElement.scrollTop : _doc.body.scrollTop;
        _windowProxy.scrollLeft = window.pageXOffset != null ? window.pageXOffset : _docElement.scrollLeft != null ? _docElement.scrollLeft : _doc.body.scrollLeft;
        pointerX = self.pointerX - _windowProxy.scrollLeft;
        pointerY = self.pointerY - _windowProxy.scrollTop;

        while (e && !isRoot) {
          //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.
          isRoot = _isRoot(e.parentNode);
          parent = isRoot ? _windowProxy : e.parentNode;
          rect = isRoot ? {
            bottom: Math.max(_docElement.clientHeight, window.innerHeight || 0),
            right: Math.max(_docElement.clientWidth, window.innerWidth || 0),
            left: 0,
            top: 0
          } : parent.getBoundingClientRect();
          changeX = changeY = 0;

          if (allowY) {
            gap = parent._gsMaxScrollY - parent.scrollTop;

            if (gap < 0) {
              changeY = gap;
            } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {
              checkAutoScrollBounds = true;
              changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);
            } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {
              checkAutoScrollBounds = true;
              changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);
            }

            if (changeY) {
              parent.scrollTop += changeY;
            }
          }

          if (allowX) {
            gap = parent._gsMaxScrollX - parent.scrollLeft;

            if (gap < 0) {
              changeX = gap;
            } else if (pointerX > rect.right - autoScrollMarginRight && gap) {
              checkAutoScrollBounds = true;
              changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);
            } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {
              checkAutoScrollBounds = true;
              changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);
            }

            if (changeX) {
              parent.scrollLeft += changeX;
            }
          }

          if (isRoot && (changeX || changeY)) {
            window.scrollTo(parent.scrollLeft, parent.scrollTop);
            setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);
          }

          e = parent;
        }
      }

      if (dirty) {
        var x = self.x,
            y = self.y,
            min = 0.000001;

        if (x < min && x > -min) {
          //browsers don't handle super small decimals well.
          x = 0;
        }

        if (y < min && y > -min) {
          y = 0;
        }

        if (rotationMode) {
          self.deltaX = x - applyObj.data.rotation;
          applyObj.data.rotation = self.rotation = x;
          applyObj.setRatio(1); //note: instead of doing TweenLite.set(), as a performance optimization we skip right to the method that renders the transforms inside CSSPlugin. For old versions of IE, though, we do a normal TweenLite.set() to leverage its ability to re-reroute to an IE-specific 2D renderer.
        } else {
          if (scrollProxy) {
            if (allowY) {
              self.deltaY = y - scrollProxy.top();
              scrollProxy.top(y);
            }

            if (allowX) {
              self.deltaX = x - scrollProxy.left();
              scrollProxy.left(x);
            }
          } else if (xyMode) {
            if (allowY) {
              self.deltaY = y - applyObj.data.y;
              applyObj.data.y = y;
            }

            if (allowX) {
              self.deltaX = x - applyObj.data.x;
              applyObj.data.x = x;
            }

            applyObj.setRatio(1); //note: instead of doing TweenLite.set(), as a performance optimization we skip right to the method that renders the transforms inside CSSPlugin. For old versions of IE, though, we do a normal TweenLite.set() to leverage its ability to re-reroute to an IE-specific 2D renderer.
          } else {
            if (allowY) {
              self.deltaY = y - parseFloat(target.style.top || 0);
              target.style.top = y + "px";
            }

            if (allowX) {
              self.deltaY = x - parseFloat(target.style.left || 0);
              target.style.left = x + "px";
            }
          }
        }

        if (hasDragCallback && !suppressEvents && !isDispatching) {
          isDispatching = true; //in case onDrag has an update() call (avoid endless loop)

          _dispatchEvent(self, "drag", "onDrag");

          isDispatching = false;
        }
      }

      dirty = false;
    },
        //copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the ThrowPropsPlugin tween in an onUpdate to ensure things are synced and snapped.
    syncXY = function (skipOnUpdate, skipSnap) {
      var x = self.x,
          y = self.y,
          snappedValue;

      if (!target._gsTransform && (xyMode || rotationMode)) {
        //just in case the _gsTransform got wiped, like if the user called clearProps on the transform or something (very rare), doing an x tween forces a re-parsing of the transforms and population of the _gsTransform.
        _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].set(target, {
          x: "+=0",
          overwrite: false,
          data: "_draggable"
        });
      }

      if (xyMode) {
        self.y = target._gsTransform.y;
        self.x = target._gsTransform.x;
      } else if (rotationMode) {
        self.x = self.rotation = target._gsTransform.rotation;
      } else if (scrollProxy) {
        self.y = scrollProxy.top();
        self.x = scrollProxy.left();
      } else {
        self.y = parseInt(target.style.top, 10) || 0;
        self.x = parseInt(target.style.left, 10) || 0;
      }

      if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {
        if (snapXY) {
          _temp1.x = self.x;
          _temp1.y = self.y;
          snappedValue = snapXY(_temp1);

          if (snappedValue.x !== self.x) {
            self.x = snappedValue.x;
            dirty = true;
          }

          if (snappedValue.y !== self.y) {
            self.y = snappedValue.y;
            dirty = true;
          }
        }

        if (snapX) {
          snappedValue = snapX(self.x);

          if (snappedValue !== self.x) {
            self.x = snappedValue;

            if (rotationMode) {
              self.rotation = snappedValue;
            }

            dirty = true;
          }
        }

        if (snapY) {
          snappedValue = snapY(self.y);

          if (snappedValue !== self.y) {
            self.y = snappedValue;
          }

          dirty = true;
        }
      }

      if (dirty) {
        render(true);
      }

      if (!skipOnUpdate) {
        self.deltaX = self.x - x;
        self.deltaY = self.y - y;

        _dispatchEvent(self, "throwupdate", "onThrowUpdate");
      }
    },
        calculateBounds = function () {
      var bounds, targetBounds, snap, snapIsRaw;
      hasBounds = false;

      if (scrollProxy) {
        scrollProxy.calibrate();
        self.minX = minX = -scrollProxy.maxScrollLeft();
        self.minY = minY = -scrollProxy.maxScrollTop();
        self.maxX = maxX = self.maxY = maxY = 0;
        hasBounds = true;
      } else if (!!vars.bounds) {
        bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic2 object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}

        if (rotationMode) {
          self.minX = minX = bounds.left;
          self.maxX = maxX = bounds.left + bounds.width;
          self.minY = minY = self.maxY = maxY = 0;
        } else if (vars.bounds.maxX !== undefined || vars.bounds.maxY !== undefined) {
          bounds = vars.bounds;
          self.minX = minX = bounds.minX;
          self.minY = minY = bounds.minY;
          self.maxX = maxX = bounds.maxX;
          self.maxY = maxY = bounds.maxY;
        } else {
          targetBounds = _getBounds(target, target.parentNode);
          self.minX = minX = _getStyle(target, xProp) + bounds.left - targetBounds.left;
          self.minY = minY = _getStyle(target, yProp) + bounds.top - targetBounds.top;
          self.maxX = maxX = minX + (bounds.width - targetBounds.width);
          self.maxY = maxY = minY + (bounds.height - targetBounds.height);
        }

        if (minX > maxX) {
          self.minX = maxX;
          self.maxX = maxX = minX;
          minX = self.minX;
        }

        if (minY > maxY) {
          self.minY = maxY;
          self.maxY = maxY = minY;
          minY = self.minY;
        }

        if (rotationMode) {
          self.minRotation = minX;
          self.maxRotation = maxX;
        }

        hasBounds = true;
      }

      if (vars.liveSnap) {
        snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;
        snapIsRaw = snap instanceof Array || typeof snap === "function";

        if (rotationMode) {
          snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);
          snapY = null;
        } else {
          if (snap.points) {
            snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);
          } else {
            if (allowX) {
              snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);
            }

            if (allowY) {
              snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);
            }
          }
        }
      }
    },
        onThrowComplete = function () {
      self.isThrowing = false;

      _dispatchEvent(self, "throwcomplete", "onThrowComplete");
    },
        onThrowOverwrite = function () {
      self.isThrowing = false;
    },
        animate = function (throwProps, forceZeroVelocity) {
      var snap, snapIsRaw, tween, overshootTolerance;

      if (throwProps && ThrowPropsPlugin) {
        if (throwProps === true) {
          snap = vars.snap || vars.liveSnap || {};
          snapIsRaw = snap instanceof Array || typeof snap === "function";
          throwProps = {
            resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)
          };

          if (rotationMode) {
            throwProps.rotation = _parseThrowProps(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
          } else {
            if (allowX) {
              throwProps[xProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.points || snap.x || snap.left || snap.scrollLeft, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "x");
            }

            if (allowY) {
              throwProps[yProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.points || snap.y || snap.top || snap.scrollTop, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "y");
            }

            if (snap.points || snap instanceof Array && typeof snap[0] === "object") {
              throwProps.linkedProps = xProp + "," + yProp;
              throwProps.radius = snap.radius; //note: we also disable liveSnapping while throwing if there's a "radius" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that "skipSnap" parameter is true for syncXY.
            }
          }
        }

        self.isThrowing = true;
        overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance + 0.2;
        self.tween = tween = ThrowPropsPlugin.to(scrollProxy || target, {
          throwProps: throwProps,
          data: "_draggable",
          ease: vars.ease || _globals.Power3.easeOut,
          onComplete: onThrowComplete,
          onOverwrite: onThrowOverwrite,
          onUpdate: vars.fastMode ? _dispatchEvent : syncXY,
          onUpdateParams: vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : snap && snap.radius ? [false, true] : _emptyArray
        }, Math.max(vars.minDuration || 0, vars.maxDuration || 0) || 2, !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || typeof throwProps === "object" && throwProps.resistance > 1000 ? 0 : 0.5, overshootTolerance);

        if (!vars.fastMode) {
          //to populate the end values, we just scrub the tween to the end, record the values, and then jump back to the beginning.
          if (scrollProxy) {
            scrollProxy._suspendTransforms = true; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
          }

          tween.render(tween.duration(), true, true);
          syncXY(true, true);
          self.endX = self.x;
          self.endY = self.y;

          if (rotationMode) {
            self.endRotation = self.x;
          }

          tween.play(0);
          syncXY(true, true);

          if (scrollProxy) {
            scrollProxy._suspendTransforms = false;
          }
        }
      } else if (hasBounds) {
        self.applyBounds();
      }
    },
        updateMatrix = function (shiftStart) {
      var start = matrix || [1, 0, 0, 1, 0, 0],
          a,
          b,
          c,
          d,
          tx,
          ty,
          determinant,
          pointerX,
          pointerY;
      matrix = _getConcatenatedMatrix(target.parentNode, true);

      if (shiftStart && self.isPressed && start.join(",") !== matrix.join(",")) {
        //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.
        a = start[0];
        b = start[1];
        c = start[2];
        d = start[3];
        tx = start[4];
        ty = start[5];
        determinant = a * d - b * c;
        pointerX = startPointerX * (d / determinant) + startPointerY * (-c / determinant) + (c * ty - d * tx) / determinant;
        pointerY = startPointerX * (-b / determinant) + startPointerY * (a / determinant) + -(a * ty - b * tx) / determinant;
        startPointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
        startPointerX = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
      }

      if (!matrix[1] && !matrix[2] && matrix[0] == 1 && matrix[3] == 1 && matrix[4] == 0 && matrix[5] == 0) {
        //if there are no transforms, we can optimize performance by not factoring in the matrix
        matrix = null;
      }
    },
        recordStartPositions = function () {
      var edgeTolerance = 1 - self.edgeResistance;
      updateMatrix(false);

      if (matrix) {
        startPointerX = self.pointerX * matrix[0] + self.pointerY * matrix[2] + matrix[4]; //translate to local coordinate system

        startPointerY = self.pointerX * matrix[1] + self.pointerY * matrix[3] + matrix[5];
      }

      if (dirty) {
        setPointerPosition(self.pointerX, self.pointerY);
        render(true);
      }

      if (scrollProxy) {
        calculateBounds();
        startElementY = scrollProxy.top();
        startElementX = scrollProxy.left();
      } else {
        //if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.
        if (isTweening()) {
          syncXY(true, true);
          calculateBounds();
        } else {
          self.applyBounds();
        }

        if (rotationMode) {
          rotationOrigin = self.rotationOrigin = _localToGlobal(target, {
            x: 0,
            y: 0
          });
          syncXY(true, true);
          startElementX = self.x; //starting rotation (x always refers to rotation in type:"rotation", measured in degrees)

          startElementY = self.y = Math.atan2(rotationOrigin.y - self.pointerY, self.pointerX - rotationOrigin.x) * _RAD2DEG;
        } else {
          startScrollTop = target.parentNode ? target.parentNode.scrollTop || 0 : 0;
          startScrollLeft = target.parentNode ? target.parentNode.scrollLeft || 0 : 0;
          startElementY = _getStyle(target, yProp); //record the starting top and left values so that we can just add the mouse's movement to them later.

          startElementX = _getStyle(target, xProp);
        }
      }

      if (hasBounds && edgeTolerance) {
        if (startElementX > maxX) {
          startElementX = maxX + (startElementX - maxX) / edgeTolerance;
        } else if (startElementX < minX) {
          startElementX = minX - (minX - startElementX) / edgeTolerance;
        }

        if (!rotationMode) {
          if (startElementY > maxY) {
            startElementY = maxY + (startElementY - maxY) / edgeTolerance;
          } else if (startElementY < minY) {
            startElementY = minY - (minY - startElementY) / edgeTolerance;
          }
        }
      }

      self.startX = startElementX;
      self.startY = startElementY;
    },
        isTweening = function () {
      return self.tween && self.tween.isActive();
    },
        removePlaceholder = function () {
      if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {
        //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.
        _placeholderDiv.parentNode.removeChild(_placeholderDiv);
      }
    },
        buildSnapFunc = function (snap, min, max, factor) {
      if (typeof snap === "function") {
        return function (n) {
          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)

          return snap.call(self, n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor;
        };
      }

      if (snap instanceof Array) {
        return function (n) {
          var i = snap.length,
              closest = 0,
              absDif = _max,
              val,
              dif;

          while (--i > -1) {
            val = snap[i];
            dif = val - n;

            if (dif < 0) {
              dif = -dif;
            }

            if (dif < absDif && val >= min && val <= max) {
              closest = i;
              absDif = dif;
            }
          }

          return snap[closest];
        };
      }

      return isNaN(snap) ? function (n) {
        return n;
      } : function () {
        return snap * factor;
      };
    },
        buildPointSnapFunc = function (snap, minX, maxX, minY, maxY, radius, factor) {
      radius = radius && radius < _max ? radius * radius : _max; //so we don't have to Math.sqrt() in the functions. Performance optimization.

      if (typeof snap === "function") {
        return function (point) {
          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,
              x = point.x,
              y = point.y,
              result,
              dx,
              dy; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)

          point.x = x = x > maxX ? maxX + (x - maxX) * edgeTolerance : x < minX ? minX + (x - minX) * edgeTolerance : x;
          point.y = y = y > maxY ? maxY + (y - maxY) * edgeTolerance : y < minY ? minY + (y - minY) * edgeTolerance : y;
          result = snap.call(self, point);

          if (result !== point) {
            point.x = result.x;
            point.y = result.y;
          }

          if (factor !== 1) {
            point.x *= factor;
            point.y *= factor;
          }

          if (radius < _max) {
            dx = point.x - x;
            dy = point.y - y;

            if (dx * dx + dy * dy > radius) {
              point.x = x;
              point.y = y;
            }
          }

          return point;
        };
      }

      if (snap instanceof Array) {
        return function (p) {
          var i = snap.length,
              closest = 0,
              minDist = _max,
              x,
              y,
              point,
              dist;

          while (--i > -1) {
            point = snap[i];
            x = point.x - p.x;
            y = point.y - p.y;
            dist = x * x + y * y;

            if (dist < minDist) {
              closest = i;
              minDist = dist;
            }
          }

          return minDist <= radius ? snap[closest] : p;
        };
      }

      return function (n) {
        return n;
      };
    },
        //called when the mouse is pressed (or touch starts)
    onPress = function (e, force) {
      var i;

      if (!enabled || self.isPressed || !e || (e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {
        //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick "click" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.
        return;
      }

      interrupted = isTweening();
      self.pointerEvent = e;

      if (_touchEventLookup[e.type]) {
        //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.
        touchEventTarget = e.type.indexOf("touch") !== -1 ? e.currentTarget || e.target : _doc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".

        _addListener(touchEventTarget, "touchend", onRelease);

        _addListener(touchEventTarget, "touchmove", onMove);

        _addListener(touchEventTarget, "touchcancel", onRelease);

        _addListener(_doc, "touchstart", _onMultiTouchDocument);
      } else {
        touchEventTarget = null;

        _addListener(_doc, "mousemove", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.

      }

      touchDragAxis = null;

      _addListener(_doc, "mouseup", onRelease);

      if (e && e.target) {
        _addListener(e.target, "mouseup", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable="true"

      }

      isClicking = isClickable.call(self, e.target) && !vars.dragClickables && !force;

      if (isClicking) {
        _addListener(e.target, "change", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a "change" event instead.


        _dispatchEvent(self, "pressInit", "onPressInit");

        _dispatchEvent(self, "press", "onPress");

        _setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable="true" (otherwise user couldn't drag to select text)


        return;
      }

      allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? "y" : "x"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn't have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.

      if (_isOldIE) {
        e = _populateIEEvent(e, true);
      } else if (!allowNativeTouchScrolling && !self.allowEventDefault) {
        e.preventDefault();

        if (e.preventManipulation) {
          e.preventManipulation(); //for some Microsoft browsers
        }
      }

      if (e.changedTouches) {
        //touch events store the data slightly differently
        e = touch = e.changedTouches[0];
        touchID = e.identifier;
      } else if (e.pointerId) {
        touchID = e.pointerId; //for some Microsoft browsers
      } else {
        touch = touchID = null;
      }

      _dragCount++;

      _addToRenderQueue(render); //causes the Draggable to render on each "tick" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)


      startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove

      startPointerX = self.pointerX = e.pageX;

      _dispatchEvent(self, "pressInit", "onPressInit");

      if (allowNativeTouchScrolling || self.autoScroll) {
        _recordMaxScrolls(target.parentNode);
      }

      if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {
        //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.
        _placeholderDiv.style.width = target.parentNode.scrollWidth + "px";
        target.parentNode.appendChild(_placeholderDiv);
      }

      recordStartPositions();

      if (self.tween) {
        self.tween.kill();
      }

      self.isThrowing = false;
      _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].killTweensOf(scrollProxy || target, true, killProps); //in case the user tries to drag it before the last tween is done.

      if (scrollProxy) {
        _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].killTweensOf(target, true, {
          scrollTo: 1
        }); //just in case the original target's scroll position is being tweened somewhere else.
      }

      self.tween = self.lockedAxis = null;

      if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {
        target.style.zIndex = Draggable.zIndex++;
      }

      self.isPressed = true;
      hasDragCallback = !!(vars.onDrag || self._listeners.drag);

      if (!rotationMode) {
        i = triggers.length;

        while (--i > -1) {
          _setStyle(triggers[i], "cursor", vars.cursor || "move");
        }
      }

      _dispatchEvent(self, "press", "onPress");
    },
        //called every time the mouse/touch moves
    onMove = function (e) {
      var originalEvent = e,
          touches,
          pointerX,
          pointerY,
          i,
          dx,
          dy;

      if (!enabled || _isMultiTouching || !self.isPressed || !e) {
        return;
      }

      self.pointerEvent = e;
      touches = e.changedTouches;

      if (touches) {
        //touch events store the data slightly differently
        e = touches[0];

        if (e !== touch && e.identifier !== touchID) {
          //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
          i = touches.length;

          while (--i > -1 && (e = touches[i]).identifier !== touchID) {}

          if (i < 0) {
            return;
          }
        }
      } else if (e.pointerId && touchID && e.pointerId !== touchID) {
        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
        return;
      }

      if (_isOldIE) {
        e = _populateIEEvent(e, true);
      } else {
        if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {
          //Android browsers force us to decide on the first "touchmove" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a "touchcancel" will be fired and then no "touchmove" or "touchend" will fire during the scrolling (no good).
          pointerX = e.pageX;
          pointerY = e.pageY;

          if (matrix) {
            i = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
            pointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
            pointerX = i;
          }

          dx = Math.abs(pointerX - startPointerX);
          dy = Math.abs(pointerY - startPointerY);

          if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {
            touchDragAxis = dx > dy && allowX ? "x" : "y";

            if (self.vars.lockAxisOnTouchScroll !== false) {
              self.lockedAxis = touchDragAxis === "x" ? "y" : "x";

              if (typeof self.vars.onLockAxis === "function") {
                self.vars.onLockAxis.call(self, originalEvent);
              }
            }

            if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
              onRelease(originalEvent);
              return;
            }
          }
        }

        if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {
          originalEvent.preventDefault();

          if (originalEvent.preventManipulation) {
            //for some Microsoft browsers
            originalEvent.preventManipulation();
          }
        }
      }

      if (self.autoScroll) {
        checkAutoScrollBounds = true;
      }

      setPointerPosition(e.pageX, e.pageY);
    },
        setPointerPosition = function (pointerX, pointerY) {
      var dragTolerance = 1 - self.dragResistance,
          edgeTolerance = 1 - self.edgeResistance,
          xChange,
          yChange,
          x,
          y,
          dif,
          temp;
      self.pointerX = pointerX;
      self.pointerY = pointerY;

      if (rotationMode) {
        y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;
        dif = self.y - y;

        if (dif > 180) {
          startElementY -= 360;
          self.y = y;
        } else if (dif < -180) {
          startElementY += 360;
          self.y = y;
        }

        if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {
          self.y = y;
          x = startElementX + (startElementY - y) * dragTolerance;
        } else {
          x = startElementX;
        }
      } else {
        if (matrix) {
          temp = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
          pointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
          pointerX = temp;
        }

        yChange = pointerY - startPointerY;
        xChange = pointerX - startPointerX;

        if (yChange < minimumMovement && yChange > -minimumMovement) {
          yChange = 0;
        }

        if (xChange < minimumMovement && xChange > -minimumMovement) {
          xChange = 0;
        }

        if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {
          temp = self.lockedAxis;

          if (!temp) {
            self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? "y" : allowY ? "x" : null;

            if (temp && typeof self.vars.onLockAxis === "function") {
              self.vars.onLockAxis.call(self, self.pointerEvent);
            }
          }

          if (temp === "y") {
            yChange = 0;
          } else if (temp === "x") {
            xChange = 0;
          }
        }

        x = startElementX + xChange * dragTolerance;
        y = startElementY + yChange * dragTolerance;
      }

      if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {
        if (snapXY) {
          _temp1.x = x;
          _temp1.y = y;
          temp = snapXY(_temp1);
          x = temp.x;
          y = temp.y;
        }

        if (snapX) {
          x = snapX(x);
        }

        if (snapY) {
          y = snapY(y);
        }
      } else if (hasBounds) {
        if (x > maxX) {
          x = maxX + (x - maxX) * edgeTolerance;
        } else if (x < minX) {
          x = minX + (x - minX) * edgeTolerance;
        }

        if (!rotationMode) {
          if (y > maxY) {
            y = maxY + (y - maxY) * edgeTolerance;
          } else if (y < minY) {
            y = minY + (y - minY) * edgeTolerance;
          }
        }
      }

      if (!rotationMode && !matrix) {
        x = Math.round(x); //helps work around an issue with some Win Touch devices

        y = Math.round(y);
      }

      if (self.x !== x || self.y !== y && !rotationMode) {
        if (rotationMode) {
          self.endRotation = self.x = self.endX = x;
          dirty = true;
        } else {
          if (allowY) {
            self.y = self.endY = y;
            dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a "tick" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)
          }

          if (allowX) {
            self.x = self.endX = x;
            dirty = true;
          }
        }

        if (!self.isDragging && self.isPressed) {
          self.isDragging = true;

          _dispatchEvent(self, "dragstart", "onDragStart");
        }
      }
    },
        //called when the mouse/touch is released
    onRelease = function (e, force) {
      if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {
        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
        return;
      }

      self.isPressed = false;
      var originalEvent = e,
          wasDragging = self.isDragging,
          isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2),
          placeholderDelayedCall = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].delayedCall(0.001, removePlaceholder),
          touches,
          i,
          syntheticEvent,
          eventTarget,
          syntheticClick;

      if (touchEventTarget) {
        _removeListener(touchEventTarget, "touchend", onRelease);

        _removeListener(touchEventTarget, "touchmove", onMove);

        _removeListener(touchEventTarget, "touchcancel", onRelease);

        _removeListener(_doc, "touchstart", _onMultiTouchDocument);
      } else {
        _removeListener(_doc, "mousemove", onMove);
      }

      _removeListener(_doc, "mouseup", onRelease);

      if (e && e.target) {
        _removeListener(e.target, "mouseup", onRelease);
      }

      dirty = false;

      if (isClicking && !isContextMenuRelease) {
        if (e) {
          _removeListener(e.target, "change", onRelease);

          self.pointerEvent = originalEvent;
        }

        _setSelectable(triggers, false);

        _dispatchEvent(self, "release", "onRelease");

        _dispatchEvent(self, "click", "onClick");

        isClicking = false;
        return;
      }

      _removeFromRenderQueue(render);

      if (!rotationMode) {
        i = triggers.length;

        while (--i > -1) {
          _setStyle(triggers[i], "cursor", vars.cursor || "move");
        }
      }

      if (wasDragging) {
        dragEndTime = _lastDragTime = _getTime();
        self.isDragging = false;
      }

      _dragCount--;

      if (e) {
        if (_isOldIE) {
          e = _populateIEEvent(e, false);
        }

        touches = e.changedTouches;

        if (touches) {
          //touch events store the data slightly differently
          e = touches[0];

          if (e !== touch && e.identifier !== touchID) {
            //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
            i = touches.length;

            while (--i > -1 && (e = touches[i]).identifier !== touchID) {}

            if (i < 0) {
              return;
            }
          }
        }

        self.pointerEvent = originalEvent;
        self.pointerX = e.pageX;
        self.pointerY = e.pageY;
      }

      if (isContextMenuRelease && originalEvent) {
        originalEvent.preventDefault();

        if (originalEvent.preventManipulation) {
          originalEvent.preventManipulation(); //for some Microsoft browsers
        }

        _dispatchEvent(self, "release", "onRelease");
      } else if (originalEvent && !wasDragging) {
        if (interrupted && (vars.snap || vars.bounds)) {
          //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)
          animate(vars.throwProps);
        }

        _dispatchEvent(self, "release", "onRelease");

        if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) {
          //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a "click".
          _dispatchEvent(self, "click", "onClick");

          if (_getTime() - clickTime < 300) {
            _dispatchEvent(self, "doubleclick", "onDoubleClick");
          }

          eventTarget = originalEvent.target || originalEvent.srcElement || target; //old IE uses srcElement

          clickTime = _getTime();

          syntheticClick = function () {
            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
            if (clickTime !== clickDispatch && self.enabled() && !self.isPressed) {
              if (eventTarget.click) {
                //some browsers (like mobile Safari) don't properly trigger the click event
                eventTarget.click();
              } else if (_doc.createEvent) {
                syntheticEvent = _doc.createEvent("MouseEvents");
                syntheticEvent.initMouseEvent("click", true, true, window, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);
                eventTarget.dispatchEvent(syntheticEvent);
              }
            }
          };

          if (!_isAndroid && !originalEvent.defaultPrevented) {
            //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.
            _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].delayedCall(0.00001, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the "click" event with "capture" false which solved the video-click-to-play issue, but it would allow the "click" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click.
          }
        }
      } else {
        animate(vars.throwProps); //will skip if throwProps isn't defined or ThrowPropsPlugin isn't loaded.

        if (!_isOldIE && !self.allowEventDefault && originalEvent && (vars.dragClickables || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {
          originalEvent.preventDefault();

          if (originalEvent.preventManipulation) {
            originalEvent.preventManipulation(); //for some Microsoft browsers
          }
        }

        _dispatchEvent(self, "release", "onRelease");
      }

      if (isTweening()) {
        placeholderDelayedCall.duration(self.tween.duration()); //sync the timing so that the placeholder DIV gets
      }

      if (wasDragging) {
        _dispatchEvent(self, "dragend", "onDragEnd");
      }

      return true;
    },
        updateScroll = function (e) {
      if (e && self.isDragging && !scrollProxy) {
        var parent = e.target || e.srcElement || target.parentNode,
            deltaX = parent.scrollLeft - parent._gsScrollX,
            deltaY = parent.scrollTop - parent._gsScrollY;

        if (deltaX || deltaY) {
          if (matrix) {
            startPointerX -= deltaX * matrix[0] + deltaY * matrix[2];
            startPointerY -= deltaY * matrix[3] + deltaX * matrix[1];
          } else {
            startPointerX -= deltaX;
            startPointerY -= deltaY;
          }

          parent._gsScrollX += deltaX;
          parent._gsScrollY += deltaY;
          setPointerPosition(self.pointerX, self.pointerY);
        }
      }
    },
        onClick = function (e) {
      //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.
      var time = _getTime(),
          recentlyClicked = time - clickTime < 40,
          recentlyDragged = time - dragEndTime < 40,
          alreadyDispatched = recentlyClicked && clickDispatch === clickTime,
          isModern = !!e.preventDefault,
          defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented,
          alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime,
          trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched; //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic "click" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?


      if (isModern && (alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false)) {
        e.stopImmediatePropagation();
      }

      if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted !== alreadyDispatchedTrusted)) {
        //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)
        if (trusted && alreadyDispatched) {
          trustedClickDispatch = clickTime;
        }

        clickDispatch = clickTime;
        return;
      }

      if (self.isPressed || recentlyDragged || recentlyClicked) {
        if (!isModern) {
          e.returnValue = false;
        } else if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {
          e.preventDefault();

          if (e.preventManipulation) {
            e.preventManipulation(); //for some Microsoft browsers
          }
        }
      }
    },
        localizePoint = function (p) {
      return matrix ? {
        x: p.x * matrix[0] + p.y * matrix[2] + matrix[4],
        y: p.x * matrix[1] + p.y * matrix[3] + matrix[5]
      } : {
        x: p.x,
        y: p.y
      };
    };

    old = Draggable.get(this.target);

    if (old) {
      old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)
    } //give the user access to start/stop dragging...


    this.startDrag = function (e, align) {
      var r1, r2, p1, p2;
      onPress(e || self.pointerEvent, true); //if the pointer isn't on top of the element, adjust things accordingly

      if (align && !self.hitTest(e || self.pointerEvent)) {
        r1 = _parseRect(e || self.pointerEvent);
        r2 = _parseRect(target);
        p1 = localizePoint({
          x: r1.left + r1.width / 2,
          y: r1.top + r1.height / 2
        });
        p2 = localizePoint({
          x: r2.left + r2.width / 2,
          y: r2.top + r2.height / 2
        });
        startPointerX -= p1.x - p2.x;
        startPointerY -= p1.y - p2.y;
      }

      if (!self.isDragging) {
        self.isDragging = true;

        _dispatchEvent(self, "dragstart", "onDragStart");
      }
    };

    this.drag = onMove;

    this.endDrag = function (e) {
      onRelease(e || self.pointerEvent, true);
    };

    this.timeSinceDrag = function () {
      return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;
    };

    this.timeSinceClick = function () {
      return (_getTime() - clickTime) / 1000;
    };

    this.hitTest = function (target, threshold) {
      return Draggable.hitTest(self.target, target, threshold);
    };

    this.getDirection = function (from, diagonalThreshold) {
      //from can be "start" (default), "velocity", or an element
      var mode = from === "velocity" && ThrowPropsPlugin ? from : typeof from === "object" && !rotationMode ? "element" : "start",
          xChange,
          yChange,
          ratio,
          direction,
          r1,
          r2;

      if (mode === "element") {
        r1 = _parseRect(self.target);
        r2 = _parseRect(from);
      }

      xChange = mode === "start" ? self.x - startElementX : mode === "velocity" ? ThrowPropsPlugin.getVelocity(this.target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);

      if (rotationMode) {
        return xChange < 0 ? "counter-clockwise" : "clockwise";
      } else {
        diagonalThreshold = diagonalThreshold || 2;
        yChange = mode === "start" ? self.y - startElementY : mode === "velocity" ? ThrowPropsPlugin.getVelocity(this.target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);
        ratio = Math.abs(xChange / yChange);
        direction = ratio < 1 / diagonalThreshold ? "" : xChange < 0 ? "left" : "right";

        if (ratio < diagonalThreshold) {
          if (direction !== "") {
            direction += "-";
          }

          direction += yChange < 0 ? "up" : "down";
        }
      }

      return direction;
    };

    this.applyBounds = function (newBounds) {
      var x, y, forceZeroVelocity, e, parent, isRoot;

      if (newBounds && vars.bounds !== newBounds) {
        vars.bounds = newBounds;
        return self.update(true);
      }

      syncXY(true);
      calculateBounds();

      if (hasBounds) {
        x = self.x;
        y = self.y;

        if (x > maxX) {
          x = maxX;
        } else if (x < minX) {
          x = minX;
        }

        if (y > maxY) {
          y = maxY;
        } else if (y < minY) {
          y = minY;
        }

        if (self.x !== x || self.y !== y) {
          forceZeroVelocity = true;
          self.x = self.endX = x;

          if (rotationMode) {
            self.endRotation = x;
          } else {
            self.y = self.endY = y;
          }

          dirty = true;
          render(true);

          if (self.autoScroll && !self.isDragging) {
            _recordMaxScrolls(target.parentNode);

            e = target;
            _windowProxy.scrollTop = window.pageYOffset != null ? window.pageYOffset : _docElement.scrollTop != null ? _docElement.scrollTop : _doc.body.scrollTop;
            _windowProxy.scrollLeft = window.pageXOffset != null ? window.pageXOffset : _docElement.scrollLeft != null ? _docElement.scrollLeft : _doc.body.scrollLeft;

            while (e && !isRoot) {
              //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.
              isRoot = _isRoot(e.parentNode);
              parent = isRoot ? _windowProxy : e.parentNode;

              if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
                parent.scrollTop = parent._gsMaxScrollY;
              }

              if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
                parent.scrollLeft = parent._gsMaxScrollX;
              }

              e = parent;
            }
          }
        }

        if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {
          animate(vars.throwProps, forceZeroVelocity);
        }
      }

      return self;
    };

    this.update = function (applyBounds, sticky, ignoreExternalChanges) {
      var x = self.x,
          y = self.y;
      updateMatrix(!sticky);

      if (applyBounds) {
        self.applyBounds();
      } else {
        if (dirty && ignoreExternalChanges) {
          render(true);
        }

        syncXY(true);
      }

      if (sticky) {
        setPointerPosition(self.pointerX, self.pointerY);

        if (dirty) {
          render(true);
        }
      }

      if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {
        recordStartPositions();
      }

      if (self.autoScroll) {
        _recordMaxScrolls(target.parentNode);

        checkAutoScrollBounds = self.isDragging;
        render(true);
      }

      if (self.autoScroll) {
        //in case reparenting occurred.
        _removeScrollListener(target, updateScroll);

        _addScrollListener(target, updateScroll);
      }

      return self;
    };

    this.enable = function (type) {
      var id, i, trigger;

      if (type !== "soft") {
        i = triggers.length;

        while (--i > -1) {
          trigger = triggers[i];

          _addListener(trigger, "mousedown", onPress);

          _addListener(trigger, "touchstart", onPress);

          _addListener(trigger, "click", onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.


          if (!rotationMode) {
            _setStyle(trigger, "cursor", vars.cursor || "move");
          }

          _setStyle(trigger, "touchCallout", "none");

          _setStyle(trigger, "touchAction", allowX === allowY ? "none" : allowX ? "pan-y" : "pan-x");

          if (_isSVG(trigger)) {
            // a bug in chrome doesn't respect touch-action on SVG elements - it only works if we set it on the parent SVG.
            _setStyle(trigger.ownerSVGElement || trigger, "touchAction", allowX === allowY ? "none" : allowX ? "pan-y" : "pan-x");
          }

          if (!this.vars.allowContextMenu) {
            _addListener(trigger, "contextmenu", onContextMenu);
          }
        }

        _setSelectable(triggers, false);
      }

      _addScrollListener(target, updateScroll);

      enabled = true;

      if (ThrowPropsPlugin && type !== "soft") {
        ThrowPropsPlugin.track(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
      }

      if (scrollProxy) {
        scrollProxy.enable();
      }

      target._gsDragID = id = "d" + _lookupCount++;
      _lookup[id] = this;

      if (scrollProxy) {
        scrollProxy.element._gsDragID = id;
      }

      _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].set(target, {
        x: "+=0",
        overwrite: false,
        data: "_draggable"
      }); //simply ensures that there's a _gsTransform on the element.

      applyObj = {
        t: target,
        data: _isOldIE ? cssVars : target._gsTransform,
        tween: {},
        setRatio: _isOldIE ? function () {
          _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].set(target, tempVars);
        } : _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["default"]._internals.setTransformRatio || _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["default"]._internals.set3DTransformRatio
      };
      recordStartPositions();
      self.update(true);
      return self;
    };

    this.disable = function (type) {
      var dragging = self.isDragging,
          i,
          trigger;

      if (!rotationMode) {
        i = triggers.length;

        while (--i > -1) {
          _setStyle(triggers[i], "cursor", null);
        }
      }

      if (type !== "soft") {
        i = triggers.length;

        while (--i > -1) {
          trigger = triggers[i];

          _setStyle(trigger, "touchCallout", null);

          _setStyle(trigger, "touchAction", null);

          _removeListener(trigger, "mousedown", onPress);

          _removeListener(trigger, "touchstart", onPress);

          _removeListener(trigger, "click", onClick);

          _removeListener(trigger, "contextmenu", onContextMenu);
        }

        _setSelectable(triggers, true);

        if (touchEventTarget) {
          _removeListener(touchEventTarget, "touchcancel", onRelease);

          _removeListener(touchEventTarget, "touchend", onRelease);

          _removeListener(touchEventTarget, "touchmove", onMove);
        }

        _removeListener(_doc, "mouseup", onRelease);

        _removeListener(_doc, "mousemove", onMove);
      }

      _removeScrollListener(target, updateScroll);

      enabled = false;

      if (ThrowPropsPlugin && type !== "soft") {
        ThrowPropsPlugin.untrack(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
      }

      if (scrollProxy) {
        scrollProxy.disable();
      }

      _removeFromRenderQueue(render);

      self.isDragging = self.isPressed = isClicking = false;

      if (dragging) {
        _dispatchEvent(self, "dragend", "onDragEnd");
      }

      return self;
    };

    this.enabled = function (value, type) {
      return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;
    };

    this.kill = function () {
      self.isThrowing = false;
      _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].killTweensOf(scrollProxy || target, true, killProps);
      self.disable();
      _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].set(triggers, {
        clearProps: "userSelect"
      });
      delete _lookup[target._gsDragID];
      return self;
    };

    if (type.indexOf("scroll") !== -1) {
      scrollProxy = this.scrollProxy = new ScrollProxy(target, _extend({
        onKill: function () {
          //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the "mouseup" properly when users drag the scrollbar of an element, so this works around that issue.
          if (self.isPressed) {
            onRelease(null);
          }
        }
      }, vars)); //a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to "hidden" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)

      target.style.overflowY = allowY && !_isTouchDevice ? "auto" : "hidden";
      target.style.overflowX = allowX && !_isTouchDevice ? "auto" : "hidden";
      target = scrollProxy.content;
    }

    if (vars.force3D !== false) {
      _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].set(target, {
        force3D: true
      }); //improve performance by forcing a GPU layer when possible
    }

    if (rotationMode) {
      killProps.rotation = 1;
    } else {
      if (allowX) {
        killProps[xProp] = 1;
      }

      if (allowY) {
        killProps[yProp] = 1;
      }
    }

    if (rotationMode) {
      tempVars = _tempVarsRotation;
      cssVars = tempVars.css;
      tempVars.overwrite = false;
    } else if (xyMode) {
      tempVars = allowX && allowY ? _tempVarsXY : allowX ? _tempVarsX : _tempVarsY;
      cssVars = tempVars.css;
      tempVars.overwrite = false;
    }

    this.enable();
  },
      p = Draggable.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"]();

  p.constructor = Draggable;
  p.pointerX = p.pointerY = p.startX = p.startY = p.deltaX = p.deltaY = 0;
  p.isDragging = p.isPressed = false;
  Draggable.version = "0.16.5";
  Draggable.zIndex = 1000;

  _addListener(_doc, "touchcancel", function () {//some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document. Very strange indeed.
  });

  _addListener(_doc, "contextmenu", function (e) {
    var p;

    for (p in _lookup) {
      if (_lookup[p].isPressed) {
        _lookup[p].endDrag();
      }
    }
  });

  Draggable.create = function (targets, vars) {
    if (typeof targets === "string") {
      targets = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].selector(targets);
    }

    var a = !targets || targets.length === 0 ? [] : _isArrayLike(targets) ? _flattenArray(targets) : [targets],
        i = a.length;

    while (--i > -1) {
      a[i] = new Draggable(a[i], vars);
    }

    return a;
  };

  Draggable.get = function (target) {
    return _lookup[(_unwrapElement(target) || {})._gsDragID];
  };

  Draggable.timeSinceDrag = function () {
    return (_getTime() - _lastDragTime) / 1000;
  };

  var _tempRect = {},
      //reuse to reduce garbage collection tasks
  _oldIERect = function (e) {
    //IE8 doesn't support getBoundingClientRect(), so we use this as a backup.
    var top = 0,
        left = 0,
        width,
        height;
    e = _unwrapElement(e);
    width = e.offsetWidth;
    height = e.offsetHeight;

    while (e) {
      top += e.offsetTop;
      left += e.offsetLeft;
      e = e.offsetParent;
    }

    return {
      top: top,
      left: left,
      width: width,
      height: height
    };
  },
      _parseRect = function (e, undefined) {
    //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties
    if (e === window) {
      _tempRect.left = _tempRect.top = 0;
      _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _doc.body.clientWidth || 0;
      _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _doc.body.clientHeight || 0;
      return _tempRect;
    }

    var r = e.pageX !== undefined ? {
      left: e.pageX - _getDocScrollLeft(),
      top: e.pageY - _getDocScrollTop(),
      right: e.pageX - _getDocScrollLeft() + 1,
      bottom: e.pageY - _getDocScrollTop() + 1
    } : !e.nodeType && e.left !== undefined && e.top !== undefined ? e : _isOldIE ? _oldIERect(e) : _unwrapElement(e).getBoundingClientRect();

    if (r.right === undefined && r.width !== undefined) {
      r.right = r.left + r.width;
      r.bottom = r.top + r.height;
    } else if (r.width === undefined) {
      //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic2 object.
      r = {
        width: r.right - r.left,
        height: r.bottom - r.top,
        right: r.right,
        left: r.left,
        bottom: r.bottom,
        top: r.top
      };
    }

    return r;
  };

  Draggable.hitTest = function (obj1, obj2, threshold) {
    if (obj1 === obj2) {
      return false;
    }

    var r1 = _parseRect(obj1),
        r2 = _parseRect(obj2),
        isOutside = r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top,
        overlap,
        area,
        isRatio;

    if (isOutside || !threshold) {
      return !isOutside;
    }

    isRatio = (threshold + "").indexOf("%") !== -1;
    threshold = parseFloat(threshold) || 0;
    overlap = {
      left: Math.max(r1.left, r2.left),
      top: Math.max(r1.top, r2.top)
    };
    overlap.width = Math.min(r1.right, r2.right) - overlap.left;
    overlap.height = Math.min(r1.bottom, r2.bottom) - overlap.top;

    if (overlap.width < 0 || overlap.height < 0) {
      return false;
    }

    if (isRatio) {
      threshold *= 0.01;
      area = overlap.width * overlap.height;
      return area >= r1.width * r1.height * threshold || area >= r2.width * r2.height * threshold;
    }

    return overlap.width > threshold && overlap.height > threshold;
  };

  _placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;";
  return Draggable;
}, true);

var Draggable = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].Draggable;


/***/ }),

/***/ "./js/plugins/greensock/EasePack.js":
/*!******************************************!*\
  !*** ./js/plugins/greensock/EasePack.js ***!
  \******************************************/
/*! exports provided: Back, Elastic, Bounce, RoughEase, SlowMo, SteppedEase, Circ, Expo, Sine, ExpoScaleEase, Linear, Power0, Power1, Power2, Power3, Power4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return Back; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return Elastic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return Bounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoughEase", function() { return RoughEase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SlowMo", function() { return SlowMo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return SteppedEase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return Circ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return Expo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return Sine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExpoScaleEase", function() { return ExpoScaleEase; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Linear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power0"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power4"]; });

/*!
 * VERSION: 1.16.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/


_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine("easing.Back", ["easing.Ease"], function () {
  var w = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].GreenSockGlobals || _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"],
      gs = w.com.greensock,
      _2PI = Math.PI * 2,
      _HALF_PI = Math.PI / 2,
      _class = gs._class,
      _create = function (n, f) {
    var C = _class("easing." + n, function () {}, true),
        p = C.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"]();

    p.constructor = C;
    p.getRatio = f;
    return C;
  },
      _easeReg = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"].register || function () {},
      //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
  _wrap = function (name, EaseOut, EaseIn, EaseInOut, aliases) {
    var C = _class("easing." + name, {
      easeOut: new EaseOut(),
      easeIn: new EaseIn(),
      easeInOut: new EaseInOut()
    }, true);

    _easeReg(C, name);

    return C;
  },
      EasePoint = function (time, value, next) {
    this.t = time;
    this.v = value;

    if (next) {
      this.next = next;
      next.prev = this;
      this.c = next.v - value;
      this.gap = next.t - time;
    }
  },
      //Back
  _createBack = function (n, f) {
    var C = _class("easing." + n, function (overshoot) {
      this._p1 = overshoot || overshoot === 0 ? overshoot : 1.70158;
      this._p2 = this._p1 * 1.525;
    }, true),
        p = C.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"]();

    p.constructor = C;
    p.getRatio = f;

    p.config = function (overshoot) {
      return new C(overshoot);
    };

    return C;
  },
      Back = _wrap("Back", _createBack("BackOut", function (p) {
    return (p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1;
  }), _createBack("BackIn", function (p) {
    return p * p * ((this._p1 + 1) * p - this._p1);
  }), _createBack("BackInOut", function (p) {
    return (p *= 2) < 1 ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
  })),
      //SlowMo
  SlowMo = _class("easing.SlowMo", function (linearRatio, power, yoyoMode) {
    power = power || power === 0 ? power : 0.7;

    if (linearRatio == null) {
      linearRatio = 0.7;
    } else if (linearRatio > 1) {
      linearRatio = 1;
    }

    this._p = linearRatio !== 1 ? power : 0;
    this._p1 = (1 - linearRatio) / 2;
    this._p2 = linearRatio;
    this._p3 = this._p1 + this._p2;
    this._calcEnd = yoyoMode === true;
  }, true),
      p = SlowMo.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"](),
      SteppedEase,
      ExpoScaleEase,
      RoughEase,
      _createElastic;

  p.constructor = SlowMo;

  p.getRatio = function (p) {
    var r = p + (0.5 - p) * this._p;

    if (p < this._p1) {
      return this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r;
    } else if (p > this._p3) {
      return this._calcEnd ? p === 1 ? 0 : 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p; //added p === 1 ? 0 to avoid floating point rounding errors from affecting the final value, like 1 - 0.7 = 0.30000000000000004 instead of 0.3
    }

    return this._calcEnd ? 1 : r;
  };

  SlowMo.ease = new SlowMo(0.7, 0.7);

  p.config = SlowMo.config = function (linearRatio, power, yoyoMode) {
    return new SlowMo(linearRatio, power, yoyoMode);
  }; //SteppedEase


  SteppedEase = _class("easing.SteppedEase", function (steps, immediateStart) {
    steps = steps || 1;
    this._p1 = 1 / steps;
    this._p2 = steps + (immediateStart ? 0 : 1);
    this._p3 = immediateStart ? 1 : 0;
  }, true);
  p = SteppedEase.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"]();
  p.constructor = SteppedEase;

  p.getRatio = function (p) {
    if (p < 0) {
      p = 0;
    } else if (p >= 1) {
      p = 0.999999999;
    }

    return ((this._p2 * p | 0) + this._p3) * this._p1;
  };

  p.config = SteppedEase.config = function (steps, immediateStart) {
    return new SteppedEase(steps, immediateStart);
  }; //ExpoScaleEase


  ExpoScaleEase = _class("easing.ExpoScaleEase", function (start, end, ease) {
    this._p1 = Math.log(end / start);
    this._p2 = end - start;
    this._p3 = start;
    this._ease = ease;
  }, true);
  p = ExpoScaleEase.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"]();
  p.constructor = ExpoScaleEase;

  p.getRatio = function (p) {
    if (this._ease) {
      p = this._ease.getRatio(p);
    }

    return (this._p3 * Math.exp(this._p1 * p) - this._p3) / this._p2;
  };

  p.config = ExpoScaleEase.config = function (start, end, ease) {
    return new ExpoScaleEase(start, end, ease);
  }; //RoughEase


  RoughEase = _class("easing.RoughEase", function (vars) {
    vars = vars || {};
    var taper = vars.taper || "none",
        a = [],
        cnt = 0,
        points = (vars.points || 20) | 0,
        i = points,
        randomize = vars.randomize !== false,
        clamp = vars.clamp === true,
        template = vars.template instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"] ? vars.template : null,
        strength = typeof vars.strength === "number" ? vars.strength * 0.4 : 0.4,
        x,
        y,
        bump,
        invX,
        obj,
        pnt;

    while (--i > -1) {
      x = randomize ? Math.random() : 1 / points * i;
      y = template ? template.getRatio(x) : x;

      if (taper === "none") {
        bump = strength;
      } else if (taper === "out") {
        invX = 1 - x;
        bump = invX * invX * strength;
      } else if (taper === "in") {
        bump = x * x * strength;
      } else if (x < 0.5) {
        //"both" (start)
        invX = x * 2;
        bump = invX * invX * 0.5 * strength;
      } else {
        //"both" (end)
        invX = (1 - x) * 2;
        bump = invX * invX * 0.5 * strength;
      }

      if (randomize) {
        y += Math.random() * bump - bump * 0.5;
      } else if (i % 2) {
        y += bump * 0.5;
      } else {
        y -= bump * 0.5;
      }

      if (clamp) {
        if (y > 1) {
          y = 1;
        } else if (y < 0) {
          y = 0;
        }
      }

      a[cnt++] = {
        x: x,
        y: y
      };
    }

    a.sort(function (a, b) {
      return a.x - b.x;
    });
    pnt = new EasePoint(1, 1, null);
    i = points;

    while (--i > -1) {
      obj = a[i];
      pnt = new EasePoint(obj.x, obj.y, pnt);
    }

    this._prev = new EasePoint(0, 0, pnt.t !== 0 ? pnt : pnt.next);
  }, true);
  p = RoughEase.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"]();
  p.constructor = RoughEase;

  p.getRatio = function (p) {
    var pnt = this._prev;

    if (p > pnt.t) {
      while (pnt.next && p >= pnt.t) {
        pnt = pnt.next;
      }

      pnt = pnt.prev;
    } else {
      while (pnt.prev && p <= pnt.t) {
        pnt = pnt.prev;
      }
    }

    this._prev = pnt;
    return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;
  };

  p.config = function (vars) {
    return new RoughEase(vars);
  };

  RoughEase.ease = new RoughEase(); //Bounce

  _wrap("Bounce", _create("BounceOut", function (p) {
    if (p < 1 / 2.75) {
      return 7.5625 * p * p;
    } else if (p < 2 / 2.75) {
      return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
    } else if (p < 2.5 / 2.75) {
      return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
    }

    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
  }), _create("BounceIn", function (p) {
    if ((p = 1 - p) < 1 / 2.75) {
      return 1 - 7.5625 * p * p;
    } else if (p < 2 / 2.75) {
      return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
    } else if (p < 2.5 / 2.75) {
      return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
    }

    return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
  }), _create("BounceInOut", function (p) {
    var invert = p < 0.5;

    if (invert) {
      p = 1 - p * 2;
    } else {
      p = p * 2 - 1;
    }

    if (p < 1 / 2.75) {
      p = 7.5625 * p * p;
    } else if (p < 2 / 2.75) {
      p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
    } else if (p < 2.5 / 2.75) {
      p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
    } else {
      p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
    }

    return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
  })); //CIRC


  _wrap("Circ", _create("CircOut", function (p) {
    return Math.sqrt(1 - (p = p - 1) * p);
  }), _create("CircIn", function (p) {
    return -(Math.sqrt(1 - p * p) - 1);
  }), _create("CircInOut", function (p) {
    return (p *= 2) < 1 ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
  })); //Elastic


  _createElastic = function (n, f, def) {
    var C = _class("easing." + n, function (amplitude, period) {
      this._p1 = amplitude >= 1 ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.

      this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
      this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
      this._p2 = _2PI / this._p2; //precalculate to optimize
    }, true),
        p = C.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"]();

    p.constructor = C;
    p.getRatio = f;

    p.config = function (amplitude, period) {
      return new C(amplitude, period);
    };

    return C;
  };

  _wrap("Elastic", _createElastic("ElasticOut", function (p) {
    return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1;
  }, 0.3), _createElastic("ElasticIn", function (p) {
    return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2));
  }, 0.3), _createElastic("ElasticInOut", function (p) {
    return (p *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * 0.5 + 1;
  }, 0.45)); //Expo


  _wrap("Expo", _create("ExpoOut", function (p) {
    return 1 - Math.pow(2, -10 * p);
  }), _create("ExpoIn", function (p) {
    return Math.pow(2, 10 * (p - 1)) - 0.001;
  }), _create("ExpoInOut", function (p) {
    return (p *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
  })); //Sine


  _wrap("Sine", _create("SineOut", function (p) {
    return Math.sin(p * _HALF_PI);
  }), _create("SineIn", function (p) {
    return -Math.cos(p * _HALF_PI) + 1;
  }), _create("SineInOut", function (p) {
    return -0.5 * (Math.cos(Math.PI * p) - 1);
  }));

  _class("easing.EaseLookup", {
    find: function (s) {
      return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"].map[s];
    }
  }, true); //register the non-standard eases


  _easeReg(w.SlowMo, "SlowMo", "ease,");

  _easeReg(RoughEase, "RoughEase", "ease,");

  _easeReg(SteppedEase, "SteppedEase", "ease,");

  return Back;
}, true);

var Back = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].Back;
var Elastic = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].Elastic;
var Bounce = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].Bounce;
var RoughEase = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].RoughEase;
var SlowMo = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].SlowMo;
var SteppedEase = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].SteppedEase;
var Circ = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].Circ;
var Expo = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].Expo;
var Sine = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].Sine;
var ExpoScaleEase = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].ExpoScaleEase;


/***/ }),

/***/ "./js/plugins/greensock/RoundPropsPlugin.js":
/*!**************************************************!*\
  !*** ./js/plugins/greensock/RoundPropsPlugin.js ***!
  \**************************************************/
/*! exports provided: RoundPropsPlugin, _getRoundFunc, _roundLinkedList, p, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoundPropsPlugin", function() { return RoundPropsPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getRoundFunc", function() { return _getRoundFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_roundLinkedList", function() { return _roundLinkedList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RoundPropsPlugin; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/*!
 * VERSION: 1.6.0
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/

var RoundPropsPlugin = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.plugin({
  propName: "roundProps",
  version: "1.7.0",
  priority: -1,
  API: 2,
  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
  init: function (target, value, tween) {
    this._tween = tween;
    return true;
  }
}),
    _getRoundFunc = function (v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()

  return function (n) {
    return (Math.round(n / v) * v * p | 0) / p;
  };
},
    _roundLinkedList = function (node, mod) {
  while (node) {
    if (!node.f && !node.blob) {
      node.m = mod || Math.round;
    }

    node = node._next;
  }
},
    p = RoundPropsPlugin.prototype;

p._onInitAllProps = function () {
  var tween = this._tween,
      rp = tween.vars.roundProps,
      lookup = {},
      rpt = tween._propLookup.roundProps,
      pt,
      next,
      i,
      p;

  if (typeof rp === "object" && !rp.push) {
    for (p in rp) {
      lookup[p] = _getRoundFunc(rp[p]);
    }
  } else {
    if (typeof rp === "string") {
      rp = rp.split(",");
    }

    i = rp.length;

    while (--i > -1) {
      lookup[rp[i]] = Math.round;
    }
  }

  for (p in lookup) {
    pt = tween._firstPT;

    while (pt) {
      next = pt._next; //record here, because it may get removed

      if (pt.pg) {
        pt.t._mod(lookup);
      } else if (pt.n === p) {
        if (pt.f === 2 && pt.t) {
          //a blob (text containing multiple numeric values)
          _roundLinkedList(pt.t._firstPT, lookup[p]);
        } else {
          this._add(pt.t, p, pt.s, pt.c, lookup[p]); //remove from linked list


          if (next) {
            next._prev = pt._prev;
          }

          if (pt._prev) {
            pt._prev._next = next;
          } else if (tween._firstPT === pt) {
            tween._firstPT = next;
          }

          pt._next = pt._prev = null;
          tween._propLookup[p] = rpt;
        }
      }

      pt = next;
    }
  }

  return false;
};

p._add = function (target, p, s, c, mod) {
  this._addTween(target, p, s, s + c, p, mod || Math.round);

  this._overwriteProps.push(p);
};



/***/ }),

/***/ "./js/plugins/greensock/ThrowPropsPlugin.js":
/*!**************************************************!*\
  !*** ./js/plugins/greensock/ThrowPropsPlugin.js ***!
  \**************************************************/
/*! exports provided: ThrowPropsPlugin, default, VelocityTracker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThrowPropsPlugin", function() { return ThrowPropsPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ThrowPropsPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VelocityTracker", function() { return VelocityTracker; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/*!
 * VERSION: 0.11.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * ThrowPropsPlugin is a Club GreenSock membership benefit; You must have a valid membership to use
 * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.
 * This work is subject to the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */


_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine("plugins.ThrowPropsPlugin", ["utils.VelocityTracker", "plugins.TweenPlugin", "TweenLite", "easing.Ease"], function (VelocityTracker) {
  var ThrowPropsPlugin = function (props, priority) {
    _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenPlugin"].call(this, "throwProps");
    this._overwriteProps.length = 0;
  },
      _max = 999999999999999,
      _min = 0.0000000001,
      _globals = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.globals,
      _recordEndMode = false,
      //in a typical throwProps css tween that has an "end" defined as a function, it grabs that value initially when the tween is rendered, then again when we calculate the necessary duration, and then a 3rd time after we invalidate() the tween, so we toggle _recordEndMode to true when we're about to begin such a tween which tells the engine to grab the end value(s) once and record them as "max" and "min" on the throwProps object, thus we can skip those extra calls. Then we set it back to false when we're done with our fancy initialization routine.
  _transforms = {
    x: 1,
    y: 1,
    z: 2,
    scale: 1,
    scaleX: 1,
    scaleY: 1,
    rotation: 1,
    rotationZ: 1,
    rotationX: 2,
    rotationY: 2,
    skewX: 1,
    skewY: 1,
    xPercent: 1,
    yPercent: 1
  },
      _getClosest = function (n, values, max, min, radius) {
    var i = values.length,
        closest = 0,
        absDif = _max,
        val,
        dif,
        p,
        dist;

    if (typeof n === "object") {
      while (--i > -1) {
        val = values[i];
        dif = 0;

        for (p in n) {
          dist = val[p] - n[p];
          dif += dist * dist;
        }

        if (dif < absDif) {
          closest = i;
          absDif = dif;
        }
      }

      if ((radius || _max) < _max && radius < Math.sqrt(absDif)) {
        return n;
      }
    } else {
      while (--i > -1) {
        val = values[i];
        dif = val - n;

        if (dif < 0) {
          dif = -dif;
        }

        if (dif < absDif && val >= min && val <= max) {
          closest = i;
          absDif = dif;
        }
      }
    }

    return values[closest];
  },
      _parseEnd = function (curProp, end, max, min, name, radius) {
    if (curProp.end === "auto") {
      return curProp;
    }

    var endVar = curProp.end,
        adjustedEnd,
        p;
    max = isNaN(max) ? _max : max;
    min = isNaN(min) ? -_max : min;

    if (typeof end === "object") {
      //for objects, like {x, y} where they're linked and we must pass an object to the function or find the closest value in an array.
      adjustedEnd = end.calculated ? end : (typeof endVar === "function" ? endVar(end) : _getClosest(end, endVar, max, min, radius)) || end;

      if (!end.calculated) {
        for (p in adjustedEnd) {
          end[p] = adjustedEnd[p];
        }

        end.calculated = true;
      }

      adjustedEnd = adjustedEnd[name];
    } else {
      adjustedEnd = typeof endVar === "function" ? endVar(end) : endVar instanceof Array ? _getClosest(end, endVar, max, min, radius) : Number(endVar);
    }

    if (adjustedEnd > max) {
      adjustedEnd = max;
    } else if (adjustedEnd < min) {
      adjustedEnd = min;
    }

    return {
      max: adjustedEnd,
      min: adjustedEnd,
      unitFactor: curProp.unitFactor
    };
  },
      _extend = function (decoratee, extras, exclude) {
    for (var p in extras) {
      if (decoratee[p] === undefined && p !== exclude) {
        decoratee[p] = extras[p];
      }
    }

    return decoratee;
  },
      _calculateChange = ThrowPropsPlugin.calculateChange = function (velocity, ease, duration, checkpoint) {
    if (checkpoint == null) {
      checkpoint = 0.05;
    }

    var e = ease instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"] ? ease : !ease ? _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"].defaultEase : new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"](ease);
    return duration * checkpoint * velocity / e.getRatio(checkpoint);
  },
      _calculateDuration = ThrowPropsPlugin.calculateDuration = function (start, end, velocity, ease, checkpoint) {
    checkpoint = checkpoint || 0.05;
    var e = ease instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"] ? ease : !ease ? _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"].defaultEase : new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"](ease);
    return Math.abs((end - start) * e.getRatio(checkpoint) / velocity / checkpoint);
  },
      _calculateTweenDuration = ThrowPropsPlugin.calculateTweenDuration = function (target, vars, maxDuration, minDuration, overshootTolerance, recordEnd) {
    if (typeof target === "string") {
      target = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"].selector(target);
    }

    if (!target) {
      return 0;
    }

    if (maxDuration == null) {
      maxDuration = 10;
    }

    if (minDuration == null) {
      minDuration = 0.2;
    }

    if (overshootTolerance == null) {
      overshootTolerance = 1;
    }

    if (target.length) {
      target = target[0] || target;
    }

    var duration = 0,
        clippedDuration = 9999999999,
        throwPropsVars = vars.throwProps || vars,
        ease = vars.ease instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"] ? vars.ease : !vars.ease ? _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"].defaultEase : new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"](vars.ease),
        checkpoint = isNaN(throwPropsVars.checkpoint) ? 0.05 : Number(throwPropsVars.checkpoint),
        resistance = isNaN(throwPropsVars.resistance) ? ThrowPropsPlugin.defaultResistance : Number(throwPropsVars.resistance),
        p,
        curProp,
        curDuration,
        curVelocity,
        curResistance,
        curVal,
        end,
        curClippedDuration,
        tracker,
        unitFactor,
        linkedProps,
        linkedPropNames,
        i;

    if (throwPropsVars.linkedProps) {
      //when there are linkedProps (typically "x,y" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we'll do later in the "real" loop.
      linkedPropNames = throwPropsVars.linkedProps.split(",");
      linkedProps = {};

      for (i = 0; i < linkedPropNames.length; i++) {
        p = linkedPropNames[i];
        curProp = throwPropsVars[p];

        if (curProp) {
          if (curProp.velocity !== undefined && typeof curProp.velocity === "number") {
            curVelocity = Number(curProp.velocity) || 0;
          } else {
            tracker = tracker || VelocityTracker.getByTarget(target);
            curVelocity = tracker && tracker.isTrackingProp(p) ? tracker.getVelocity(p) : 0;
          }

          curResistance = isNaN(curProp.resistance) ? resistance : Number(curProp.resistance);
          curDuration = curVelocity * curResistance > 0 ? curVelocity / curResistance : curVelocity / -curResistance;
          curVal = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]() : target[p] || 0;
          linkedProps[p] = curVal + _calculateChange(curVelocity, ease, curDuration, checkpoint);
        }
      }
    }

    for (p in throwPropsVars) {
      if (p !== "resistance" && p !== "checkpoint" && p !== "preventOvershoot" && p !== "linkedProps" && p !== "radius") {
        curProp = throwPropsVars[p];

        if (typeof curProp !== "object") {
          tracker = tracker || VelocityTracker.getByTarget(target);

          if (tracker && tracker.isTrackingProp(p)) {
            curProp = typeof curProp === "number" ? {
              velocity: curProp
            } : {
              velocity: tracker.getVelocity(p)
            }; //if we're tracking this property, we should use the tracking velocity and then use the numeric value that was passed in as the min and max so that it tweens exactly there.
          } else {
            curVelocity = Number(curProp) || 0;
            curDuration = curVelocity * resistance > 0 ? curVelocity / resistance : curVelocity / -resistance;
          }
        }

        if (typeof curProp === "object") {
          if (curProp.velocity !== undefined && typeof curProp.velocity === "number") {
            curVelocity = Number(curProp.velocity) || 0;
          } else {
            tracker = tracker || VelocityTracker.getByTarget(target);
            curVelocity = tracker && tracker.isTrackingProp(p) ? tracker.getVelocity(p) : 0;
          }

          curResistance = isNaN(curProp.resistance) ? resistance : Number(curProp.resistance);
          curDuration = curVelocity * curResistance > 0 ? curVelocity / curResistance : curVelocity / -curResistance;
          curVal = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]() : target[p] || 0;
          end = curVal + _calculateChange(curVelocity, ease, curDuration, checkpoint);

          if (curProp.end !== undefined) {
            curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, throwPropsVars.radius);

            if (recordEnd || _recordEndMode) {
              throwPropsVars[p] = _extend(curProp, throwPropsVars[p], "end");
            }
          }

          if (curProp.max !== undefined && end > Number(curProp.max) + _min) {
            unitFactor = curProp.unitFactor || ThrowPropsPlugin.defaultUnitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.
            //if the value is already exceeding the max or the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive. If the max and min match, it means we're animating to a particular value and we don't want to shorten the time unless the velocity is really slow. Example: a rotation where the start and natural end value are less than the snapping spot, but the natural end is pretty close to the snap.

            curClippedDuration = curVal > curProp.max && curProp.min !== curProp.max || curVelocity * unitFactor > -15 && curVelocity * unitFactor < 45 ? minDuration + (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.max, curVelocity, ease, checkpoint);

            if (curClippedDuration + overshootTolerance < clippedDuration) {
              clippedDuration = curClippedDuration + overshootTolerance;
            }
          } else if (curProp.min !== undefined && end < Number(curProp.min) - _min) {
            unitFactor = curProp.unitFactor || ThrowPropsPlugin.defaultUnitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.
            //if the value is already exceeding the min or if the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive.

            curClippedDuration = curVal < curProp.min && curProp.min !== curProp.max || curVelocity * unitFactor > -45 && curVelocity * unitFactor < 15 ? minDuration + (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.min, curVelocity, ease, checkpoint);

            if (curClippedDuration + overshootTolerance < clippedDuration) {
              clippedDuration = curClippedDuration + overshootTolerance;
            }
          }

          if (curClippedDuration > duration) {
            duration = curClippedDuration;
          }
        }

        if (curDuration > duration) {
          duration = curDuration;
        }
      }
    }

    if (duration > clippedDuration) {
      duration = clippedDuration;
    }

    if (duration > maxDuration) {
      return maxDuration;
    } else if (duration < minDuration) {
      return minDuration;
    }

    return duration;
  },
      p = ThrowPropsPlugin.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenPlugin"]("throwProps"),
      _cssProxy,
      _cssVars,
      _last,
      _lastValue; //these serve as a cache of sorts, recording the last css-related proxy and the throwProps vars that get calculated in the _cssRegister() method. This allows us to grab them in the ThrowPropsPlugin.to() function and calculate the duration. Of course we could have structured things in a more "clean" fashion, but performance is of paramount importance.


  p.constructor = ThrowPropsPlugin;
  ThrowPropsPlugin.version = "0.11.1";
  ThrowPropsPlugin.API = 2;
  ThrowPropsPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite

  ThrowPropsPlugin.defaultResistance = 100;
  ThrowPropsPlugin.defaultUnitFactors = {
    time: 1000,
    totalTime: 1000
  }; //setting the unitFactor to a higher value (default is 1) reduces the chance of the auto-accelerating behavior kicking in when determining durations when the initial velocity is adequately low - imagine dragging something past a boundary and then letting go - snapping back relatively quickly should be prioritized over matching the initial velocity (at least that's the behavior most people consider intuitive). But in some situations when the units are very low (like "time" of a timeline or rotation when using radians), it can kick in too frequently so this allows tweaking.

  ThrowPropsPlugin.track = function (target, props, types) {
    return VelocityTracker.track(target, props, types);
  };

  ThrowPropsPlugin.untrack = function (target, props) {
    VelocityTracker.untrack(target, props);
  };

  ThrowPropsPlugin.isTracking = function (target, prop) {
    return VelocityTracker.isTracking(target, prop);
  };

  ThrowPropsPlugin.getVelocity = function (target, prop) {
    var vt = VelocityTracker.getByTarget(target);
    return vt ? vt.getVelocity(prop) : NaN;
  };

  ThrowPropsPlugin._cssRegister = function () {
    var CSSPlugin = _globals.com.greensock.plugins.CSSPlugin;

    if (!CSSPlugin) {
      return;
    }

    var _internals = CSSPlugin._internals,
        _parseToProxy = _internals._parseToProxy,
        _setPluginRatio = _internals._setPluginRatio,
        CSSPropTween = _internals.CSSPropTween;

    _internals._registerComplexSpecialProp("throwProps", {
      parser: function (t, e, prop, cssp, pt, plugin) {
        plugin = new ThrowPropsPlugin();
        var velocities = {},
            min = {},
            max = {},
            end = {},
            res = {},
            preventOvershoot = {},
            hasResistance,
            val,
            p,
            data,
            tracker;
        _cssVars = {};

        for (p in e) {
          if (p !== "resistance" && p !== "preventOvershoot" && p !== "linkedProps" && p !== "radius") {
            val = e[p];

            if (typeof val === "object") {
              if (val.velocity !== undefined && typeof val.velocity === "number") {
                velocities[p] = Number(val.velocity) || 0;
              } else {
                tracker = tracker || VelocityTracker.getByTarget(t);
                velocities[p] = tracker && tracker.isTrackingProp(p) ? tracker.getVelocity(p) : 0; //rotational values are actually converted to radians in CSSPlugin, but our tracking velocity is in radians already, so make it into degrees to avoid a funky conversion
              }

              if (val.end !== undefined) {
                end[p] = val.end;
              }

              if (val.min !== undefined) {
                min[p] = val.min;
              }

              if (val.max !== undefined) {
                max[p] = val.max;
              }

              if (val.preventOvershoot) {
                preventOvershoot[p] = true;
              }

              if (val.resistance !== undefined) {
                hasResistance = true;
                res[p] = val.resistance;
              }
            } else if (typeof val === "number") {
              velocities[p] = val;
            } else {
              tracker = tracker || VelocityTracker.getByTarget(t);

              if (tracker && tracker.isTrackingProp(p)) {
                velocities[p] = tracker.getVelocity(p);
              } else {
                velocities[p] = val || 0;
              }
            }

            if (_transforms[p]) {
              cssp._enableTransforms(_transforms[p] === 2);
            }
          }
        }

        data = _parseToProxy(t, velocities, cssp, pt, plugin);
        _cssProxy = data.proxy;
        velocities = data.end;

        for (p in _cssProxy) {
          _cssVars[p] = {
            velocity: velocities[p],
            min: min[p],
            max: max[p],
            end: end[p],
            resistance: res[p],
            preventOvershoot: preventOvershoot[p]
          };
        }

        if (e.resistance != null) {
          _cssVars.resistance = e.resistance;
        }

        if (e.linkedProps != null) {
          _cssVars.linkedProps = e.linkedProps;
        }

        if (e.radius != null) {
          _cssVars.radius = e.radius;
        }

        if (e.preventOvershoot) {
          _cssVars.preventOvershoot = true;
        }

        pt = new CSSPropTween(t, "throwProps", 0, 0, data.pt, 2);

        cssp._overwriteProps.pop(); //don't overwrite all other throwProps tweens. In the CSSPropTween constructor, we add the property to the _overwriteProps, so remove it here.


        pt.plugin = plugin;
        pt.setRatio = _setPluginRatio;
        pt.data = data;

        plugin._onInitTween(_cssProxy, _cssVars, cssp._tween);

        return pt;
      }
    });
  };

  ThrowPropsPlugin.to = function (target, vars, maxDuration, minDuration, overshootTolerance) {
    if (!vars.throwProps) {
      vars = {
        throwProps: vars
      };
    }

    if (overshootTolerance === 0) {
      vars.throwProps.preventOvershoot = true;
    }

    _recordEndMode = true; //if we encounter a function-based "end" value, ThrowPropsPlugin will record it as "max" and "min" properties, replacing "end" (this is an optimization so that the function only gets called once)

    var tween = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"](target, minDuration || 1, vars);
    tween.render(0, true, true); //we force a render so that the CSSPlugin instantiates and populates the _cssProxy and _cssVars which we need in order to calculate the tween duration. Remember, we can't use the regular target for calculating the duration because the current values wouldn't be able to be grabbed like target["propertyName"], as css properties can be complex like boxShadow:"10px 10px 20px 30px red" or backgroundPosition:"25px 50px". The proxy is the result of breaking all that complex data down and finding just the numeric values and assigning them to a generic2 proxy object with unique names. THAT is what the _calculateTweenDuration() can look at. We also needed to do the same break down of any min or max or velocity data

    if (tween.vars.css) {
      tween.duration(_calculateTweenDuration(_cssProxy, {
        throwProps: _cssVars,
        ease: vars.ease
      }, maxDuration, minDuration, overshootTolerance));

      if (tween._delay && !tween.vars.immediateRender) {
        tween.invalidate(); //if there's a delay, the starting values could be off, so invalidate() to force reinstantiation when the tween actually starts.
      } else {
        _last._onInitTween(_cssProxy, _lastValue, tween);
      }

      _recordEndMode = false;
      return tween;
    } else {
      tween.kill();
      tween = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"](target, _calculateTweenDuration(target, vars, maxDuration, minDuration, overshootTolerance), vars);
      _recordEndMode = false;
      return tween;
    }
  };

  p._onInitTween = function (target, value, tween, index) {
    this.target = target;
    this._props = [];
    _last = this;
    _lastValue = value;
    var ease = tween._ease,
        checkpoint = isNaN(value.checkpoint) ? 0.05 : Number(value.checkpoint),
        duration = tween._duration,
        preventOvershoot = value.preventOvershoot,
        cnt = 0,
        p,
        curProp,
        curVal,
        isFunc,
        velocity,
        change1,
        end,
        change2,
        tracker,
        linkedProps,
        linkedPropNames,
        i;

    if (value.linkedProps) {
      //when there are linkedProps (typically "x,y" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we'll do later in the "real" loop.
      linkedPropNames = value.linkedProps.split(",");
      linkedProps = {};

      for (i = 0; i < linkedPropNames.length; i++) {
        p = linkedPropNames[i];
        curProp = value[p];

        if (curProp) {
          if (curProp.velocity !== undefined && typeof curProp.velocity === "number") {
            velocity = Number(curProp.velocity) || 0;
          } else {
            tracker = tracker || VelocityTracker.getByTarget(target);
            velocity = tracker && tracker.isTrackingProp(p) ? tracker.getVelocity(p) : 0;
          }

          curVal = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]() : target[p] || 0;
          linkedProps[p] = curVal + _calculateChange(velocity, ease, duration, checkpoint);
        }
      }
    }

    for (p in value) {
      if (p !== "resistance" && p !== "checkpoint" && p !== "preventOvershoot" && p !== "linkedProps" && p !== "radius") {
        curProp = value[p];

        if (typeof curProp === "function") {
          curProp = curProp(index, target);
        }

        if (typeof curProp === "number") {
          velocity = Number(curProp) || 0;
        } else if (typeof curProp === "object" && !isNaN(curProp.velocity)) {
          velocity = Number(curProp.velocity);
        } else {
          tracker = tracker || VelocityTracker.getByTarget(target);

          if (tracker && tracker.isTrackingProp(p)) {
            velocity = tracker.getVelocity(p);
          } else {
            throw "ERROR: No velocity was defined in the throwProps tween of " + target + " property: " + p;
          }
        }

        change1 = _calculateChange(velocity, ease, duration, checkpoint);
        change2 = 0;
        isFunc = typeof target[p] === "function";
        curVal = isFunc ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]() : target[p];

        if (typeof curProp === "object") {
          end = curVal + change1;

          if (curProp.end !== undefined) {
            curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, value.radius);

            if (_recordEndMode) {
              value[p] = _extend(curProp, value[p], "end");
            }
          }

          if (curProp.max !== undefined && Number(curProp.max) < end) {
            if (preventOvershoot || curProp.preventOvershoot) {
              change1 = curProp.max - curVal;
            } else {
              change2 = curProp.max - curVal - change1;
            }
          } else if (curProp.min !== undefined && Number(curProp.min) > end) {
            if (preventOvershoot || curProp.preventOvershoot) {
              change1 = curProp.min - curVal;
            } else {
              change2 = curProp.min - curVal - change1;
            }
          }
        }

        this._overwriteProps[cnt] = p;
        this._props[cnt++] = {
          p: p,
          s: curVal,
          c1: change1,
          c2: change2,
          f: isFunc,
          r: false
        };
      }
    }

    return true;
  };

  p._kill = function (lookup) {
    var i = this._props.length;

    while (--i > -1) {
      if (lookup[this._props[i].p] != null) {
        this._props.splice(i, 1);
      }
    }

    return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenPlugin"].prototype._kill.call(this, lookup);
  };

  p._mod = function (lookup) {
    var p = this._props,
        i = p.length,
        val;

    while (--i > -1) {
      val = lookup[p[i].p] || lookup.throwProps;

      if (typeof val === "function") {
        p[i].m = val;
      }
    }
  };

  p.setRatio = function (v) {
    var i = this._props.length,
        cp,
        val;

    while (--i > -1) {
      cp = this._props[i];
      val = cp.s + cp.c1 * v + cp.c2 * v * v;

      if (cp.m) {
        val = cp.m(val, this.target);
      } else if (v === 1) {
        val = (val * 10000 + (val < 0 ? -0.5 : 0.5) | 0) / 10000; //if we don't round things at the very end, binary math issues can creep in and cause snapping not to be exact (like landing on 20.000000000001 instead of 20).
      }

      if (cp.f) {
        this.target[cp.p](val);
      } else {
        this.target[cp.p] = val;
      }
    }
  };

  _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenPlugin"].activate([ThrowPropsPlugin]);
  return ThrowPropsPlugin;
}, true);
/*
 * ----------------------------------------------------------------
 * VelocityTracker
 * ----------------------------------------------------------------
 */


_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine("utils.VelocityTracker", ["TweenLite"], function () {
  var _first,
      _initted,
      _time1,
      _time2,
      _capsExp = /([A-Z])/g,
      _empty = {},
      _doc = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"].document,
      _transforms = {
    x: 1,
    y: 1,
    z: 2,
    scale: 1,
    scaleX: 1,
    scaleY: 1,
    rotation: 1,
    rotationZ: 1,
    rotationX: 2,
    rotationY: 2,
    skewX: 1,
    skewY: 1,
    xPercent: 1,
    yPercent: 1
  },
      _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function () {},
      _getStyle = function (t, p, cs) {
    var rv = (t._gsTransform || _empty)[p];

    if (rv || rv === 0) {
      return rv;
    } else if (t.style[p]) {
      rv = t.style[p];
    } else if (cs = cs || _getComputedStyle(t, null)) {
      rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
    } else if (t.currentStyle) {
      rv = t.currentStyle[p];
    }

    return parseFloat(rv) || 0;
  },
      _ticker = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"].ticker,
      VelocityProp = function (p, isFunc, next) {
    this.p = p;
    this.f = isFunc;
    this.v1 = this.v2 = 0;
    this.t1 = this.t2 = _ticker.time;
    this.css = false;
    this.type = "";
    this._prev = null;

    if (next) {
      this._next = next;
      next._prev = this;
    }
  },
      _update = function () {
    var vt = _first,
        t = _ticker.time,
        val,
        vp; //if the frame rate is too high, we won't be able to track the velocity as well, so only update the values about 33 times per second

    if (t - _time1 >= 0.03) {
      _time2 = _time1;
      _time1 = t;

      while (vt) {
        vp = vt._firstVP;

        while (vp) {
          val = vp.css ? _getStyle(vt.target, vp.p) : vp.f ? vt.target[vp.p]() : vt.target[vp.p];

          if (val !== vp.v1 || t - vp.t1 > 0.15) {
            //use a threshold of 0.15 seconds for zeroing-out velocity. If we only use 0.03 and things update slightly slower, like some Android devices dispatch "touchmove" events sluggishly so 2 or 3 ticks of the TweenLite.ticker may elapse inbetween, thus it may appear like the object is not moving but it actually is but it's not updating as frequently. A threshold of 0.15 seconds seems to be a good balance. We want to update things frequently (0.03 seconds) when they're moving so that we can respond to fast motions accurately, but we want to be more resistant to go back to a zero velocity.
            vp.v2 = vp.v1;
            vp.v1 = val;
            vp.t2 = vp.t1;
            vp.t1 = t;
          }

          vp = vp._next;
        }

        vt = vt._next;
      }
    }
  },
      VelocityTracker = function (target) {
    this._lookup = {};
    this.target = target;
    this.elem = target.style && target.nodeType ? true : false;

    if (!_initted) {
      _ticker.addEventListener("tick", _update, null, false, -100);

      _time1 = _time2 = _ticker.time;
      _initted = true;
    }

    if (_first) {
      this._next = _first;
      _first._prev = this;
    }

    _first = this;
  },
      getByTarget = VelocityTracker.getByTarget = function (target) {
    var vt = _first;

    while (vt) {
      if (vt.target === target) {
        return vt;
      }

      vt = vt._next;
    }
  },
      p = VelocityTracker.prototype;

  p.addProp = function (prop, type) {
    if (!this._lookup[prop]) {
      var t = this.target,
          isFunc = typeof t[prop] === "function",
          alt = isFunc ? this._altProp(prop) : prop,
          vp = this._firstVP;
      this._firstVP = this._lookup[prop] = this._lookup[alt] = vp = new VelocityProp(alt !== prop && prop.indexOf("set") === 0 ? alt : prop, isFunc, vp);
      vp.css = this.elem && (this.target.style[vp.p] !== undefined || _transforms[vp.p]);

      if (vp.css && _transforms[vp.p] && !t._gsTransform) {
        _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"].set(t, {
          x: "+=0",
          overwrite: false
        }); //just forces CSSPlugin to create a _gsTransform for the element if it doesn't exist
      }

      vp.type = type || vp.css && prop.indexOf("rotation") === 0 ? "deg" : "";
      vp.v1 = vp.v2 = vp.css ? _getStyle(t, vp.p) : isFunc ? t[vp.p]() : t[vp.p];
    }
  };

  p.removeProp = function (prop) {
    var vp = this._lookup[prop];

    if (vp) {
      if (vp._prev) {
        vp._prev._next = vp._next;
      } else if (vp === this._firstVP) {
        this._firstVP = vp._next;
      }

      if (vp._next) {
        vp._next._prev = vp._prev;
      }

      this._lookup[prop] = 0;

      if (vp.f) {
        this._lookup[this._altProp(prop)] = 0; //if it's a getter/setter, we should remove the matching counterpart (if one exists)
      }
    }
  };

  p.isTrackingProp = function (prop) {
    return this._lookup[prop] instanceof VelocityProp;
  };

  p.getVelocity = function (prop) {
    var vp = this._lookup[prop],
        target = this.target,
        val,
        dif,
        rotationCap;

    if (!vp) {
      throw "The velocity of " + prop + " is not being tracked.";
    }

    val = vp.css ? _getStyle(target, vp.p) : vp.f ? target[vp.p]() : target[vp.p];
    dif = val - vp.v2;

    if (vp.type === "rad" || vp.type === "deg") {
      //rotational values need special interpretation so that if, for example, they go from 179 to -178 degrees it is interpreted as a change of 3 instead of -357.
      rotationCap = vp.type === "rad" ? Math.PI * 2 : 360;
      dif = dif % rotationCap;

      if (dif !== dif % (rotationCap / 2)) {
        dif = dif < 0 ? dif + rotationCap : dif - rotationCap;
      }
    }

    return dif / (_ticker.time - vp.t2);
  };

  p._altProp = function (p) {
    //for getters/setters like getCustomProp() and setCustomProp() - we should accommodate both
    var pre = p.substr(0, 3),
        alt = (pre === "get" ? "set" : pre === "set" ? "get" : pre) + p.substr(3);
    return typeof this.target[alt] === "function" ? alt : p;
  };

  VelocityTracker.getByTarget = function (target) {
    var vt = _first;

    if (typeof target === "string") {
      target = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"].selector(target);
    }

    if (target.length && target !== window && target[0] && target[0].style && !target.nodeType) {
      target = target[0];
    }

    while (vt) {
      if (vt.target === target) {
        return vt;
      }

      vt = vt._next;
    }
  };

  VelocityTracker.track = function (target, props, types) {
    var vt = getByTarget(target),
        a = props.split(","),
        i = a.length;
    types = (types || "").split(",");

    if (!vt) {
      vt = new VelocityTracker(target);
    }

    while (--i > -1) {
      vt.addProp(a[i], types[i] || types[0]);
    }

    return vt;
  };

  VelocityTracker.untrack = function (target, props) {
    var vt = getByTarget(target),
        a = (props || "").split(","),
        i = a.length;

    if (!vt) {
      return;
    }

    while (--i > -1) {
      vt.removeProp(a[i]);
    }

    if (!vt._firstVP || !props) {
      if (vt._prev) {
        vt._prev._next = vt._next;
      } else if (vt === _first) {
        _first = vt._next;
      }

      if (vt._next) {
        vt._next._prev = vt._prev;
      }
    }
  };

  VelocityTracker.isTracking = function (target, prop) {
    var vt = getByTarget(target);
    return !vt ? false : !prop && vt._firstVP ? true : vt.isTrackingProp(prop);
  };

  return VelocityTracker;
}, true);

var ThrowPropsPlugin = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].ThrowPropsPlugin;

var VelocityTracker = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].com.greensock.utils.VelocityTracker;

/***/ }),

/***/ "./js/plugins/greensock/TimelineLite.js":
/*!**********************************************!*\
  !*** ./js/plugins/greensock/TimelineLite.js ***!
  \**********************************************/
/*! exports provided: TimelineLite, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return TimelineLite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TimelineLite; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */


_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function () {
  var TimelineLite = function (vars) {
    _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["SimpleTimeline"].call(this, vars);
    this._labels = {};
    this.autoRemoveChildren = this.vars.autoRemoveChildren === true;
    this.smoothChildTiming = this.vars.smoothChildTiming === true;
    this._sortChildren = true;
    this._onUpdate = this.vars.onUpdate;
    var v = this.vars,
        val,
        p;

    for (p in v) {
      val = v[p];
      if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
        v[p] = this._swapSelfInParams(val);
      }
    }

    if (_isArray(v.tweens)) {
      this.add(v.tweens, 0, v.align, v.stagger);
    }
  },
      _tinyNum = 0.0000000001,
      TweenLiteInternals = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]._internals,
      _internals = TimelineLite._internals = {},
      _isSelector = TweenLiteInternals.isSelector,
      _isArray = TweenLiteInternals.isArray,
      _lazyTweens = TweenLiteInternals.lazyTweens,
      _lazyRender = TweenLiteInternals.lazyRender,
      _globals = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.globals,
      _copy = function (vars) {
    var copy = {},
        p;

    for (p in vars) {
      copy[p] = vars[p];
    }

    return copy;
  },
      _applyCycle = function (vars, targets, i) {
    var alt = vars.cycle,
        p,
        val;

    for (p in alt) {
      val = alt[p];
      vars[p] = typeof val === "function" ? val(i, targets[i]) : val[i % val.length];
    }

    delete vars.cycle;
  },
      _pauseCallback = _internals.pauseCallback = function () {},
      _slice = function (a) {
    //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
    var b = [],
        l = a.length,
        i;

    for (i = 0; i !== l; b.push(a[i++]));

    return b;
  },
      p = TimelineLite.prototype = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["SimpleTimeline"]();

  TimelineLite.version = "2.0.2";
  p.constructor = TimelineLite;
  p.kill()._gc = p._forcingPlayhead = p._hasPause = false;
  /* might use later...
  //translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
  function localToGlobal(time, animation) {
  	while (animation) {
  		time = (time / animation._timeScale) + animation._startTime;
  		animation = animation.timeline;
  	}
  	return time;
  }
  		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
  function globalToLocal(time, animation) {
  	var scale = 1;
  	time -= localToGlobal(0, animation);
  	while (animation) {
  		scale *= animation._timeScale;
  		animation = animation.timeline;
  	}
  	return time * scale;
  }
  */

  p.to = function (target, duration, vars, position) {
    var Engine = vars.repeat && _globals.TweenMax || _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
  };

  p.from = function (target, duration, vars, position) {
    return this.add((vars.repeat && _globals.TweenMax || _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]).from(target, duration, vars), position);
  };

  p.fromTo = function (target, duration, fromVars, toVars, position) {
    var Engine = toVars.repeat && _globals.TweenMax || _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
  };

  p.staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
    var tl = new TimelineLite({
      onComplete: onCompleteAll,
      onCompleteParams: onCompleteAllParams,
      callbackScope: onCompleteAllScope,
      smoothChildTiming: this.smoothChildTiming
    }),
        cycle = vars.cycle,
        copy,
        i;

    if (typeof targets === "string") {
      targets = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].selector(targets) || targets;
    }

    targets = targets || [];

    if (_isSelector(targets)) {
      //senses if the targets object is a selector. If it is, we should translate it into an array.
      targets = _slice(targets);
    }

    stagger = stagger || 0;

    if (stagger < 0) {
      targets = _slice(targets);
      targets.reverse();
      stagger *= -1;
    }

    for (i = 0; i < targets.length; i++) {
      copy = _copy(vars);

      if (copy.startAt) {
        copy.startAt = _copy(copy.startAt);

        if (copy.startAt.cycle) {
          _applyCycle(copy.startAt, targets, i);
        }
      }

      if (cycle) {
        _applyCycle(copy, targets, i);

        if (copy.duration != null) {
          duration = copy.duration;
          delete copy.duration;
        }
      }

      tl.to(targets[i], duration, copy, i * stagger);
    }

    return this.add(tl, position);
  };

  p.staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
    vars.immediateRender = vars.immediateRender != false;
    vars.runBackwards = true;
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
  };

  p.staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
    toVars.startAt = fromVars;
    toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
  };

  p.call = function (callback, params, scope, position) {
    return this.add(_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].delayedCall(0, callback, params, scope), position);
  };

  p.set = function (target, vars, position) {
    position = this._parseTimeOrLabel(position, 0, true);

    if (vars.immediateRender == null) {
      vars.immediateRender = position === this._time && !this._paused;
    }

    return this.add(new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"](target, 0, vars), position);
  };

  TimelineLite.exportRoot = function (vars, ignoreDelayedCalls) {
    vars = vars || {};

    if (vars.smoothChildTiming == null) {
      vars.smoothChildTiming = true;
    }

    var tl = new TimelineLite(vars),
        root = tl._timeline,
        hasNegativeStart,
        time,
        tween,
        next;

    if (ignoreDelayedCalls == null) {
      ignoreDelayedCalls = true;
    }

    root._remove(tl, true);

    tl._startTime = 0;
    tl._rawPrevTime = tl._time = tl._totalTime = root._time;
    tween = root._first;

    while (tween) {
      next = tween._next;

      if (!ignoreDelayedCalls || !(tween instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"] && tween.target === tween.vars.onComplete)) {
        time = tween._startTime - tween._delay;

        if (time < 0) {
          hasNegativeStart = 1;
        }

        tl.add(tween, time);
      }

      tween = next;
    }

    root.add(tl, 0);

    if (hasNegativeStart) {
      //calling totalDuration() will force the adjustment necessary to shift the children forward so none of them start before zero, and moves the timeline backwards the same amount, so the playhead is still aligned where it should be globally, but the timeline doesn't have illegal children that start before zero.
      tl.totalDuration();
    }

    return tl;
  };

  p.add = function (value, position, align, stagger) {
    var curTime, l, i, child, tl, beforeRawTime;

    if (typeof position !== "number") {
      position = this._parseTimeOrLabel(position, 0, true, value);
    }

    if (!(value instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"])) {
      if (value instanceof Array || value && value.push && _isArray(value)) {
        align = align || "normal";
        stagger = stagger || 0;
        curTime = position;
        l = value.length;

        for (i = 0; i < l; i++) {
          if (_isArray(child = value[i])) {
            child = new TimelineLite({
              tweens: child
            });
          }

          this.add(child, curTime);

          if (typeof child !== "string" && typeof child !== "function") {
            if (align === "sequence") {
              curTime = child._startTime + child.totalDuration() / child._timeScale;
            } else if (align === "start") {
              child._startTime -= child.delay();
            }
          }

          curTime += stagger;
        }

        return this._uncache(true);
      } else if (typeof value === "string") {
        return this.addLabel(value, position);
      } else if (typeof value === "function") {
        value = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].delayedCall(0, value);
      } else {
        throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
      }
    }

    _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["SimpleTimeline"].prototype.add.call(this, value, position);

    if (value._time) {
      //in case, for example, the _startTime is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
      curTime = Math.max(0, Math.min(value.totalDuration(), (this.rawTime() - value._startTime) * value._timeScale));

      if (Math.abs(curTime - value._totalTime) > 0.00001) {
        //if an onComplete restarts the tween in a nested timeline, for example, there could be an endless loop without this logic (v2.0.2), like var masterTL = new TimelineMax({autoRemoveChildren: true}), tl = new TimelineMax(); tl.eventCallback("onComplete", function() { tl.restart() } );tl.fromTo('div', 1.1, { rotation: 0 }, { rotation: 360 }, 0);masterTL.add(tl);
        value.render(curTime, false, false);
      }
    } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


    if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
      //in case any of the ancestors had completed but should now be enabled...
      tl = this;
      beforeRawTime = tl.rawTime() > value._startTime; //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.

      while (tl._timeline) {
        if (beforeRawTime && tl._timeline.smoothChildTiming) {
          tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
        } else if (tl._gc) {
          tl._enabled(true, false);
        }

        tl = tl._timeline;
      }
    }
    return this;
  };

  p.remove = function (value) {
    if (value instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"]) {
      this._remove(value, false);

      var tl = value._timeline = value.vars.useFrames ? _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"]._rootFramesTimeline : _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"]._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.

      value._startTime = (value._paused ? value._pauseTime : tl._time) - (!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale; //ensure that if it gets played again, the timing is correct.

      return this;
    } else if (value instanceof Array || value && value.push && _isArray(value)) {
      var i = value.length;

      while (--i > -1) {
        this.remove(value[i]);
      }

      return this;
    } else if (typeof value === "string") {
      return this.removeLabel(value);
    }

    return this.kill(null, value);
  };

  p._remove = function (tween, skipDisable) {
    _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["SimpleTimeline"].prototype._remove.call(this, tween, skipDisable);

    var last = this._last;

    if (!last) {
      this._time = this._totalTime = this._duration = this._totalDuration = 0;
    } else if (this._time > this.duration()) {
      this._time = this._duration;
      this._totalTime = this._totalDuration;
    }

    return this;
  };

  p.append = function (value, offsetOrLabel) {
    return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
  };

  p.insert = p.insertMultiple = function (value, position, align, stagger) {
    return this.add(value, position || 0, align, stagger);
  };

  p.appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
    return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
  };

  p.addLabel = function (label, position) {
    this._labels[label] = this._parseTimeOrLabel(position);
    return this;
  };

  p.addPause = function (position, callback, params, scope) {
    var t = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].delayedCall(0, _pauseCallback, params, scope || this);
    t.vars.onComplete = t.vars.onReverseComplete = callback;
    t.data = "isPause";
    this._hasPause = true;
    return this.add(t, position);
  };

  p.removeLabel = function (label) {
    delete this._labels[label];
    return this;
  };

  p.getLabelTime = function (label) {
    return this._labels[label] != null ? this._labels[label] : -1;
  };

  p._parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
    var clippedDuration, i; //if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().

    if (ignore instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"] && ignore.timeline === this) {
      this.remove(ignore);
    } else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
      i = ignore.length;

      while (--i > -1) {
        if (ignore[i] instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"] && ignore[i].timeline === this) {
          this.remove(ignore[i]);
        }
      }
    }

    clippedDuration = typeof timeOrLabel === "number" && !offsetOrLabel ? 0 : this.duration() > 99999999999 ? this.recent().endTime(false) : this._duration; //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.

    if (typeof offsetOrLabel === "string") {
      return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - clippedDuration : 0, appendIfAbsent);
    }

    offsetOrLabel = offsetOrLabel || 0;

    if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
      //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
      i = timeOrLabel.indexOf("=");

      if (i === -1) {
        if (this._labels[timeOrLabel] == null) {
          return appendIfAbsent ? this._labels[timeOrLabel] = clippedDuration + offsetOrLabel : offsetOrLabel;
        }

        return this._labels[timeOrLabel] + offsetOrLabel;
      }

      offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
      timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : clippedDuration;
    } else if (timeOrLabel == null) {
      timeOrLabel = clippedDuration;
    }

    return Number(timeOrLabel) + offsetOrLabel;
  };

  p.seek = function (position, suppressEvents) {
    return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false);
  };

  p.stop = function () {
    return this.paused(true);
  };

  p.gotoAndPlay = function (position, suppressEvents) {
    return this.play(position, suppressEvents);
  };

  p.gotoAndStop = function (position, suppressEvents) {
    return this.pause(position, suppressEvents);
  };

  p.render = function (time, suppressEvents, force) {
    if (this._gc) {
      this._enabled(true, false);
    }

    var prevTime = this._time,
        totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
        prevStart = this._startTime,
        prevTimeScale = this._timeScale,
        prevPaused = this._paused,
        tween,
        isComplete,
        next,
        callback,
        internalForce,
        pauseTween,
        curTime;

    if (prevTime !== this._time) {
      //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
      time += this._time - prevTime;
    }

    if (time >= totalDur - 0.0000001 && time >= 0) {
      //to work around occasional floating point math artifacts.
      this._totalTime = this._time = totalDur;
      if (!this._reversed) if (!this._hasPausedChild()) {
        isComplete = true;
        callback = "onComplete";
        internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.

        if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
          internalForce = true;

          if (this._rawPrevTime > _tinyNum) {
            callback = "onReverseComplete";
          }
        }
      }
      this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.

      time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.
    } else if (time < 0.0000001) {
      //to work around occasional floating point math artifacts, round super small values to 0.
      this._totalTime = this._time = 0;

      if (prevTime !== 0 || this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) {
        callback = "onReverseComplete";
        isComplete = this._reversed;
      }

      if (time < 0) {
        this._active = false;

        if (this._timeline.autoRemoveChildren && this._reversed) {
          //ensures proper GC if a timeline is resumed after it's finished reversing.
          internalForce = isComplete = true;
          callback = "onReverseComplete";
        } else if (this._rawPrevTime >= 0 && this._first) {
          //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
          internalForce = true;
        }

        this._rawPrevTime = time;
      } else {
        this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.

        if (time === 0 && isComplete) {
          //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
          tween = this._first;

          while (tween && tween._startTime === 0) {
            if (!tween._duration) {
              isComplete = false;
            }

            tween = tween._next;
          }
        }

        time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)

        if (!this._initted) {
          internalForce = true;
        }
      }
    } else {
      if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
        if (time >= prevTime) {
          tween = this._first;

          while (tween && tween._startTime <= time && !pauseTween) {
            if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
              pauseTween = tween;
            }
            tween = tween._next;
          }
        } else {
          tween = this._last;

          while (tween && tween._startTime >= time && !pauseTween) {
            if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
              pauseTween = tween;
            }
            tween = tween._prev;
          }
        }

        if (pauseTween) {
          this._time = time = pauseTween._startTime;
          this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
        }
      }

      this._totalTime = this._time = this._rawPrevTime = time;
    }

    if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
      return;
    } else if (!this._initted) {
      this._initted = true;
    }

    if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
      this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
    }
    if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0 || !this._duration) if (!suppressEvents) {
      this._callback("onStart");
    }
    curTime = this._time;

    if (curTime >= prevTime) {
      tween = this._first;

      while (tween) {
        next = tween._next; //record it here because the value could change after rendering...

        if (curTime !== this._time || this._paused && !prevPaused) {
          //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
          break;
        } else if (tween._active || tween._startTime <= curTime && !tween._paused && !tween._gc) {
          if (pauseTween === tween) {
            this.pause();
          }

          if (!tween._reversed) {
            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
          } else {
            tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
          }
        }

        tween = next;
      }
    } else {
      tween = this._last;

      while (tween) {
        next = tween._prev; //record it here because the value could change after rendering...

        if (curTime !== this._time || this._paused && !prevPaused) {
          //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
          break;
        } else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
          if (pauseTween === tween) {
            pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.

            while (pauseTween && pauseTween.endTime() > this._time) {
              pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
              pauseTween = pauseTween._prev;
            }

            pauseTween = null;
            this.pause();
          }

          if (!tween._reversed) {
            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
          } else {
            tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
          }
        }

        tween = next;
      }
    }

    if (this._onUpdate) if (!suppressEvents) {
      if (_lazyTweens.length) {
        //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
        _lazyRender();
      }

      this._callback("onUpdate");
    }
    if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
      //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
      if (isComplete) {
        if (_lazyTweens.length) {
          //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
          _lazyRender();
        }

        if (this._timeline.autoRemoveChildren) {
          this._enabled(false, false);
        }

        this._active = false;
      }

      if (!suppressEvents && this.vars[callback]) {
        this._callback(callback);
      }
    }
  };

  p._hasPausedChild = function () {
    var tween = this._first;

    while (tween) {
      if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
        return true;
      }

      tween = tween._next;
    }

    return false;
  };

  p.getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
    ignoreBeforeTime = ignoreBeforeTime || -9999999999;
    var a = [],
        tween = this._first,
        cnt = 0;

    while (tween) {
      if (tween._startTime < ignoreBeforeTime) {//do nothing
      } else if (tween instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
        if (tweens !== false) {
          a[cnt++] = tween;
        }
      } else {
        if (timelines !== false) {
          a[cnt++] = tween;
        }

        if (nested !== false) {
          a = a.concat(tween.getChildren(true, tweens, timelines));
          cnt = a.length;
        }
      }

      tween = tween._next;
    }

    return a;
  };

  p.getTweensOf = function (target, nested) {
    var disabled = this._gc,
        a = [],
        cnt = 0,
        tweens,
        i;

    if (disabled) {
      this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.

    }

    tweens = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].getTweensOf(target);
    i = tweens.length;

    while (--i > -1) {
      if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
        a[cnt++] = tweens[i];
      }
    }

    if (disabled) {
      this._enabled(false, true);
    }

    return a;
  };

  p.recent = function () {
    return this._recent;
  };

  p._contains = function (tween) {
    var tl = tween.timeline;

    while (tl) {
      if (tl === this) {
        return true;
      }

      tl = tl.timeline;
    }

    return false;
  };

  p.shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
    ignoreBeforeTime = ignoreBeforeTime || 0;
    var tween = this._first,
        labels = this._labels,
        p;

    while (tween) {
      if (tween._startTime >= ignoreBeforeTime) {
        tween._startTime += amount;
      }

      tween = tween._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return this._uncache(true);
  };

  p._kill = function (vars, target) {
    if (!vars && !target) {
      return this._enabled(false, false);
    }

    var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target),
        i = tweens.length,
        changed = false;

    while (--i > -1) {
      if (tweens[i]._kill(vars, target)) {
        changed = true;
      }
    }

    return changed;
  };

  p.clear = function (labels) {
    var tweens = this.getChildren(false, true, true),
        i = tweens.length;
    this._time = this._totalTime = 0;

    while (--i > -1) {
      tweens[i]._enabled(false, false);
    }

    if (labels !== false) {
      this._labels = {};
    }

    return this._uncache(true);
  };

  p.invalidate = function () {
    var tween = this._first;

    while (tween) {
      tween.invalidate();
      tween = tween._next;
    }

    return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"].prototype.invalidate.call(this);
    ;
  };

  p._enabled = function (enabled, ignoreTimeline) {
    if (enabled === this._gc) {
      var tween = this._first;

      while (tween) {
        tween._enabled(enabled, true);

        tween = tween._next;
      }
    }

    return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["SimpleTimeline"].prototype._enabled.call(this, enabled, ignoreTimeline);
  };

  p.totalTime = function (time, suppressEvents, uncapped) {
    this._forcingPlayhead = true;
    var val = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"].prototype.totalTime.apply(this, arguments);
    this._forcingPlayhead = false;
    return val;
  };

  p.duration = function (value) {
    if (!arguments.length) {
      if (this._dirty) {
        this.totalDuration(); //just triggers recalculation
      }

      return this._duration;
    }

    if (this.duration() !== 0 && value !== 0) {
      this.timeScale(this._duration / value);
    }

    return this;
  };

  p.totalDuration = function (value) {
    if (!arguments.length) {
      if (this._dirty) {
        var max = 0,
            tween = this._last,
            prevStart = 999999999999,
            prev,
            end;

        while (tween) {
          prev = tween._prev; //record it here in case the tween changes position in the sequence...

          if (tween._dirty) {
            tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
          }

          if (tween._startTime > prevStart && this._sortChildren && !tween._paused && !this._calculatingDuration) {
            //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
            this._calculatingDuration = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add(), like _parseTimeOrLabel().

            this.add(tween, tween._startTime - tween._delay);
            this._calculatingDuration = 0;
          } else {
            prevStart = tween._startTime;
          }

          if (tween._startTime < 0 && !tween._paused) {
            //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
            max -= tween._startTime;

            if (this._timeline.smoothChildTiming) {
              this._startTime += tween._startTime / this._timeScale;
              this._time -= tween._startTime;
              this._totalTime -= tween._startTime;
              this._rawPrevTime -= tween._startTime;
            }

            this.shiftChildren(-tween._startTime, false, -9999999999);
            prevStart = 0;
          }

          end = tween._startTime + tween._totalDuration / tween._timeScale;

          if (end > max) {
            max = end;
          }

          tween = prev;
        }

        this._duration = this._totalDuration = max;
        this._dirty = false;
      }

      return this._totalDuration;
    }

    return value && this.totalDuration() ? this.timeScale(this._totalDuration / value) : this;
  };

  p.paused = function (value) {
    if (!value) {
      //if there's a pause directly at the spot from where we're unpausing, skip it.
      var tween = this._first,
          time = this._time;

      while (tween) {
        if (tween._startTime === time && tween.data === "isPause") {
          tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
        }

        tween = tween._next;
      }
    }

    return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"].prototype.paused.apply(this, arguments);
  };

  p.usesFrames = function () {
    var tl = this._timeline;

    while (tl._timeline) {
      tl = tl._timeline;
    }

    return tl === _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"]._rootFramesTimeline;
  };

  p.rawTime = function (wrapRepeats) {
    return wrapRepeats && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
  };

  return TimelineLite;
}, true);

var TimelineLite = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].TimelineLite;


/***/ }),

/***/ "./js/plugins/greensock/TimelineMax.js":
/*!*********************************************!*\
  !*** ./js/plugins/greensock/TimelineMax.js ***!
  \*********************************************/
/*! exports provided: TimelineMax, TimelineLite, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return TimelineMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TimelineMax; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/* harmony import */ var _TimelineLite_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TimelineLite.js */ "./js/plugins/greensock/TimelineLite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return _TimelineLite_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */



_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function () {
  var TimelineMax = function (vars) {
    _TimelineLite_js__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, vars);
    this._repeat = this.vars.repeat || 0;
    this._repeatDelay = this.vars.repeatDelay || 0;
    this._cycle = 0;
    this._yoyo = this.vars.yoyo === true;
    this._dirty = true;
  },
      _tinyNum = 0.0000000001,
      TweenLiteInternals = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]._internals,
      _lazyTweens = TweenLiteInternals.lazyTweens,
      _lazyRender = TweenLiteInternals.lazyRender,
      _globals = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine.globals,
      _easeNone = new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"](null, null, 1, 0),
      p = TimelineMax.prototype = new _TimelineLite_js__WEBPACK_IMPORTED_MODULE_1__["default"]();

  p.constructor = TimelineMax;
  p.kill()._gc = false;
  TimelineMax.version = "2.0.2";

  p.invalidate = function () {
    this._yoyo = this.vars.yoyo === true;
    this._repeat = this.vars.repeat || 0;
    this._repeatDelay = this.vars.repeatDelay || 0;

    this._uncache(true);

    return _TimelineLite_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.invalidate.call(this);
  };

  p.addCallback = function (callback, position, params, scope) {
    return this.add(_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].delayedCall(0, callback, params, scope), position);
  };

  p.removeCallback = function (callback, position) {
    if (callback) {
      if (position == null) {
        this._kill(null, callback);
      } else {
        var a = this.getTweensOf(callback, false),
            i = a.length,
            time = this._parseTimeOrLabel(position);

        while (--i > -1) {
          if (a[i]._startTime === time) {
            a[i]._enabled(false, false);
          }
        }
      }
    }

    return this;
  };

  p.removePause = function (position) {
    return this.removeCallback(_TimelineLite_js__WEBPACK_IMPORTED_MODULE_1__["default"]._internals.pauseCallback, position);
  };

  p.tweenTo = function (position, vars) {
    vars = vars || {};
    var copy = {
      ease: _easeNone,
      useFrames: this.usesFrames(),
      immediateRender: false,
      lazy: false
    },
        Engine = vars.repeat && _globals.TweenMax || _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"],
        duration,
        p,
        t;

    for (p in vars) {
      copy[p] = vars[p];
    }

    copy.time = this._parseTimeOrLabel(position);
    duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || 0.001;
    t = new Engine(this, duration, copy);

    copy.onStart = function () {
      t.target.paused(true);

      if (t.vars.time !== t.target.time() && duration === t.duration() && !t.isFromTo) {
        //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
        t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale).render(t.time(), true, true); //render() right away to ensure that things look right, especially in the case of .tweenTo(0).
      }

      if (vars.onStart) {
        //in case the user had an onStart in the vars - we don't want to overwrite it.
        vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || []); //don't use t._callback("onStart") or it'll point to the copy.onStart and we'll get a recursion error.
      }
    };

    return t;
  };

  p.tweenFromTo = function (fromPosition, toPosition, vars) {
    vars = vars || {};
    fromPosition = this._parseTimeOrLabel(fromPosition);
    vars.startAt = {
      onComplete: this.seek,
      onCompleteParams: [fromPosition],
      callbackScope: this
    };
    vars.immediateRender = vars.immediateRender !== false;
    var t = this.tweenTo(toPosition, vars);
    t.isFromTo = 1; //to ensure we don't mess with the duration in the onStart (we've got the start and end values here, so lock it in)

    return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || 0.001);
  };

  p.render = function (time, suppressEvents, force) {
    if (this._gc) {
      this._enabled(true, false);
    }

    var prevTime = this._time,
        totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
        dur = this._duration,
        prevTotalTime = this._totalTime,
        prevStart = this._startTime,
        prevTimeScale = this._timeScale,
        prevRawPrevTime = this._rawPrevTime,
        prevPaused = this._paused,
        prevCycle = this._cycle,
        tween,
        isComplete,
        next,
        callback,
        internalForce,
        cycleDuration,
        pauseTween,
        curTime;

    if (prevTime !== this._time) {
      //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
      time += this._time - prevTime;
    }

    if (time >= totalDur - 0.0000001 && time >= 0) {
      //to work around occasional floating point math artifacts.
      if (!this._locked) {
        this._totalTime = totalDur;
        this._cycle = this._repeat;
      }

      if (!this._reversed) if (!this._hasPausedChild()) {
        isComplete = true;
        callback = "onComplete";
        internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.

        if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
          internalForce = true;

          if (prevRawPrevTime > _tinyNum) {
            callback = "onReverseComplete";
          }
        }
      }
      this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.

      if (this._yoyo && (this._cycle & 1) !== 0) {
        this._time = time = 0;
      } else {
        this._time = dur;
        time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
      }
    } else if (time < 0.0000001) {
      //to work around occasional floating point math artifacts, round super small values to 0.
      if (!this._locked) {
        this._totalTime = this._cycle = 0;
      }

      this._time = 0;

      if (prevTime !== 0 || dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
        //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
        callback = "onReverseComplete";
        isComplete = this._reversed;
      }

      if (time < 0) {
        this._active = false;

        if (this._timeline.autoRemoveChildren && this._reversed) {
          internalForce = isComplete = true;
          callback = "onReverseComplete";
        } else if (prevRawPrevTime >= 0 && this._first) {
          //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
          internalForce = true;
        }

        this._rawPrevTime = time;
      } else {
        this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.

        if (time === 0 && isComplete) {
          //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
          tween = this._first;

          while (tween && tween._startTime === 0) {
            if (!tween._duration) {
              isComplete = false;
            }

            tween = tween._next;
          }
        }

        time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)

        if (!this._initted) {
          internalForce = true;
        }
      }
    } else {
      if (dur === 0 && prevRawPrevTime < 0) {
        //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
        internalForce = true;
      }

      this._time = this._rawPrevTime = time;

      if (!this._locked) {
        this._totalTime = time;

        if (this._repeat !== 0) {
          cycleDuration = dur + this._repeatDelay;
          this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)

          if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
            this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
          }
          this._time = this._totalTime - this._cycle * cycleDuration;
          if (this._yoyo) if ((this._cycle & 1) !== 0) {
            this._time = dur - this._time;
          }

          if (this._time > dur) {
            this._time = dur;
            time = dur + 0.0001; //to avoid occasional floating point rounding error
          } else if (this._time < 0) {
            this._time = time = 0;
          } else {
            time = this._time;
          }
        }
      }

      if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
        time = this._time;

        if (time >= prevTime || this._repeat && prevCycle !== this._cycle) {
          tween = this._first;

          while (tween && tween._startTime <= time && !pauseTween) {
            if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
              pauseTween = tween;
            }
            tween = tween._next;
          }
        } else {
          tween = this._last;

          while (tween && tween._startTime >= time && !pauseTween) {
            if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
              pauseTween = tween;
            }
            tween = tween._prev;
          }
        }

        if (pauseTween && pauseTween._startTime < dur) {
          this._time = time = pauseTween._startTime;
          this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
        }
      }
    }

    if (this._cycle !== prevCycle) if (!this._locked) {
      /*
      make sure children at the end/beginning of the timeline are rendered properly. If, for example, 
      a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
      would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
      could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So 
      we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
      ensure that zero-duration tweens at the very beginning or end of the TimelineMax work. 
      */
      var backwards = this._yoyo && (prevCycle & 1) !== 0,
          wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0),
          recTotalTime = this._totalTime,
          recCycle = this._cycle,
          recRawPrevTime = this._rawPrevTime,
          recTime = this._time;
      this._totalTime = prevCycle * dur;

      if (this._cycle < prevCycle) {
        backwards = !backwards;
      } else {
        this._totalTime += dur;
      }

      this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

      this._rawPrevTime = dur === 0 ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
      this._cycle = prevCycle;
      this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()

      prevTime = backwards ? 0 : dur;
      this.render(prevTime, suppressEvents, dur === 0);
      if (!suppressEvents) if (!this._gc) {
        if (this.vars.onRepeat) {
          this._cycle = recCycle; //in case the onRepeat alters the playhead or invalidates(), we shouldn't stay locked or use the previous cycle.

          this._locked = false;

          this._callback("onRepeat");
        }
      }

      if (prevTime !== this._time) {
        //in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
        return;
      }

      if (wrap) {
        this._cycle = prevCycle; //if there's an onRepeat, we reverted this above, so make sure it's set properly again. We also unlocked in that scenario, so reset that too.

        this._locked = true;
        prevTime = backwards ? dur + 0.0001 : -0.0001;
        this.render(prevTime, true, false);
      }

      this._locked = false;

      if (this._paused && !prevPaused) {
        //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
        return;
      }

      this._time = recTime;
      this._totalTime = recTotalTime;
      this._cycle = recCycle;
      this._rawPrevTime = recRawPrevTime;
    }

    if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
      if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
        //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
        this._callback("onUpdate");
      }
      return;
    } else if (!this._initted) {
      this._initted = true;
    }

    if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
      this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
    }
    if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0 || !this._totalDuration) if (!suppressEvents) {
      this._callback("onStart");
    }
    curTime = this._time;

    if (curTime >= prevTime) {
      tween = this._first;

      while (tween) {
        next = tween._next; //record it here because the value could change after rendering...

        if (curTime !== this._time || this._paused && !prevPaused) {
          //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
          break;
        } else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
          if (pauseTween === tween) {
            this.pause();
          }

          if (!tween._reversed) {
            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
          } else {
            tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
          }
        }

        tween = next;
      }
    } else {
      tween = this._last;

      while (tween) {
        next = tween._prev; //record it here because the value could change after rendering...

        if (curTime !== this._time || this._paused && !prevPaused) {
          //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
          break;
        } else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
          if (pauseTween === tween) {
            pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.

            while (pauseTween && pauseTween.endTime() > this._time) {
              pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
              pauseTween = pauseTween._prev;
            }

            pauseTween = null;
            this.pause();
          }

          if (!tween._reversed) {
            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
          } else {
            tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
          }
        }

        tween = next;
      }
    }

    if (this._onUpdate) if (!suppressEvents) {
      if (_lazyTweens.length) {
        //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
        _lazyRender();
      }

      this._callback("onUpdate");
    }
    if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
      //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
      if (isComplete) {
        if (_lazyTweens.length) {
          //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
          _lazyRender();
        }

        if (this._timeline.autoRemoveChildren) {
          this._enabled(false, false);
        }

        this._active = false;
      }

      if (!suppressEvents && this.vars[callback]) {
        this._callback(callback);
      }
    }
  };

  p.getActive = function (nested, tweens, timelines) {
    if (nested == null) {
      nested = true;
    }

    if (tweens == null) {
      tweens = true;
    }

    if (timelines == null) {
      timelines = false;
    }

    var a = [],
        all = this.getChildren(nested, tweens, timelines),
        cnt = 0,
        l = all.length,
        i,
        tween;

    for (i = 0; i < l; i++) {
      tween = all[i];

      if (tween.isActive()) {
        a[cnt++] = tween;
      }
    }

    return a;
  };

  p.getLabelAfter = function (time) {
    if (!time) if (time !== 0) {
      //faster than isNan()
      time = this._time;
    }
    var labels = this.getLabelsArray(),
        l = labels.length,
        i;

    for (i = 0; i < l; i++) {
      if (labels[i].time > time) {
        return labels[i].name;
      }
    }

    return null;
  };

  p.getLabelBefore = function (time) {
    if (time == null) {
      time = this._time;
    }

    var labels = this.getLabelsArray(),
        i = labels.length;

    while (--i > -1) {
      if (labels[i].time < time) {
        return labels[i].name;
      }
    }

    return null;
  };

  p.getLabelsArray = function () {
    var a = [],
        cnt = 0,
        p;

    for (p in this._labels) {
      a[cnt++] = {
        time: this._labels[p],
        name: p
      };
    }

    a.sort(function (a, b) {
      return a.time - b.time;
    });
    return a;
  };

  p.invalidate = function () {
    this._locked = false; //unlock and set cycle in case invalidate() is called from inside an onRepeat

    return _TimelineLite_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.invalidate.call(this);
  }; //---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------


  p.progress = function (value, suppressEvents) {
    return !arguments.length ? this._time / this.duration() || 0 : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
  };

  p.totalProgress = function (value, suppressEvents) {
    return !arguments.length ? this._totalTime / this.totalDuration() || 0 : this.totalTime(this.totalDuration() * value, suppressEvents);
  };

  p.totalDuration = function (value) {
    if (!arguments.length) {
      if (this._dirty) {
        _TimelineLite_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.totalDuration.call(this); //just forces refresh
        //Instead of Infinity, we use 999999999999 so that we can accommodate reverses.

        this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
      }

      return this._totalDuration;
    }

    return this._repeat === -1 || !value ? this : this.timeScale(this.totalDuration() / value);
  };

  p.time = function (value, suppressEvents) {
    if (!arguments.length) {
      return this._time;
    }

    if (this._dirty) {
      this.totalDuration();
    }

    if (value > this._duration) {
      value = this._duration;
    }

    if (this._yoyo && (this._cycle & 1) !== 0) {
      value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
    } else if (this._repeat !== 0) {
      value += this._cycle * (this._duration + this._repeatDelay);
    }

    return this.totalTime(value, suppressEvents);
  };

  p.repeat = function (value) {
    if (!arguments.length) {
      return this._repeat;
    }

    this._repeat = value;
    return this._uncache(true);
  };

  p.repeatDelay = function (value) {
    if (!arguments.length) {
      return this._repeatDelay;
    }

    this._repeatDelay = value;
    return this._uncache(true);
  };

  p.yoyo = function (value) {
    if (!arguments.length) {
      return this._yoyo;
    }

    this._yoyo = value;
    return this;
  };

  p.currentLabel = function (value) {
    if (!arguments.length) {
      return this.getLabelBefore(this._time + 0.00000001);
    }

    return this.seek(value, true);
  };

  return TimelineMax;
}, true);

var TimelineMax = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].TimelineMax;


/***/ }),

/***/ "./js/plugins/greensock/TweenLite.js":
/*!*******************************************!*\
  !*** ./js/plugins/greensock/TweenLite.js ***!
  \*******************************************/
/*! exports provided: _gsScope, TweenLite, globals, default, SimpleTimeline, Animation, Ease, Linear, Power0, Power1, Power2, Power3, Power4, TweenPlugin, EventDispatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_gsScope", function() { return _gsScope; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return TweenLite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globals", function() { return globals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TweenLite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleTimeline", function() { return SimpleTimeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ease", function() { return Ease; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return Linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return Power0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return Power1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return Power2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return Power3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return Power4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenPlugin", function() { return TweenPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */

/* ES6 changes:
	- declare and export _gsScope at top.
	- set var TweenLite = the result of the main function
	- export default TweenLite at the bottom
	- return TweenLite at the bottom of the main function
	- pass in _gsScope as the first parameter of the main function (which is actually at the bottom)
	- remove the "export to multiple environments" in Definition().
 */
var _gsScope = typeof window !== "undefined" ? window :  true && module.exports && typeof global !== "undefined" ? global : undefined || {};
var TweenLite = function (window, moduleName) {
  "use strict";

  var _exports = {},
      _doc = window.document,
      _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;

  if (_globals.TweenLite) {
    return _globals.TweenLite; //in case the core set of classes is already loaded, don't instantiate twice.
  }

  var _namespace = function (ns) {
    var a = ns.split("."),
        p = _globals,
        i;

    for (i = 0; i < a.length; i++) {
      p[a[i]] = p = p[a[i]] || {};
    }

    return p;
  },
      gs = _namespace("com.greensock"),
      _tinyNum = 0.0000000001,
      _slice = function (a) {
    //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
    var b = [],
        l = a.length,
        i;

    for (i = 0; i !== l; b.push(a[i++])) {}

    return b;
  },
      _emptyFunc = function () {},
      _isArray = function () {
    //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
    var toString = Object.prototype.toString,
        array = toString.call([]);
    return function (obj) {
      return obj != null && (obj instanceof Array || typeof obj === "object" && !!obj.push && toString.call(obj) === array);
    };
  }(),
      a,
      i,
      p,
      _ticker,
      _tickerActive,
      _defLookup = {},

  /**
   * @constructor
   * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
   * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
   * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
   * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
   *
   * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
   * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
   * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
   * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
   * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
   * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
   * sandbox the banner one like:
   *
   * <script>
   *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
   * </script>
   * <script src="js/greensock/v1.7/TweenMax.js"></script>
   * <script>
   *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
   * </script>
   * <script src="js/greensock/v1.6/TweenMax.js"></script>
   * <script>
   *     gs.TweenLite.to(...); //would use v1.7
   *     TweenLite.to(...); //would use v1.6
   * </script>
   *
   * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
   * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
   * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
   * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
   */
  Definition = function (ns, dependencies, func, global) {
    this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses

    _defLookup[ns] = this;
    this.gsClass = null;
    this.func = func;
    var _classes = [];

    this.check = function (init) {
      var i = dependencies.length,
          missing = i,
          cur,
          a,
          n,
          cl;

      while (--i > -1) {
        if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
          _classes[i] = cur.gsClass;
          missing--;
        } else if (init) {
          cur.sc.push(this);
        }
      }

      if (missing === 0 && func) {
        a = ("com.greensock." + ns).split(".");
        n = a.pop();
        cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes); //exports to multiple environments

        if (global) {
          _globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)

          /*
          if (typeof(module) !== "undefined" && module.exports) { //node
          	if (ns === moduleName) {
          		module.exports = _exports[moduleName] = cl;
          		for (i in _exports) {
          			cl[i] = _exports[i];
          		}
          	} else if (_exports[moduleName]) {
          		_exports[moduleName][n] = cl;
          	}
          } else if (typeof(define) === "function" && define.amd){ //AMD
          	define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
          }
          */
        }

        for (i = 0; i < this.sc.length; i++) {
          this.sc[i].check();
        }
      }
    };

    this.check(true);
  },
      //used to create Definition instances (which basically registers a class that has dependencies).
  _gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
    return new Definition(ns, dependencies, func, global);
  },
      //a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
  _class = gs._class = function (ns, func, global) {
    func = func || function () {};

    _gsDefine(ns, [], function () {
      return func;
    }, global);

    return func;
  };

  _gsDefine.globals = _globals;
  /*
   * ----------------------------------------------------------------
   * Ease
   * ----------------------------------------------------------------
   */

  var _baseParams = [0, 0, 1, 1],
      Ease = _class("easing.Ease", function (func, extraParams, type, power) {
    this._func = func;
    this._type = type || 0;
    this._power = power || 0;
    this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
  }, true),
      _easeMap = Ease.map = {},
      _easeReg = Ease.register = function (ease, names, types, create) {
    var na = names.split(","),
        i = na.length,
        ta = (types || "easeIn,easeOut,easeInOut").split(","),
        e,
        name,
        j,
        type;

    while (--i > -1) {
      name = na[i];
      e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
      j = ta.length;

      while (--j > -1) {
        type = ta[j];
        _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
      }
    }
  };

  p = Ease.prototype;
  p._calcEnd = false;

  p.getRatio = function (p) {
    if (this._func) {
      this._params[0] = p;
      return this._func.apply(null, this._params);
    }

    var t = this._type,
        pw = this._power,
        r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;

    if (pw === 1) {
      r *= r;
    } else if (pw === 2) {
      r *= r * r;
    } else if (pw === 3) {
      r *= r * r * r;
    } else if (pw === 4) {
      r *= r * r * r * r;
    }

    return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
  }; //create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)


  a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
  i = a.length;

  while (--i > -1) {
    p = a[i] + ",Power" + i;

    _easeReg(new Ease(null, null, 1, i), p, "easeOut", true);

    _easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));

    _easeReg(new Ease(null, null, 3, i), p, "easeInOut");
  }

  _easeMap.linear = gs.easing.Linear.easeIn;
  _easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks

  /*
   * ----------------------------------------------------------------
   * EventDispatcher
   * ----------------------------------------------------------------
   */

  var EventDispatcher = _class("events.EventDispatcher", function (target) {
    this._listeners = {};
    this._eventTarget = target || this;
  });

  p = EventDispatcher.prototype;

  p.addEventListener = function (type, callback, scope, useParam, priority) {
    priority = priority || 0;
    var list = this._listeners[type],
        index = 0,
        listener,
        i;

    if (this === _ticker && !_tickerActive) {
      _ticker.wake();
    }

    if (list == null) {
      this._listeners[type] = list = [];
    }

    i = list.length;

    while (--i > -1) {
      listener = list[i];

      if (listener.c === callback && listener.s === scope) {
        list.splice(i, 1);
      } else if (index === 0 && listener.pr < priority) {
        index = i + 1;
      }
    }

    list.splice(index, 0, {
      c: callback,
      s: scope,
      up: useParam,
      pr: priority
    });
  };

  p.removeEventListener = function (type, callback) {
    var list = this._listeners[type],
        i;

    if (list) {
      i = list.length;

      while (--i > -1) {
        if (list[i].c === callback) {
          list.splice(i, 1);
          return;
        }
      }
    }
  };

  p.dispatchEvent = function (type) {
    var list = this._listeners[type],
        i,
        t,
        listener;

    if (list) {
      i = list.length;

      if (i > 1) {
        list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
      }

      t = this._eventTarget;

      while (--i > -1) {
        listener = list[i];

        if (listener) {
          if (listener.up) {
            listener.c.call(listener.s || t, {
              type: type,
              target: t
            });
          } else {
            listener.c.call(listener.s || t);
          }
        }
      }
    }
  };
  /*
   * ----------------------------------------------------------------
   * Ticker
   * ----------------------------------------------------------------
   */


  var _reqAnimFrame = window.requestAnimationFrame,
      _cancelAnimFrame = window.cancelAnimationFrame,
      _getTime = Date.now || function () {
    return new Date().getTime();
  },
      _lastUpdate = _getTime(); //now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.


  a = ["ms", "moz", "webkit", "o"];
  i = a.length;

  while (--i > -1 && !_reqAnimFrame) {
    _reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
    _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
  }

  _class("Ticker", function (fps, useRAF) {
    var _self = this,
        _startTime = _getTime(),
        _useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
        _lagThreshold = 500,
        _adjustedLag = 33,
        _tickWord = "tick",
        //helps reduce gc burden
    _fps,
        _req,
        _id,
        _gap,
        _nextTime,
        _tick = function (manual) {
      var elapsed = _getTime() - _lastUpdate,
          overlap,
          dispatch;

      if (elapsed > _lagThreshold) {
        _startTime += elapsed - _adjustedLag;
      }

      _lastUpdate += elapsed;
      _self.time = (_lastUpdate - _startTime) / 1000;
      overlap = _self.time - _nextTime;

      if (!_fps || overlap > 0 || manual === true) {
        _self.frame++;
        _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
        dispatch = true;
      }

      if (manual !== true) {
        //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
        _id = _req(_tick);
      }

      if (dispatch) {
        _self.dispatchEvent(_tickWord);
      }
    };

    EventDispatcher.call(_self);
    _self.time = _self.frame = 0;

    _self.tick = function () {
      _tick(true);
    };

    _self.lagSmoothing = function (threshold, adjustedLag) {
      if (!arguments.length) {
        //if lagSmoothing() is called with no arguments, treat it like a getter that returns a boolean indicating if it's enabled or not. This is purposely undocumented and is for internal use.
        return _lagThreshold < 1 / _tinyNum;
      }

      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    };

    _self.sleep = function () {
      if (_id == null) {
        return;
      }

      if (!_useRAF || !_cancelAnimFrame) {
        clearTimeout(_id);
      } else {
        _cancelAnimFrame(_id);
      }

      _req = _emptyFunc;
      _id = null;

      if (_self === _ticker) {
        _tickerActive = false;
      }
    };

    _self.wake = function (seamless) {
      if (_id !== null) {
        _self.sleep();
      } else if (seamless) {
        _startTime += -_lastUpdate + (_lastUpdate = _getTime());
      } else if (_self.frame > 10) {
        //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
        _lastUpdate = _getTime() - _lagThreshold + 5;
      }

      _req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
        return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
      } : _reqAnimFrame;

      if (_self === _ticker) {
        _tickerActive = true;
      }

      _tick(2);
    };

    _self.fps = function (value) {
      if (!arguments.length) {
        return _fps;
      }

      _fps = value;
      _gap = 1 / (_fps || 60);
      _nextTime = this.time + _gap;

      _self.wake();
    };

    _self.useRAF = function (value) {
      if (!arguments.length) {
        return _useRAF;
      }

      _self.sleep();

      _useRAF = value;

      _self.fps(_fps);
    };

    _self.fps(fps); //a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.


    setTimeout(function () {
      if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
        _self.useRAF(false);
      }
    }, 1500);
  });

  p = gs.Ticker.prototype = new gs.events.EventDispatcher();
  p.constructor = gs.Ticker;
  /*
   * ----------------------------------------------------------------
   * Animation
   * ----------------------------------------------------------------
   */

  var Animation = _class("core.Animation", function (duration, vars) {
    this.vars = vars = vars || {};
    this._duration = this._totalDuration = duration || 0;
    this._delay = Number(vars.delay) || 0;
    this._timeScale = 1;
    this._active = vars.immediateRender === true;
    this.data = vars.data;
    this._reversed = vars.reversed === true;

    if (!_rootTimeline) {
      return;
    }

    if (!_tickerActive) {
      //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
      _ticker.wake();
    }

    var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
    tl.add(this, tl._time);

    if (this.vars.paused) {
      this.paused(true);
    }
  });

  _ticker = Animation.ticker = new gs.Ticker();
  p = Animation.prototype;
  p._dirty = p._gc = p._initted = p._paused = false;
  p._totalTime = p._time = 0;
  p._rawPrevTime = -1;
  p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
  p._paused = false; //some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.

  var _checkTimeout = function () {
    if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) {
      //note: if the tab is hidden, we should still wake if lagSmoothing has been disabled.
      _ticker.wake();
    }

    var t = setTimeout(_checkTimeout, 2000);

    if (t.unref) {
      // allows a node process to exit even if the timeouts callback hasn't been invoked. Without it, the node process could hang as this function is called every two seconds.
      t.unref();
    }
  };

  _checkTimeout();

  p.play = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }

    return this.reversed(false).paused(false);
  };

  p.pause = function (atTime, suppressEvents) {
    if (atTime != null) {
      this.seek(atTime, suppressEvents);
    }

    return this.paused(true);
  };

  p.resume = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }

    return this.paused(false);
  };

  p.seek = function (time, suppressEvents) {
    return this.totalTime(Number(time), suppressEvents !== false);
  };

  p.restart = function (includeDelay, suppressEvents) {
    return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
  };

  p.reverse = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from || this.totalDuration(), suppressEvents);
    }

    return this.reversed(true).paused(false);
  };

  p.render = function (time, suppressEvents, force) {//stub - we override this method in subclasses.
  };

  p.invalidate = function () {
    this._time = this._totalTime = 0;
    this._initted = this._gc = false;
    this._rawPrevTime = -1;

    if (this._gc || !this.timeline) {
      this._enabled(true);
    }

    return this;
  };

  p.isActive = function () {
    var tl = this._timeline,
        //the 2 root timelines won't have a _timeline; they're always active.
    startTime = this._startTime,
        rawTime;
    return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - 0.0000001;
  };

  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }

    this._gc = !enabled;
    this._active = this.isActive();

    if (ignoreTimeline !== true) {
      if (enabled && !this.timeline) {
        this._timeline.add(this, this._startTime - this._delay);
      } else if (!enabled && this.timeline) {
        this._timeline._remove(this, true);
      }
    }

    return false;
  };

  p._kill = function (vars, target) {
    return this._enabled(false, false);
  };

  p.kill = function (vars, target) {
    this._kill(vars, target);

    return this;
  };

  p._uncache = function (includeSelf) {
    var tween = includeSelf ? this : this.timeline;

    while (tween) {
      tween._dirty = true;
      tween = tween.timeline;
    }

    return this;
  };

  p._swapSelfInParams = function (params) {
    var i = params.length,
        copy = params.concat();

    while (--i > -1) {
      if (params[i] === "{self}") {
        copy[i] = this;
      }
    }

    return copy;
  };

  p._callback = function (type) {
    var v = this.vars,
        callback = v[type],
        params = v[type + "Params"],
        scope = v[type + "Scope"] || v.callbackScope || this,
        l = params ? params.length : 0;

    switch (l) {
      //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
      case 0:
        callback.call(scope);
        break;

      case 1:
        callback.call(scope, params[0]);
        break;

      case 2:
        callback.call(scope, params[0], params[1]);
        break;

      default:
        callback.apply(scope, params);
    }
  }; //----Animation getters/setters --------------------------------------------------------


  p.eventCallback = function (type, callback, params, scope) {
    if ((type || "").substr(0, 2) === "on") {
      var v = this.vars;

      if (arguments.length === 1) {
        return v[type];
      }

      if (callback == null) {
        delete v[type];
      } else {
        v[type] = callback;
        v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
        v[type + "Scope"] = scope;
      }

      if (type === "onUpdate") {
        this._onUpdate = callback;
      }
    }

    return this;
  };

  p.delay = function (value) {
    if (!arguments.length) {
      return this._delay;
    }

    if (this._timeline.smoothChildTiming) {
      this.startTime(this._startTime + value - this._delay);
    }

    this._delay = value;
    return this;
  };

  p.duration = function (value) {
    if (!arguments.length) {
      this._dirty = false;
      return this._duration;
    }

    this._duration = this._totalDuration = value;

    this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.


    if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
      this.totalTime(this._totalTime * (value / this._duration), true);
    }
    return this;
  };

  p.totalDuration = function (value) {
    this._dirty = false;
    return !arguments.length ? this._totalDuration : this.duration(value);
  };

  p.time = function (value, suppressEvents) {
    if (!arguments.length) {
      return this._time;
    }

    if (this._dirty) {
      this.totalDuration();
    }

    return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
  };

  p.totalTime = function (time, suppressEvents, uncapped) {
    if (!_tickerActive) {
      _ticker.wake();
    }

    if (!arguments.length) {
      return this._totalTime;
    }

    if (this._timeline) {
      if (time < 0 && !uncapped) {
        time += this.totalDuration();
      }

      if (this._timeline.smoothChildTiming) {
        if (this._dirty) {
          this.totalDuration();
        }

        var totalDuration = this._totalDuration,
            tl = this._timeline;

        if (time > totalDuration && !uncapped) {
          time = totalDuration;
        }

        this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;

        if (!tl._dirty) {
          //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
          this._uncache(false);
        } //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.


        if (tl._timeline) {
          while (tl._timeline) {
            if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
              tl.totalTime(tl._totalTime, true);
            }

            tl = tl._timeline;
          }
        }
      }

      if (this._gc) {
        this._enabled(true, false);
      }

      if (this._totalTime !== time || this._duration === 0) {
        if (_lazyTweens.length) {
          _lazyRender();
        }

        this.render(time, suppressEvents, false);

        if (_lazyTweens.length) {
          //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
          _lazyRender();
        }
      }
    }

    return this;
  };

  p.progress = p.totalProgress = function (value, suppressEvents) {
    var duration = this.duration();
    return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
  };

  p.startTime = function (value) {
    if (!arguments.length) {
      return this._startTime;
    }

    if (value !== this._startTime) {
      this._startTime = value;
      if (this.timeline) if (this.timeline._sortChildren) {
        this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
      }
    }

    return this;
  };

  p.endTime = function (includeRepeats) {
    return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
  };

  p.timeScale = function (value) {
    if (!arguments.length) {
      return this._timeScale;
    }

    var pauseTime, t;
    value = value || _tinyNum; //can't allow zero because it'll throw the math off

    if (this._timeline && this._timeline.smoothChildTiming) {
      pauseTime = this._pauseTime;
      t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
      this._startTime = t - (t - this._startTime) * this._timeScale / value;
    }

    this._timeScale = value;
    t = this.timeline;

    while (t && t.timeline) {
      //must update the duration/totalDuration of all ancestor timelines immediately in case in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
      t._dirty = true;
      t.totalDuration();
      t = t.timeline;
    }

    return this;
  };

  p.reversed = function (value) {
    if (!arguments.length) {
      return this._reversed;
    }

    if (value != this._reversed) {
      this._reversed = value;
      this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
    }

    return this;
  };

  p.paused = function (value) {
    if (!arguments.length) {
      return this._paused;
    }

    var tl = this._timeline,
        raw,
        elapsed;
    if (value != this._paused) if (tl) {
      if (!_tickerActive && !value) {
        _ticker.wake();
      }

      raw = tl.rawTime();
      elapsed = raw - this._pauseTime;

      if (!value && tl.smoothChildTiming) {
        this._startTime += elapsed;

        this._uncache(false);
      }

      this._pauseTime = value ? raw : null;
      this._paused = value;
      this._active = this.isActive();

      if (!value && elapsed !== 0 && this._initted && this.duration()) {
        raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
        this.render(raw, raw === this._totalTime, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
      }
    }

    if (this._gc && !value) {
      this._enabled(true, false);
    }

    return this;
  };
  /*
   * ----------------------------------------------------------------
   * SimpleTimeline
   * ----------------------------------------------------------------
   */


  var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
    Animation.call(this, 0, vars);
    this.autoRemoveChildren = this.smoothChildTiming = true;
  });

  p = SimpleTimeline.prototype = new Animation();
  p.constructor = SimpleTimeline;
  p.kill()._gc = false;
  p._first = p._last = p._recent = null;
  p._sortChildren = false;

  p.add = p.insert = function (child, position, align, stagger) {
    var prevTween, st;
    child._startTime = Number(position || 0) + child._delay;
    if (child._paused) if (this !== child._timeline) {
      //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
      child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);
    }

    if (child.timeline) {
      child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.

    }

    child.timeline = child._timeline = this;

    if (child._gc) {
      child._enabled(true, true);
    }

    prevTween = this._last;

    if (this._sortChildren) {
      st = child._startTime;

      while (prevTween && prevTween._startTime > st) {
        prevTween = prevTween._prev;
      }
    }

    if (prevTween) {
      child._next = prevTween._next;
      prevTween._next = child;
    } else {
      child._next = this._first;
      this._first = child;
    }

    if (child._next) {
      child._next._prev = child;
    } else {
      this._last = child;
    }

    child._prev = prevTween;
    this._recent = child;

    if (this._timeline) {
      this._uncache(true);
    }

    return this;
  };

  p._remove = function (tween, skipDisable) {
    if (tween.timeline === this) {
      if (!skipDisable) {
        tween._enabled(false, true);
      }

      if (tween._prev) {
        tween._prev._next = tween._next;
      } else if (this._first === tween) {
        this._first = tween._next;
      }

      if (tween._next) {
        tween._next._prev = tween._prev;
      } else if (this._last === tween) {
        this._last = tween._prev;
      }

      tween._next = tween._prev = tween.timeline = null;

      if (tween === this._recent) {
        this._recent = this._last;
      }

      if (this._timeline) {
        this._uncache(true);
      }
    }

    return this;
  };

  p.render = function (time, suppressEvents, force) {
    var tween = this._first,
        next;
    this._totalTime = this._time = this._rawPrevTime = time;

    while (tween) {
      next = tween._next; //record it here because the value could change after rendering...

      if (tween._active || time >= tween._startTime && !tween._paused && !tween._gc) {
        if (!tween._reversed) {
          tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
        } else {
          tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
        }
      }

      tween = next;
    }
  };

  p.rawTime = function () {
    if (!_tickerActive) {
      _ticker.wake();
    }

    return this._totalTime;
  };
  /*
   * ----------------------------------------------------------------
   * TweenLite
   * ----------------------------------------------------------------
   */


  var TweenLite = _class("TweenLite", function (target, duration, vars) {
    Animation.call(this, duration, vars);
    this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

    if (target == null) {
      throw "Cannot tween a null target.";
    }

    this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
    var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
        overwrite = this.vars.overwrite,
        i,
        targ,
        targets;
    this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];

    if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
      this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()

      this._propLookup = [];
      this._siblings = [];

      for (i = 0; i < targets.length; i++) {
        targ = targets[i];

        if (!targ) {
          targets.splice(i--, 1);
          continue;
        } else if (typeof targ === "string") {
          targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings

          if (typeof targ === "string") {
            targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
          }

          continue;
        } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
          //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
          targets.splice(i--, 1);
          this._targets = targets = targets.concat(_slice(targ));
          continue;
        }

        this._siblings[i] = _register(targ, this, false);
        if (overwrite === 1) if (this._siblings[i].length > 1) {
          _applyOverwrite(targ, this, null, 1, this._siblings[i]);
        }
      }
    } else {
      this._propLookup = {};
      this._siblings = _register(target, this, false);
      if (overwrite === 1) if (this._siblings.length > 1) {
        _applyOverwrite(target, this, null, 1, this._siblings);
      }
    }

    if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
      this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      this.render(Math.min(0, -this._delay)); //in case delay is negative
    }
  }, true),
      _isSelector = function (v) {
    return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
  },
      _autoCSS = function (vars, target) {
    var css = {},
        p;

    for (p in vars) {
      if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
        //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
        css[p] = vars[p];
        delete vars[p];
      }
    }

    vars.css = css;
  };

  p = TweenLite.prototype = new Animation();
  p.constructor = TweenLite;
  p.kill()._gc = false; //----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

  p.ratio = 0;
  p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
  p._notifyPluginsOfEnabled = p._lazy = false;
  TweenLite.version = "2.0.2";
  TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
  TweenLite.defaultOverwrite = "auto";
  TweenLite.ticker = _ticker;
  TweenLite.autoSleep = 120;

  TweenLite.lagSmoothing = function (threshold, adjustedLag) {
    _ticker.lagSmoothing(threshold, adjustedLag);
  };

  TweenLite.selector = window.$ || window.jQuery || function (e) {
    var selector = window.$ || window.jQuery;

    if (selector) {
      TweenLite.selector = selector;
      return selector(e);
    }

    if (!_doc) {
      //in some dev environments (like Angular 6), GSAP gets loaded before the document is defined! So re-query it here if/when necessary.
      _doc = window.document;
    }

    return !_doc ? e : _doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
  };

  var _lazyTweens = [],
      _lazyLookup = {},
      _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
      _relExp = /[\+-]=-?[\.\d]/,
      //_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
  _setRatio = function (v) {
    var pt = this._firstPT,
        min = 0.000001,
        val;

    while (pt) {
      val = !pt.blob ? pt.c * v + pt.s : v === 1 && this.end != null ? this.end : v ? this.join("") : this.start;

      if (pt.m) {
        val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);
      } else if (val < min) if (val > -min && !pt.blob) {
        //prevents issues with converting very small numbers to strings in the browser
        val = 0;
      }

      if (!pt.f) {
        pt.t[pt.p] = val;
      } else if (pt.fp) {
        pt.t[pt.p](pt.fp, val);
      } else {
        pt.t[pt.p](val);
      }

      pt = pt._next;
    }
  },
      //compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
  _blobDif = function (start, end, filter, pt) {
    var a = [],
        charIndex = 0,
        s = "",
        color = 0,
        startNums,
        endNums,
        num,
        i,
        l,
        nonNumbers,
        currentNum;
    a.start = start;
    a.end = end;
    start = a[0] = start + ""; //ensure values are strings

    end = a[1] = end + "";

    if (filter) {
      filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

      start = a[0];
      end = a[1];
    }

    a.length = 0;
    startNums = start.match(_numbersExp) || [];
    endNums = end.match(_numbersExp) || [];

    if (pt) {
      pt._next = null;
      pt.blob = 1;
      a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
    }

    l = endNums.length;

    for (i = 0; i < l; i++) {
      currentNum = endNums[i];
      nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
      s += nonNumbers || !i ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.

      charIndex += nonNumbers.length;

      if (color) {
        //sense rgba() values and round them.
        color = (color + 1) % 5;
      } else if (nonNumbers.substr(-5) === "rgba(") {
        color = 1;
      }

      if (currentNum === startNums[i] || startNums.length <= i) {
        s += currentNum;
      } else {
        if (s) {
          a.push(s);
          s = "";
        }

        num = parseFloat(startNums[i]);
        a.push(num);
        a._firstPT = {
          _next: a._firstPT,
          t: a,
          p: a.length - 1,
          s: num,
          c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0,
          f: 0,
          m: color && color < 4 ? Math.round : 0
        }; //note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
      }

      charIndex += currentNum.length;
    }

    s += end.substr(charIndex);

    if (s) {
      a.push(s);
    }

    a.setRatio = _setRatio;

    if (_relExp.test(end)) {
      //if the end string contains relative values, delete it so that on the final render (in _setRatio()), we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
      a.end = null;
    }

    return a;
  },
      //note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
  _addPropTween = function (target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
    if (typeof end === "function") {
      end = end(index || 0, target);
    }

    var type = typeof target[prop],
        getterName = type !== "function" ? "" : prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3),
        s = start !== "get" ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
        isRelative = typeof end === "string" && end.charAt(1) === "=",
        pt = {
      t: target,
      p: prop,
      s: s,
      f: type === "function",
      pg: 0,
      n: overwriteProp || prop,
      m: !mod ? 0 : typeof mod === "function" ? mod : Math.round,
      pr: 0,
      c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0
    },
        blob;

    if (typeof s !== "number" || typeof end !== "number" && !isRelative) {
      if (funcParam || isNaN(s) || !isRelative && isNaN(end) || typeof s === "boolean" || typeof end === "boolean") {
        //a blob (string that has multiple numbers in it)
        pt.fp = funcParam;
        blob = _blobDif(s, isRelative ? parseFloat(pt.s) + pt.c + (pt.s + "").replace(/[0-9\-\.]/g, "") : end, stringFilter || TweenLite.defaultStringFilter, pt);
        pt = {
          t: blob,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 2,
          pg: 0,
          n: overwriteProp || prop,
          pr: 0,
          m: 0
        }; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
      } else {
        pt.s = parseFloat(s);

        if (!isRelative) {
          pt.c = parseFloat(end) - pt.s || 0;
        }
      }
    }

    if (pt.c) {
      //only add it to the linked list if there's a change.
      if (pt._next = this._firstPT) {
        pt._next._prev = pt;
      }

      this._firstPT = pt;
      return pt;
    }
  },
      _internals = TweenLite._internals = {
    isArray: _isArray,
    isSelector: _isSelector,
    lazyTweens: _lazyTweens,
    blobDif: _blobDif
  },
      //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
  _plugins = TweenLite._plugins = {},
      _tweenLookup = _internals.tweenLookup = {},
      _tweenLookupNum = 0,
      _reservedProps = _internals.reservedProps = {
    ease: 1,
    delay: 1,
    overwrite: 1,
    onComplete: 1,
    onCompleteParams: 1,
    onCompleteScope: 1,
    useFrames: 1,
    runBackwards: 1,
    startAt: 1,
    onUpdate: 1,
    onUpdateParams: 1,
    onUpdateScope: 1,
    onStart: 1,
    onStartParams: 1,
    onStartScope: 1,
    onReverseComplete: 1,
    onReverseCompleteParams: 1,
    onReverseCompleteScope: 1,
    onRepeat: 1,
    onRepeatParams: 1,
    onRepeatScope: 1,
    easeParams: 1,
    yoyo: 1,
    immediateRender: 1,
    repeat: 1,
    repeatDelay: 1,
    data: 1,
    paused: 1,
    reversed: 1,
    autoCSS: 1,
    lazy: 1,
    onOverwrite: 1,
    callbackScope: 1,
    stringFilter: 1,
    id: 1,
    yoyoEase: 1
  },
      _overwriteLookup = {
    none: 0,
    all: 1,
    auto: 2,
    concurrent: 3,
    allOnStart: 4,
    preexisting: 5,
    "true": 1,
    "false": 0
  },
      _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
      _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
      _nextGCFrame = 30,
      _lazyRender = _internals.lazyRender = function () {
    var i = _lazyTweens.length,
        tween;
    _lazyLookup = {};

    while (--i > -1) {
      tween = _lazyTweens[i];

      if (tween && tween._lazy !== false) {
        tween.render(tween._lazy[0], tween._lazy[1], true);
        tween._lazy = false;
      }
    }

    _lazyTweens.length = 0;
  };

  _rootTimeline._startTime = _ticker.time;
  _rootFramesTimeline._startTime = _ticker.frame;
  _rootTimeline._active = _rootFramesTimeline._active = true;
  setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

  Animation._updateRoot = TweenLite.render = function () {
    var i, a, p;

    if (_lazyTweens.length) {
      //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
      _lazyRender();
    }

    _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);

    _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);

    if (_lazyTweens.length) {
      _lazyRender();
    }

    if (_ticker.frame >= _nextGCFrame) {
      //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
      _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);

      for (p in _tweenLookup) {
        a = _tweenLookup[p].tweens;
        i = a.length;

        while (--i > -1) {
          if (a[i]._gc) {
            a.splice(i, 1);
          }
        }

        if (a.length === 0) {
          delete _tweenLookup[p];
        }
      } //if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly


      p = _rootTimeline._first;
      if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
        while (p && p._paused) {
          p = p._next;
        }

        if (!p) {
          _ticker.sleep();
        }
      }
    }
  };

  _ticker.addEventListener("tick", Animation._updateRoot);

  var _register = function (target, tween, scrub) {
    var id = target._gsTweenID,
        a,
        i;

    if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
      _tweenLookup[id] = {
        target: target,
        tweens: []
      };
    }

    if (tween) {
      a = _tweenLookup[id].tweens;
      a[i = a.length] = tween;

      if (scrub) {
        while (--i > -1) {
          if (a[i] === tween) {
            a.splice(i, 1);
          }
        }
      }
    }

    return _tweenLookup[id].tweens;
  },
      _onOverwrite = function (overwrittenTween, overwritingTween, target, killedProps) {
    var func = overwrittenTween.vars.onOverwrite,
        r1,
        r2;

    if (func) {
      r1 = func(overwrittenTween, overwritingTween, target, killedProps);
    }

    func = TweenLite.onOverwrite;

    if (func) {
      r2 = func(overwrittenTween, overwritingTween, target, killedProps);
    }

    return r1 !== false && r2 !== false;
  },
      _applyOverwrite = function (target, tween, props, mode, siblings) {
    var i, changed, curTween, l;

    if (mode === 1 || mode >= 4) {
      l = siblings.length;

      for (i = 0; i < l; i++) {
        if ((curTween = siblings[i]) !== tween) {
          if (!curTween._gc) {
            if (curTween._kill(null, target, tween)) {
              changed = true;
            }
          }
        } else if (mode === 5) {
          break;
        }
      }

      return changed;
    } //NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)


    var startTime = tween._startTime + _tinyNum,
        overlaps = [],
        oCount = 0,
        zeroDur = tween._duration === 0,
        globalStart;
    i = siblings.length;

    while (--i > -1) {
      if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {//ignore
      } else if (curTween._timeline !== tween._timeline) {
        globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);

        if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
          overlaps[oCount++] = curTween;
        }
      } else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
        overlaps[oCount++] = curTween;
      }
    }

    i = oCount;

    while (--i > -1) {
      curTween = overlaps[i];
      l = curTween._firstPT; //we need to discern if there were property tweens originally; if they all get removed in the next line's _kill() call, the tween should be killed. See https://github.com/greensock/GreenSock-JS/issues/278

      if (mode === 2) if (curTween._kill(props, target, tween)) {
        changed = true;
      }

      if (mode !== 2 || !curTween._firstPT && curTween._initted && l) {
        if (mode !== 2 && !_onOverwrite(curTween, tween)) {
          continue;
        }

        if (curTween._enabled(false, false)) {
          //if all property tweens have been overwritten, kill the tween.
          changed = true;
        }
      }
    }

    return changed;
  },
      _checkOverlap = function (tween, reference, zeroDur) {
    var tl = tween._timeline,
        ts = tl._timeScale,
        t = tween._startTime;

    while (tl._timeline) {
      t += tl._startTime;
      ts *= tl._timeScale;

      if (tl._paused) {
        return -100;
      }

      tl = tl._timeline;
    }

    t /= ts;
    return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
  }; //---- TweenLite instance methods -----------------------------------------------------------------------------


  p._init = function () {
    var v = this.vars,
        op = this._overwrittenProps,
        dur = this._duration,
        immediate = !!v.immediateRender,
        ease = v.ease,
        i,
        initPlugins,
        pt,
        p,
        startVars,
        l;

    if (v.startAt) {
      if (this._startAt) {
        this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.


        this._startAt.kill();
      }

      startVars = {};

      for (p in v.startAt) {
        //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
        startVars[p] = v.startAt[p];
      }

      startVars.data = "isStart";
      startVars.overwrite = false;
      startVars.immediateRender = true;
      startVars.lazy = immediate && v.lazy !== false;
      startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).

      startVars.onUpdate = v.onUpdate;
      startVars.onUpdateParams = v.onUpdateParams;
      startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
      this._startAt = TweenLite.to(this.target || {}, 0, startVars);

      if (immediate) {
        if (this._time > 0) {
          this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
        } else if (dur !== 0) {
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (v.runBackwards && dur !== 0) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (this._startAt) {
        this._startAt.render(-1, true);

        this._startAt.kill();

        this._startAt = null;
      } else {
        if (this._time !== 0) {
          //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
          immediate = false;
        }

        pt = {};

        for (p in v) {
          //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
          if (!_reservedProps[p] || p === "autoCSS") {
            pt[p] = v[p];
          }
        }

        pt.overwrite = 0;
        pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.

        pt.lazy = immediate && v.lazy !== false;
        pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)

        this._startAt = TweenLite.to(this.target, 0, pt);

        if (!immediate) {
          this._startAt._init(); //ensures that the initial values are recorded


          this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.


          if (this.vars.immediateRender) {
            this._startAt = null;
          }
        } else if (this._time === 0) {
          return;
        }
      }
    }

    this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;

    if (v.easeParams instanceof Array && ease.config) {
      this._ease = ease.config.apply(ease, v.easeParams);
    }

    this._easeType = this._ease._type;
    this._easePower = this._ease._power;
    this._firstPT = null;

    if (this._targets) {
      l = this._targets.length;

      for (i = 0; i < l; i++) {
        if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null, i)) {
          initPlugins = true;
        }
      }
    } else {
      initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
    }

    if (initPlugins) {
      TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite

    }

    if (op) if (!this._firstPT) if (typeof this.target !== "function") {
      //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
      this._enabled(false, false);
    }

    if (v.runBackwards) {
      pt = this._firstPT;

      while (pt) {
        pt.s += pt.c;
        pt.c = -pt.c;
        pt = pt._next;
      }
    }

    this._onUpdate = v.onUpdate;
    this._initted = true;
  };

  p._initProps = function (target, propLookup, siblings, overwrittenProps, index) {
    var p, i, initPlugins, plugin, pt, v;

    if (target == null) {
      return false;
    }

    if (_lazyLookup[target._gsTweenID]) {
      _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

    }

    if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {
      //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
      _autoCSS(this.vars, target);
    }

    for (p in this.vars) {
      v = this.vars[p];

      if (_reservedProps[p]) {
        if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join("").indexOf("{self}") !== -1) {
          this.vars[p] = v = this._swapSelfInParams(v, this);
        }
      } else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {
        //t - target 		[object]
        //p - property 		[string]
        //s - start			[number]
        //c - change		[number]
        //f - isFunction	[boolean]
        //n - name			[string]
        //pg - isPlugin 	[boolean]
        //pr - priority		[number]
        //m - mod           [function | 0]
        this._firstPT = pt = {
          _next: this._firstPT,
          t: plugin,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          n: p,
          pg: 1,
          pr: plugin._priority,
          m: 0
        };
        i = plugin._overwriteProps.length;

        while (--i > -1) {
          propLookup[plugin._overwriteProps[i]] = this._firstPT;
        }

        if (plugin._priority || plugin._onInitAllProps) {
          initPlugins = true;
        }

        if (plugin._onDisable || plugin._onEnable) {
          this._notifyPluginsOfEnabled = true;
        }

        if (pt._next) {
          pt._next._prev = pt;
        }
      } else {
        propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
      }
    }

    if (overwrittenProps) if (this._kill(overwrittenProps, target)) {
      //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
      return this._initProps(target, propLookup, siblings, overwrittenProps, index);
    }
    if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
      this._kill(propLookup, target);

      return this._initProps(target, propLookup, siblings, overwrittenProps, index);
    }
    if (this._firstPT) if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
      //zero duration tweens don't lazy render by default; everything else does.
      _lazyLookup[target._gsTweenID] = true;
    }
    return initPlugins;
  };

  p.render = function (time, suppressEvents, force) {
    var prevTime = this._time,
        duration = this._duration,
        prevRawPrevTime = this._rawPrevTime,
        isComplete,
        callback,
        pt,
        rawPrevTime;

    if (time >= duration - 0.0000001 && time >= 0) {
      //to work around occasional floating point math artifacts.
      this._totalTime = this._time = duration;
      this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;

      if (!this._reversed) {
        isComplete = true;
        callback = "onComplete";
        force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
      }

      if (duration === 0) if (this._initted || !this.vars.lazy || force) {
        //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
        if (this._startTime === this._timeline._duration) {
          //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
          time = 0;
        }

        if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
          //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
          force = true;

          if (prevRawPrevTime > _tinyNum) {
            callback = "onReverseComplete";
          }
        }
        this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
      }
    } else if (time < 0.0000001) {
      //to work around occasional floating point math artifacts, round super small values to 0.
      this._totalTime = this._time = 0;
      this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;

      if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
        callback = "onReverseComplete";
        isComplete = this._reversed;
      }

      if (time < 0) {
        this._active = false;
        if (duration === 0) if (this._initted || !this.vars.lazy || force) {
          //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
          if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
            force = true;
          }

          this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        }
      }

      if (!this._initted || this._startAt && this._startAt.progress()) {
        //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately. Also, we check progress() because if startAt has already rendered at its end, we should force a render at its beginning. Otherwise, if you put the playhead directly on top of where a fromTo({immediateRender:false}) starts, and then move it backwards, the from() won't revert its values.
        force = true;
      }
    } else {
      this._totalTime = this._time = time;

      if (this._easeType) {
        var r = time / duration,
            type = this._easeType,
            pow = this._easePower;

        if (type === 1 || type === 3 && r >= 0.5) {
          r = 1 - r;
        }

        if (type === 3) {
          r *= 2;
        }

        if (pow === 1) {
          r *= r;
        } else if (pow === 2) {
          r *= r * r;
        } else if (pow === 3) {
          r *= r * r * r;
        } else if (pow === 4) {
          r *= r * r * r * r;
        }

        if (type === 1) {
          this.ratio = 1 - r;
        } else if (type === 2) {
          this.ratio = r;
        } else if (time / duration < 0.5) {
          this.ratio = r / 2;
        } else {
          this.ratio = 1 - r / 2;
        }
      } else {
        this.ratio = this._ease.getRatio(time / duration);
      }
    }

    if (this._time === prevTime && !force) {
      return;
    } else if (!this._initted) {
      this._init();

      if (!this._initted || this._gc) {
        //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
        return;
      } else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
        this._time = this._totalTime = prevTime;
        this._rawPrevTime = prevRawPrevTime;

        _lazyTweens.push(this);

        this._lazy = [time, suppressEvents];
        return;
      } //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.


      if (this._time && !isComplete) {
        this.ratio = this._ease.getRatio(this._time / duration);
      } else if (isComplete && this._ease._calcEnd) {
        this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
      }
    }

    if (this._lazy !== false) {
      //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
      this._lazy = false;
    }

    if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
      this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
    }

    if (prevTime === 0) {
      if (this._startAt) {
        if (time >= 0) {
          this._startAt.render(time, true, force);
        } else if (!callback) {
          callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
        }
      }

      if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
        this._callback("onStart");
      }
    }

    pt = this._firstPT;

    while (pt) {
      if (pt.f) {
        pt.t[pt.p](pt.c * this.ratio + pt.s);
      } else {
        pt.t[pt.p] = pt.c * this.ratio + pt.s;
      }

      pt = pt._next;
    }

    if (this._onUpdate) {
      if (time < 0) if (this._startAt && time !== -0.0001) {
        //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
        this._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

      }
      if (!suppressEvents) if (this._time !== prevTime || isComplete || force) {
        this._callback("onUpdate");
      }
    }

    if (callback) if (!this._gc || force) {
      //check _gc because there's a chance that kill() could be called in an onUpdate
      if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) {
        //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
        this._startAt.render(time, true, force);
      }

      if (isComplete) {
        if (this._timeline.autoRemoveChildren) {
          this._enabled(false, false);
        }

        this._active = false;
      }

      if (!suppressEvents && this.vars[callback]) {
        this._callback(callback);
      }

      if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
        //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
        this._rawPrevTime = 0;
      }
    }
  };

  p._kill = function (vars, target, overwritingTween) {
    if (vars === "all") {
      vars = null;
    }

    if (vars == null) if (target == null || target === this.target) {
      this._lazy = false;
      return this._enabled(false, false);
    }
    target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
    var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
        firstPT = this._firstPT,
        i,
        overwrittenProps,
        p,
        pt,
        propLookup,
        changed,
        killProps,
        record,
        killed;

    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;

      while (--i > -1) {
        if (this._kill(vars, target[i], overwritingTween)) {
          changed = true;
        }
      }
    } else {
      if (this._targets) {
        i = this._targets.length;

        while (--i > -1) {
          if (target === this._targets[i]) {
            propLookup = this._propLookup[i] || {};
            this._overwrittenProps = this._overwrittenProps || [];
            overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
            break;
          }
        }
      } else if (target !== this.target) {
        return false;
      } else {
        propLookup = this._propLookup;
        overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
      }

      if (propLookup) {
        killProps = vars || propLookup;
        record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof vars !== "object" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)

        if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
          for (p in killProps) {
            if (propLookup[p]) {
              if (!killed) {
                killed = [];
              }

              killed.push(p);
            }
          }

          if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
            //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
            return false;
          }
        }

        for (p in killProps) {
          if (pt = propLookup[p]) {
            if (simultaneousOverwrite) {
              //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
              if (pt.f) {
                pt.t[pt.p](pt.s);
              } else {
                pt.t[pt.p] = pt.s;
              }

              changed = true;
            }

            if (pt.pg && pt.t._kill(killProps)) {
              changed = true; //some plugins need to be notified so they can perform cleanup tasks first
            }

            if (!pt.pg || pt.t._overwriteProps.length === 0) {
              if (pt._prev) {
                pt._prev._next = pt._next;
              } else if (pt === this._firstPT) {
                this._firstPT = pt._next;
              }

              if (pt._next) {
                pt._next._prev = pt._prev;
              }

              pt._next = pt._prev = null;
            }

            delete propLookup[p];
          }

          if (record) {
            overwrittenProps[p] = 1;
          }
        }

        if (!this._firstPT && this._initted && firstPT) {
          //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
          this._enabled(false, false);
        }
      }
    }

    return changed;
  };

  p.invalidate = function () {
    if (this._notifyPluginsOfEnabled) {
      TweenLite._onPluginEvent("_onDisable", this);
    }

    this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
    this._notifyPluginsOfEnabled = this._active = this._lazy = false;
    this._propLookup = this._targets ? {} : [];
    Animation.prototype.invalidate.call(this);

    if (this.vars.immediateRender) {
      this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      this.render(Math.min(0, -this._delay)); //in case delay is negative.
    }

    return this;
  };

  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }

    if (enabled && this._gc) {
      var targets = this._targets,
          i;

      if (targets) {
        i = targets.length;

        while (--i > -1) {
          this._siblings[i] = _register(targets[i], this, true);
        }
      } else {
        this._siblings = _register(this.target, this, true);
      }
    }

    Animation.prototype._enabled.call(this, enabled, ignoreTimeline);

    if (this._notifyPluginsOfEnabled) if (this._firstPT) {
      return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
    }
    return false;
  }; //----TweenLite static methods -----------------------------------------------------


  TweenLite.to = function (target, duration, vars) {
    return new TweenLite(target, duration, vars);
  };

  TweenLite.from = function (target, duration, vars) {
    vars.runBackwards = true;
    vars.immediateRender = vars.immediateRender != false;
    return new TweenLite(target, duration, vars);
  };

  TweenLite.fromTo = function (target, duration, fromVars, toVars) {
    toVars.startAt = fromVars;
    toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
    return new TweenLite(target, duration, toVars);
  };

  TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
    return new TweenLite(callback, 0, {
      delay: delay,
      onComplete: callback,
      onCompleteParams: params,
      callbackScope: scope,
      onReverseComplete: callback,
      onReverseCompleteParams: params,
      immediateRender: false,
      lazy: false,
      useFrames: useFrames,
      overwrite: 0
    });
  };

  TweenLite.set = function (target, vars) {
    return new TweenLite(target, 0, vars);
  };

  TweenLite.getTweensOf = function (target, onlyActive) {
    if (target == null) {
      return [];
    }

    target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
    var i, a, j, t;

    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;
      a = [];

      while (--i > -1) {
        a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
      }

      i = a.length; //now get rid of any duplicates (tweens of arrays of objects could cause duplicates)

      while (--i > -1) {
        t = a[i];
        j = i;

        while (--j > -1) {
          if (t === a[j]) {
            a.splice(i, 1);
          }
        }
      }
    } else if (target._gsTweenID) {
      a = _register(target).concat();
      i = a.length;

      while (--i > -1) {
        if (a[i]._gc || onlyActive && !a[i].isActive()) {
          a.splice(i, 1);
        }
      }
    }

    return a || [];
  };

  TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
    if (typeof onlyActive === "object") {
      vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)

      onlyActive = false;
    }

    var a = TweenLite.getTweensOf(target, onlyActive),
        i = a.length;

    while (--i > -1) {
      a[i]._kill(vars, target);
    }
  };
  /*
   * ----------------------------------------------------------------
   * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
   * ----------------------------------------------------------------
   */


  var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
    this._overwriteProps = (props || "").split(",");
    this._propName = this._overwriteProps[0];
    this._priority = priority || 0;
    this._super = TweenPlugin.prototype;
  }, true);

  p = TweenPlugin.prototype;
  TweenPlugin.version = "1.19.0";
  TweenPlugin.API = 2;
  p._firstPT = null;
  p._addTween = _addPropTween;
  p.setRatio = _setRatio;

  p._kill = function (lookup) {
    var a = this._overwriteProps,
        pt = this._firstPT,
        i;

    if (lookup[this._propName] != null) {
      this._overwriteProps = [];
    } else {
      i = a.length;

      while (--i > -1) {
        if (lookup[a[i]] != null) {
          a.splice(i, 1);
        }
      }
    }

    while (pt) {
      if (lookup[pt.n] != null) {
        if (pt._next) {
          pt._next._prev = pt._prev;
        }

        if (pt._prev) {
          pt._prev._next = pt._next;
          pt._prev = null;
        } else if (this._firstPT === pt) {
          this._firstPT = pt._next;
        }
      }

      pt = pt._next;
    }

    return false;
  };

  p._mod = p._roundProps = function (lookup) {
    var pt = this._firstPT,
        val;

    while (pt) {
      val = lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")];

      if (val && typeof val === "function") {
        //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
        if (pt.f === 2) {
          pt.t._applyPT.m = val;
        } else {
          pt.m = val;
        }
      }

      pt = pt._next;
    }
  };

  TweenLite._onPluginEvent = function (type, tween) {
    var pt = tween._firstPT,
        changed,
        pt2,
        first,
        last,
        next;

    if (type === "_onInitAllProps") {
      //sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
      while (pt) {
        next = pt._next;
        pt2 = first;

        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }

        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }

        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }

        pt = next;
      }

      pt = tween._firstPT = first;
    }

    while (pt) {
      if (pt.pg) if (typeof pt.t[type] === "function") if (pt.t[type]()) {
        changed = true;
      }
      pt = pt._next;
    }

    return changed;
  };

  TweenPlugin.activate = function (plugins) {
    var i = plugins.length;

    while (--i > -1) {
      if (plugins[i].API === TweenPlugin.API) {
        _plugins[new plugins[i]()._propName] = plugins[i];
      }
    }

    return true;
  }; //provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.


  _gsDefine.plugin = function (config) {
    if (!config || !config.propName || !config.init || !config.API) {
      throw "illegal plugin definition.";
    }

    var propName = config.propName,
        priority = config.priority || 0,
        overwriteProps = config.overwriteProps,
        map = {
      init: "_onInitTween",
      set: "setRatio",
      kill: "_kill",
      round: "_mod",
      mod: "_mod",
      initAll: "_onInitAllProps"
    },
        Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
      TweenPlugin.call(this, propName, priority);
      this._overwriteProps = overwriteProps || [];
    }, config.global === true),
        p = Plugin.prototype = new TweenPlugin(propName),
        prop;

    p.constructor = Plugin;
    Plugin.API = config.API;

    for (prop in map) {
      if (typeof config[prop] === "function") {
        p[map[prop]] = config[prop];
      }
    }

    Plugin.version = config.version;
    TweenPlugin.activate([Plugin]);
    return Plugin;
  }; //now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.


  a = window._gsQueue;

  if (a) {
    for (i = 0; i < a.length; i++) {
      a[i]();
    }

    for (p in _defLookup) {
      if (!_defLookup[p].func) {
        window.console.log("GSAP encountered missing dependency: " + p);
      }
    }
  }

  _tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

  return TweenLite;
}(_gsScope, "TweenLite");
var globals = _gsScope.GreenSockGlobals;
var nonGlobals = globals.com.greensock;

var SimpleTimeline = nonGlobals.core.SimpleTimeline;
var Animation = nonGlobals.core.Animation;
var Ease = globals.Ease;
var Linear = globals.Linear;
var Power0 = Linear;
var Power1 = globals.Power1;
var Power2 = globals.Power2;
var Power3 = globals.Power3;
var Power4 = globals.Power4;
var TweenPlugin = globals.TweenPlugin;
var EventDispatcher = nonGlobals.events.EventDispatcher;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module), __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./js/plugins/greensock/TweenMax.js":
/*!******************************************!*\
  !*** ./js/plugins/greensock/TweenMax.js ***!
  \******************************************/
/*! exports provided: TweenMax, default, TweenLite, TimelineLite, TimelineMax, CSSPlugin, AttrPlugin, BezierPlugin, DirectionalRotationPlugin, RoundPropsPlugin, TweenPlugin, Ease, Power0, Power1, Power2, Power3, Power4, Linear, Back, Elastic, Bounce, RoughEase, SlowMo, SteppedEase, Circ, Expo, Sine, ExpoScaleEase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return TweenMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TweenMax; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TweenPlugin", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["TweenPlugin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Ease", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power0"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Linear"]; });

/* harmony import */ var _TweenMaxBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TweenMaxBase.js */ "./js/plugins/greensock/TweenMaxBase.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CSSPlugin.js */ "./js/plugins/greensock/CSSPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _AttrPlugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AttrPlugin.js */ "./js/plugins/greensock/AttrPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AttrPlugin", function() { return _AttrPlugin_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _RoundPropsPlugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RoundPropsPlugin.js */ "./js/plugins/greensock/RoundPropsPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RoundPropsPlugin", function() { return _RoundPropsPlugin_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _DirectionalRotationPlugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DirectionalRotationPlugin.js */ "./js/plugins/greensock/DirectionalRotationPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DirectionalRotationPlugin", function() { return _DirectionalRotationPlugin_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _TimelineLite_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TimelineLite.js */ "./js/plugins/greensock/TimelineLite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return _TimelineLite_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _TimelineMax_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TimelineMax.js */ "./js/plugins/greensock/TimelineMax.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return _TimelineMax_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _BezierPlugin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BezierPlugin.js */ "./js/plugins/greensock/BezierPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BezierPlugin", function() { return _BezierPlugin_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _EasePack_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EasePack.js */ "./js/plugins/greensock/EasePack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Back"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Elastic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Bounce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RoughEase", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["RoughEase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SlowMo", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["SlowMo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["SteppedEase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Circ"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Expo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Sine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExpoScaleEase", function() { return _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["ExpoScaleEase"]; });

/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/









 //the following two lines are designed to prevent tree shaking of the classes that were historically included with TweenMax (otherwise, folks would have to reference CSSPlugin, for example, to ensure their CSS-related animations worked)

var TweenMax = _TweenMaxBase_js__WEBPACK_IMPORTED_MODULE_1__["default"];
TweenMax._autoActivated = [_TimelineLite_js__WEBPACK_IMPORTED_MODULE_6__["default"], _TimelineMax_js__WEBPACK_IMPORTED_MODULE_7__["default"], _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_2__["default"], _AttrPlugin_js__WEBPACK_IMPORTED_MODULE_3__["default"], _BezierPlugin_js__WEBPACK_IMPORTED_MODULE_8__["default"], _RoundPropsPlugin_js__WEBPACK_IMPORTED_MODULE_4__["default"], _DirectionalRotationPlugin_js__WEBPACK_IMPORTED_MODULE_5__["default"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Back"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Elastic"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Bounce"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["RoughEase"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["SlowMo"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["SteppedEase"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Circ"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Expo"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["Sine"], _EasePack_js__WEBPACK_IMPORTED_MODULE_9__["ExpoScaleEase"]];



/***/ }),

/***/ "./js/plugins/greensock/TweenMaxBase.js":
/*!**********************************************!*\
  !*** ./js/plugins/greensock/TweenMaxBase.js ***!
  \**********************************************/
/*! exports provided: TweenMax, TweenMaxBase, default, TweenLite, Ease, Power0, Power1, Power2, Power3, Power4, Linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return TweenMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMaxBase", function() { return TweenMaxBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TweenMax; });
/* harmony import */ var _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TweenLite.js */ "./js/plugins/greensock/TweenLite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Ease", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power0"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Power4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Linear"]; });

/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/


_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["_gsScope"]._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function () {
  var _slice = function (a) {
    //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
    var b = [],
        l = a.length,
        i;

    for (i = 0; i !== l; b.push(a[i++]));

    return b;
  },
      _applyCycle = function (vars, targets, i) {
    var alt = vars.cycle,
        p,
        val;

    for (p in alt) {
      val = alt[p];
      vars[p] = typeof val === "function" ? val(i, targets[i]) : val[i % val.length];
    }

    delete vars.cycle;
  },
      TweenMax = function (target, duration, vars) {
    _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, target, duration, vars);
    this._cycle = 0;
    this._yoyo = this.vars.yoyo === true || !!this.vars.yoyoEase;
    this._repeat = this.vars.repeat || 0;
    this._repeatDelay = this.vars.repeatDelay || 0;

    if (this._repeat) {
      this._uncache(true); //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.

    }

    this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
  },
      _tinyNum = 0.0000000001,
      TweenLiteInternals = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]._internals,
      _isSelector = TweenLiteInternals.isSelector,
      _isArray = TweenLiteInternals.isArray,
      p = TweenMax.prototype = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].to({}, 0.1, {}),
      _blankArray = [];

  TweenMax.version = "2.0.2";
  p.constructor = TweenMax;
  p.kill()._gc = false;
  TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].killTweensOf;
  TweenMax.getTweensOf = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].getTweensOf;
  TweenMax.lagSmoothing = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].lagSmoothing;
  TweenMax.ticker = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].ticker;
  TweenMax.render = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].render;

  p.invalidate = function () {
    this._yoyo = this.vars.yoyo === true || !!this.vars.yoyoEase;
    this._repeat = this.vars.repeat || 0;
    this._repeatDelay = this.vars.repeatDelay || 0;
    this._yoyoEase = null;

    this._uncache(true);

    return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.invalidate.call(this);
  };

  p.updateTo = function (vars, resetDuration) {
    var curRatio = this.ratio,
        immediate = this.vars.immediateRender || vars.immediateRender,
        p;

    if (resetDuration && this._startTime < this._timeline._time) {
      this._startTime = this._timeline._time;

      this._uncache(false);

      if (this._gc) {
        this._enabled(true, false);
      } else {
        this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.

      }
    }

    for (p in vars) {
      this.vars[p] = vars[p];
    }

    if (this._initted || immediate) {
      if (resetDuration) {
        this._initted = false;

        if (immediate) {
          this.render(0, true, true);
        }
      } else {
        if (this._gc) {
          this._enabled(true, false);
        }

        if (this._notifyPluginsOfEnabled && this._firstPT) {
          _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks

        }

        if (this._time / this._duration > 0.998) {
          //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards.
          var prevTime = this._totalTime;
          this.render(0, true, false);
          this._initted = false;
          this.render(prevTime, true, false);
        } else {
          this._initted = false;

          this._init();

          if (this._time > 0 || immediate) {
            var inv = 1 / (1 - curRatio),
                pt = this._firstPT,
                endValue;

            while (pt) {
              endValue = pt.s + pt.c;
              pt.c *= inv;
              pt.s = endValue - pt.c;
              pt = pt._next;
            }
          }
        }
      }
    }

    return this;
  };

  p.render = function (time, suppressEvents, force) {
    if (!this._initted) if (this._duration === 0 && this.vars.repeat) {
      //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
      this.invalidate();
    }
    var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
        prevTime = this._time,
        prevTotalTime = this._totalTime,
        prevCycle = this._cycle,
        duration = this._duration,
        prevRawPrevTime = this._rawPrevTime,
        isComplete,
        callback,
        pt,
        cycleDuration,
        r,
        type,
        pow,
        rawPrevTime,
        yoyoEase;

    if (time >= totalDur - 0.0000001 && time >= 0) {
      //to work around occasional floating point math artifacts.
      this._totalTime = totalDur;
      this._cycle = this._repeat;

      if (this._yoyo && (this._cycle & 1) !== 0) {
        this._time = 0;
        this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
      } else {
        this._time = duration;
        this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
      }

      if (!this._reversed) {
        isComplete = true;
        callback = "onComplete";
        force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
      }

      if (duration === 0) if (this._initted || !this.vars.lazy || force) {
        //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
        if (this._startTime === this._timeline._duration) {
          //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
          time = 0;
        }

        if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
          //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
          force = true;

          if (prevRawPrevTime > _tinyNum) {
            callback = "onReverseComplete";
          }
        }
        this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
      }
    } else if (time < 0.0000001) {
      //to work around occasional floating point math artifacts, round super small values to 0.
      this._totalTime = this._time = this._cycle = 0;
      this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;

      if (prevTotalTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
        callback = "onReverseComplete";
        isComplete = this._reversed;
      }

      if (time < 0) {
        this._active = false;
        if (duration === 0) if (this._initted || !this.vars.lazy || force) {
          //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
          if (prevRawPrevTime >= 0) {
            force = true;
          }

          this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        }
      }

      if (!this._initted) {
        //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
        force = true;
      }
    } else {
      this._totalTime = this._time = time;

      if (this._repeat !== 0) {
        cycleDuration = duration + this._repeatDelay;
        this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
          this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
        }
        this._time = this._totalTime - this._cycle * cycleDuration;
        if (this._yoyo) if ((this._cycle & 1) !== 0) {
          this._time = duration - this._time;
          yoyoEase = this._yoyoEase || this.vars.yoyoEase; //note: we don't set this._yoyoEase in _init() like we do other properties because it's TweenMax-specific and doing it here allows us to optimize performance (most tweens don't have a yoyoEase). Note that we also must skip the this.ratio calculation further down right after we _init() in this function, because we're doing it here.

          if (yoyoEase) {
            if (!this._yoyoEase) {
              if (yoyoEase === true && !this._initted) {
                //if it's not initted and yoyoEase is true, this._ease won't have been populated yet so we must discern it here.
                yoyoEase = this.vars.ease;
                this._yoyoEase = yoyoEase = !yoyoEase ? _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].defaultEase : yoyoEase instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"] ? yoyoEase : typeof yoyoEase === "function" ? new _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"](yoyoEase, this.vars.easeParams) : _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"].map[yoyoEase] || _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].defaultEase;
              } else {
                this._yoyoEase = yoyoEase = yoyoEase === true ? this._ease : yoyoEase instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"] ? yoyoEase : _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Ease"].map[yoyoEase];
              }
            }

            this.ratio = yoyoEase ? 1 - yoyoEase.getRatio((duration - this._time) / duration) : 0;
          }
        }

        if (this._time > duration) {
          this._time = duration;
        } else if (this._time < 0) {
          this._time = 0;
        }
      }

      if (this._easeType && !yoyoEase) {
        r = this._time / duration;
        type = this._easeType;
        pow = this._easePower;

        if (type === 1 || type === 3 && r >= 0.5) {
          r = 1 - r;
        }

        if (type === 3) {
          r *= 2;
        }

        if (pow === 1) {
          r *= r;
        } else if (pow === 2) {
          r *= r * r;
        } else if (pow === 3) {
          r *= r * r * r;
        } else if (pow === 4) {
          r *= r * r * r * r;
        }

        if (type === 1) {
          this.ratio = 1 - r;
        } else if (type === 2) {
          this.ratio = r;
        } else if (this._time / duration < 0.5) {
          this.ratio = r / 2;
        } else {
          this.ratio = 1 - r / 2;
        }
      } else if (!yoyoEase) {
        this.ratio = this._ease.getRatio(this._time / duration);
      }
    }

    if (prevTime === this._time && !force && prevCycle === this._cycle) {
      if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
        //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
        this._callback("onUpdate");
      }
      return;
    } else if (!this._initted) {
      this._init();

      if (!this._initted || this._gc) {
        //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
        return;
      } else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
        //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
        this._time = prevTime;
        this._totalTime = prevTotalTime;
        this._rawPrevTime = prevRawPrevTime;
        this._cycle = prevCycle;
        TweenLiteInternals.lazyTweens.push(this);
        this._lazy = [time, suppressEvents];
        return;
      } //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.


      if (this._time && !isComplete && !yoyoEase) {
        this.ratio = this._ease.getRatio(this._time / duration);
      } else if (isComplete && this._ease._calcEnd && !yoyoEase) {
        this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
      }
    }

    if (this._lazy !== false) {
      this._lazy = false;
    }

    if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
      this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
    }

    if (prevTotalTime === 0) {
      if (this._initted === 2 && time > 0) {
        //this.invalidate();
        this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true

      }

      if (this._startAt) {
        if (time >= 0) {
          this._startAt.render(time, true, force);
        } else if (!callback) {
          callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
        }
      }

      if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
        this._callback("onStart");
      }
    }

    pt = this._firstPT;

    while (pt) {
      if (pt.f) {
        pt.t[pt.p](pt.c * this.ratio + pt.s);
      } else {
        pt.t[pt.p] = pt.c * this.ratio + pt.s;
      }

      pt = pt._next;
    }

    if (this._onUpdate) {
      if (time < 0) if (this._startAt && this._startTime) {
        //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
        this._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

      }
      if (!suppressEvents) if (this._totalTime !== prevTotalTime || callback) {
        this._callback("onUpdate");
      }
    }

    if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
      this._callback("onRepeat");
    }
    if (callback) if (!this._gc || force) {
      //check gc because there's a chance that kill() could be called in an onUpdate
      if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
        //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
        this._startAt.render(time, true, force);
      }

      if (isComplete) {
        if (this._timeline.autoRemoveChildren) {
          this._enabled(false, false);
        }

        this._active = false;
      }

      if (!suppressEvents && this.vars[callback]) {
        this._callback(callback);
      }

      if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
        //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
        this._rawPrevTime = 0;
      }
    }
  }; //---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------


  TweenMax.to = function (target, duration, vars) {
    return new TweenMax(target, duration, vars);
  };

  TweenMax.from = function (target, duration, vars) {
    vars.runBackwards = true;
    vars.immediateRender = vars.immediateRender != false;
    return new TweenMax(target, duration, vars);
  };

  TweenMax.fromTo = function (target, duration, fromVars, toVars) {
    toVars.startAt = fromVars;
    toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
    return new TweenMax(target, duration, toVars);
  };

  TweenMax.staggerTo = TweenMax.allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
    stagger = stagger || 0;

    var delay = 0,
        a = [],
        finalComplete = function () {
      if (vars.onComplete) {
        vars.onComplete.apply(vars.onCompleteScope || this, arguments);
      }

      onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
    },
        cycle = vars.cycle,
        fromCycle = vars.startAt && vars.startAt.cycle,
        l,
        copy,
        i,
        p;

    if (!_isArray(targets)) {
      if (typeof targets === "string") {
        targets = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].selector(targets) || targets;
      }

      if (_isSelector(targets)) {
        targets = _slice(targets);
      }
    }

    targets = targets || [];

    if (stagger < 0) {
      targets = _slice(targets);
      targets.reverse();
      stagger *= -1;
    }

    l = targets.length - 1;

    for (i = 0; i <= l; i++) {
      copy = {};

      for (p in vars) {
        copy[p] = vars[p];
      }

      if (cycle) {
        _applyCycle(copy, targets, i);

        if (copy.duration != null) {
          duration = copy.duration;
          delete copy.duration;
        }
      }

      if (fromCycle) {
        fromCycle = copy.startAt = {};

        for (p in vars.startAt) {
          fromCycle[p] = vars.startAt[p];
        }

        _applyCycle(copy.startAt, targets, i);
      }

      copy.delay = delay + (copy.delay || 0);

      if (i === l && onCompleteAll) {
        copy.onComplete = finalComplete;
      }

      a[i] = new TweenMax(targets[i], duration, copy);
      delay += stagger;
    }

    return a;
  };

  TweenMax.staggerFrom = TweenMax.allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
    vars.runBackwards = true;
    vars.immediateRender = vars.immediateRender != false;
    return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
  };

  TweenMax.staggerFromTo = TweenMax.allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
    toVars.startAt = fromVars;
    toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
    return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
  };

  TweenMax.delayedCall = function (delay, callback, params, scope, useFrames) {
    return new TweenMax(callback, 0, {
      delay: delay,
      onComplete: callback,
      onCompleteParams: params,
      callbackScope: scope,
      onReverseComplete: callback,
      onReverseCompleteParams: params,
      immediateRender: false,
      useFrames: useFrames,
      overwrite: 0
    });
  };

  TweenMax.set = function (target, vars) {
    return new TweenMax(target, 0, vars);
  };

  TweenMax.isTweening = function (target) {
    return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].getTweensOf(target, true).length > 0;
  };

  var _getChildrenOf = function (timeline, includeTimelines) {
    var a = [],
        cnt = 0,
        tween = timeline._first;

    while (tween) {
      if (tween instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
        a[cnt++] = tween;
      } else {
        if (includeTimelines) {
          a[cnt++] = tween;
        }

        a = a.concat(_getChildrenOf(tween, includeTimelines));
        cnt = a.length;
      }

      tween = tween._next;
    }

    return a;
  },
      getAllTweens = TweenMax.getAllTweens = function (includeTimelines) {
    return _getChildrenOf(_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"]._rootTimeline, includeTimelines).concat(_getChildrenOf(_TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"]._rootFramesTimeline, includeTimelines));
  };

  TweenMax.killAll = function (complete, tweens, delayedCalls, timelines) {
    if (tweens == null) {
      tweens = true;
    }

    if (delayedCalls == null) {
      delayedCalls = true;
    }

    var a = getAllTweens(timelines != false),
        l = a.length,
        allTrue = tweens && delayedCalls && timelines,
        isDC,
        tween,
        i;

    for (i = 0; i < l; i++) {
      tween = a[i];

      if (allTrue || tween instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["SimpleTimeline"] || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
        if (complete) {
          tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
        } else {
          tween._enabled(false, false);
        }
      }
    }
  };

  TweenMax.killChildTweensOf = function (parent, complete) {
    if (parent == null) {
      return;
    }

    var tl = TweenLiteInternals.tweenLookup,
        a,
        curParent,
        p,
        i,
        l;

    if (typeof parent === "string") {
      parent = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].selector(parent) || parent;
    }

    if (_isSelector(parent)) {
      parent = _slice(parent);
    }

    if (_isArray(parent)) {
      i = parent.length;

      while (--i > -1) {
        TweenMax.killChildTweensOf(parent[i], complete);
      }

      return;
    }

    a = [];

    for (p in tl) {
      curParent = tl[p].target.parentNode;

      while (curParent) {
        if (curParent === parent) {
          a = a.concat(tl[p].tweens);
        }

        curParent = curParent.parentNode;
      }
    }

    l = a.length;

    for (i = 0; i < l; i++) {
      if (complete) {
        a[i].totalTime(a[i].totalDuration());
      }

      a[i]._enabled(false, false);
    }
  };

  var _changePause = function (pause, tweens, delayedCalls, timelines) {
    tweens = tweens !== false;
    delayedCalls = delayedCalls !== false;
    timelines = timelines !== false;
    var a = getAllTweens(timelines),
        allTrue = tweens && delayedCalls && timelines,
        i = a.length,
        isDC,
        tween;

    while (--i > -1) {
      tween = a[i];

      if (allTrue || tween instanceof _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["SimpleTimeline"] || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
        tween.paused(pause);
      }
    }
  };

  TweenMax.pauseAll = function (tweens, delayedCalls, timelines) {
    _changePause(true, tweens, delayedCalls, timelines);
  };

  TweenMax.resumeAll = function (tweens, delayedCalls, timelines) {
    _changePause(false, tweens, delayedCalls, timelines);
  };

  TweenMax.globalTimeScale = function (value) {
    var tl = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"]._rootTimeline,
        t = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].ticker.time;

    if (!arguments.length) {
      return tl._timeScale;
    }

    value = value || _tinyNum; //can't allow zero because it'll throw the math off

    tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
    tl = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"]._rootFramesTimeline;
    t = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["default"].ticker.frame;
    tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
    tl._timeScale = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"]._rootTimeline._timeScale = value;
    return value;
  }; //---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------


  p.progress = function (value, suppressEvents) {
    return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
  };

  p.totalProgress = function (value, suppressEvents) {
    return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
  };

  p.time = function (value, suppressEvents) {
    if (!arguments.length) {
      return this._time;
    }

    if (this._dirty) {
      this.totalDuration();
    }

    if (value > this._duration) {
      value = this._duration;
    }

    if (this._yoyo && (this._cycle & 1) !== 0) {
      value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
    } else if (this._repeat !== 0) {
      value += this._cycle * (this._duration + this._repeatDelay);
    }

    return this.totalTime(value, suppressEvents);
  };

  p.duration = function (value) {
    if (!arguments.length) {
      return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
    }

    return _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["Animation"].prototype.duration.call(this, value);
  };

  p.totalDuration = function (value) {
    if (!arguments.length) {
      if (this._dirty) {
        //instead of Infinity, we use 999999999999 so that we can accommodate reverses
        this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
        this._dirty = false;
      }

      return this._totalDuration;
    }

    return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1));
  };

  p.repeat = function (value) {
    if (!arguments.length) {
      return this._repeat;
    }

    this._repeat = value;
    return this._uncache(true);
  };

  p.repeatDelay = function (value) {
    if (!arguments.length) {
      return this._repeatDelay;
    }

    this._repeatDelay = value;
    return this._uncache(true);
  };

  p.yoyo = function (value) {
    if (!arguments.length) {
      return this._yoyo;
    }

    this._yoyo = value;
    return this;
  };

  return TweenMax;
}, true);

var TweenMax = _TweenLite_js__WEBPACK_IMPORTED_MODULE_0__["globals"].TweenMax;
var TweenMaxBase = TweenMax;



/***/ }),

/***/ "./js/plugins/hammer/hammer-custom.js":
/*!********************************************!*\
  !*** ./js/plugins/hammer/hammer-custom.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// AH - Tue 21/02/17 this file was updated with our custom code from previous version

/* Hammer.JS - v2.0.7 - 2016-04-21 */
(function (window, document, exportName, undefined) {
  'use strict';

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');
  var TYPE_FUNCTION = 'function';
  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;
  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */

  function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
  }
  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */


  function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }

    return false;
  }
  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */


  function each(obj, iterator, context) {
    var i;

    if (!obj) {
      return;
    }

    if (obj.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
      i = 0;

      while (i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for (i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }
  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */


  function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function () {
      var e = new Error('get-stack-trace');
      var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
      var log = window.console && (window.console.warn || window.console.log);

      if (log) {
        log.call(window.console, deprecationMessage, stack);
      }

      return method.apply(this, arguments);
    };
  }
  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */


  var assign;

  if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];

        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }

      return output;
    };
  } else {
    assign = Object.assign;
  }
  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */


  var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;

    while (i < keys.length) {
      if (!merge || merge && dest[keys[i]] === undefined) {
        dest[keys[i]] = src[keys[i]];
      }

      i++;
    }

    return dest;
  }, 'extend', 'Use `assign`.');
  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */

  var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');
  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */

  function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
      assign(childP, properties);
    }
  }
  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */


  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }
  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */


  function boolOrFn(val, args) {
    if (_typeof(val) == TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }

    return val;
  }
  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */


  function ifUndefined(val1, val2) {
    return val1 === undefined ? val2 : val1;
  }
  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function addEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.addEventListener(type, handler, false);
    });
  }
  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.removeEventListener(type, handler, false);
    });
  }
  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */


  function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }

      node = node.parentNode;
    }

    return false;
  }
  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */


  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }
  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */


  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }
  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */


  function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;

      while (i < src.length) {
        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
          return i;
        }

        i++;
      }

      return -1;
    }
  }
  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */


  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }
  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */


  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
      var val = key ? src[i][key] : src[i];

      if (inArray(values, val) < 0) {
        results.push(src[i]);
      }

      values[i] = val;
      i++;
    }

    if (sort) {
      if (!key) {
        results = results.sort();
      } else {
        results = results.sort(function sortUniqueArray(a, b) {
          return a[key] > b[key];
        });
      }
    }

    return results;
  }
  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */


  function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;

    while (i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = prefix ? prefix + camelProp : property;

      if (prop in obj) {
        return prop;
      }

      i++;
    }

    return undefined;
  }
  /**
   * get a unique id
   * @returns {number} uniqueId
   */


  var _uniqueId = 1;

  function uniqueId() {
    return _uniqueId++;
  }
  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */


  function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return doc.defaultView || doc.parentWindow || window;
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  var SUPPORT_TOUCH = 'ontouchstart' in window; // annam protoio disable pointer events
  //var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;

  var SUPPORT_POINTER_EVENTS = false;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';
  var COMPUTE_INTERVAL = 25;
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;
  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;
  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];
  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */

  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.

    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };

    this.init();
  }

  Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function handler() {},

    /**
     * bind the events
     */
    init: function init() {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function destroy() {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  };
  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */

  function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
      Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
      Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
      Type = MouseInput;
    } else {
      Type = TouchMouseInput;
    }

    return new Type(manager, inputHandler);
  }
  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */


  function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
      manager.session = {};
    } // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'


    input.eventType = eventType; // compute scale, rotation etc

    computeInputData(manager, input); // emit secret event

    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
  }
  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */


  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length; // store the first input to calculate the distance and direction

    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    } // to compute scale and rotation we need to store the multiple touches


    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
    computeIntervalInputData(session, input); // find the correct target

    var target = manager.element;

    if (hasParent(input.srcEvent.target, target)) {
      target = input.srcEvent.target;
    }

    input.target = target;
  }

  function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }
  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */


  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity,
        velocityX,
        velocityY,
        direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = input.deltaX - last.deltaX;
      var deltaY = input.deltaY - last.deltaY;
      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      // use latest velocity info if it doesn't overtake a minimum period
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }
  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */


  function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;

    while (i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }

    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }
  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */


  function getCenter(pointers) {
    var pointersLength = pointers.length; // no need to loop when only one touch

    if (pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }

    var x = 0,
        y = 0,
        i = 0;

    while (i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }

    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }
  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */


  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }
  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */


  function getDirection(x, y) {
    if (x === y) {
      return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }

    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }
  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */


  function getDistance(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */


  function getAngle(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }
  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */


  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }
  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */


  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */

  function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }

      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      } // mouse must be down


      if (!this.pressed) {
        return;
      }

      if (eventType & INPUT_END) {
        this.pressed = false;
      }

      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    }
  });
  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  }; // in IE10 the pointer types is defined as an enum

  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

  };
  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

  if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }
  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */


  function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    Input.apply(this, arguments);
    this.store = this.manager.session.pointerEvents = [];
  }

  inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store

      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      } // it not found, so the pointer hasn't been down (so it's probably a hover)


      if (storeIndex < 0) {
        return;
      } // update the event in the store


      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });

      if (removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    }
  });
  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * Touch events input
   * @constructor
   * @extends Input
   */

  function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;
    Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

      if (type === INPUT_START) {
        this.started = true;
      }

      if (!this.started) {
        return;
      }

      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });
  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */

  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */

  function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};
    Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);

      if (!touches) {
        return;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });
  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */

  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target; // get target touches from touches

    targetTouches = allTouches.filter(function (touch) {
      return hasParent(touch.target, target);
    }); // collect touches

    if (type === INPUT_START) {
      i = 0;

      while (i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    } // filter changed touches to only contain touches that exist in the collected target ids


    i = 0;

    while (i < changedTouches.length) {
      if (targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      } // cleanup removed touches


      if (type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }

      i++;
    }

    if (!changedTargetTouches.length) {
      return;
    }

    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
  }
  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */


  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;

  function TouchMouseInput() {
    Input.apply(this, arguments);
    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
    this.primaryTouch = null;
    this.lastTouches = [];
  }

  inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;

      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
        return;
      } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


      if (isTouch) {
        recordTouches.call(this, inputEvent, inputData);
      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
        return;
      }

      this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    }
  });

  function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
      this.primaryTouch = eventData.changedPointers[0].identifier;
      setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      setLastTouch.call(this, eventData);
    }
  }

  function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
      var lastTouch = {
        x: touch.clientX,
        y: touch.clientY
      };
      this.lastTouches.push(lastTouch);
      var lts = this.lastTouches;

      var removeLastTouch = function removeLastTouch() {
        var i = lts.indexOf(lastTouch);

        if (i > -1) {
          lts.splice(i, 1);
        }
      };

      setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
  }

  function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX,
        y = eventData.srcEvent.clientY;

    for (var i = 0; i < this.lastTouches.length; i++) {
      var t = this.lastTouches[i];
      var dx = Math.abs(x - t.x),
          dy = Math.abs(y - t.y);

      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
        return true;
      }
    }

    return false;
  }

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value

  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */

  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }

  TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function set(value) {
      // find out the touch-action by the event handlers
      if (value == TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }

      if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }

      this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function update() {
      this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function compute() {
      var actions = [];
      each(this.manager.recognizers, function (recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function preventDefaults(input) {
      // not needed with native support for the touchAction property
      if (NATIVE_TOUCH_ACTION) {
        return;
      }

      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection; // if the touch action did prevented once this session

      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }

      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

      if (hasNone) {
        //do not prevent defaults if this is a tap gesture
        var isTapPointer = input.pointers.length === 1;
        var isTapMovement = input.distance < 2;
        var isTapTouchTime = input.deltaTime < 250;

        if (isTapPointer && isTapMovement && isTapTouchTime) {
          return;
        }
      }

      if (hasPanX && hasPanY) {
        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
        return;
      }

      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
        return this.preventSrc(srcEvent);
      }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function preventSrc(srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    }
  };
  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */

  function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning

    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_NONE;
    } // pan-x OR pan-y


    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    } // manipulation


    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
  }
  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */


  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;
  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */

  function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});
    this.id = uniqueId();
    this.manager = null; // default is enable true

    this.options.enable = ifUndefined(this.options.enable, true);
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }

  Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function set(options) {
      assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

      this.manager && this.manager.touchAction.update();
      return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function recognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }

      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }

      return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function requireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }

      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }

      return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function dropRequireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);

      if (index > -1) {
        this.requireFail.splice(index, 1);
      }

      return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function hasRequireFailures() {
      return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function canRecognizeWith(otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function emit(input) {
      var self = this;
      var state = this.state;

      function emit(event) {
        self.manager.emit(event, input);
      } // 'panstart' and 'panmove'


      if (state < STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }

      emit(self.options.event); // simple 'eventName' events

      if (input.additionalEvent) {
        // additional event(panleft, panright, pinchin, pinchout...)
        emit(input.additionalEvent);
      } // panend and pancancel


      if (state >= STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function tryEmit(input) {
      if (this.canEmit()) {
        return this.emit(input);
      } // it's failing anyway


      this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function canEmit() {
      var i = 0;

      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }

        i++;
      }

      return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function recognize(inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?

      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      } // reset when we've reached the end


      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }

      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
      // so trigger an event

      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function process(inputData) {},
    // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function getTouchAction() {},

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function reset() {}
  };
  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */

  function stateStr(state) {
    if (state & STATE_CANCELLED) {
      return 'cancel';
    } else if (state & STATE_ENDED) {
      return 'end';
    } else if (state & STATE_CHANGED) {
      return 'move';
    } else if (state & STATE_BEGAN) {
      return 'start';
    }

    return '';
  }
  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */


  function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
      return 'down';
    } else if (direction == DIRECTION_UP) {
      return 'up';
    } else if (direction == DIRECTION_LEFT) {
      return 'left';
    } else if (direction == DIRECTION_RIGHT) {
      return 'right';
    }

    return '';
  }
  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */


  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;

    if (manager) {
      return manager.get(otherRecognizer);
    }

    return otherRecognizer;
  }
  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */


  function AttrRecognizer() {
    Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
      /**
       * @type {Number}
       * @default 1
       */
      pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function attrTest(input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function process(input) {
      var state = this.state;
      var eventType = input.eventType;
      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }

        return state | STATE_CHANGED;
      }

      return STATE_FAILED;
    }
  });
  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */

  function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);
    this.pX = null;
    this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    },
    getTouchAction: function getTouchAction() {
      var direction = this.options.direction;
      var actions = [];

      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }

      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }

      return actions;
    },
    directionTest: function directionTest(input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY; // lock to axis?

      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x != this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y != this.pY;
          distance = Math.abs(input.deltaY);
        }
      }

      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    },
    attrTest: function attrTest(input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
    },
    emit: function emit(input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      var direction = directionStr(input.direction);

      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }

      this._super.emit.call(this, input);
    }
  });
  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */

  function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'pinch',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function attrTest(input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },
    emit: function emit(input) {
      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        input.additionalEvent = this.options.event + inOut;
      }

      this._super.emit.call(this, input);
    }
  });
  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */

  function PressRecognizer() {
    Recognizer.apply(this, arguments);
    this._timer = null;
    this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
      event: 'press',
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9 // a minimal movement is ok, but keep it low

    },
    getTouchAction: function getTouchAction() {
      return [TOUCH_ACTION_AUTO];
    },
    process: function process(input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;
      this._input = input; // we only allow little movement
      // and we've reached an end event, so a tap is possible

      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeoutContext(function () {
          this.state = STATE_RECOGNIZED;
          this.tryEmit();
        }, options.time, this);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }

      return STATE_FAILED;
    },
    reset: function reset() {
      clearTimeout(this._timer);
    },
    emit: function emit(input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }

      if (input && input.eventType & INPUT_END) {
        this.manager.emit(this.options.event + 'up', input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */

  function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
      event: 'rotate',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function attrTest(input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
  });
  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */

  function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    },
    getTouchAction: function getTouchAction() {
      return PanRecognizer.prototype.getTouchAction.call(this);
    },
    attrTest: function attrTest(input) {
      var direction = this.options.direction;
      var velocity;

      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.overallVelocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.overallVelocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.overallVelocityY;
      }

      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },
    emit: function emit(input) {
      var direction = directionStr(input.offsetDirection);

      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this.manager.emit(this.options.event, input);
    }
  });
  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */

  function TapRecognizer() {
    Recognizer.apply(this, arguments); // previous time and center,
    // used for tap counting

    this.pTime = false;
    this.pCenter = false;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10 // a multi-tap can be a bit off the initial position

    },
    getTouchAction: function getTouchAction() {
      return [TOUCH_ACTION_MANIPULATION];
    },
    process: function process(input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;
      this.reset();

      if (input.eventType & INPUT_START && this.count === 0) {
        return this.failTimeout();
      } // we only allow little movement
      // and we've reached an end event, so a tap is possible


      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType != INPUT_END) {
          return this.failTimeout();
        }

        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;

        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }

        this._input = input; // if tap count matches we have recognized it,
        // else it has began recognizing...

        var tapCount = this.count % options.taps;

        if (tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.interval, this);
            return STATE_BEGAN;
          }
        }
      }

      return STATE_FAILED;
    },
    failTimeout: function failTimeout() {
      this._timer = setTimeoutContext(function () {
        this.state = STATE_FAILED;
      }, this.options.interval, this);
      return STATE_FAILED;
    },
    reset: function reset() {
      clearTimeout(this._timer);
    },
    emit: function emit() {
      if (this.state == STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */

  function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
  }
  /**
   * @const {string}
   */


  Hammer.VERSION = '2.0.7';
  /**
   * default settings
   * @namespace
   */

  Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
    [RotateRecognizer, {
      enable: false
    }], [PinchRecognizer, {
      enable: false
    }, ['rotate']], [SwipeRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }], [PanRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }, ['swipe']], [TapRecognizer], [TapRecognizer, {
      event: 'doubletap',
      taps: 2
    }, ['tap']], [PressRecognizer]],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: 'none',

      /**
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: 'none',

      /**
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: 'none',

      /**
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: 'none',

      /**
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: 'none',

      /**
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: 'rgba(0,0,0,0)'
    }
  };
  var STOP = 1;
  var FORCED_STOP = 2;
  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */

  function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
      var recognizer = this.add(new item[0](item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }

  Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function set(options) {
      assign(this.options, options); // Options that need a little more setup

      if (options.touchAction) {
        this.touchAction.update();
      }

      if (options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }

      return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function stop(force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function recognize(inputData) {
      var session = this.session;

      if (session.stopped) {
        return;
      } // run the touch-action polyfill


      this.touchAction.preventDefaults(inputData);
      var recognizer;
      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`

      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
      // or when we're in a new session

      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
        curRecognizer = session.curRecognizer = null;
      }

      var i = 0;

      while (i < recognizers.length) {
        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.

        if (session.stopped !== FORCED_STOP && ( // 1
        !curRecognizer || recognizer == curRecognizer || // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer


        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          curRecognizer = session.curRecognizer = recognizer;
        }

        i++;
      }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function get(recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }

      var recognizers = this.recognizers;

      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event == recognizer) {
          return recognizers[i];
        }
      }

      return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function add(recognizer) {
      if (invokeArrayArg(recognizer, 'add', this)) {
        return this;
      } // remove existing


      var existing = this.get(recognizer.options.event);

      if (existing) {
        this.remove(existing);
      }

      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function remove(recognizer) {
      if (invokeArrayArg(recognizer, 'remove', this)) {
        return this;
      }

      recognizer = this.get(recognizer); // let's make sure this recognizer exists

      if (recognizer) {
        var recognizers = this.recognizers;
        var index = inArray(recognizers, recognizer);

        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }

      return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function on(events, handler) {
      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function off(events, handler) {
      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function emit(event, data) {
      // we also want to trigger dom events
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      } // no handlers, so skip it all


      var handlers = this.handlers[event] && this.handlers[event].slice();

      if (!handlers || !handlers.length) {
        return;
      }

      data.type = event;

      data.preventDefault = function () {
        data.srcEvent.preventDefault();
      };

      var i = 0;

      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function destroy() {
      this.element && toggleCssProps(this, false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
  };
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */

  function toggleCssProps(manager, add) {
    var element = manager.element;

    if (!element.style) {
      return;
    }

    each(manager.options.cssProps, function (value, name) {
      element.style[prefixed(element.style, name)] = add ? value : '';
    });
  }
  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */


  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }

  assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,
    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,
    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,
    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,
    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,
    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,
    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
  }); // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.

  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line

  freeGlobal.Hammer = Hammer;

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return Hammer;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(window, document, 'Hammer');

/***/ }),

/***/ "./js/plugins/hammer/jquery.hammer-custom.js":
/*!***************************************************!*\
  !*** ./js/plugins/hammer/jquery.hammer-custom.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($, Hammer, dataAttr) {
  // annam - removing. couldnt find solution for events being triggered twice due to domEvents: true
  //Hammer = propagating(Hammer);   // AH - make hammer propagating
  function hammerify(el, options) {
    var $el = $(el);

    if (!$el.data(dataAttr)) {
      $el.data(dataAttr, new Hammer($el[0], options));
    }
  }

  $.fn.hammer = function (options) {
    // AH - need domEvents=true for propagating to work, otherwise clicks don't trigger
    // annam - removing. couldnt find solution for events being triggered twice due to domEvents: true
    //options = Object.assign({}, {domEvents: true}, options);
    return this.each(function () {
      hammerify(this, options);
    });
  }; // extend the emit method to also trigger jQuery events


  Hammer.Manager.prototype.emit = function (originalEmit) {
    return function (type, data) {
      originalEmit.call(this, type, data);
      jQuery(this.element).triggerHandler({
        type: type,
        gesture: data
      });
    };
  }(Hammer.Manager.prototype.emit);
})(jQuery, Hammer, "hammer");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./js/plugins/hammer/propagating-hammer/propagating.js":
/*!*************************************************************!*\
  !*** ./js/plugins/hammer/propagating-hammer/propagating.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function () {
  var _firstTarget = null; // singleton, will contain the target element where the touch event started

  /**
   * Extend an Hammer.js instance with event propagation.
   *
   * Features:
   * - Events emitted by hammer will propagate in order from child to parent
   *   elements.
   * - Events are extended with a function `event.stopPropagation()` to stop
   *   propagation to parent elements.
   * - An option `preventDefault` to stop all default browser behavior.
   *
   * Usage:
   *   var hammer = propagatingHammer(new Hammer(element));
   *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
   *
   * @param {Hammer.Manager} hammer   An hammer instance.
   * @param {Object} [options]        Available options:
   *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
   *                                    Enforce preventing the default browser behavior.
   *                                    Cannot be set to `false`.
   * @return {Hammer.Manager} Returns the same hammer instance with extended
   *                          functionality
   */

  return function propagating(hammer, options) {
    var _options = options || {
      preventDefault: false
    };

    if (hammer.Manager) {
      // This looks like the Hammer constructor.
      // Overload the constructors with our own.
      var Hammer = hammer;

      var PropagatingHammer = function PropagatingHammer(element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer(element, o), o);
      };

      Hammer.assign(PropagatingHammer, Hammer);

      PropagatingHammer.Manager = function (element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer.Manager(element, o), o);
      };

      return PropagatingHammer;
    } // create a wrapper object which will override the functions
    // `on`, `off`, `destroy`, and `emit` of the hammer instance


    var wrapper = Object.create(hammer); // attach to DOM element

    var element = hammer.element;
    if (!element.hammer) element.hammer = [];
    element.hammer.push(wrapper); // register an event to catch the start of a gesture and store the
    // target in a singleton

    hammer.on('hammer.input', function (event) {
      if (_options.preventDefault === true || _options.preventDefault === event.pointerType) {
        event.preventDefault();
      }

      if (event.isFirst) {
        _firstTarget = event.target;
      }
    });
    /** @type {Object.<String, Array.<function>>} */

    wrapper._handlers = {};
    /**
     * Register a handler for one or multiple events
     * @param {String} events    A space separated string with events
     * @param {function} handler A callback function, called as handler(event)
     * @returns {Hammer.Manager} Returns the hammer instance
     */

    wrapper.on = function (events, handler) {
      // register the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];

        if (!_handlers) {
          wrapper._handlers[event] = _handlers = []; // register the static, propagated handler

          hammer.on(event, propagatedHandler);
        }

        _handlers.push(handler);
      });
      return wrapper;
    };
    /**
     * Unregister a handler for one or multiple events
     * @param {String} events      A space separated string with events
     * @param {function} [handler] Optional. The registered handler. If not
     *                             provided, all handlers for given events
     *                             are removed.
     * @returns {Hammer.Manager}   Returns the hammer instance
     */


    wrapper.off = function (events, handler) {
      // unregister the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];

        if (_handlers) {
          _handlers = handler ? _handlers.filter(function (h) {
            return h !== handler;
          }) : [];

          if (_handlers.length > 0) {
            wrapper._handlers[event] = _handlers;
          } else {
            // remove static, propagated handler
            hammer.off(event, propagatedHandler);
            delete wrapper._handlers[event];
          }
        }
      });
      return wrapper;
    };
    /**
     * Emit to the event listeners
     * @param {string} eventType
     * @param {Event} event
     */


    wrapper.emit = function (eventType, event) {
      _firstTarget = event.target;
      hammer.emit(eventType, event);
    };

    wrapper.destroy = function () {
      // Detach from DOM element
      var hammers = hammer.element.hammer;
      var idx = hammers.indexOf(wrapper);
      if (idx !== -1) hammers.splice(idx, 1);
      if (!hammers.length) delete hammer.element.hammer; // clear all handlers

      wrapper._handlers = {}; // call original hammer destroy

      hammer.destroy();
    }; // split a string with space separated words


    function split(events) {
      return events.match(/[^ ]+/g);
    }
    /**
     * A static event handler, applying event propagation.
     * @param {Object} event
     */


    function propagatedHandler(event) {
      // let only a single hammer instance handle this event
      if (event.type !== 'hammer.input') {
        // it is possible that the same srcEvent is used with multiple hammer events,
        // we keep track on which events are handled in an object _handled
        if (!event.srcEvent._handled) {
          event.srcEvent._handled = {};
        }

        if (event.srcEvent._handled[event.type]) {
          return;
        } else {
          event.srcEvent._handled[event.type] = true;
        }
      } // attach a stopPropagation function to the event


      var stopped = false;

      event.stopPropagation = function () {
        stopped = true;
      }; //wrap the srcEvent's stopPropagation to also stop hammer propagation:


      var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);

      if (typeof srcStop == "function") {
        event.srcEvent.stopPropagation = function () {
          srcStop();
          event.stopPropagation();
        };
      } // attach firstTarget property to the event


      event.firstTarget = _firstTarget; // propagate over all elements (until stopped)

      var elem = _firstTarget;

      while (elem && !stopped) {
        var elemHammer = elem.hammer;

        if (elemHammer) {
          var _handlers;

          for (var k = 0; k < elemHammer.length; k++) {
            _handlers = elemHammer[k]._handlers[event.type];
            if (_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
              _handlers[i](event);
            }
          }
        }

        elem = elem.parentNode;
      }
    }

    return wrapper;
  };
}); // Hammer = propagating(Hammer);

/***/ }),

/***/ "./js/plugins/iscroll/iscroll-zoom.js":
/*!********************************************!*\
  !*** ./js/plugins/iscroll/iscroll-zoom.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! iScroll v5.1.2 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license */
(function (window, document, Math) {
  var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };

  var utils = function () {
    var me = {};
    var _elementStyle = document.createElement('div').style;

    var _vendor = function () {
      var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
          transform,
          i = 0,
          l = vendors.length;

      for (; i < l; i++) {
        transform = vendors[i] + 'ransform';
        if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
      }

      return false;
    }();

    function _prefixStyle(style) {
      if (_vendor === false) return false;
      if (_vendor === '') return style;
      return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
    }

    me.getTime = Date.now || function getTime() {
      return new Date().getTime();
    };

    me.extend = function (target, obj) {
      for (var i in obj) {
        target[i] = obj[i];
      }
    };

    me.addEvent = function (el, type, fn, capture) {
      el.addEventListener(type, fn, !!capture);
    };

    me.removeEvent = function (el, type, fn, capture) {
      el.removeEventListener(type, fn, !!capture);
    };

    me.prefixPointerEvent = function (pointerEvent) {
      return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10) : pointerEvent;
    };

    me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
      var distance = current - start,
          speed = Math.abs(distance) / time,
          destination,
          duration;
      deceleration = deceleration === undefined ? 0.0006 : deceleration;
      destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
      duration = speed / deceleration;

      if (destination < lowerMargin) {
        destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
        distance = Math.abs(destination - current);
        duration = distance / speed;
      } else if (destination > 0) {
        destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
        distance = Math.abs(current) + destination;
        duration = distance / speed;
      }

      return {
        destination: Math.round(destination),
        duration: duration
      };
    };

    var _transform = _prefixStyle('transform');

    me.extend(me, {
      hasTransform: _transform !== false,
      hasPerspective: _prefixStyle('perspective') in _elementStyle,
      hasTouch: 'ontouchstart' in window,
      hasPointer: window.PointerEvent || window.MSPointerEvent,
      // IE10 is prefixed
      hasTransition: _prefixStyle('transition') in _elementStyle
    }); // This should find all Android browsers lower than build 535.19 (both stock browser and webview)

    me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !/Chrome\/\d/.test(window.navigator.appVersion);
    me.extend(me.style = {}, {
      transform: _transform,
      transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
      transitionDuration: _prefixStyle('transitionDuration'),
      transitionDelay: _prefixStyle('transitionDelay'),
      transformOrigin: _prefixStyle('transformOrigin')
    });

    me.hasClass = function (e, c) {
      var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
      return re.test(e.className);
    };

    me.addClass = function (e, c) {
      if (me.hasClass(e, c)) {
        return;
      }

      var newclass = e.className.split(' ');
      newclass.push(c);
      e.className = newclass.join(' ');
    };

    me.removeClass = function (e, c) {
      if (!me.hasClass(e, c)) {
        return;
      }

      var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
      e.className = e.className.replace(re, ' ');
    };

    me.offset = function (el) {
      var left = -el.offsetLeft,
          top = -el.offsetTop; // jshint -W084

      while (el = el.offsetParent) {
        left -= el.offsetLeft;
        top -= el.offsetTop;
      } // jshint +W084


      return {
        left: left,
        top: top
      };
    };

    me.preventDefaultException = function (el, exceptions) {
      for (var i in exceptions) {
        if (exceptions[i].test(el[i])) {
          return true;
        }
      }

      return false;
    };

    me.extend(me.eventType = {}, {
      touchstart: 1,
      touchmove: 1,
      touchend: 1,
      mousedown: 2,
      mousemove: 2,
      mouseup: 2,
      pointerdown: 3,
      pointermove: 3,
      pointerup: 3,
      MSPointerDown: 3,
      MSPointerMove: 3,
      MSPointerUp: 3
    });
    me.extend(me.ease = {}, {
      quadratic: {
        style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
        fn: function fn(k) {
          return k * (2 - k);
        }
      },
      circular: {
        style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',
        // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
        fn: function fn(k) {
          return Math.sqrt(1 - --k * k);
        }
      },
      back: {
        style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
        fn: function fn(k) {
          var b = 4;
          return (k = k - 1) * k * ((b + 1) * k + b) + 1;
        }
      },
      bounce: {
        style: '',
        fn: function fn(k) {
          if ((k /= 1) < 1 / 2.75) {
            return 7.5625 * k * k;
          } else if (k < 2 / 2.75) {
            return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
          } else if (k < 2.5 / 2.75) {
            return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
          } else {
            return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
          }
        }
      },
      elastic: {
        style: '',
        fn: function fn(k) {
          var f = 0.22,
              e = 0.4;

          if (k === 0) {
            return 0;
          }

          if (k == 1) {
            return 1;
          }

          return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
        }
      }
    });

    me.tap = function (e, eventName) {
      var ev = document.createEvent('Event');
      ev.initEvent(eventName, true, true);
      ev.pageX = e.pageX;
      ev.pageY = e.pageY;
      e.target.dispatchEvent(ev);
    };

    me.click = function (e) {
      var target = e.target,
          ev;

      if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
        ev = document.createEvent('MouseEvents');
        ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);
        ev._constructed = true;
        target.dispatchEvent(ev);
      }
    };

    return me;
  }();

  function IScroll(el, options) {
    this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
    this.scroller = this.wrapper.children[0];
    this.scrollerStyle = this.scroller.style; // cache style for better performance

    this.options = {
      zoomMin: 1,
      zoomMax: 4,
      startZoom: 1,
      resizeScrollbars: true,
      mouseWheelSpeed: 20,
      snapThreshold: 0.334,
      // INSERT POINT: OPTIONS 
      startX: 0,
      startY: 0,
      scrollY: true,
      directionLockThreshold: 5,
      momentum: true,
      bounce: true,
      bounceTime: 600,
      bounceEasing: '',
      preventDefault: true,
      preventDefaultException: {
        tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|VIDEO)$/
      },
      HWCompositing: true,
      useTransition: true,
      useTransform: true
    };

    for (var i in options) {
      this.options[i] = options[i];
    } // Normalize options


    this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : ''; // Proto.io fix for border radious safari bug that causes border radius not to work on mask when an element on dom has translateZ

    if ($.browser.safari) this.translateZ = '';
    this.options.useTransition = utils.hasTransition && this.options.useTransition;
    this.options.useTransform = utils.hasTransform && this.options.useTransform;
    this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
    this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault; // If you want eventPassthrough I have to lock one of the axes

    this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
    this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX; // With eventPassthrough we also need lockDirection mechanism

    this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
    /* ANNAM ADDED FROM PROTO.IO-SPECIFIC ISCROLL.JS */

    this.options.freeScroll = this.options.twoWayScroll || this.options.freeScroll;
    /* ANNAM ADDED FROM PROTO.IO-SPECIFIC ISCROLL.JS END */

    this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;
    this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;
    this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

    if (this.options.tap === true) {
      this.options.tap = 'tap';
    }

    if (this.options.shrinkScrollbars == 'scale') {
      this.options.useTransition = false;
    }

    this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;
    /* ANNAM ADDED FROM ISCROLL-PROBE.JS */

    if (this.options.probeType == 3) {
      this.options.useTransition = false;
    }
    /* ANNAM ADDED FROM ISCROLL-PROBE.JS END */
    // INSERT POINT: NORMALIZATION
    // Some defaults	


    this.x = 0;
    this.y = 0;
    this.directionX = 0;
    this.directionY = 0;
    this._events = {};
    this.scale = Math.min(Math.max(this.options.startZoom, this.options.zoomMin), this.options.zoomMax); // INSERT POINT: DEFAULTS

    this._init();

    this.refresh();
    this.scrollTo(this.options.startX, this.options.startY);
    this.enable();
  }

  IScroll.prototype = {
    version: '5.1.2',
    _init: function _init() {
      this._initEvents();

      if (this.options.zoom) {
        this._initZoom();
      }

      if (this.options.scrollbars || this.options.indicators) {
        this._initIndicators();
      }

      if (this.options.mouseWheel) {
        this._initWheel();
      }

      if (this.options.snap) {
        this._initSnap();
      }

      if (this.options.keyBindings) {
        this._initKeys();
      } // INSERT POINT: _init

    },
    destroy: function destroy() {
      this._initEvents(true);

      this._execEvent('destroy');
    },
    _transitionEnd: function _transitionEnd(e) {
      if (e.target != this.scroller || !this.isInTransition) {
        return;
      }

      this._transitionTime();

      if (!this.resetPosition(this.options.bounceTime)) {
        this.isInTransition = false;

        this._execEvent('scrollEnd');
      }
    },
    _start: function _start(e) {
      // React to left mouse button only
      if (utils.eventType[e.type] != 1) {
        if (e.button !== 0) {
          return;
        }
      }

      if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
        return;
      }

      if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
        e.preventDefault();
      }

      var point = e.touches ? e.touches[0] : e,
          pos;
      this.initiated = utils.eventType[e.type];
      /* ANNAM ADDED FROM PROTO.IO-SPECIFIC ISCROLL.JS */

      this.twoWayOnEndCheck = true;
      /* ANNAM ADDED FROM PROTO.IO-SPECIFIC ISCROLL.JS END */

      this.moved = false;
      this.distX = 0;
      this.distY = 0;
      this.directionX = 0;
      this.directionY = 0;
      this.directionLocked = 0;

      this._transitionTime();

      this.startTime = utils.getTime();

      if (this.options.useTransition && this.isInTransition) {
        this.isInTransition = false;
        pos = this.getComputedPosition();

        this._translate(Math.round(pos.x), Math.round(pos.y));

        this._execEvent('scrollEnd');
      } else if (!this.options.useTransition && this.isAnimating) {
        this.isAnimating = false;

        this._execEvent('scrollEnd');
      }

      this.startX = this.x;
      this.startY = this.y;
      this.absStartX = this.x;
      this.absStartY = this.y;
      this.pointX = point.pageX;
      this.pointY = point.pageY;

      this._execEvent('beforeScrollStart');
    },
    _move: function _move(e) {
      if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
        return;
      }

      if (this.options.preventDefault) {
        // increases performance on Android? TODO: check!
        e.preventDefault();
      }

      var point = e.touches ? e.touches[0] : e,
          deltaX = point.pageX - this.pointX,
          deltaY = point.pageY - this.pointY,
          timestamp = utils.getTime(),
          newX,
          newY,
          absDistX,
          absDistY;
      this.pointX = point.pageX;
      this.pointY = point.pageY;
      this.distX += deltaX;
      this.distY += deltaY;
      absDistX = Math.abs(this.distX);
      absDistY = Math.abs(this.distY); // We need to move at least 10 pixels for the scrolling to initiate

      if (timestamp - this.endTime > 300 && absDistX < 10 && absDistY < 10) {
        return;
      }
      /* ANNAM REMOVING FROM PROTO.IO-SPECIFIC ISCROLL.JS */
      // If you are scrolling in one direction lock the other

      /*
      if ( !this.directionLocked && !this.options.freeScroll ) {
      	if ( absDistX > absDistY + this.options.directionLockThreshold ) {
      		this.directionLocked = 'h';		// lock horizontally
      	} else if ( absDistY >= absDistX + this.options.directionLockThreshold ) {
      		this.directionLocked = 'v';		// lock vertically
      	} else {
      		this.directionLocked = 'n';		// no lock
      	}
      }
      */

      /* ANNAM ADDED FROM PROTO.IO-SPECIFIC ISCROLL.JS */
      // 2-way scroll


      if (this.options.twoWayScroll && this.options.scrollX) {
        if (!this.directionLocked && absDistX >= absDistY) {
          this.directionLocked = true;
        }

        if (this.directionLocked) {
          e.preventDefault();
          e.stopPropagation();
        } else {
          this.initiated = false;
          return;
        }
      } else if (this.options.twoWayScroll && this.options.scrollY) {
        if (!this.directionLocked && absDistY > absDistX) {
          this.directionLocked = true;
        }

        if (this.directionLocked) {
          e.preventDefault();
          e.stopPropagation();
        } else {
          this.initiated = false;
          return;
        }
      } // If you are scrolling in one direction lock the other


      if (!this.directionLocked && !this.options.freeScroll) {
        if (absDistX > absDistY + this.options.directionLockThreshold) {
          this.directionLocked = 'h'; // lock horizontally
        } else if (absDistY >= absDistX + this.options.directionLockThreshold) {
          this.directionLocked = 'v'; // lock vertically
        } else {
          this.directionLocked = 'n'; // no lock
        }
      }
      /* ANNAM ADDED FROM PROTO.IO-SPECIFIC ISCROLL.JS END */


      if (this.directionLocked == 'h') {
        if (this.options.eventPassthrough == 'vertical') {
          e.preventDefault();
        } else if (this.options.eventPassthrough == 'horizontal') {
          this.initiated = false;
          return;
        }

        deltaY = 0;
      } else if (this.directionLocked == 'v') {
        if (this.options.eventPassthrough == 'horizontal') {
          e.preventDefault();
        } else if (this.options.eventPassthrough == 'vertical') {
          this.initiated = false;
          return;
        }

        deltaX = 0;
      }

      deltaX = this.hasHorizontalScroll ? deltaX : 0;
      deltaY = this.hasVerticalScroll ? deltaY : 0;
      newX = this.x + deltaX;
      newY = this.y + deltaY; // Slow down if outside of the boundaries

      if (newX > 0 || newX < this.maxScrollX) {
        newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
      }

      if (newY > 0 || newY < this.maxScrollY) {
        newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
      }

      this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
      this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

      if (!this.moved) {
        this._execEvent('scrollStart');
      }

      this.moved = true;

      this._translate(newX, newY);
      /* REPLACE START: _move */


      if (timestamp - this.startTime > 300) {
        this.startTime = timestamp;
        this.startX = this.x;
        this.startY = this.y;
        /* ANNAM ADDED FROM ISCROLL-PROBE.JS */

        if (this.options.probeType == 1) {
          this._execEvent('scroll');
        }
      }

      if (this.options.probeType > 1) {
        this._execEvent('scroll');
      }
      /* ANNAM ADDED FROM ISCROLL-PROBE.JS END */

      /* REPLACE END: _move */

    },
    _end: function _end(e) {
      /* ANNAM CHANGED FROM PROTO.IO-SPECIFIC ISCROLL.JS */
      //if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
      // ANNAM MADE THIS CHANGE MYSELF! ISCROLL WAS BROKEN 
      //if ( (this.options.twoWayScroll && !this.twoWayOnEndCheck) && (!this.enabled || utils.eventType[e.type] !== this.initiated) ) {
      if (!this.twoWayOnEndCheck && (!this.enabled || utils.eventType[e.type] !== this.initiated)) {
        return;
      }
      /* ANNAM ADDED FROM PROTO.IO-SPECIFIC ISCROLL.JS */


      this.twoWayOnEndCheck = false;
      /* ANNAM ADDED FROM PROTO.IO-SPECIFIC ISCROLL.JS END */

      if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
        e.preventDefault();
      }

      var point = e.changedTouches ? e.changedTouches[0] : e,
          momentumX,
          momentumY,
          duration = utils.getTime() - this.startTime,
          newX = Math.round(this.x),
          newY = Math.round(this.y),
          distanceX = Math.abs(newX - this.startX),
          distanceY = Math.abs(newY - this.startY),
          time = 0,
          easing = '';
      this.isInTransition = 0;
      this.initiated = 0;
      this.endTime = utils.getTime(); // reset if we are outside of the boundaries

      if (this.resetPosition(this.options.bounceTime)) {
        return;
      }

      this.scrollTo(newX, newY); // ensures that the last position is rounded
      // we scrolled less than 10 pixels

      /* ANNAM CHANGED FROM PROTO.IO-SPECIFIC ISCROLL.JS */
      //if ( !this.moved ) {

      if (!this.moved && !this.options.snap) {
        if (this.options.tap) {
          utils.tap(e, this.options.tap);
        }

        if (this.options.click) {
          utils.click(e);
        }

        this._execEvent('scrollCancel');

        return;
      } // ANNAM
      //if ( this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100 ) {


      if (this.moved && this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
        // annam i have an issue where if container is scrollable but has no scroll, scroll start is triggered (disableding all parents)
        // but then scroll end is not triggered on flick because flick causes "goto page" which does nothing in my case.
        // so cancelling scroll instead if we didn't move.
        if (distanceX == 0 && distanceY == 0) {
          this._execEvent('scrollCancel');

          return;
        }

        this._execEvent('flick');

        return;
      } // start momentum animation if needed


      if (this.options.momentum && duration < 300) {
        momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : {
          destination: newX,
          duration: 0
        };
        momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : {
          destination: newY,
          duration: 0
        };
        newX = momentumX.destination;
        newY = momentumY.destination;
        time = Math.max(momentumX.duration, momentumY.duration);
        this.isInTransition = 1;
      }

      if (this.options.snap) {
        var snap = this._nearestSnap(newX, newY);

        this.currentPage = snap;
        time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
        newX = snap.x;
        newY = snap.y;
        this.directionX = 0;
        this.directionY = 0;
        easing = this.options.bounceEasing;
      } // INSERT POINT: _end


      if (newX != this.x || newY != this.y) {
        // change easing function when scroller goes out of the boundaries
        if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
          easing = utils.ease.quadratic;
        }

        this.scrollTo(newX, newY, time, easing);
        return;
      } // ANNAM v5.10.8 because if snap and omnidirectional it keeps triggering scrollend on every mouseup touchend etc
      // was causing problems with labels not toggling


      if (!this.moved && this.options.snap) {
        if (this.options.tap) {
          utils.tap(e, this.options.tap);
        }

        if (this.options.click) {
          utils.click(e);
        }

        this._execEvent('scrollCancel');

        return;
      }

      this.moved = false;

      this._execEvent('scrollEnd');
    },
    _resize: function _resize() {
      var that = this;
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(function () {
        that.refresh();
      }, this.options.resizePolling);
    },
    resetPosition: function resetPosition(time) {
      var x = this.x,
          y = this.y;
      time = time || 0;

      if (!this.hasHorizontalScroll || this.x > 0) {
        x = 0;
      } else if (this.x < this.maxScrollX) {
        x = this.maxScrollX;
      }

      if (!this.hasVerticalScroll || this.y > 0) {
        y = 0;
      } else if (this.y < this.maxScrollY) {
        y = this.maxScrollY;
      }

      if (x == this.x && y == this.y) {
        return false;
      }

      this.scrollTo(x, y, time, this.options.bounceEasing);
      return true;
    },
    disable: function disable() {
      this.enabled = false;
    },
    enable: function enable() {
      this.enabled = true;
    },
    refresh: function refresh() {
      var rf = this.wrapper.offsetHeight; // Force reflow

      this.wrapperWidth = this.wrapper.clientWidth;
      this.wrapperHeight = this.wrapper.clientHeight;
      /* REPLACE START: refresh */

      this.scrollerWidth = Math.round(this.scroller.offsetWidth * this.scale);
      this.scrollerHeight = Math.round(this.scroller.offsetHeight * this.scale);
      this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
      this.maxScrollY = this.wrapperHeight - this.scrollerHeight;
      /* REPLACE END: refresh */

      this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
      this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

      if (!this.hasHorizontalScroll) {
        this.maxScrollX = 0;
        this.scrollerWidth = this.wrapperWidth;
      }

      if (!this.hasVerticalScroll) {
        this.maxScrollY = 0;
        this.scrollerHeight = this.wrapperHeight;
      }

      this.endTime = 0;
      this.directionX = 0;
      this.directionY = 0;
      this.wrapperOffset = utils.offset(this.wrapper);

      this._execEvent('refresh');

      this.resetPosition(); // INSERT POINT: _refresh
    },
    on: function on(type, fn) {
      if (!this._events[type]) {
        this._events[type] = [];
      }

      this._events[type].push(fn);
    },
    off: function off(type, fn) {
      if (!this._events[type]) {
        return;
      }

      var index = this._events[type].indexOf(fn);

      if (index > -1) {
        this._events[type].splice(index, 1);
      }
    },
    _execEvent: function _execEvent(type) {
      if (!this._events[type]) {
        return;
      }

      var i = 0,
          l = this._events[type].length;

      if (!l) {
        return;
      }

      for (; i < l; i++) {
        this._events[type][i].apply(this, [].slice.call(arguments, 1));
      }
    },
    scrollBy: function scrollBy(x, y, time, easing) {
      x = this.x + x;
      y = this.y + y;
      time = time || 0;
      this.scrollTo(x, y, time, easing);
    },
    scrollTo: function scrollTo(x, y, time, easing) {
      easing = easing || utils.ease.circular;
      this.isInTransition = this.options.useTransition && time > 0;

      if (!time || this.options.useTransition && easing.style) {
        this._transitionTimingFunction(easing.style);

        this._transitionTime(time);

        this._translate(x, y);
      } else {
        this._animate(x, y, time, easing.fn);
      }
    },
    scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
      el = el.nodeType ? el : this.scroller.querySelector(el);

      if (!el) {
        return;
      }

      var pos = utils.offset(el);
      pos.left -= this.wrapperOffset.left;
      pos.top -= this.wrapperOffset.top; // if offsetX/Y are true we center the element to the screen

      if (offsetX === true) {
        offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
      }

      if (offsetY === true) {
        offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
      }

      pos.left -= offsetX || 0;
      pos.top -= offsetY || 0;
      pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
      pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;
      time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;
      this.scrollTo(pos.left, pos.top, time, easing);
    },
    _transitionTime: function _transitionTime(time) {
      time = time || 0;
      this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';

      if (!time && utils.isBadAndroid) {
        this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
      }

      if (this.indicators) {
        for (var i = this.indicators.length; i--;) {
          this.indicators[i].transitionTime(time);
        }
      } // INSERT POINT: _transitionTime

    },
    _transitionTimingFunction: function _transitionTimingFunction(easing) {
      this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

      if (this.indicators) {
        for (var i = this.indicators.length; i--;) {
          this.indicators[i].transitionTimingFunction(easing);
        }
      } // INSERT POINT: _transitionTimingFunction

    },
    _translate: function _translate(x, y) {
      if (this.options.useTransform) {
        /* REPLACE START: _translate */
        this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px) scale(' + this.scale + ') ' + this.translateZ;
        /* REPLACE END: _translate */
      } else {
        x = Math.round(x);
        y = Math.round(y);
        this.scrollerStyle.left = x + 'px';
        this.scrollerStyle.top = y + 'px';
      }

      this.x = x;
      this.y = y;

      if (this.indicators) {
        for (var i = this.indicators.length; i--;) {
          this.indicators[i].updatePosition();
        }
      } // INSERT POINT: _translate

    },
    _initEvents: function _initEvents(remove) {
      var eventType = remove ? utils.removeEvent : utils.addEvent,
          target = this.options.bindToWrapper ? this.wrapper : window;
      eventType(window, 'orientationchange', this);
      eventType(window, 'resize', this);

      if (this.options.click) {
        eventType(this.wrapper, 'click', this, true);
      }

      if (!this.options.disableMouse) {
        eventType(this.wrapper, 'mousedown', this);
        eventType(target, 'mousemove', this);
        eventType(target, 'mousecancel', this);
        eventType(target, 'mouseup', this);
      }

      if (utils.hasPointer && !this.options.disablePointer) {
        eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
        eventType(target, utils.prefixPointerEvent('pointermove'), this);
        eventType(target, utils.prefixPointerEvent('pointercancel'), this);
        eventType(target, utils.prefixPointerEvent('pointerup'), this);
      }

      if (utils.hasTouch && !this.options.disableTouch) {
        eventType(this.wrapper, 'touchstart', this);
        eventType(target, 'touchmove', this);
        eventType(target, 'touchcancel', this);
        eventType(target, 'touchend', this);
      }

      eventType(this.scroller, 'transitionend', this);
      eventType(this.scroller, 'webkitTransitionEnd', this);
      eventType(this.scroller, 'oTransitionEnd', this);
      eventType(this.scroller, 'MSTransitionEnd', this);
    },
    getComputedPosition: function getComputedPosition() {
      var matrix = window.getComputedStyle(this.scroller, null),
          x,
          y;

      if (this.options.useTransform) {
        matrix = matrix[utils.style.transform].split(')')[0].split(', ');
        x = +(matrix[12] || matrix[4]);
        y = +(matrix[13] || matrix[5]);
      } else {
        x = +matrix.left.replace(/[^-\d.]/g, '');
        y = +matrix.top.replace(/[^-\d.]/g, '');
      }

      return {
        x: x,
        y: y
      };
    },
    _initIndicators: function _initIndicators() {
      var interactive = this.options.interactiveScrollbars,
          customStyle = typeof this.options.scrollbars != 'string',
          indicators = [],
          indicator;
      var that = this;
      this.indicators = [];

      if (this.options.scrollbars) {
        // Vertical scrollbar
        if (this.options.scrollY) {
          indicator = {
            el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
            interactive: interactive,
            defaultScrollbars: true,
            customStyle: customStyle,
            resize: this.options.resizeScrollbars,
            shrink: this.options.shrinkScrollbars,
            fade: this.options.fadeScrollbars,
            listenX: false
          };
          this.wrapper.appendChild(indicator.el);
          indicators.push(indicator);
        } // Horizontal scrollbar


        if (this.options.scrollX) {
          indicator = {
            el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
            interactive: interactive,
            defaultScrollbars: true,
            customStyle: customStyle,
            resize: this.options.resizeScrollbars,
            shrink: this.options.shrinkScrollbars,
            fade: this.options.fadeScrollbars,
            listenY: false
          };
          this.wrapper.appendChild(indicator.el);
          indicators.push(indicator);
        }
      }

      if (this.options.indicators) {
        // TODO: check concat compatibility
        indicators = indicators.concat(this.options.indicators);
      }

      for (var i = indicators.length; i--;) {
        this.indicators.push(new Indicator(this, indicators[i]));
      } // TODO: check if we can use array.map (wide compatibility and performance issues)


      function _indicatorsMap(fn) {
        for (var i = that.indicators.length; i--;) {
          fn.call(that.indicators[i]);
        }
      }

      if (this.options.fadeScrollbars) {
        this.on('scrollEnd', function () {
          _indicatorsMap(function () {
            this.fade();
          });
        });
        this.on('scrollCancel', function () {
          _indicatorsMap(function () {
            this.fade();
          });
        });
        this.on('scrollStart', function () {
          _indicatorsMap(function () {
            this.fade(1);
          });
        });
        this.on('beforeScrollStart', function () {
          _indicatorsMap(function () {
            this.fade(1, true);
          });
        });
      }

      this.on('refresh', function () {
        _indicatorsMap(function () {
          this.refresh();
        });
      });
      this.on('destroy', function () {
        _indicatorsMap(function () {
          this.destroy();
        });

        delete this.indicators;
      });
    },
    _initZoom: function _initZoom() {
      this.scrollerStyle[utils.style.transformOrigin] = '0 0';
    },
    _zoomStart: function _zoomStart(e) {
      var c1 = Math.abs(e.touches[0].pageX - e.touches[1].pageX),
          c2 = Math.abs(e.touches[0].pageY - e.touches[1].pageY);
      this.touchesDistanceStart = Math.sqrt(c1 * c1 + c2 * c2);
      this.startScale = this.scale;
      this.originX = Math.abs(e.touches[0].pageX + e.touches[1].pageX) / 2 + this.wrapperOffset.left - this.x;
      this.originY = Math.abs(e.touches[0].pageY + e.touches[1].pageY) / 2 + this.wrapperOffset.top - this.y;

      this._execEvent('zoomStart');
    },
    _zoom: function _zoom(e) {
      if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
        return;
      }

      if (this.options.preventDefault) {
        e.preventDefault();
      }

      var c1 = Math.abs(e.touches[0].pageX - e.touches[1].pageX),
          c2 = Math.abs(e.touches[0].pageY - e.touches[1].pageY),
          distance = Math.sqrt(c1 * c1 + c2 * c2),
          scale = 1 / this.touchesDistanceStart * distance * this.startScale,
          lastScale,
          x,
          y;
      this.scaled = true;

      if (scale < this.options.zoomMin) {
        scale = 0.5 * this.options.zoomMin * Math.pow(2.0, scale / this.options.zoomMin);
      } else if (scale > this.options.zoomMax) {
        scale = 2.0 * this.options.zoomMax * Math.pow(0.5, this.options.zoomMax / scale);
      }

      lastScale = scale / this.startScale;
      x = this.originX - this.originX * lastScale + this.startX;
      y = this.originY - this.originY * lastScale + this.startY;
      this.scale = scale;
      this.scrollTo(x, y, 0);
    },
    _zoomEnd: function _zoomEnd(e) {
      if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
        return;
      }

      if (this.options.preventDefault) {
        e.preventDefault();
      }

      var newX, newY, lastScale;
      this.isInTransition = 0;
      this.initiated = 0;

      if (this.scale > this.options.zoomMax) {
        this.scale = this.options.zoomMax;
      } else if (this.scale < this.options.zoomMin) {
        this.scale = this.options.zoomMin;
      } // Update boundaries


      this.refresh();
      lastScale = this.scale / this.startScale;
      newX = this.originX - this.originX * lastScale + this.startX;
      newY = this.originY - this.originY * lastScale + this.startY;

      if (newX > 0) {
        newX = 0;
      } else if (newX < this.maxScrollX) {
        newX = this.maxScrollX;
      }

      if (newY > 0) {
        newY = 0;
      } else if (newY < this.maxScrollY) {
        newY = this.maxScrollY;
      }

      if (this.x != newX || this.y != newY) {
        this.scrollTo(newX, newY, this.options.bounceTime);
      }

      this.scaled = false;

      this._execEvent('zoomEnd');
    },
    zoom: function zoom(scale, x, y, time) {
      if (scale < this.options.zoomMin) {
        scale = this.options.zoomMin;
      } else if (scale > this.options.zoomMax) {
        scale = this.options.zoomMax;
      }

      if (scale == this.scale) {
        return;
      }

      var relScale = scale / this.scale;
      x = x === undefined ? this.wrapperWidth / 2 : x;
      y = y === undefined ? this.wrapperHeight / 2 : y;
      time = time === undefined ? 300 : time;
      x = x + this.wrapperOffset.left - this.x;
      y = y + this.wrapperOffset.top - this.y;
      x = x - x * relScale + this.x;
      y = y - y * relScale + this.y;
      this.scale = scale;
      this.refresh(); // update boundaries

      if (x > 0) {
        x = 0;
      } else if (x < this.maxScrollX) {
        x = this.maxScrollX;
      }

      if (y > 0) {
        y = 0;
      } else if (y < this.maxScrollY) {
        y = this.maxScrollY;
      }

      this.scrollTo(x, y, time);
    },
    _wheelZoom: function _wheelZoom(e) {
      var wheelDeltaY,
          deltaScale,
          that = this; // Execute the zoomEnd event after 400ms the wheel stopped scrolling

      clearTimeout(this.wheelTimeout);
      this.wheelTimeout = setTimeout(function () {
        that._execEvent('zoomEnd');
      }, 400);

      if ('deltaX' in e) {
        wheelDeltaY = -e.deltaY / Math.abs(e.deltaY);
      } else if ('wheelDeltaX' in e) {
        wheelDeltaY = e.wheelDeltaY / Math.abs(e.wheelDeltaY);
      } else if ('wheelDelta' in e) {
        wheelDeltaY = e.wheelDelta / Math.abs(e.wheelDelta);
      } else if ('detail' in e) {
        wheelDeltaY = -e.detail / Math.abs(e.wheelDelta);
      } else {
        return;
      }

      deltaScale = this.scale + wheelDeltaY / 5;
      this.zoom(deltaScale, e.pageX, e.pageY, 0);
    },
    _initWheel: function _initWheel() {
      utils.addEvent(this.wrapper, 'wheel', this);
      utils.addEvent(this.wrapper, 'mousewheel', this);
      utils.addEvent(this.wrapper, 'DOMMouseScroll', this);
      this.on('destroy', function () {
        utils.removeEvent(this.wrapper, 'wheel', this);
        utils.removeEvent(this.wrapper, 'mousewheel', this);
        utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
      });
    },
    _wheel: function _wheel(e) {
      if (!this.enabled) {
        return;
      }

      e.preventDefault();
      e.stopPropagation();
      var wheelDeltaX,
          wheelDeltaY,
          newX,
          newY,
          that = this;

      if (this.wheelTimeout === undefined) {
        that._execEvent('scrollStart');
      } // Execute the scrollEnd event after 400ms the wheel stopped scrolling


      clearTimeout(this.wheelTimeout);
      this.wheelTimeout = setTimeout(function () {
        that._execEvent('scrollEnd');

        that.wheelTimeout = undefined;
      }, 400);

      if ('deltaX' in e) {
        wheelDeltaX = -e.deltaX;
        wheelDeltaY = -e.deltaY;
      } else if ('wheelDeltaX' in e) {
        wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
        wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
      } else if ('wheelDelta' in e) {
        wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
      } else if ('detail' in e) {
        wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
      } else {
        return;
      }

      wheelDeltaX *= this.options.invertWheelDirection;
      wheelDeltaY *= this.options.invertWheelDirection;

      if (!this.hasVerticalScroll) {
        wheelDeltaX = wheelDeltaY;
        wheelDeltaY = 0;
      }

      if (this.options.snap) {
        newX = this.currentPage.pageX;
        newY = this.currentPage.pageY;

        if (wheelDeltaX > 0) {
          newX--;
        } else if (wheelDeltaX < 0) {
          newX++;
        }

        if (wheelDeltaY > 0) {
          newY--;
        } else if (wheelDeltaY < 0) {
          newY++;
        }

        this.goToPage(newX, newY);
        return;
      }

      newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
      newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

      if (newX > 0) {
        newX = 0;
      } else if (newX < this.maxScrollX) {
        newX = this.maxScrollX;
      }

      if (newY > 0) {
        newY = 0;
      } else if (newY < this.maxScrollY) {
        newY = this.maxScrollY;
      }

      this.scrollTo(newX, newY, 0);
      /* ANNAM ADDED FROM ISCROLL-PROBE.JS */

      if (this.options.probeType > 1) {
        this._execEvent('scroll');
      }
      /* ANNAM ADDED FROM ISCROLL-PROBE.JS END */
      // INSERT POINT: _wheel

    },
    _initSnap: function _initSnap() {
      this.currentPage = {};

      if (typeof this.options.snap == 'string') {
        this.options.snap = this.scroller.querySelectorAll(this.options.snap);
      }

      this.on('refresh', function () {
        var i = 0,
            l,
            m = 0,
            n,
            cx,
            cy,
            x = 0,
            y,
            stepX = this.options.snapStepX || this.wrapperWidth,
            stepY = this.options.snapStepY || this.wrapperHeight,
            el;
        this.pages = [];

        if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
          return;
        }

        if (this.options.snap === true) {
          cx = Math.round(stepX / 2);
          cy = Math.round(stepY / 2);

          while (x > -this.scrollerWidth) {
            this.pages[i] = [];
            l = 0;
            y = 0;

            while (y > -this.scrollerHeight) {
              this.pages[i][l] = {
                x: Math.max(x, this.maxScrollX),
                y: Math.max(y, this.maxScrollY),
                width: stepX,
                height: stepY,
                cx: x - cx,
                cy: y - cy
              };
              y -= stepY;
              l++;
            }

            x -= stepX;
            i++;
          }
        } else {
          el = this.options.snap;
          l = el.length;
          n = -1;

          for (; i < l; i++) {
            if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
              m = 0;
              n++;
            }

            if (!this.pages[m]) {
              this.pages[m] = [];
            }

            x = Math.max(-el[i].offsetLeft, this.maxScrollX);
            y = Math.max(-el[i].offsetTop, this.maxScrollY);
            cx = x - Math.round(el[i].offsetWidth / 2);
            cy = y - Math.round(el[i].offsetHeight / 2);
            this.pages[m][n] = {
              x: x,
              y: y,
              width: el[i].offsetWidth,
              height: el[i].offsetHeight,
              cx: cx,
              cy: cy
            };

            if (x > this.maxScrollX) {
              m++;
            }
          }
        } // ANNAM - if we set initial scroll position, this is not respected here. once we start scrolling this is reverted
        // anw current page should be set depending on initial position


        if (JSON.stringify(this.currentPage) === "{}") this.currentPage = this._nearestSnap(this.options.startX, this.options.startY);
        this.goToPage(this.currentPage.pageX, this.currentPage.pageY, 0); // Update snap threshold if needed

        if (this.options.snapThreshold % 1 === 0) {
          this.snapThresholdX = this.options.snapThreshold;
          this.snapThresholdY = this.options.snapThreshold;
        } else {
          this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
          this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
        }
      });
      this.on('flick', function () {
        var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);
        this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
      });
    },
    _nearestSnap: function _nearestSnap(x, y) {
      if (!this.pages.length) {
        return {
          x: 0,
          y: 0,
          pageX: 0,
          pageY: 0
        };
      }

      var i = 0,
          l = this.pages.length,
          m = 0; // Check if we exceeded the snap threshold

      if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
        return this.currentPage;
      }

      if (x > 0) {
        x = 0;
      } else if (x < this.maxScrollX) {
        x = this.maxScrollX;
      }

      if (y > 0) {
        y = 0;
      } else if (y < this.maxScrollY) {
        y = this.maxScrollY;
      }

      for (; i < l; i++) {
        if (x >= this.pages[i][0].cx) {
          x = this.pages[i][0].x;
          break;
        }
      }

      l = this.pages[i].length;

      for (; m < l; m++) {
        if (y >= this.pages[0][m].cy) {
          y = this.pages[0][m].y;
          break;
        }
      }

      if (i == this.currentPage.pageX) {
        i += this.directionX;

        if (i < 0) {
          i = 0;
        } else if (i >= this.pages.length) {
          i = this.pages.length - 1;
        }

        x = this.pages[i][0].x;
      }

      if (m == this.currentPage.pageY) {
        m += this.directionY;

        if (m < 0) {
          m = 0;
        } else if (m >= this.pages[0].length) {
          m = this.pages[0].length - 1;
        }

        y = this.pages[0][m].y;
      }

      return {
        x: x,
        y: y,
        pageX: i,
        pageY: m
      };
    },
    goToPage: function goToPage(x, y, time, easing) {
      easing = easing || this.options.bounceEasing; // ANNAM BECAUSE WHEN NOT VISIBLE, this.pages.length==0;

      if (typeof this.pages == 'undefined' || typeof this.pages != 'undefined' && this.pages.length == 0) {
        return false;
      } // ANNAM END


      if (x >= this.pages.length) {
        x = this.pages.length - 1;
      } else if (x < 0) {
        x = 0;
      }

      if (y >= this.pages[x].length) {
        y = this.pages[x].length - 1;
      } else if (y < 0) {
        y = 0;
      }

      var posX = this.pages[x][y].x,
          posY = this.pages[x][y].y;
      time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;
      this.currentPage = {
        x: posX,
        y: posY,
        pageX: x,
        pageY: y
      };
      this.scrollTo(posX, posY, time, easing);
    },
    next: function next(time, easing) {
      var x = this.currentPage.pageX,
          y = this.currentPage.pageY;
      x++;

      if (x >= this.pages.length && this.hasVerticalScroll) {
        x = 0;
        y++;
      }

      this.goToPage(x, y, time, easing);
    },
    prev: function prev(time, easing) {
      var x = this.currentPage.pageX,
          y = this.currentPage.pageY;
      x--;

      if (x < 0 && this.hasVerticalScroll) {
        x = 0;
        y--;
      }

      this.goToPage(x, y, time, easing);
    },
    _initKeys: function _initKeys(e) {
      // default key bindings
      var keys = {
        pageUp: 33,
        pageDown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40
      };
      var i; // if you give me characters I give you keycode

      if (_typeof(this.options.keyBindings) == 'object') {
        for (i in this.options.keyBindings) {
          if (typeof this.options.keyBindings[i] == 'string') {
            this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
          }
        }
      } else {
        this.options.keyBindings = {};
      }

      for (i in keys) {
        this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
      }

      utils.addEvent(window, 'keydown', this);
      this.on('destroy', function () {
        utils.removeEvent(window, 'keydown', this);
      });
    },
    _key: function _key(e) {
      if (!this.enabled) {
        return;
      }

      var snap = this.options.snap,
          // we are using this alot, better to cache it
      newX = snap ? this.currentPage.pageX : this.x,
          newY = snap ? this.currentPage.pageY : this.y,
          now = utils.getTime(),
          prevTime = this.keyTime || 0,
          acceleration = 0.250,
          pos;

      if (this.options.useTransition && this.isInTransition) {
        pos = this.getComputedPosition();

        this._translate(Math.round(pos.x), Math.round(pos.y));

        this.isInTransition = false;
      }

      this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

      switch (e.keyCode) {
        case this.options.keyBindings.pageUp:
          if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
            newX += snap ? 1 : this.wrapperWidth;
          } else {
            newY += snap ? 1 : this.wrapperHeight;
          }

          break;

        case this.options.keyBindings.pageDown:
          if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
            newX -= snap ? 1 : this.wrapperWidth;
          } else {
            newY -= snap ? 1 : this.wrapperHeight;
          }

          break;

        case this.options.keyBindings.end:
          newX = snap ? this.pages.length - 1 : this.maxScrollX;
          newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
          break;

        case this.options.keyBindings.home:
          newX = 0;
          newY = 0;
          break;

        case this.options.keyBindings.left:
          newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
          break;

        case this.options.keyBindings.up:
          newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
          break;

        case this.options.keyBindings.right:
          newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
          break;

        case this.options.keyBindings.down:
          newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
          break;

        default:
          return;
      }

      if (snap) {
        this.goToPage(newX, newY);
        return;
      }

      if (newX > 0) {
        newX = 0;
        this.keyAcceleration = 0;
      } else if (newX < this.maxScrollX) {
        newX = this.maxScrollX;
        this.keyAcceleration = 0;
      }

      if (newY > 0) {
        newY = 0;
        this.keyAcceleration = 0;
      } else if (newY < this.maxScrollY) {
        newY = this.maxScrollY;
        this.keyAcceleration = 0;
      }

      this.scrollTo(newX, newY, 0);
      this.keyTime = now;
    },
    _animate: function _animate(destX, destY, duration, easingFn) {
      var that = this,
          startX = this.x,
          startY = this.y,
          startTime = utils.getTime(),
          destTime = startTime + duration;

      function step() {
        var now = utils.getTime(),
            newX,
            newY,
            easing;

        if (now >= destTime) {
          that.isAnimating = false;

          that._translate(destX, destY);

          if (!that.resetPosition(that.options.bounceTime)) {
            that._execEvent('scrollEnd');
          }

          return;
        }

        now = (now - startTime) / duration;
        easing = easingFn(now);
        newX = (destX - startX) * easing + startX;
        newY = (destY - startY) * easing + startY;

        that._translate(newX, newY);

        if (that.isAnimating) {
          rAF(step);
        }
        /* ANNAM ADDED FROM ISCROLL-PROBE.JS */


        if (that.options.probeType == 3) {
          that._execEvent('scroll');
        }
        /* ANNAM ADDED FROM ISCROLL-PROBE.JS END */

      }

      this.isAnimating = true;
      step();
    },
    handleEvent: function handleEvent(e) {
      switch (e.type) {
        case 'touchstart':
        case 'pointerdown':
        case 'MSPointerDown':
        case 'mousedown':
          /* ANNAM FOR AO APP */
          if (e.touches && e.touches.length == 3) {
            return;
          }
          /* ANNAM FOR AO APP END */


          this._start(e);

          if (this.options.zoom && e.touches && e.touches.length > 1) {
            this._zoomStart(e);
          }

          break;

        case 'touchmove':
        case 'pointermove':
        case 'MSPointerMove':
        case 'mousemove':
          /* ANNAM FOR AO APP */
          if (e.touches && e.touches.length == 3) {
            return;
          }
          /* ANNAM FOR AO APP END */


          if (this.options.zoom && e.touches && e.touches[1]) {
            this._zoom(e);

            return;
          }

          this._move(e);

          break;

        case 'touchend':
        case 'pointerup':
        case 'MSPointerUp':
        case 'mouseup':
        case 'touchcancel':
        case 'pointercancel':
        case 'MSPointerCancel':
        case 'mousecancel':
          /* ANNAM FOR AO APP */
          if (e.touches && e.touches.length == 3) {
            return;
          }
          /* ANNAM FOR AO APP END */


          if (this.scaled) {
            this._zoomEnd(e);

            return;
          }

          this._end(e);

          break;

        case 'orientationchange':
        case 'resize':
          this._resize();

          break;

        case 'transitionend':
        case 'webkitTransitionEnd':
        case 'oTransitionEnd':
        case 'MSTransitionEnd':
          this._transitionEnd(e);

          break;

        case 'wheel':
        case 'DOMMouseScroll':
        case 'mousewheel':
          if (this.options.wheelAction == 'zoom') {
            this._wheelZoom(e);

            return;
          }

          this._wheel(e);

          break;

        case 'keydown':
          this._key(e);

          break;
      }
    }
  };

  function createDefaultScrollbar(direction, interactive, type) {
    var scrollbar = document.createElement('div'),
        indicator = document.createElement('div');

    if (type === true) {
      scrollbar.style.cssText = 'position:absolute;z-index:9999';
      indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
    }

    indicator.className = 'iScrollIndicator';

    if (direction == 'h') {
      if (type === true) {
        scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
        indicator.style.height = '100%';
      }

      scrollbar.className = 'iScrollHorizontalScrollbar';
    } else {
      if (type === true) {
        scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
        indicator.style.width = '100%';
      }

      scrollbar.className = 'iScrollVerticalScrollbar';
    }

    scrollbar.style.cssText += ';overflow:hidden';

    if (!interactive) {
      scrollbar.style.pointerEvents = 'none';
    }

    scrollbar.appendChild(indicator);
    return scrollbar;
  }

  function Indicator(scroller, options) {
    this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
    this.wrapperStyle = this.wrapper.style;
    this.indicator = this.wrapper.children[0];
    this.indicatorStyle = this.indicator.style;
    this.scroller = scroller;
    this.options = {
      listenX: true,
      listenY: true,
      interactive: false,
      resize: true,
      defaultScrollbars: false,
      shrink: false,
      fade: false,
      speedRatioX: 0,
      speedRatioY: 0
    };

    for (var i in options) {
      this.options[i] = options[i];
    }

    this.sizeRatioX = 1;
    this.sizeRatioY = 1;
    this.maxPosX = 0;
    this.maxPosY = 0;

    if (this.options.interactive) {
      if (!this.options.disableTouch) {
        utils.addEvent(this.indicator, 'touchstart', this);
        utils.addEvent(window, 'touchend', this);
      }

      if (!this.options.disablePointer) {
        utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
        utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
      }

      if (!this.options.disableMouse) {
        utils.addEvent(this.indicator, 'mousedown', this);
        utils.addEvent(window, 'mouseup', this);
      }
    }

    if (this.options.fade) {
      this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
      this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
      this.wrapperStyle.opacity = '0';
    }
  }

  Indicator.prototype = {
    handleEvent: function handleEvent(e) {
      switch (e.type) {
        case 'touchstart':
        case 'pointerdown':
        case 'MSPointerDown':
        case 'mousedown':
          this._start(e);

          break;

        case 'touchmove':
        case 'pointermove':
        case 'MSPointerMove':
        case 'mousemove':
          this._move(e);

          break;

        case 'touchend':
        case 'pointerup':
        case 'MSPointerUp':
        case 'mouseup':
        case 'touchcancel':
        case 'pointercancel':
        case 'MSPointerCancel':
        case 'mousecancel':
          this._end(e);

          break;
      }
    },
    destroy: function destroy() {
      if (this.options.interactive) {
        utils.removeEvent(this.indicator, 'touchstart', this);
        utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
        utils.removeEvent(this.indicator, 'mousedown', this);
        utils.removeEvent(window, 'touchmove', this);
        utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
        utils.removeEvent(window, 'mousemove', this);
        utils.removeEvent(window, 'touchend', this);
        utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
        utils.removeEvent(window, 'mouseup', this);
      }

      if (this.options.defaultScrollbars) {
        this.wrapper.parentNode.removeChild(this.wrapper);
      }
    },
    _start: function _start(e) {
      var point = e.touches ? e.touches[0] : e;
      e.preventDefault();
      e.stopPropagation();
      this.transitionTime();
      this.initiated = true;
      this.moved = false;
      this.lastPointX = point.pageX;
      this.lastPointY = point.pageY;
      this.startTime = utils.getTime();

      if (!this.options.disableTouch) {
        utils.addEvent(window, 'touchmove', this);
      }

      if (!this.options.disablePointer) {
        utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
      }

      if (!this.options.disableMouse) {
        utils.addEvent(window, 'mousemove', this);
      }

      this.scroller._execEvent('beforeScrollStart');
    },
    _move: function _move(e) {
      var point = e.touches ? e.touches[0] : e,
          deltaX,
          deltaY,
          newX,
          newY,
          timestamp = utils.getTime();

      if (!this.moved) {
        this.scroller._execEvent('scrollStart');
      }

      this.moved = true;
      deltaX = point.pageX - this.lastPointX;
      this.lastPointX = point.pageX;
      deltaY = point.pageY - this.lastPointY;
      this.lastPointY = point.pageY;
      newX = this.x + deltaX;
      newY = this.y + deltaY;

      this._pos(newX, newY);
      /* ANNAM ADDED FROM ISCROLL-PROBE.JS */


      if (this.scroller.options.probeType == 1 && timestamp - this.startTime > 300) {
        this.startTime = timestamp;

        this.scroller._execEvent('scroll');
      } else if (this.scroller.options.probeType > 1) {
        this.scroller._execEvent('scroll');
      }
      /* ANNAM ADDED FROM ISCROLL-PROBE.JS END */
      // INSERT POINT: indicator._move


      e.preventDefault();
      e.stopPropagation();
    },
    _end: function _end(e) {
      if (!this.initiated) {
        return;
      }

      this.initiated = false;
      e.preventDefault();
      e.stopPropagation();
      utils.removeEvent(window, 'touchmove', this);
      utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
      utils.removeEvent(window, 'mousemove', this);

      if (this.scroller.options.snap) {
        var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

        var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

        if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
          this.scroller.directionX = 0;
          this.scroller.directionY = 0;
          this.scroller.currentPage = snap;
          this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
        }
      }

      if (this.moved) {
        this.scroller._execEvent('scrollEnd');
      }
    },
    transitionTime: function transitionTime(time) {
      time = time || 0;
      this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';

      if (!time && utils.isBadAndroid) {
        this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
      }
    },
    transitionTimingFunction: function transitionTimingFunction(easing) {
      this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
    },
    refresh: function refresh() {
      this.transitionTime();

      if (this.options.listenX && !this.options.listenY) {
        this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
      } else if (this.options.listenY && !this.options.listenX) {
        this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
      } else {
        this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
      }

      if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
        utils.addClass(this.wrapper, 'iScrollBothScrollbars');
        utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

        if (this.options.defaultScrollbars && this.options.customStyle) {
          if (this.options.listenX) {
            this.wrapper.style.right = '8px';
          } else {
            this.wrapper.style.bottom = '8px';
          }
        }
      } else {
        utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
        utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

        if (this.options.defaultScrollbars && this.options.customStyle) {
          if (this.options.listenX) {
            this.wrapper.style.right = '2px';
          } else {
            this.wrapper.style.bottom = '2px';
          }
        }
      }

      var r = this.wrapper.offsetHeight; // force refresh

      if (this.options.listenX) {
        this.wrapperWidth = this.wrapper.clientWidth;

        if (this.options.resize) {
          this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
          this.indicatorStyle.width = this.indicatorWidth + 'px';
        } else {
          this.indicatorWidth = this.indicator.clientWidth;
        }

        this.maxPosX = this.wrapperWidth - this.indicatorWidth;

        if (this.options.shrink == 'clip') {
          this.minBoundaryX = -this.indicatorWidth + 8;
          this.maxBoundaryX = this.wrapperWidth - 8;
        } else {
          this.minBoundaryX = 0;
          this.maxBoundaryX = this.maxPosX;
        }

        this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
      }

      if (this.options.listenY) {
        //var isAppleWatch = ( (typeof(prx.devices[prx.device]) != "undefined" && prx.devices[prx.device].deviceType == "applewatch") || (typeof(prx.deviceExtraParams)!="undefined" && prx.deviceExtraParams.deviceType == "applewatch")) ? true : false;
        var isAppleWatchCrown = typeof prx.devices[prx.device] != "undefined" && prx.devices[prx.device].scrollType == "crown" || typeof prx.deviceExtraParams != "undefined" && prx.deviceExtraParams.scrollType == "crown" ? true : false;
        this.wrapperHeight = this.wrapper.clientHeight;

        if (this.options.resize) {
          this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
          this.indicatorStyle.height = this.indicatorHeight + 'px';
        } else {
          //this.indicatorHeight = this.indicator.clientHeight;
          //Added for OsWatch so that it calculates the correct indicator height
          //when resizeScrollbars = true (with border)
          this.indicatorHeight = this.indicator.offsetHeight;
        }

        this.maxPosY = this.wrapperHeight - this.indicatorHeight - (isAppleWatchCrown == true ? 3 : 0);

        if (this.options.shrink == 'clip') {
          this.minBoundaryY = -this.indicatorHeight + 8;
          this.maxBoundaryY = this.wrapperHeight - 8;
        } else {
          this.minBoundaryY = isAppleWatchCrown == true ? 3 : 0;
          this.maxBoundaryY = this.maxPosY;
        }

        this.maxPosY = this.wrapperHeight - this.indicatorHeight;
        this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
      }

      this.updatePosition();
    },
    updatePosition: function updatePosition() {
      var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
          y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

      if (!this.options.ignoreBoundaries) {
        if (x < this.minBoundaryX) {
          if (this.options.shrink == 'scale') {
            this.width = Math.max(this.indicatorWidth + x, 8);
            this.indicatorStyle.width = this.width + 'px';
          }

          x = this.minBoundaryX;
        } else if (x > this.maxBoundaryX) {
          if (this.options.shrink == 'scale') {
            this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
            this.indicatorStyle.width = this.width + 'px';
            x = this.maxPosX + this.indicatorWidth - this.width;
          } else {
            x = this.maxBoundaryX;
          }
        } else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
          this.width = this.indicatorWidth;
          this.indicatorStyle.width = this.width + 'px';
        }

        if (y < this.minBoundaryY) {
          if (this.options.shrink == 'scale') {
            this.height = Math.max(this.indicatorHeight + y * 3, 8);
            this.indicatorStyle.height = this.height + 'px';
          }

          y = this.minBoundaryY;
        } else if (y > this.maxBoundaryY) {
          if (this.options.shrink == 'scale') {
            this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
            this.indicatorStyle.height = this.height + 'px';
            y = this.maxPosY + this.indicatorHeight - this.height;
          } else {
            y = this.maxBoundaryY;
          }
        } else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
          this.height = this.indicatorHeight;
          this.indicatorStyle.height = this.height + 'px';
        }
      }

      this.x = x;
      this.y = y;

      if (this.scroller.options.useTransform) {
        this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
      } else {
        this.indicatorStyle.left = x + 'px';
        this.indicatorStyle.top = y + 'px';
      }
    },
    _pos: function _pos(x, y) {
      if (x < 0) {
        x = 0;
      } else if (x > this.maxPosX) {
        x = this.maxPosX;
      }

      if (y < 0) {
        y = 0;
      } else if (y > this.maxPosY) {
        y = this.maxPosY;
      }

      x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
      y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;
      this.scroller.scrollTo(x, y);
    },
    fade: function fade(val, hold) {
      if (hold && !this.visible) {
        return;
      }

      clearTimeout(this.fadeTimeout);
      this.fadeTimeout = null;
      var time = val ? 250 : 500,
          delay = val ? 0 : 300;
      val = val ? '1' : '0';
      this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';
      this.fadeTimeout = setTimeout(function (val) {
        this.wrapperStyle.opacity = val;
        this.visible = +val;
      }.bind(this, val), delay);
    }
  };
  IScroll.utils = utils;

  if ( true && module.exports) {
    module.exports = IScroll;
  } else {
    window.IScroll = IScroll;
  }
})(window, document, Math);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./js/plugins/js-xss/xss_custom.min.js":
/*!*********************************************!*\
  !*** ./js/plugins/js-xss/xss_custom.min.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;var __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a) return require(o, !0);
        if (i) return i(o, !0);
        var f = new Error("Cannot find module '" + o + "'");
        throw f.code = "MODULE_NOT_FOUND", f;
      }

      var l = n[o] = {
        exports: {}
      };
      t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }

    return n[o].exports;
  }

  var i = typeof require == "function" && require;

  for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }

  return s;
})({
  1: [function (require, module, exports) {
    var FilterCSS = require("cssfilter").FilterCSS;

    var _ = require("./util");

    var whiteList = {
      a: ["target", "href", "title", "style"],
      abbr: ["title"],
      address: ["style"],
      area: ["shape", "coords", "href", "alt", "style"],
      article: ["style"],
      aside: ["style"],
      audio: ["autoplay", "controls", "loop", "preload", "src"],
      b: [],
      bdi: ["dir"],
      bdo: ["dir"],
      big: [],
      blockquote: ["cite", "style"],
      br: [],
      caption: ["style"],
      center: [],
      cite: [],
      code: [],
      col: ["align", "valign", "span", "width", "style"],
      colgroup: ["align", "valign", "span", "width", "style"],
      dd: [],
      del: ["datetime"],
      details: ["open"],
      div: ["style"],
      dl: [],
      dt: [],
      em: [],
      font: ["color", "size", "face", "style", "family"],
      footer: ["style"],
      h1: ["style"],
      h2: ["style"],
      h3: ["style"],
      h4: ["style"],
      h5: ["style"],
      h6: ["style"],
      header: ["style"],
      hr: ["style"],
      i: [],
      img: ["src", "alt", "title", "width", "height"],
      ins: ["datetime"],
      li: ["style"],
      mark: [],
      nav: ["style"],
      ol: [],
      p: ["style"],
      pre: ["style"],
      s: [],
      section: ["style"],
      small: [],
      span: ["style"],
      sub: [],
      sup: [],
      strong: [],
      strike: [],
      table: ["width", "border", "align", "valign", "style"],
      tbody: ["align", "valign", "style"],
      td: ["width", "colspan", "align", "valign", "style", "style"],
      tfoot: ["align", "valign", "style"],
      th: ["width", "colspan", "align", "valign", "style"],
      thead: ["align", "valign", "style"],
      tr: ["rowspan", "align", "valign", "style"],
      tt: [],
      u: [],
      ul: ["style"],
      video: ["autoplay", "controls", "loop", "preload", "src", "height", "width", "style"]
    };
    var defaultCSSFilter = new FilterCSS();

    function onTag(tag, html, options) {}

    function onIgnoreTag(tag, html, options) {}

    function onTagAttr(tag, name, value) {}

    function onIgnoreTagAttr(tag, name, value) {}

    function escapeHtml(html) {
      return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
    }

    function safeAttrValue(tag, name, value, cssFilter) {
      cssFilter = cssFilter || defaultCSSFilter;
      value = friendlyAttrValue(value);

      if (name === "href" || name === "src") {
        value = _.trim(value);
        if (value === "#") return "#";

        if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value[0] === "/")) {
          return "";
        }
      } else if (name === "background") {
        REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;

        if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
          return "";
        }
      } else if (name === "style") {
        REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;

        if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
          return "";
        }

        REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;

        if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
          REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;

          if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
            return "";
          }
        }

        value = cssFilter.process(value);
      }

      value = escapeAttrValue(value);
      return value;
    }

    var REGEXP_LT = /</g;
    var REGEXP_GT = />/g;
    var REGEXP_QUOTE = /"/g;
    var REGEXP_QUOTE_2 = /&quot;/g;
    var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
    var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
    var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
    var REGEXP_DEFAULT_ON_TAG_ATTR_3 = /\/\*|\*\//gm;
    var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a)\:/gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_5 = /^[\s"'`]*(d\s*a\s*t\s*a\s*)\:/gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_6 = /^[\s"'`]*(d\s*a\s*t\s*a\s*)\:\s*image\//gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;

    function escapeQuote(str) {
      return str.replace(REGEXP_QUOTE, "&quot;");
    }

    function unescapeQuote(str) {
      return str.replace(REGEXP_QUOTE_2, '"');
    }

    function escapeHtmlEntities(str) {
      return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str, code) {
        return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
      });
    }

    function escapeDangerHtml5Entities(str) {
      return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
    }

    function clearNonPrintableCharacter(str) {
      var str2 = "";

      for (var i = 0, len = str.length; i < len; i++) {
        str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
      }

      return _.trim(str2);
    }

    function friendlyAttrValue(str) {
      str = unescapeQuote(str);
      str = escapeHtmlEntities(str);
      str = escapeDangerHtml5Entities(str);
      str = clearNonPrintableCharacter(str);
      return str;
    }

    function escapeAttrValue(str) {
      str = escapeQuote(str);
      str = escapeHtml(str);
      return str;
    }

    function onIgnoreTagStripAll() {
      return "";
    }

    function StripTagBody(tags, next) {
      if (typeof next !== "function") {
        next = function next() {};
      }

      var isRemoveAllTag = !Array.isArray(tags);

      function isRemoveTag(tag) {
        if (isRemoveAllTag) return true;
        return _.indexOf(tags, tag) !== -1;
      }

      var removeList = [];
      var posStart = false;
      return {
        onIgnoreTag: function onIgnoreTag(tag, html, options) {
          if (isRemoveTag(tag)) {
            if (options.isClosing) {
              var ret = "[/removed]";
              var end = options.position + ret.length;
              removeList.push([posStart !== false ? posStart : options.position, end]);
              posStart = false;
              return ret;
            } else {
              if (!posStart) {
                posStart = options.position;
              }

              return "[removed]";
            }
          } else {
            return next(tag, html, options);
          }
        },
        remove: function remove(html) {
          var rethtml = "";
          var lastPos = 0;

          _.forEach(removeList, function (pos) {
            rethtml += html.slice(lastPos, pos[0]);
            lastPos = pos[1];
          });

          rethtml += html.slice(lastPos);
          return rethtml;
        }
      };
    }

    function stripCommentTag(html) {
      return html.replace(STRIP_COMMENT_TAG_REGEXP, "");
    }

    var STRIP_COMMENT_TAG_REGEXP = /<!--[\s\S]*?-->/g;

    function stripBlankChar(html) {
      var chars = html.split("");
      chars = chars.filter(function (_char) {
        var c = _char.charCodeAt(0);

        if (c === 127) return false;

        if (c <= 31) {
          if (c === 10 || c === 13) return true;
          return false;
        }

        return true;
      });
      return chars.join("");
    }

    exports.whiteList = whiteList;
    exports.onTag = onTag;
    exports.onIgnoreTag = onIgnoreTag;
    exports.onTagAttr = onTagAttr;
    exports.onIgnoreTagAttr = onIgnoreTagAttr;
    exports.safeAttrValue = safeAttrValue;
    exports.escapeHtml = escapeHtml;
    exports.escapeQuote = escapeQuote;
    exports.unescapeQuote = unescapeQuote;
    exports.escapeHtmlEntities = escapeHtmlEntities;
    exports.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
    exports.clearNonPrintableCharacter = clearNonPrintableCharacter;
    exports.friendlyAttrValue = friendlyAttrValue;
    exports.escapeAttrValue = escapeAttrValue;
    exports.onIgnoreTagStripAll = onIgnoreTagStripAll;
    exports.StripTagBody = StripTagBody;
    exports.stripCommentTag = stripCommentTag;
    exports.stripBlankChar = stripBlankChar;
    exports.cssFilter = defaultCSSFilter;
  }, {
    "./util": 4,
    cssfilter: 8
  }],
  2: [function (require, module, exports) {
    var DEFAULT = require("./default");

    var parser = require("./parser");

    var FilterXSS = require("./xss");

    function filterXSS(html, options) {
      var xss = new FilterXSS(options);
      return xss.process(html);
    }

    exports = module.exports = filterXSS;
    exports.FilterXSS = FilterXSS;

    for (var i in DEFAULT) {
      exports[i] = DEFAULT[i];
    }

    for (var i in parser) {
      exports[i] = parser[i];
    }

    if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return module.exports;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }

    if (typeof window !== "undefined") {
      window.filterXSS = module.exports;
    }
  }, {
    "./default": 1,
    "./parser": 3,
    "./xss": 5
  }],
  3: [function (require, module, exports) {
    var _ = require("./util");

    function getTagName(html) {
      var i = html.indexOf(" ");

      if (i === -1) {
        var tagName = html.slice(1, -1);
      } else {
        var tagName = html.slice(1, i + 1);
      }

      tagName = _.trim(tagName).toLowerCase();
      if (tagName.slice(0, 1) === "/") tagName = tagName.slice(1);
      if (tagName.slice(-1) === "/") tagName = tagName.slice(0, -1);
      return tagName;
    }

    function isClosing(html) {
      return html.slice(0, 2) === "</";
    }

    function parseTag(html, onTag, escapeHtml) {
      "user strict";

      var rethtml = "";
      var lastPos = 0;
      var tagStart = false;
      var quoteStart = false;
      var currentPos = 0;
      var len = html.length;
      var currentHtml = "";
      var currentTagName = "";

      for (currentPos = 0; currentPos < len; currentPos++) {
        var c = html.charAt(currentPos);

        if (tagStart === false) {
          if (c === "<") {
            tagStart = currentPos;
            continue;
          }
        } else {
          if (quoteStart === false) {
            if (c === "<") {
              rethtml += escapeHtml(html.slice(lastPos, currentPos));
              tagStart = currentPos;
              lastPos = currentPos;
              continue;
            }

            if (c === ">") {
              rethtml += escapeHtml(html.slice(lastPos, tagStart));
              currentHtml = html.slice(tagStart, currentPos + 1);
              currentTagName = getTagName(currentHtml);
              rethtml += onTag(tagStart, rethtml.length, currentTagName, currentHtml, isClosing(currentHtml));
              lastPos = currentPos + 1;
              tagStart = false;
              continue;
            }

            if ((c === '"' || c === "'") && html.charAt(currentPos - 1) === "=") {
              quoteStart = c;
              continue;
            }
          } else {
            if (c === quoteStart) {
              quoteStart = false;
              continue;
            }
          }
        }
      }

      if (lastPos < html.length) {
        rethtml += escapeHtml(html.substr(lastPos));
      }

      return rethtml;
    }

    var REGEXP_ATTR_NAME = /[^a-zA-Z0-9_:\.\-]/gim;

    function parseAttr(html, onAttr) {
      "user strict";

      var lastPos = 0;
      var retAttrs = [];
      var tmpName = false;
      var len = html.length;

      function addAttr(name, value) {
        name = _.trim(name);
        name = name.replace(REGEXP_ATTR_NAME, "").toLowerCase();
        if (name.length < 1) return;
        var ret = onAttr(name, value || "");
        if (ret) retAttrs.push(ret);
      }

      for (var i = 0; i < len; i++) {
        var c = html.charAt(i);
        var v, j;

        if (tmpName === false && c === "=") {
          tmpName = html.slice(lastPos, i);
          lastPos = i + 1;
          continue;
        }

        if (tmpName !== false) {
          if (i === lastPos && (c === '"' || c === "'") && html.charAt(i - 1) === "=") {
            j = html.indexOf(c, i + 1);

            if (j === -1) {
              break;
            } else {
              v = _.trim(html.slice(lastPos + 1, j));
              addAttr(tmpName, v);
              tmpName = false;
              i = j;
              lastPos = i + 1;
              continue;
            }
          }
        }

        if (c === " ") {
          if (tmpName === false) {
            j = findNextEqual(html, i);

            if (j === -1) {
              v = _.trim(html.slice(lastPos, i));
              addAttr(v);
              tmpName = false;
              lastPos = i + 1;
              continue;
            } else {
              i = j - 1;
              continue;
            }
          } else {
            j = findBeforeEqual(html, i - 1);

            if (j === -1) {
              v = _.trim(html.slice(lastPos, i));
              v = stripQuoteWrap(v);
              addAttr(tmpName, v);
              tmpName = false;
              lastPos = i + 1;
              continue;
            } else {
              continue;
            }
          }
        }
      }

      if (lastPos < html.length) {
        if (tmpName === false) {
          addAttr(html.slice(lastPos));
        } else {
          addAttr(tmpName, stripQuoteWrap(_.trim(html.slice(lastPos))));
        }
      }

      return _.trim(retAttrs.join(" "));
    }

    function findNextEqual(str, i) {
      for (; i < str.length; i++) {
        var c = str[i];
        if (c === " ") continue;
        if (c === "=") return i;
        return -1;
      }
    }

    function findBeforeEqual(str, i) {
      for (; i > 0; i--) {
        var c = str[i];
        if (c === " ") continue;
        if (c === "=") return i;
        return -1;
      }
    }

    function isQuoteWrapString(text) {
      if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
        return true;
      } else {
        return false;
      }
    }

    function stripQuoteWrap(text) {
      if (isQuoteWrapString(text)) {
        return text.substr(1, text.length - 2);
      } else {
        return text;
      }
    }

    exports.parseTag = parseTag;
    exports.parseAttr = parseAttr;
  }, {
    "./util": 4
  }],
  4: [function (require, module, exports) {
    module.exports = {
      indexOf: function indexOf(arr, item) {
        var i, j;

        if (Array.prototype.indexOf) {
          return arr.indexOf(item);
        }

        for (i = 0, j = arr.length; i < j; i++) {
          if (arr[i] === item) {
            return i;
          }
        }

        return -1;
      },
      forEach: function forEach(arr, fn, scope) {
        var i, j;

        if (Array.prototype.forEach) {
          return arr.forEach(fn, scope);
        }

        for (i = 0, j = arr.length; i < j; i++) {
          fn.call(scope, arr[i], i, arr);
        }
      },
      trim: function trim(str) {
        if (String.prototype.trim) {
          return str.trim();
        }

        return str.replace(/(^\s*)|(\s*$)/g, "");
      }
    };
  }, {}],
  5: [function (require, module, exports) {
    var FilterCSS = require("cssfilter").FilterCSS;

    var DEFAULT = require("./default");

    var parser = require("./parser");

    var parseTag = parser.parseTag;
    var parseAttr = parser.parseAttr;

    var _ = require("./util");

    function isNull(obj) {
      return obj === undefined || obj === null;
    }

    function getAttrs(html) {
      var i = html.indexOf(" ");

      if (i === -1) {
        return {
          html: "",
          closing: html[html.length - 2] === "/"
        };
      }

      html = _.trim(html.slice(i + 1, -1));
      var isClosing = html[html.length - 1] === "/";
      if (isClosing) html = _.trim(html.slice(0, -1));
      return {
        html: html,
        closing: isClosing
      };
    }

    function FilterXSS(options) {
      options = options || {};

      if (options.stripIgnoreTag) {
        if (options.onIgnoreTag) {
          console.error('Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time');
        }

        options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
      }

      options.whiteList = options.whiteList || DEFAULT.whiteList;
      options.onTag = options.onTag || DEFAULT.onTag;
      options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
      options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
      options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
      options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
      options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
      options.css = options.css || {};
      this.options = options;
      this.cssFilter = new FilterCSS(options.css);
    }

    FilterXSS.prototype.process = function (html) {
      html = html || "";
      html = html.toString();
      if (!html) return "";
      var me = this;
      var options = me.options;
      var whiteList = options.whiteList;
      var onTag = options.onTag;
      var onIgnoreTag = options.onIgnoreTag;
      var onTagAttr = options.onTagAttr;
      var onIgnoreTagAttr = options.onIgnoreTagAttr;
      var safeAttrValue = options.safeAttrValue;
      var escapeHtml = options.escapeHtml;
      var cssFilter = me.cssFilter;

      if (options.stripBlankChar) {
        html = DEFAULT.stripBlankChar(html);
      }

      if (!options.allowCommentTag) {
        html = DEFAULT.stripCommentTag(html);
      }

      if (options.stripIgnoreTagBody) {
        var stripIgnoreTagBody = DEFAULT.StripTagBody(options.stripIgnoreTagBody, onIgnoreTag);
        onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
      } else {
        stripIgnoreTagBody = false;
      }

      var retHtml = parseTag(html, function (sourcePosition, position, tag, html, isClosing) {
        var info = {
          sourcePosition: sourcePosition,
          position: position,
          isClosing: isClosing,
          isWhite: tag in whiteList
        };
        var ret = onTag(tag, html, info);
        if (!isNull(ret)) return ret;

        if (info.isWhite) {
          if (info.isClosing) {
            return "</" + tag + ">";
          }

          var attrs = getAttrs(html);
          var whiteAttrList = whiteList[tag];
          var attrsHtml = parseAttr(attrs.html, function (name, value) {
            var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
            var ret = onTagAttr(tag, name, value, isWhiteAttr);
            if (!isNull(ret)) return ret;

            if (isWhiteAttr) {
              value = safeAttrValue(tag, name, value, cssFilter);

              if (value) {
                return name + '="' + value + '"';
              } else {
                return name;
              }
            } else {
              var ret = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
              if (!isNull(ret)) return ret;
              return;
            }
          });
          var html = "<" + tag;
          if (attrsHtml) html += " " + attrsHtml;
          if (attrs.closing) html += " /";
          html += ">";
          return html;
        } else {
          var ret = onIgnoreTag(tag, html, info);
          if (!isNull(ret)) return ret;
          return escapeHtml(html);
        }
      }, escapeHtml);

      if (stripIgnoreTagBody) {
        retHtml = stripIgnoreTagBody.remove(retHtml);
      }

      return retHtml;
    };

    module.exports = FilterXSS;
  }, {
    "./default": 1,
    "./parser": 3,
    "./util": 4,
    cssfilter: 8
  }],
  6: [function (require, module, exports) {
    var DEFAULT = require("./default");

    var parseStyle = require("./parser");

    var _ = require("./util");

    function isNull(obj) {
      return obj === undefined || obj === null;
    }

    function FilterCSS(options) {
      options = options || {};
      options.whiteList = options.whiteList || DEFAULT.whiteList;
      options.onAttr = options.onAttr || DEFAULT.onAttr;
      options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT.onIgnoreAttr;
      this.options = options;
    }

    FilterCSS.prototype.process = function (css) {
      css = css || "";
      css = css.toString();
      if (!css) return "";
      var me = this;
      var options = me.options;
      var whiteList = options.whiteList;
      var onAttr = options.onAttr;
      var onIgnoreAttr = options.onIgnoreAttr;
      var retCSS = parseStyle(css, function (sourcePosition, position, name, value, source) {
        var check = whiteList[name];
        var isWhite = false;
        if (check === true) isWhite = check;else if (typeof check === "function") isWhite = check(value);else if (check instanceof RegExp) isWhite = check.test(value);
        if (isWhite !== true) isWhite = false;
        var opts = {
          position: position,
          sourcePosition: sourcePosition,
          source: source,
          isWhite: isWhite
        };

        if (isWhite) {
          var ret = onAttr(name, value, opts);

          if (isNull(ret)) {
            return name + ":" + value;
          } else {
            return ret;
          }
        } else {
          var ret = onIgnoreAttr(name, value, opts);

          if (!isNull(ret)) {
            return ret;
          }
        }
      });
      return retCSS;
    };

    module.exports = FilterCSS;
  }, {
    "./default": 7,
    "./parser": 9,
    "./util": 10
  }],
  7: [function (require, module, exports) {
    var whiteList = {};
    whiteList["align-content"] = false;
    whiteList["align-items"] = false;
    whiteList["align-self"] = false;
    whiteList["alignment-adjust"] = false;
    whiteList["alignment-baseline"] = false;
    whiteList["all"] = false;
    whiteList["anchor-point"] = false;
    whiteList["animation"] = false;
    whiteList["animation-delay"] = false;
    whiteList["animation-direction"] = false;
    whiteList["animation-duration"] = false;
    whiteList["animation-fill-mode"] = false;
    whiteList["animation-iteration-count"] = false;
    whiteList["animation-name"] = false;
    whiteList["animation-play-state"] = false;
    whiteList["animation-timing-function"] = false;
    whiteList["azimuth"] = false;
    whiteList["backface-visibility"] = false;
    whiteList["background"] = true;
    whiteList["background-attachment"] = true;
    whiteList["background-clip"] = true;
    whiteList["background-color"] = true;
    whiteList["background-image"] = true;
    whiteList["background-origin"] = true;
    whiteList["background-position"] = true;
    whiteList["background-repeat"] = true;
    whiteList["background-size"] = true;
    whiteList["baseline-shift"] = false;
    whiteList["binding"] = false;
    whiteList["bleed"] = false;
    whiteList["bookmark-label"] = false;
    whiteList["bookmark-level"] = false;
    whiteList["bookmark-state"] = false;
    whiteList["border"] = true;
    whiteList["border-bottom"] = true;
    whiteList["border-bottom-color"] = true;
    whiteList["border-bottom-left-radius"] = true;
    whiteList["border-bottom-right-radius"] = true;
    whiteList["border-bottom-style"] = true;
    whiteList["border-bottom-width"] = true;
    whiteList["border-collapse"] = true;
    whiteList["border-color"] = true;
    whiteList["border-image"] = true;
    whiteList["border-image-outset"] = true;
    whiteList["border-image-repeat"] = true;
    whiteList["border-image-slice"] = true;
    whiteList["border-image-source"] = true;
    whiteList["border-image-width"] = true;
    whiteList["border-left"] = true;
    whiteList["border-left-color"] = true;
    whiteList["border-left-style"] = true;
    whiteList["border-left-width"] = true;
    whiteList["border-radius"] = true;
    whiteList["border-right"] = true;
    whiteList["border-right-color"] = true;
    whiteList["border-right-style"] = true;
    whiteList["border-right-width"] = true;
    whiteList["border-spacing"] = true;
    whiteList["border-style"] = true;
    whiteList["border-top"] = true;
    whiteList["border-top-color"] = true;
    whiteList["border-top-left-radius"] = true;
    whiteList["border-top-right-radius"] = true;
    whiteList["border-top-style"] = true;
    whiteList["border-top-width"] = true;
    whiteList["border-width"] = true;
    whiteList["bottom"] = false;
    whiteList["box-decoration-break"] = true;
    whiteList["box-shadow"] = true;
    whiteList["box-sizing"] = true;
    whiteList["box-snap"] = true;
    whiteList["box-suppress"] = true;
    whiteList["break-after"] = true;
    whiteList["break-before"] = true;
    whiteList["break-inside"] = true;
    whiteList["caption-side"] = false;
    whiteList["chains"] = false;
    whiteList["clear"] = true;
    whiteList["clip"] = false;
    whiteList["clip-path"] = false;
    whiteList["clip-rule"] = false;
    whiteList["color"] = true;
    whiteList["color-interpolation-filters"] = true;
    whiteList["column-count"] = false;
    whiteList["column-fill"] = false;
    whiteList["column-gap"] = false;
    whiteList["column-rule"] = false;
    whiteList["column-rule-color"] = false;
    whiteList["column-rule-style"] = false;
    whiteList["column-rule-width"] = false;
    whiteList["column-span"] = false;
    whiteList["column-width"] = false;
    whiteList["columns"] = false;
    whiteList["contain"] = false;
    whiteList["content"] = false;
    whiteList["counter-increment"] = false;
    whiteList["counter-reset"] = false;
    whiteList["counter-set"] = false;
    whiteList["crop"] = false;
    whiteList["cue"] = false;
    whiteList["cue-after"] = false;
    whiteList["cue-before"] = false;
    whiteList["cursor"] = false;
    whiteList["direction"] = false;
    whiteList["display"] = true;
    whiteList["display-inside"] = true;
    whiteList["display-list"] = true;
    whiteList["display-outside"] = true;
    whiteList["dominant-baseline"] = false;
    whiteList["elevation"] = false;
    whiteList["empty-cells"] = false;
    whiteList["filter"] = false;
    whiteList["flex"] = false;
    whiteList["flex-basis"] = false;
    whiteList["flex-direction"] = false;
    whiteList["flex-flow"] = false;
    whiteList["flex-grow"] = false;
    whiteList["flex-shrink"] = false;
    whiteList["flex-wrap"] = false;
    whiteList["float"] = false;
    whiteList["float-offset"] = false;
    whiteList["flood-color"] = false;
    whiteList["flood-opacity"] = false;
    whiteList["flow-from"] = false;
    whiteList["flow-into"] = false;
    whiteList["font"] = true;
    whiteList["font-family"] = true;
    whiteList["font-feature-settings"] = true;
    whiteList["font-kerning"] = true;
    whiteList["font-language-override"] = true;
    whiteList["font-size"] = true;
    whiteList["font-size-adjust"] = true;
    whiteList["font-stretch"] = true;
    whiteList["font-style"] = true;
    whiteList["font-synthesis"] = true;
    whiteList["font-variant"] = true;
    whiteList["font-variant-alternates"] = true;
    whiteList["font-variant-caps"] = true;
    whiteList["font-variant-east-asian"] = true;
    whiteList["font-variant-ligatures"] = true;
    whiteList["font-variant-numeric"] = true;
    whiteList["font-variant-position"] = true;
    whiteList["font-weight"] = true;
    whiteList["grid"] = false;
    whiteList["grid-area"] = false;
    whiteList["grid-auto-columns"] = false;
    whiteList["grid-auto-flow"] = false;
    whiteList["grid-auto-rows"] = false;
    whiteList["grid-column"] = false;
    whiteList["grid-column-end"] = false;
    whiteList["grid-column-start"] = false;
    whiteList["grid-row"] = false;
    whiteList["grid-row-end"] = false;
    whiteList["grid-row-start"] = false;
    whiteList["grid-template"] = false;
    whiteList["grid-template-areas"] = false;
    whiteList["grid-template-columns"] = false;
    whiteList["grid-template-rows"] = false;
    whiteList["hanging-punctuation"] = false;
    whiteList["height"] = true;
    whiteList["hyphens"] = false;
    whiteList["icon"] = false;
    whiteList["image-orientation"] = false;
    whiteList["image-resolution"] = false;
    whiteList["ime-mode"] = false;
    whiteList["initial-letters"] = false;
    whiteList["inline-box-align"] = false;
    whiteList["justify-content"] = false;
    whiteList["justify-items"] = false;
    whiteList["justify-self"] = false;
    whiteList["left"] = false;
    whiteList["letter-spacing"] = true;
    whiteList["lighting-color"] = true;
    whiteList["line-box-contain"] = false;
    whiteList["line-break"] = false;
    whiteList["line-grid"] = false;
    whiteList["line-height"] = true;
    whiteList["line-snap"] = false;
    whiteList["line-stacking"] = false;
    whiteList["line-stacking-ruby"] = false;
    whiteList["line-stacking-shift"] = false;
    whiteList["line-stacking-strategy"] = false;
    whiteList["list-style"] = true;
    whiteList["list-style-image"] = true;
    whiteList["list-style-position"] = true;
    whiteList["list-style-type"] = true;
    whiteList["margin"] = true;
    whiteList["margin-bottom"] = true;
    whiteList["margin-left"] = true;
    whiteList["margin-right"] = true;
    whiteList["margin-top"] = true;
    whiteList["marker-offset"] = false;
    whiteList["marker-side"] = false;
    whiteList["marks"] = false;
    whiteList["mask"] = false;
    whiteList["mask-box"] = false;
    whiteList["mask-box-outset"] = false;
    whiteList["mask-box-repeat"] = false;
    whiteList["mask-box-slice"] = false;
    whiteList["mask-box-source"] = false;
    whiteList["mask-box-width"] = false;
    whiteList["mask-clip"] = false;
    whiteList["mask-image"] = false;
    whiteList["mask-origin"] = false;
    whiteList["mask-position"] = false;
    whiteList["mask-repeat"] = false;
    whiteList["mask-size"] = false;
    whiteList["mask-source-type"] = false;
    whiteList["mask-type"] = false;
    whiteList["max-height"] = true;
    whiteList["max-lines"] = false;
    whiteList["max-width"] = true;
    whiteList["min-height"] = true;
    whiteList["min-width"] = true;
    whiteList["move-to"] = false;
    whiteList["nav-down"] = false;
    whiteList["nav-index"] = false;
    whiteList["nav-left"] = false;
    whiteList["nav-right"] = false;
    whiteList["nav-up"] = false;
    whiteList["object-fit"] = false;
    whiteList["object-position"] = false;
    whiteList["opacity"] = false;
    whiteList["order"] = false;
    whiteList["orphans"] = false;
    whiteList["outline"] = false;
    whiteList["outline-color"] = false;
    whiteList["outline-offset"] = false;
    whiteList["outline-style"] = false;
    whiteList["outline-width"] = false;
    whiteList["overflow"] = false;
    whiteList["overflow-wrap"] = false;
    whiteList["overflow-x"] = false;
    whiteList["overflow-y"] = false;
    whiteList["padding"] = true;
    whiteList["padding-bottom"] = true;
    whiteList["padding-left"] = true;
    whiteList["padding-right"] = true;
    whiteList["padding-top"] = true;
    whiteList["page"] = false;
    whiteList["page-break-after"] = false;
    whiteList["page-break-before"] = false;
    whiteList["page-break-inside"] = false;
    whiteList["page-policy"] = false;
    whiteList["pause"] = false;
    whiteList["pause-after"] = false;
    whiteList["pause-before"] = false;
    whiteList["perspective"] = false;
    whiteList["perspective-origin"] = false;
    whiteList["pitch"] = false;
    whiteList["pitch-range"] = false;
    whiteList["play-during"] = false;
    whiteList["position"] = false;
    whiteList["presentation-level"] = false;
    whiteList["quotes"] = false;
    whiteList["region-fragment"] = false;
    whiteList["resize"] = false;
    whiteList["rest"] = false;
    whiteList["rest-after"] = false;
    whiteList["rest-before"] = false;
    whiteList["richness"] = false;
    whiteList["right"] = false;
    whiteList["rotation"] = false;
    whiteList["rotation-point"] = false;
    whiteList["ruby-align"] = false;
    whiteList["ruby-merge"] = false;
    whiteList["ruby-position"] = false;
    whiteList["shape-image-threshold"] = false;
    whiteList["shape-outside"] = false;
    whiteList["shape-margin"] = false;
    whiteList["size"] = false;
    whiteList["speak"] = false;
    whiteList["speak-as"] = false;
    whiteList["speak-header"] = false;
    whiteList["speak-numeral"] = false;
    whiteList["speak-punctuation"] = false;
    whiteList["speech-rate"] = false;
    whiteList["stress"] = false;
    whiteList["string-set"] = false;
    whiteList["tab-size"] = false;
    whiteList["table-layout"] = false;
    whiteList["text-align"] = true;
    whiteList["text-align-last"] = true;
    whiteList["text-combine-upright"] = true;
    whiteList["text-decoration"] = true;
    whiteList["text-decoration-color"] = true;
    whiteList["text-decoration-line"] = true;
    whiteList["text-decoration-skip"] = true;
    whiteList["text-decoration-style"] = true;
    whiteList["text-emphasis"] = true;
    whiteList["text-emphasis-color"] = true;
    whiteList["text-emphasis-position"] = true;
    whiteList["text-emphasis-style"] = true;
    whiteList["text-height"] = true;
    whiteList["text-indent"] = true;
    whiteList["text-justify"] = true;
    whiteList["text-orientation"] = true;
    whiteList["text-overflow"] = true;
    whiteList["text-shadow"] = true;
    whiteList["text-space-collapse"] = true;
    whiteList["text-transform"] = true;
    whiteList["text-underline-position"] = true;
    whiteList["text-wrap"] = true;
    whiteList["top"] = false;
    whiteList["transform"] = false;
    whiteList["transform-origin"] = false;
    whiteList["transform-style"] = false;
    whiteList["transition"] = false;
    whiteList["transition-delay"] = false;
    whiteList["transition-duration"] = false;
    whiteList["transition-property"] = false;
    whiteList["transition-timing-function"] = false;
    whiteList["unicode-bidi"] = false;
    whiteList["vertical-align"] = false;
    whiteList["visibility"] = false;
    whiteList["voice-balance"] = false;
    whiteList["voice-duration"] = false;
    whiteList["voice-family"] = false;
    whiteList["voice-pitch"] = false;
    whiteList["voice-range"] = false;
    whiteList["voice-rate"] = false;
    whiteList["voice-stress"] = false;
    whiteList["voice-volume"] = false;
    whiteList["volume"] = false;
    whiteList["white-space"] = false;
    whiteList["widows"] = false;
    whiteList["width"] = true;
    whiteList["will-change"] = false;
    whiteList["word-break"] = true;
    whiteList["word-spacing"] = true;
    whiteList["word-wrap"] = true;
    whiteList["wrap-flow"] = false;
    whiteList["wrap-through"] = false;
    whiteList["writing-mode"] = false;
    whiteList["z-index"] = false;

    function onAttr(name, value, options) {}

    function onIgnoreAttr(name, value, options) {}

    exports.whiteList = whiteList;
    exports.onAttr = onAttr;
    exports.onIgnoreAttr = onIgnoreAttr;
  }, {}],
  8: [function (require, module, exports) {
    var DEFAULT = require("./default");

    var FilterCSS = require("./css");

    function filterCSS(html, options) {
      var xss = new FilterCSS(options);
      return xss.process(html);
    }

    exports = module.exports = filterCSS;
    exports.FilterCSS = FilterCSS;

    for (var i in DEFAULT) {
      exports[i] = DEFAULT[i];
    }

    if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return module.exports;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }

    if (typeof window !== "undefined") {
      window.filterCSS = module.exports;
    }
  }, {
    "./css": 6,
    "./default": 7
  }],
  9: [function (require, module, exports) {
    var _ = require("./util");

    function parseStyle(css, onAttr) {
      css = _.trimRight(css);
      if (css[css.length - 1] !== ";") css += ";";
      var cssLength = css.length;
      var isParenthesisOpen = false;
      var lastPos = 0;
      var i = 0;
      var retCSS = "";

      function addNewAttr() {
        if (!isParenthesisOpen) {
          var source = _.trim(css.slice(lastPos, i));

          var j = source.indexOf(":");

          if (j !== -1) {
            var name = _.trim(source.slice(0, j));

            var value = _.trim(source.slice(j + 1));

            if (name) {
              var ret = onAttr(lastPos, retCSS.length, name, value, source);
              if (ret) retCSS += ret + "; ";
            }
          }
        }

        lastPos = i + 1;
      }

      for (; i < cssLength; i++) {
        var c = css[i];

        if (c === "/" && css[i + 1] === "*") {
          var j = css.indexOf("*/", i + 2);
          if (j === -1) break;
          i = j + 1;
          lastPos = i + 1;
          isParenthesisOpen = false;
        } else if (c === "(") {
          isParenthesisOpen = true;
        } else if (c === ")") {
          isParenthesisOpen = false;
        } else if (c === ";") {
          if (isParenthesisOpen) {} else {
            addNewAttr();
          }
        } else if (c === "\n") {
          addNewAttr();
        }
      }

      return _.trim(retCSS);
    }

    module.exports = parseStyle;
  }, {
    "./util": 10
  }],
  10: [function (require, module, exports) {
    module.exports = {
      indexOf: function indexOf(arr, item) {
        var i, j;

        if (Array.prototype.indexOf) {
          return arr.indexOf(item);
        }

        for (i = 0, j = arr.length; i < j; i++) {
          if (arr[i] === item) {
            return i;
          }
        }

        return -1;
      },
      forEach: function forEach(arr, fn, scope) {
        var i, j;

        if (Array.prototype.forEach) {
          return arr.forEach(fn, scope);
        }

        for (i = 0, j = arr.length; i < j; i++) {
          fn.call(scope, arr[i], i, arr);
        }
      },
      trim: function trim(str) {
        if (String.prototype.trim) {
          return str.trim();
        }

        return str.replace(/(^\s*)|(\s*$)/g, "");
      },
      trimRight: function trimRight(str) {
        if (String.prototype.trimRight) {
          return str.trimRight();
        }

        return str.replace(/(\s*$)/g, "");
      }
    };
  }, {}]
}, {}, [2]);
/**gy contains custom var whitelist**/

/***/ }),

/***/ "./js/plugins/lodash/lodash.clonedeep.js":
/*!***********************************************!*\
  !*** ./js/plugins/lodash/lodash.clonedeep.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (lodash, undefined) {
  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER = 9007199254740991;
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to match `RegExp` flags from their coerced string values. */

  var reFlags = /\w*$/;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /** Used to identify `toStringTag` values supported by `_.clone`. */

  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();
  /** Detect free variable `exports`. */

  var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */

  function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
  }
  /**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */


  function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
  }
  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */


  function arrayEach(array, iteratee) {
    var index = -1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */


  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }
  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */


  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array ? array.length : 0;

    if (initAccum && length) {
      accumulator = array[++index];
    }

    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }

    return accumulator;
  }
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */


  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */


  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */


  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }
  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */


  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */


  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */


  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }
  /** Used for built-in method references. */


  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;
  /** Used to detect overreaching core-js shims. */

  var coreJsData = root['__core-js_shared__'];
  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /** Used to resolve the decompiled source of functions. */


  var funcToString = funcProto.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString = objectProto.toString;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /** Built-in value references. */

  var Buffer = moduleExports ? root.Buffer : undefined,
      _Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object);
  /* Built-in method references that are verified to be native. */

  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');
  /** Used to detect maps, sets, and weakmaps. */

  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */


  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */


  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  } // Add methods to `Hash`.


  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */


  function listCacheClear() {
    this.__data__ = [];
  }
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    return true;
  }
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */


  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */


  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */


  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */


  function stackClear() {
    this.__data__ = new ListCache();
  }
  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function stackDelete(key) {
    return this.__data__['delete'](key);
  }
  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function stackGet(key) {
    return this.__data__.get(key);
  }
  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function stackHas(key) {
    return this.__data__.has(key);
  }
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */


  function stackSet(key, value) {
    var cache = this.__data__;

    if (cache instanceof ListCache) {
      var pairs = cache.__data__;

      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }

      cache = this.__data__ = new MapCache(pairs);
    }

    cache.set(key, value);
    return this;
  } // Add methods to `Stack`.


  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length,
        skipIndexes = !!length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */


  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      object[key] = value;
    }
  }
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }
  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */


  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @param {boolean} [isFull] Specify a clone including symbols.
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */


  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }

    if (result !== undefined) {
      return result;
    }

    if (!isObject(value)) {
      return value;
    }

    var isArr = isArray(value);

    if (isArr) {
      result = initCloneArray(value);

      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }

      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }

        result = initCloneObject(isFunc ? {} : value);

        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }

        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    } // Check for circular references and return its corresponding clone.


    stack || (stack = new Stack());
    var stacked = stack.get(value);

    if (stacked) {
      return stacked;
    }

    stack.set(value, result);

    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys(value);
    }

    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      } // Recursively populate clone (susceptible to call stack limits).


      assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
  }
  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */


  function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
  }
  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  /**
   * The base implementation of `getTag`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */


  function baseGetTag(value) {
    return objectToString.call(value);
  }
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */


  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */


  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */


  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }
  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */


  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  /**
   * Creates a clone of `map`.
   *
   * @private
   * @param {Object} map The map to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned map.
   */


  function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor());
  }
  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */


  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  /**
   * Creates a clone of `set`.
   *
   * @private
   * @param {Object} set The set to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned set.
   */


  function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor());
  }
  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */


  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */


  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */


  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }
  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */


  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
      assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }

    return object;
  }
  /**
   * Copies own symbol properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */


  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */


  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */


  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  /**
   * Creates an array of the own enumerable symbol properties of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */


  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
  // for data views in Edge < 14, and promises in Node.js.

  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = objectToString.call(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : undefined;

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;

          case mapCtorString:
            return mapTag;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag;

          case weakMapCtorString:
            return weakMapTag;
        }
      }

      return result;
    };
  }
  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */


  function initCloneArray(array) {
    var length = array.length,
        result = array.constructor(length); // Add properties assigned by `RegExp#exec`.

    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }

    return result;
  }
  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */


  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */


  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;

    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return cloneSet(object, isDeep, cloneFunc);

      case symbolTag:
        return cloneSymbol(object);
    }
  }
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */


  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */


  function isKeyable(value) {
    var type = _typeof(value);

    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */


  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to process.
   * @returns {string} Returns the source code.
   */


  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }
  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */


  lodash.cloneDeep = function (value) {
    return baseClone(value, true, true);
  };
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */


  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */


  function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
  }
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */


  var isArray = Array.isArray;
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */


  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */


  var isBuffer = nativeIsBuffer || stubFalse;
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */

  function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */


  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject(value) {
    var type = _typeof(value);

    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike(value) {
    return !!value && _typeof(value) == 'object';
  }
  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */


  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */


  function stubArray() {
    return [];
  }
  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */


  function stubFalse() {
    return false;
  }
})(window.lodash = window.lodash || {});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./js/plugins/lottie/lottie.min.js":
/*!*****************************************!*\
  !*** ./js/plugins/lottie/lottie.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

typeof navigator !== "undefined" && function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return factory(root);
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(window || {}, function (window) {
  "use strict";

  var svgNS = "http://www.w3.org/2000/svg";
  var locationHref = '';
  var initialDefaultFrame = -999999;
  var subframeEnabled = true;
  var expressionsPlugin;
  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  var cachedColors = {};
  var bm_rounder = Math.round;
  var bm_rnd;
  var bm_pow = Math.pow;
  var bm_sqrt = Math.sqrt;
  var bm_abs = Math.abs;
  var bm_floor = Math.floor;
  var bm_max = Math.max;
  var bm_min = Math.min;
  var blitter = 10;
  var BMMath = {};

  (function () {
    var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
    var i,
        len = propertyNames.length;

    for (i = 0; i < len; i += 1) {
      BMMath[propertyNames[i]] = Math[propertyNames[i]];
    }
  })();

  function ProjectInterface() {
    return {};
  }

  BMMath.random = Math.random;

  BMMath.abs = function (val) {
    var tOfVal = _typeof(val);

    if (tOfVal === 'object' && val.length) {
      var absArr = createSizedArray(val.length);
      var i,
          len = val.length;

      for (i = 0; i < len; i += 1) {
        absArr[i] = Math.abs(val[i]);
      }

      return absArr;
    }

    return Math.abs(val);
  };

  var defaultCurveSegments = 150;
  var degToRads = Math.PI / 180;
  var roundCorner = 0.5519;

  function roundValues(flag) {
    if (flag) {
      bm_rnd = Math.round;
    } else {
      bm_rnd = function bm_rnd(val) {
        return val;
      };
    }
  }

  roundValues(false);

  function styleDiv(element) {
    element.style.position = 'absolute';
    element.style.top = 0;
    element.style.left = 0;
    element.style.display = 'block';
    element.style.transformOrigin = element.style.webkitTransformOrigin = '0 0';
    element.style.backfaceVisibility = element.style.webkitBackfaceVisibility = 'visible';
    element.style.transformStyle = element.style.webkitTransformStyle = element.style.mozTransformStyle = "preserve-3d";
  }

  function BMEnterFrameEvent(n, c, t, d) {
    this.type = n;
    this.currentTime = c;
    this.totalTime = t;
    this.direction = d < 0 ? -1 : 1;
  }

  function BMCompleteEvent(n, d) {
    this.type = n;
    this.direction = d < 0 ? -1 : 1;
  }

  function BMCompleteLoopEvent(n, c, t, d) {
    this.type = n;
    this.currentLoop = t;
    this.totalLoops = c;
    this.direction = d < 0 ? -1 : 1;
  }

  function BMSegmentStartEvent(n, f, t) {
    this.type = n;
    this.firstFrame = f;
    this.totalFrames = t;
  }

  function BMDestroyEvent(n, t) {
    this.type = n;
    this.target = t;
  }

  var createElementID = function () {
    var _count = 0;
    return function createID() {
      return '__lottie_element_' + ++_count;
    };
  }();

  function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;

      case 1:
        r = q;
        g = v;
        b = p;
        break;

      case 2:
        r = p;
        g = v;
        b = t;
        break;

      case 3:
        r = p;
        g = q;
        b = v;
        break;

      case 4:
        r = t;
        g = p;
        b = v;
        break;

      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }

    return [r, g, b];
  }

  function RGBtoHSV(r, g, b) {
    var max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        d = max - min,
        h,
        s = max === 0 ? 0 : d / max,
        v = max / 255;

    switch (max) {
      case min:
        h = 0;
        break;

      case r:
        h = g - b + d * (g < b ? 6 : 0);
        h /= 6 * d;
        break;

      case g:
        h = b - r + d * 2;
        h /= 6 * d;
        break;

      case b:
        h = r - g + d * 4;
        h /= 6 * d;
        break;
    }

    return [h, s, v];
  }

  function addSaturationToRGB(color, offset) {
    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
    hsv[1] += offset;

    if (hsv[1] > 1) {
      hsv[1] = 1;
    } else if (hsv[1] <= 0) {
      hsv[1] = 0;
    }

    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
  }

  function addBrightnessToRGB(color, offset) {
    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
    hsv[2] += offset;

    if (hsv[2] > 1) {
      hsv[2] = 1;
    } else if (hsv[2] < 0) {
      hsv[2] = 0;
    }

    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
  }

  function addHueToRGB(color, offset) {
    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
    hsv[0] += offset / 360;

    if (hsv[0] > 1) {
      hsv[0] -= 1;
    } else if (hsv[0] < 0) {
      hsv[0] += 1;
    }

    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
  }

  var rgbToHex = function () {
    var colorMap = [];
    var i;
    var hex;

    for (i = 0; i < 256; i += 1) {
      hex = i.toString(16);
      colorMap[i] = hex.length == 1 ? '0' + hex : hex;
    }

    return function (r, g, b) {
      if (r < 0) {
        r = 0;
      }

      if (g < 0) {
        g = 0;
      }

      if (b < 0) {
        b = 0;
      }

      return '#' + colorMap[r] + colorMap[g] + colorMap[b];
    };
  }();

  function BaseEvent() {}

  BaseEvent.prototype = {
    triggerEvent: function triggerEvent(eventName, args) {
      if (this._cbs[eventName]) {
        var len = this._cbs[eventName].length;

        for (var i = 0; i < len; i++) {
          this._cbs[eventName][i](args);
        }
      }
    },
    addEventListener: function addEventListener(eventName, callback) {
      if (!this._cbs[eventName]) {
        this._cbs[eventName] = [];
      }

      this._cbs[eventName].push(callback);

      return function () {
        this.removeEventListener(eventName, callback);
      }.bind(this);
    },
    removeEventListener: function removeEventListener(eventName, callback) {
      if (!callback) {
        this._cbs[eventName] = null;
      } else if (this._cbs[eventName]) {
        var i = 0,
            len = this._cbs[eventName].length;

        while (i < len) {
          if (this._cbs[eventName][i] === callback) {
            this._cbs[eventName].splice(i, 1);

            i -= 1;
            len -= 1;
          }

          i += 1;
        }

        if (!this._cbs[eventName].length) {
          this._cbs[eventName] = null;
        }
      }
    }
  };

  var createTypedArray = function () {
    function createRegularArray(type, len) {
      var i = 0,
          arr = [],
          value;

      switch (type) {
        case 'int16':
        case 'uint8c':
          value = 1;
          break;

        default:
          value = 1.1;
          break;
      }

      for (i = 0; i < len; i += 1) {
        arr.push(value);
      }

      return arr;
    }

    function createTypedArray(type, len) {
      if (type === 'float32') {
        return new Float32Array(len);
      } else if (type === 'int16') {
        return new Int16Array(len);
      } else if (type === 'uint8c') {
        return new Uint8ClampedArray(len);
      }
    }

    if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
      return createTypedArray;
    } else {
      return createRegularArray;
    }
  }();

  function createSizedArray(len) {
    return Array.apply(null, {
      length: len
    });
  }

  function createNS(type) {
    //return {appendChild:function(){},setAttribute:function(){},style:{}}
    return document.createElementNS(svgNS, type);
  }

  function createTag(type) {
    //return {appendChild:function(){},setAttribute:function(){},style:{}}
    return document.createElement(type);
  }

  function DynamicPropertyContainer() {}

  ;
  DynamicPropertyContainer.prototype = {
    addDynamicProperty: function addDynamicProperty(prop) {
      if (this.dynamicProperties.indexOf(prop) === -1) {
        this.dynamicProperties.push(prop);
        this.container.addDynamicProperty(this);
        this._isAnimated = true;
      }
    },
    iterateDynamicProperties: function iterateDynamicProperties() {
      this._mdf = false;
      var i,
          len = this.dynamicProperties.length;

      for (i = 0; i < len; i += 1) {
        this.dynamicProperties[i].getValue();

        if (this.dynamicProperties[i]._mdf) {
          this._mdf = true;
        }
      }
    },
    initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
      this.container = container;
      this.dynamicProperties = [];
      this._mdf = false;
      this._isAnimated = false;
    }
  };

  var getBlendMode = function () {
    var blendModeEnums = {
      0: 'source-over',
      1: 'multiply',
      2: 'screen',
      3: 'overlay',
      4: 'darken',
      5: 'lighten',
      6: 'color-dodge',
      7: 'color-burn',
      8: 'hard-light',
      9: 'soft-light',
      10: 'difference',
      11: 'exclusion',
      12: 'hue',
      13: 'saturation',
      14: 'color',
      15: 'luminosity'
    };
    return function (mode) {
      return blendModeEnums[mode] || '';
    };
  }();
  /*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   */

  /**
   * 2D transformation matrix object initialized with identity matrix.
   *
   * The matrix can synchronize a canvas context by supplying the context
   * as an argument, or later apply current absolute transform to an
   * existing context.
   *
   * All values are handled as floating point values.
   *
   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
   * @prop {number} a - scale x
   * @prop {number} b - shear y
   * @prop {number} c - shear x
   * @prop {number} d - scale y
   * @prop {number} e - translate x
   * @prop {number} f - translate y
   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
   * @constructor
   */


  var Matrix = function () {
    var _cos = Math.cos;
    var _sin = Math.sin;
    var _tan = Math.tan;
    var _rnd = Math.round;

    function reset() {
      this.props[0] = 1;
      this.props[1] = 0;
      this.props[2] = 0;
      this.props[3] = 0;
      this.props[4] = 0;
      this.props[5] = 1;
      this.props[6] = 0;
      this.props[7] = 0;
      this.props[8] = 0;
      this.props[9] = 0;
      this.props[10] = 1;
      this.props[11] = 0;
      this.props[12] = 0;
      this.props[13] = 0;
      this.props[14] = 0;
      this.props[15] = 1;
      return this;
    }

    function rotate(angle) {
      if (angle === 0) {
        return this;
      }

      var mCos = _cos(angle);

      var mSin = _sin(angle);

      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }

    function rotateX(angle) {
      if (angle === 0) {
        return this;
      }

      var mCos = _cos(angle);

      var mSin = _sin(angle);

      return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
    }

    function rotateY(angle) {
      if (angle === 0) {
        return this;
      }

      var mCos = _cos(angle);

      var mSin = _sin(angle);

      return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
    }

    function rotateZ(angle) {
      if (angle === 0) {
        return this;
      }

      var mCos = _cos(angle);

      var mSin = _sin(angle);

      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }

    function shear(sx, sy) {
      return this._t(1, sy, sx, 1, 0, 0);
    }

    function skew(ax, ay) {
      return this.shear(_tan(ax), _tan(ay));
    }

    function skewFromAxis(ax, angle) {
      var mCos = _cos(angle);

      var mSin = _sin(angle);

      return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); //return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
    }

    function scale(sx, sy, sz) {
      if (!sz && sz !== 0) {
        sz = 1;
      }

      if (sx === 1 && sy === 1 && sz === 1) {
        return this;
      }

      return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
    }

    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
      this.props[0] = a;
      this.props[1] = b;
      this.props[2] = c;
      this.props[3] = d;
      this.props[4] = e;
      this.props[5] = f;
      this.props[6] = g;
      this.props[7] = h;
      this.props[8] = i;
      this.props[9] = j;
      this.props[10] = k;
      this.props[11] = l;
      this.props[12] = m;
      this.props[13] = n;
      this.props[14] = o;
      this.props[15] = p;
      return this;
    }

    function translate(tx, ty, tz) {
      tz = tz || 0;

      if (tx !== 0 || ty !== 0 || tz !== 0) {
        return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
      }

      return this;
    }

    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
      var _p = this.props;

      if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
        //NOTE: commenting this condition because TurboFan deoptimizes code when present
        //if(m2 !== 0 || n2 !== 0 || o2 !== 0){
        _p[12] = _p[12] * a2 + _p[15] * m2;
        _p[13] = _p[13] * f2 + _p[15] * n2;
        _p[14] = _p[14] * k2 + _p[15] * o2;
        _p[15] = _p[15] * p2; //}

        this._identityCalculated = false;
        return this;
      }

      var a1 = _p[0];
      var b1 = _p[1];
      var c1 = _p[2];
      var d1 = _p[3];
      var e1 = _p[4];
      var f1 = _p[5];
      var g1 = _p[6];
      var h1 = _p[7];
      var i1 = _p[8];
      var j1 = _p[9];
      var k1 = _p[10];
      var l1 = _p[11];
      var m1 = _p[12];
      var n1 = _p[13];
      var o1 = _p[14];
      var p1 = _p[15];
      /* matrix order (canvas compatible):
       * ace
       * bdf
       * 001
       */

      _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
      _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
      _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
      _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
      _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
      _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
      _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
      _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
      _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
      _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
      _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
      _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
      _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
      _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
      _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
      _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
      this._identityCalculated = false;
      return this;
    }

    function isIdentity() {
      if (!this._identityCalculated) {
        this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
        this._identityCalculated = true;
      }

      return this._identity;
    }

    function equals(matr) {
      var i = 0;

      while (i < 16) {
        if (matr.props[i] !== this.props[i]) {
          return false;
        }

        i += 1;
      }

      return true;
    }

    function clone(matr) {
      var i;

      for (i = 0; i < 16; i += 1) {
        matr.props[i] = this.props[i];
      }
    }

    function cloneFromProps(props) {
      var i;

      for (i = 0; i < 16; i += 1) {
        this.props[i] = props[i];
      }
    }

    function applyToPoint(x, y, z) {
      return {
        x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
        y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
        z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
      };
      /*return {
       x: x * me.a + y * me.c + me.e,
       y: x * me.b + y * me.d + me.f
       };*/
    }

    function applyToX(x, y, z) {
      return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
    }

    function applyToY(x, y, z) {
      return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
    }

    function applyToZ(x, y, z) {
      return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
    }

    function inversePoint(pt) {
      var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
      var a = this.props[5] / determinant;
      var b = -this.props[1] / determinant;
      var c = -this.props[4] / determinant;
      var d = this.props[0] / determinant;
      var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
      var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
      return [pt[0] * a + pt[1] * c + e, pt[0] * b + pt[1] * d + f, 0];
    }

    function inversePoints(pts) {
      var i,
          len = pts.length,
          retPts = [];

      for (i = 0; i < len; i += 1) {
        retPts[i] = inversePoint(pts[i]);
      }

      return retPts;
    }

    function applyToTriplePoints(pt1, pt2, pt3) {
      var arr = createTypedArray('float32', 6);

      if (this.isIdentity()) {
        arr[0] = pt1[0];
        arr[1] = pt1[1];
        arr[2] = pt2[0];
        arr[3] = pt2[1];
        arr[4] = pt3[0];
        arr[5] = pt3[1];
      } else {
        var p0 = this.props[0],
            p1 = this.props[1],
            p4 = this.props[4],
            p5 = this.props[5],
            p12 = this.props[12],
            p13 = this.props[13];
        arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
        arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
        arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
        arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
        arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
        arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
      }

      return arr;
    }

    function applyToPointArray(x, y, z) {
      var arr;

      if (this.isIdentity()) {
        arr = [x, y, z];
      } else {
        arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
      }

      return arr;
    }

    function applyToPointStringified(x, y) {
      if (this.isIdentity()) {
        return x + ',' + y;
      }

      var _p = this.props;
      return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
    }

    function toCSS() {
      //Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

      /*if(this.isIdentity()) {
          return '';
      }*/
      var i = 0;
      var props = this.props;
      var cssValue = 'matrix3d(';
      var v = 10000;

      while (i < 16) {
        cssValue += _rnd(props[i] * v) / v;
        cssValue += i === 15 ? ')' : ',';
        i += 1;
      }

      return cssValue;
    }

    function roundMatrixProperty(val) {
      var v = 10000;

      if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {
        return _rnd(val * v) / v;
      }

      return val;
    }

    function to2dCSS() {
      //Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

      /*if(this.isIdentity()) {
          return '';
      }*/
      var props = this.props;

      var _a = roundMatrixProperty(props[0]);

      var _b = roundMatrixProperty(props[1]);

      var _c = roundMatrixProperty(props[4]);

      var _d = roundMatrixProperty(props[5]);

      var _e = roundMatrixProperty(props[12]);

      var _f = roundMatrixProperty(props[13]);

      return "matrix(" + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ")";
    }

    return function () {
      this.reset = reset;
      this.rotate = rotate;
      this.rotateX = rotateX;
      this.rotateY = rotateY;
      this.rotateZ = rotateZ;
      this.skew = skew;
      this.skewFromAxis = skewFromAxis;
      this.shear = shear;
      this.scale = scale;
      this.setTransform = setTransform;
      this.translate = translate;
      this.transform = transform;
      this.applyToPoint = applyToPoint;
      this.applyToX = applyToX;
      this.applyToY = applyToY;
      this.applyToZ = applyToZ;
      this.applyToPointArray = applyToPointArray;
      this.applyToTriplePoints = applyToTriplePoints;
      this.applyToPointStringified = applyToPointStringified;
      this.toCSS = toCSS;
      this.to2dCSS = to2dCSS;
      this.clone = clone;
      this.cloneFromProps = cloneFromProps;
      this.equals = equals;
      this.inversePoints = inversePoints;
      this.inversePoint = inversePoint;
      this._t = this.transform;
      this.isIdentity = isIdentity;
      this._identity = true;
      this._identityCalculated = false;
      this.props = createTypedArray('float32', 16);
      this.reset();
    };
  }();
  /*
   Copyright 2014 David Bau.
  
   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:
  
   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.
  
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  
   */


  (function (pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //
    var global = this,
        width = 256,
        // each RC4 output is 0 <= x < 256
    chunks = 6,
        // at least six RC4 outputs for each double
    digits = 52,
        // there are 52 significant digits in a double
    rngname = 'random',
        // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1,
        nodecrypto; // node.js crypto module, initialized at the bottom.
    //
    // seedrandom()
    // This is the seedrandom function described above.
    //

    function seedrandom(seed, options, callback) {
      var key = [];
      options = options === true ? {
        entropy: true
      } : options || {}; // Flatten the seed string or build one from local entropy if needed.

      var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.

      var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains
      // randomness in every bit of the mantissa of the IEEE 754 value.

      var prng = function prng() {
        var n = arc4.g(chunks),
            // Start with a numerator n < 2 ^ 48
        d = startdenom,
            //   and denominator d = 2 ^ 48.
        x = 0; //   and no 'extra last byte'.

        while (n < significance) {
          // Fill up all significant digits by
          n = (n + x) * width; //   shifting numerator and

          d *= width; //   denominator and generating a

          x = arc4.g(1); //   new least-significant-byte.
        }

        while (n >= overflow) {
          // To avoid rounding up, before adding
          n /= 2; //   last byte, shift everything

          d /= 2; //   right using integer math until

          x >>>= 1; //   we have exactly the desired bits.
        }

        return (n + x) / d; // Form the number within [0, 1).
      };

      prng.int32 = function () {
        return arc4.g(4) | 0;
      };

      prng.quick = function () {
        return arc4.g(4) / 0x100000000;
      };

      prng["double"] = prng; // Mix the randomness into accumulated entropy.

      mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.

      return (options.pass || callback || function (prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) {
            copy(state, arc4);
          } // Only provide the .state method if requested via options.state.


          prng.state = function () {
            return copy(arc4, {});
          };
        } // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.


        if (is_math_call) {
          math[rngname] = prng;
          return seed;
        } // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);
    }

    math['seed' + rngname] = seedrandom; //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //

    function ARC4(key) {
      var t,
          keylen = key.length,
          me = this,
          i = 0,
          j = me.i = me.j = 0,
          s = me.S = []; // The empty key [] is treated as [0].

      if (!keylen) {
        key = [keylen++];
      } // Set up S using the standard key scheduling algorithm.


      while (i < width) {
        s[i] = i++;
      }

      for (i = 0; i < width; i++) {
        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
        s[j] = t;
      } // The "g" method returns the next (count) outputs as one number.


      me.g = function (count) {
        // Using instance members instead of closure state nearly doubles speed.
        var t,
            r = 0,
            i = me.i,
            j = me.j,
            s = me.S;

        while (count--) {
          t = s[i = mask & i + 1];
          r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
        }

        me.i = i;
        me.j = j;
        return r; // For robust unpredictability, the function call below automatically
        // discards an initial batch of values.  This is called RC4-drop[256].
        // See http://google.com/search?q=rsa+fluhrer+response&btnI
      };
    } //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //


    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    } //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //


    function flatten(obj, depth) {
      var result = [],
          typ = _typeof(obj),
          prop;

      if (depth && typ == 'object') {
        for (prop in obj) {
          try {
            result.push(flatten(obj[prop], depth - 1));
          } catch (e) {}
        }
      }

      return result.length ? result : typ == 'string' ? obj : obj + '\0';
    } //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //


    function mixkey(seed, key) {
      var stringseed = seed + '',
          smear,
          j = 0;

      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }

      return tostring(key);
    } //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //


    function autoseed() {
      try {
        if (nodecrypto) {
          return tostring(nodecrypto.randomBytes(width));
        }

        var out = new Uint8Array(width);
        (global.crypto || global.msCrypto).getRandomValues(out);
        return tostring(out);
      } catch (e) {
        var browser = global.navigator,
            plugins = browser && browser.plugins;
        return [+new Date(), global, plugins, global.screen, tostring(pool)];
      }
    } //
    // tostring()
    // Converts an array of charcodes to a string
    //


    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    } //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //


    mixkey(math.random(), pool); //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    // End anonymous scope, and pass initial values.
  })([], // pool: entropy pool starts empty
  BMMath // math: package containing random, pow, and seedrandom
  );

  var BezierFactory = function () {
    /**
     * BezierEasing - use bezier curve for transition easing function
     * by Gatan Renaudeau 2014 - 2015  MIT License
     *
     * Credits: is based on Firefox's nsSMILKeySpline.cpp
     * Usage:
     * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
     * spline.get(x) => returns the easing value | x must be in [0, 1] range
     *
     */
    var ob = {};
    ob.getBezierEasing = getBezierEasing;
    var beziers = {};

    function getBezierEasing(a, b, c, d, nm) {
      var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');

      if (beziers[str]) {
        return beziers[str];
      }

      var bezEasing = new BezierEasing([a, b, c, d]);
      beziers[str] = bezEasing;
      return bezEasing;
    } // These values are established by empiricism with tests (tradeoff: performance VS precision)


    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;
    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
    var float32ArraySupported = typeof Float32Array === "function";

    function A(aA1, aA2) {
      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }

    function B(aA1, aA2) {
      return 3.0 * aA2 - 6.0 * aA1;
    }

    function C(aA1) {
      return 3.0 * aA1;
    } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


    function calcBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


    function getSlope(aT, aA1, aA2) {
      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function binarySubdivide(aX, aA, aB, mX1, mX2) {
      var currentX,
          currentT,
          i = 0;

      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;

        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

      return currentT;
    }

    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) return aGuessT;
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }

      return aGuessT;
    }
    /**
     * points is an array of [ mX1, mY1, mX2, mY2 ]
     */


    function BezierEasing(points) {
      this._p = points;
      this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      this._precomputed = false;
      this.get = this.get.bind(this);
    }

    BezierEasing.prototype = {
      get: function get(x) {
        var mX1 = this._p[0],
            mY1 = this._p[1],
            mX2 = this._p[2],
            mY2 = this._p[3];
        if (!this._precomputed) this._precompute();
        if (mX1 === mY1 && mX2 === mY2) return x; // linear
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.

        if (x === 0) return 0;
        if (x === 1) return 1;
        return calcBezier(this._getTForX(x), mY1, mY2);
      },
      // Private part
      _precompute: function _precompute() {
        var mX1 = this._p[0],
            mY1 = this._p[1],
            mX2 = this._p[2],
            mY2 = this._p[3];
        this._precomputed = true;
        if (mX1 !== mY1 || mX2 !== mY2) this._calcSampleValues();
      },
      _calcSampleValues: function _calcSampleValues() {
        var mX1 = this._p[0],
            mX2 = this._p[2];

        for (var i = 0; i < kSplineTableSize; ++i) {
          this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
        }
      },

      /**
       * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
       */
      _getTForX: function _getTForX(aX) {
        var mX1 = this._p[0],
            mX2 = this._p[2],
            mSampleValues = this._mSampleValues;
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;

        for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }

        --currentSample; // Interpolate to provide an initial guess for t

        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);

        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }
    };
    return ob;
  }();

  (function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];

    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  })();

  function extendPrototype(sources, destination) {
    var i,
        len = sources.length,
        sourcePrototype;

    for (i = 0; i < len; i += 1) {
      sourcePrototype = sources[i].prototype;

      for (var attr in sourcePrototype) {
        if (sourcePrototype.hasOwnProperty(attr)) destination.prototype[attr] = sourcePrototype[attr];
      }
    }
  }

  function getDescriptor(object, prop) {
    return Object.getOwnPropertyDescriptor(object, prop);
  }

  function createProxyFunction(prototype) {
    function ProxyFunction() {}

    ProxyFunction.prototype = prototype;
    return ProxyFunction;
  }

  function bezFunction() {
    var easingFunctions = [];
    var math = Math;

    function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
      var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
      return det1 > -0.001 && det1 < 0.001;
    }

    function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
      if (z1 === 0 && z2 === 0 && z3 === 0) {
        return pointOnLine2D(x1, y1, x2, y2, x3, y3);
      }

      var dist1 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2));
      var dist2 = Math.sqrt(Math.pow(x3 - x1, 2) + Math.pow(y3 - y1, 2) + Math.pow(z3 - z1, 2));
      var dist3 = Math.sqrt(Math.pow(x3 - x2, 2) + Math.pow(y3 - y2, 2) + Math.pow(z3 - z2, 2));
      var diffDist;

      if (dist1 > dist2) {
        if (dist1 > dist3) {
          diffDist = dist1 - dist2 - dist3;
        } else {
          diffDist = dist3 - dist2 - dist1;
        }
      } else if (dist3 > dist2) {
        diffDist = dist3 - dist2 - dist1;
      } else {
        diffDist = dist2 - dist1 - dist3;
      }

      return diffDist > -0.0001 && diffDist < 0.0001;
    }

    var getBezierLength = function () {
      return function (pt1, pt2, pt3, pt4) {
        var curveSegments = defaultCurveSegments;
        var k;
        var i, len;
        var ptCoord,
            perc,
            addedLength = 0;
        var ptDistance;
        var point = [],
            lastPoint = [];
        var lengthData = bezier_length_pool.newElement();
        len = pt3.length;

        for (k = 0; k < curveSegments; k += 1) {
          perc = k / (curveSegments - 1);
          ptDistance = 0;

          for (i = 0; i < len; i += 1) {
            ptCoord = bm_pow(1 - perc, 3) * pt1[i] + 3 * bm_pow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bm_pow(perc, 2) * pt4[i] + bm_pow(perc, 3) * pt2[i];
            point[i] = ptCoord;

            if (lastPoint[i] !== null) {
              ptDistance += bm_pow(point[i] - lastPoint[i], 2);
            }

            lastPoint[i] = point[i];
          }

          if (ptDistance) {
            ptDistance = bm_sqrt(ptDistance);
            addedLength += ptDistance;
          }

          lengthData.percents[k] = perc;
          lengthData.lengths[k] = addedLength;
        }

        lengthData.addedLength = addedLength;
        return lengthData;
      };
    }();

    function getSegmentsLength(shapeData) {
      var segmentsLength = segments_length_pool.newElement();
      var closed = shapeData.c;
      var pathV = shapeData.v;
      var pathO = shapeData.o;
      var pathI = shapeData.i;
      var i,
          len = shapeData._length;
      var lengths = segmentsLength.lengths;
      var totalLength = 0;

      for (i = 0; i < len - 1; i += 1) {
        lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
        totalLength += lengths[i].addedLength;
      }

      if (closed && len) {
        lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
        totalLength += lengths[i].addedLength;
      }

      segmentsLength.totalLength = totalLength;
      return segmentsLength;
    }

    function BezierData(length) {
      this.segmentLength = 0;
      this.points = new Array(length);
    }

    function PointData(partial, point) {
      this.partialLength = partial;
      this.point = point;
    }

    var buildBezierData = function () {
      var storedData = {};
      return function (pt1, pt2, pt3, pt4) {
        var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');

        if (!storedData[bezierName]) {
          var curveSegments = defaultCurveSegments;
          var k, i, len;
          var ptCoord,
              perc,
              addedLength = 0;
          var ptDistance;
          var point,
              lastPoint = null;

          if (pt1.length === 2 && (pt1[0] != pt2[0] || pt1[1] != pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
            curveSegments = 2;
          }

          var bezierData = new BezierData(curveSegments);
          len = pt3.length;

          for (k = 0; k < curveSegments; k += 1) {
            point = createSizedArray(len);
            perc = k / (curveSegments - 1);
            ptDistance = 0;

            for (i = 0; i < len; i += 1) {
              ptCoord = bm_pow(1 - perc, 3) * pt1[i] + 3 * bm_pow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bm_pow(perc, 2) * (pt2[i] + pt4[i]) + bm_pow(perc, 3) * pt2[i];
              point[i] = ptCoord;

              if (lastPoint !== null) {
                ptDistance += bm_pow(point[i] - lastPoint[i], 2);
              }
            }

            ptDistance = bm_sqrt(ptDistance);
            addedLength += ptDistance;
            bezierData.points[k] = new PointData(ptDistance, point);
            lastPoint = point;
          }

          bezierData.segmentLength = addedLength;
          storedData[bezierName] = bezierData;
        }

        return storedData[bezierName];
      };
    }();

    function getDistancePerc(perc, bezierData) {
      var percents = bezierData.percents;
      var lengths = bezierData.lengths;
      var len = percents.length;
      var initPos = bm_floor((len - 1) * perc);
      var lengthPos = perc * bezierData.addedLength;
      var lPerc = 0;

      if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
        return percents[initPos];
      } else {
        var dir = lengths[initPos] > lengthPos ? -1 : 1;
        var flag = true;

        while (flag) {
          if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
            lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
            flag = false;
          } else {
            initPos += dir;
          }

          if (initPos < 0 || initPos >= len - 1) {
            //FIX for TypedArrays that don't store floating point values with enough accuracy
            if (initPos === len - 1) {
              return percents[initPos];
            }

            flag = false;
          }
        }

        return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
      }
    }

    function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
      var t1 = getDistancePerc(percent, bezierData);
      var u0 = 1;
      var u1 = 1 - t1;
      var ptX = Math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
      var ptY = Math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
      return [ptX, ptY];
    }

    function getSegmentArray() {}

    var bezier_segment_points = createTypedArray('float32', 8);

    function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
      startPerc = startPerc < 0 ? 0 : startPerc > 1 ? 1 : startPerc;
      var t0 = getDistancePerc(startPerc, bezierData);
      endPerc = endPerc > 1 ? 1 : endPerc;
      var t1 = getDistancePerc(endPerc, bezierData);
      var i,
          len = pt1.length;
      var u0 = 1 - t0;
      var u1 = 1 - t1;
      var u0u0u0 = u0 * u0 * u0;
      var t0u0u0_3 = t0 * u0 * u0 * 3;
      var t0t0u0_3 = t0 * t0 * u0 * 3;
      var t0t0t0 = t0 * t0 * t0; //

      var u0u0u1 = u0 * u0 * u1;
      var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
      var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
      var t0t0t1 = t0 * t0 * t1; //

      var u0u1u1 = u0 * u1 * u1;
      var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
      var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
      var t0t1t1 = t0 * t1 * t1; //

      var u1u1u1 = u1 * u1 * u1;
      var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
      var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
      var t1t1t1 = t1 * t1 * t1;

      for (i = 0; i < len; i += 1) {
        bezier_segment_points[i * 4] = Math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000;
        bezier_segment_points[i * 4 + 1] = Math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000;
        bezier_segment_points[i * 4 + 2] = Math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000;
        bezier_segment_points[i * 4 + 3] = Math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000;
      }

      return bezier_segment_points;
    }

    return {
      getSegmentsLength: getSegmentsLength,
      getNewSegment: getNewSegment,
      getPointInSegment: getPointInSegment,
      buildBezierData: buildBezierData,
      pointOnLine2D: pointOnLine2D,
      pointOnLine3D: pointOnLine3D
    };
  }

  var bez = bezFunction();

  function dataFunctionManager() {
    //var tCanvasHelper = createTag('canvas').getContext('2d');
    function completeLayers(layers, comps, fontManager) {
      var layerData;
      var animArray, lastFrame;
      var i,
          len = layers.length;
      var j, jLen, k, kLen;

      for (i = 0; i < len; i += 1) {
        layerData = layers[i];

        if (!('ks' in layerData) || layerData.completed) {
          continue;
        }

        layerData.completed = true;

        if (layerData.tt) {
          layers[i - 1].td = layerData.tt;
        }

        animArray = [];
        lastFrame = -1;

        if (layerData.hasMask) {
          var maskProps = layerData.masksProperties;
          jLen = maskProps.length;

          for (j = 0; j < jLen; j += 1) {
            if (maskProps[j].pt.k.i) {
              convertPathsToAbsoluteValues(maskProps[j].pt.k);
            } else {
              kLen = maskProps[j].pt.k.length;

              for (k = 0; k < kLen; k += 1) {
                if (maskProps[j].pt.k[k].s) {
                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                }

                if (maskProps[j].pt.k[k].e) {
                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                }
              }
            }
          }
        }

        if (layerData.ty === 0) {
          layerData.layers = findCompLayers(layerData.refId, comps);
          completeLayers(layerData.layers, comps, fontManager);
        } else if (layerData.ty === 4) {
          completeShapes(layerData.shapes);
        } else if (layerData.ty == 5) {
          completeText(layerData, fontManager);
        }
      }
    }

    function findCompLayers(id, comps) {
      var i = 0,
          len = comps.length;

      while (i < len) {
        if (comps[i].id === id) {
          if (!comps[i].layers.__used) {
            comps[i].layers.__used = true;
            return comps[i].layers;
          }

          return JSON.parse(JSON.stringify(comps[i].layers));
        }

        i += 1;
      }
    }

    function completeShapes(arr) {
      var i,
          len = arr.length;
      var j, jLen;
      var hasPaths = false;

      for (i = len - 1; i >= 0; i -= 1) {
        if (arr[i].ty == 'sh') {
          if (arr[i].ks.k.i) {
            convertPathsToAbsoluteValues(arr[i].ks.k);
          } else {
            jLen = arr[i].ks.k.length;

            for (j = 0; j < jLen; j += 1) {
              if (arr[i].ks.k[j].s) {
                convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
              }

              if (arr[i].ks.k[j].e) {
                convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
              }
            }
          }

          hasPaths = true;
        } else if (arr[i].ty == 'gr') {
          completeShapes(arr[i].it);
        }
      }
      /*if(hasPaths){
          //mx: distance
          //ss: sensitivity
          //dc: decay
          arr.splice(arr.length-1,0,{
              "ty": "ms",
              "mx":20,
              "ss":10,
               "dc":0.001,
              "maxDist":200
          });
      }*/

    }

    function convertPathsToAbsoluteValues(path) {
      var i,
          len = path.i.length;

      for (i = 0; i < len; i += 1) {
        path.i[i][0] += path.v[i][0];
        path.i[i][1] += path.v[i][1];
        path.o[i][0] += path.v[i][0];
        path.o[i][1] += path.v[i][1];
      }
    }

    function checkVersion(minimum, animVersionString) {
      var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];

      if (minimum[0] > animVersion[0]) {
        return true;
      } else if (animVersion[0] > minimum[0]) {
        return false;
      }

      if (minimum[1] > animVersion[1]) {
        return true;
      } else if (animVersion[1] > minimum[1]) {
        return false;
      }

      if (minimum[2] > animVersion[2]) {
        return true;
      } else if (animVersion[2] > minimum[2]) {
        return false;
      }
    }

    var checkText = function () {
      var minimumVersion = [4, 4, 14];

      function updateTextLayer(textLayer) {
        var documentData = textLayer.t.d;
        textLayer.t.d = {
          k: [{
            s: documentData,
            t: 0
          }]
        };
      }

      function iterateLayers(layers) {
        var i,
            len = layers.length;

        for (i = 0; i < len; i += 1) {
          if (layers[i].ty === 5) {
            updateTextLayer(layers[i]);
          }
        }
      }

      return function (animationData) {
        if (checkVersion(minimumVersion, animationData.v)) {
          iterateLayers(animationData.layers);

          if (animationData.assets) {
            var i,
                len = animationData.assets.length;

            for (i = 0; i < len; i += 1) {
              if (animationData.assets[i].layers) {
                iterateLayers(animationData.assets[i].layers);
              }
            }
          }
        }
      };
    }();

    var checkChars = function () {
      var minimumVersion = [4, 7, 99];
      return function (animationData) {
        if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
          var i,
              len = animationData.chars.length,
              j,
              jLen,
              k,
              kLen;
          var pathData, paths;

          for (i = 0; i < len; i += 1) {
            if (animationData.chars[i].data && animationData.chars[i].data.shapes) {
              paths = animationData.chars[i].data.shapes[0].it;
              jLen = paths.length;

              for (j = 0; j < jLen; j += 1) {
                pathData = paths[j].ks.k;

                if (!pathData.__converted) {
                  convertPathsToAbsoluteValues(paths[j].ks.k);
                  pathData.__converted = true;
                }
              }
            }
          }
        }
      };
    }();

    var checkColors = function () {
      var minimumVersion = [4, 1, 9];

      function iterateShapes(shapes) {
        var i,
            len = shapes.length;
        var j, jLen;

        for (i = 0; i < len; i += 1) {
          if (shapes[i].ty === 'gr') {
            iterateShapes(shapes[i].it);
          } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
            if (shapes[i].c.k && shapes[i].c.k[0].i) {
              jLen = shapes[i].c.k.length;

              for (j = 0; j < jLen; j += 1) {
                if (shapes[i].c.k[j].s) {
                  shapes[i].c.k[j].s[0] /= 255;
                  shapes[i].c.k[j].s[1] /= 255;
                  shapes[i].c.k[j].s[2] /= 255;
                  shapes[i].c.k[j].s[3] /= 255;
                }

                if (shapes[i].c.k[j].e) {
                  shapes[i].c.k[j].e[0] /= 255;
                  shapes[i].c.k[j].e[1] /= 255;
                  shapes[i].c.k[j].e[2] /= 255;
                  shapes[i].c.k[j].e[3] /= 255;
                }
              }
            } else {
              shapes[i].c.k[0] /= 255;
              shapes[i].c.k[1] /= 255;
              shapes[i].c.k[2] /= 255;
              shapes[i].c.k[3] /= 255;
            }
          }
        }
      }

      function iterateLayers(layers) {
        var i,
            len = layers.length;

        for (i = 0; i < len; i += 1) {
          if (layers[i].ty === 4) {
            iterateShapes(layers[i].shapes);
          }
        }
      }

      return function (animationData) {
        if (checkVersion(minimumVersion, animationData.v)) {
          iterateLayers(animationData.layers);

          if (animationData.assets) {
            var i,
                len = animationData.assets.length;

            for (i = 0; i < len; i += 1) {
              if (animationData.assets[i].layers) {
                iterateLayers(animationData.assets[i].layers);
              }
            }
          }
        }
      };
    }();

    var checkShapes = function () {
      var minimumVersion = [4, 4, 18];

      function completeShapes(arr) {
        var i,
            len = arr.length;
        var j, jLen;
        var hasPaths = false;

        for (i = len - 1; i >= 0; i -= 1) {
          if (arr[i].ty == 'sh') {
            if (arr[i].ks.k.i) {
              arr[i].ks.k.c = arr[i].closed;
            } else {
              jLen = arr[i].ks.k.length;

              for (j = 0; j < jLen; j += 1) {
                if (arr[i].ks.k[j].s) {
                  arr[i].ks.k[j].s[0].c = arr[i].closed;
                }

                if (arr[i].ks.k[j].e) {
                  arr[i].ks.k[j].e[0].c = arr[i].closed;
                }
              }
            }

            hasPaths = true;
          } else if (arr[i].ty == 'gr') {
            completeShapes(arr[i].it);
          }
        }
      }

      function iterateLayers(layers) {
        var layerData;
        var i,
            len = layers.length;
        var j, jLen, k, kLen;

        for (i = 0; i < len; i += 1) {
          layerData = layers[i];

          if (layerData.hasMask) {
            var maskProps = layerData.masksProperties;
            jLen = maskProps.length;

            for (j = 0; j < jLen; j += 1) {
              if (maskProps[j].pt.k.i) {
                maskProps[j].pt.k.c = maskProps[j].cl;
              } else {
                kLen = maskProps[j].pt.k.length;

                for (k = 0; k < kLen; k += 1) {
                  if (maskProps[j].pt.k[k].s) {
                    maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                  }

                  if (maskProps[j].pt.k[k].e) {
                    maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                  }
                }
              }
            }
          }

          if (layerData.ty === 4) {
            completeShapes(layerData.shapes);
          }
        }
      }

      return function (animationData) {
        if (checkVersion(minimumVersion, animationData.v)) {
          iterateLayers(animationData.layers);

          if (animationData.assets) {
            var i,
                len = animationData.assets.length;

            for (i = 0; i < len; i += 1) {
              if (animationData.assets[i].layers) {
                iterateLayers(animationData.assets[i].layers);
              }
            }
          }
        }
      };
    }();

    function completeData(animationData, fontManager) {
      if (animationData.__complete) {
        return;
      }

      checkColors(animationData);
      checkText(animationData);
      checkChars(animationData);
      checkShapes(animationData);
      completeLayers(animationData.layers, animationData.assets, fontManager);
      animationData.__complete = true; //blitAnimation(animationData, animationData.assets, fontManager);
    }

    function completeText(data, fontManager) {
      if (data.t.a.length === 0 && !('m' in data.t.p)) {
        data.singleShape = true;
      }
    }

    var moduleOb = {};
    moduleOb.completeData = completeData;
    return moduleOb;
  }

  var dataManager = dataFunctionManager();

  var FontManager = function () {
    var maxWaitingTime = 5000;
    var emptyChar = {
      w: 0,
      size: 0,
      shapes: []
    };
    var combinedCharacters = []; //Hindi characters

    combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);

    function setUpNode(font, family) {
      var parentNode = createTag('span');
      parentNode.style.fontFamily = family;
      var node = createTag('span'); // Characters that vary significantly among different fonts

      node.innerHTML = 'giItT1WQy@!-/#'; // Visible - so we can measure it - but not on the screen

      parentNode.style.position = 'absolute';
      parentNode.style.left = '-10000px';
      parentNode.style.top = '-10000px'; // Large font size makes even subtle changes obvious

      parentNode.style.fontSize = '300px'; // Reset any font properties

      parentNode.style.fontVariant = 'normal';
      parentNode.style.fontStyle = 'normal';
      parentNode.style.fontWeight = 'normal';
      parentNode.style.letterSpacing = '0';
      parentNode.appendChild(node);
      document.body.appendChild(parentNode); // Remember width with no applied web font

      var width = node.offsetWidth;
      node.style.fontFamily = font + ', ' + family;
      return {
        node: node,
        w: width,
        parent: parentNode
      };
    }

    function checkLoadedFonts() {
      var i,
          len = this.fonts.length;
      var node, w;
      var loadedCount = len;

      for (i = 0; i < len; i += 1) {
        if (this.fonts[i].loaded) {
          loadedCount -= 1;
          continue;
        }

        if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
          this.fonts[i].loaded = true;
        } else {
          node = this.fonts[i].monoCase.node;
          w = this.fonts[i].monoCase.w;

          if (node.offsetWidth !== w) {
            loadedCount -= 1;
            this.fonts[i].loaded = true;
          } else {
            node = this.fonts[i].sansCase.node;
            w = this.fonts[i].sansCase.w;

            if (node.offsetWidth !== w) {
              loadedCount -= 1;
              this.fonts[i].loaded = true;
            }
          }

          if (this.fonts[i].loaded) {
            this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
            this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
          }
        }
      }

      if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
        setTimeout(this.checkLoadedFonts.bind(this), 20);
      } else {
        setTimeout(function () {
          this.isLoaded = true;
        }.bind(this), 0);
      }
    }

    function createHelper(def, fontData) {
      var tHelper = createNS('text');
      tHelper.style.fontSize = '100px'; //tHelper.style.fontFamily = fontData.fFamily;

      tHelper.setAttribute('font-family', fontData.fFamily);
      tHelper.setAttribute('font-style', fontData.fStyle);
      tHelper.setAttribute('font-weight', fontData.fWeight);
      tHelper.textContent = '1';

      if (fontData.fClass) {
        tHelper.style.fontFamily = 'inherit';
        tHelper.setAttribute('class', fontData.fClass);
      } else {
        tHelper.style.fontFamily = fontData.fFamily;
      }

      def.appendChild(tHelper);
      var tCanvasHelper = createTag('canvas').getContext('2d');
      tCanvasHelper.font = fontData.fWeight + ' ' + fontData.fStyle + ' 100px ' + fontData.fFamily; //tCanvasHelper.font = ' 100px '+ fontData.fFamily;

      return tHelper;
    }

    function addFonts(fontData, defs) {
      if (!fontData) {
        this.isLoaded = true;
        return;
      }

      if (this.chars) {
        this.isLoaded = true;
        this.fonts = fontData.list;
        return;
      }

      var fontArr = fontData.list;
      var i,
          len = fontArr.length;
      var _pendingFonts = len;

      for (i = 0; i < len; i += 1) {
        var shouldLoadFont = true;
        var loadedSelector;
        var j;
        fontArr[i].loaded = false;
        fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
        fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');

        if (!fontArr[i].fPath) {
          fontArr[i].loaded = true;
          _pendingFonts -= 1;
        } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
          loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');

          if (loadedSelector.length > 0) {
            shouldLoadFont = false;
          }

          if (shouldLoadFont) {
            var s = createTag('style');
            s.setAttribute('f-forigin', fontArr[i].fOrigin);
            s.setAttribute('f-origin', fontArr[i].origin);
            s.setAttribute('f-family', fontArr[i].fFamily);
            s.type = "text/css";
            s.innerHTML = "@font-face {" + "font-family: " + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
            defs.appendChild(s);
          }
        } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
          loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');

          for (j = 0; j < loadedSelector.length; j++) {
            if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
              // Font is already loaded
              shouldLoadFont = false;
            }
          }

          if (shouldLoadFont) {
            var l = createTag('link');
            l.setAttribute('f-forigin', fontArr[i].fOrigin);
            l.setAttribute('f-origin', fontArr[i].origin);
            l.type = "text/css";
            l.rel = "stylesheet";
            l.href = fontArr[i].fPath;
            document.body.appendChild(l);
          }
        } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
          loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');

          for (j = 0; j < loadedSelector.length; j++) {
            if (fontArr[i].fPath === loadedSelector[j].src) {
              // Font is already loaded
              shouldLoadFont = false;
            }
          }

          if (shouldLoadFont) {
            var sc = createTag('link');
            sc.setAttribute('f-forigin', fontArr[i].fOrigin);
            sc.setAttribute('f-origin', fontArr[i].origin);
            sc.setAttribute('rel', 'stylesheet');
            sc.setAttribute('href', fontArr[i].fPath);
            defs.appendChild(sc);
          }
        }

        fontArr[i].helper = createHelper(defs, fontArr[i]);
        fontArr[i].cache = {};
        this.fonts.push(fontArr[i]);
      }

      if (_pendingFonts === 0) {
        this.isLoaded = true;
      } else {
        //On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
        //Adding this timeout seems to fix it
        setTimeout(this.checkLoadedFonts.bind(this), 100);
      }
    }

    function addChars(chars) {
      if (!chars) {
        return;
      }

      if (!this.chars) {
        this.chars = [];
      }

      var i,
          len = chars.length;
      var j,
          jLen = this.chars.length,
          found;

      for (i = 0; i < len; i += 1) {
        j = 0;
        found = false;

        while (j < jLen) {
          if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
            found = true;
          }

          j += 1;
        }

        if (!found) {
          this.chars.push(chars[i]);
          jLen += 1;
        }
      }
    }

    function getCharData(_char, style, font) {
      var i = 0,
          len = this.chars.length;

      while (i < len) {
        if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {
          return this.chars[i];
        }

        i += 1;
      }

      if (console && console.warn) {
        console.warn('Missing character from exported characters list: ', _char, style, font);
      }

      return emptyChar;
    }

    function measureText(_char2, fontName, size) {
      var fontData = this.getFontByName(fontName);

      var index = _char2.charCodeAt(0);

      if (!fontData.cache[index + 1]) {
        var tHelper = fontData.helper; //Canvas version
        //fontData.cache[index] = tHelper.measureText(char).width / 100;
        //SVG version
        //console.log(tHelper.getBBox().width)

        if (_char2 === ' ') {
          tHelper.textContent = '|' + _char2 + '|';
          var doubleSize = tHelper.getComputedTextLength();
          tHelper.textContent = '||';
          var singleSize = tHelper.getComputedTextLength();
          fontData.cache[index + 1] = (doubleSize - singleSize) / 100;
        } else {
          tHelper.textContent = _char2;
          fontData.cache[index + 1] = tHelper.getComputedTextLength() / 100;
        }
      }

      return fontData.cache[index + 1] * size;
    }

    function getFontByName(name) {
      var i = 0,
          len = this.fonts.length;

      while (i < len) {
        if (this.fonts[i].fName === name) {
          return this.fonts[i];
        }

        i += 1;
      }

      return this.fonts[0];
    }

    function getCombinedCharacterCodes() {
      return combinedCharacters;
    }

    function loaded() {
      return this.isLoaded;
    }

    var Font = function Font() {
      this.fonts = [];
      this.chars = null;
      this.typekitLoaded = 0;
      this.isLoaded = false;
      this.initTime = Date.now();
    }; //TODO: for now I'm adding these methods to the Class and not the prototype. Think of a better way to implement it.


    Font.getCombinedCharacterCodes = getCombinedCharacterCodes;
    Font.prototype.addChars = addChars;
    Font.prototype.addFonts = addFonts;
    Font.prototype.getCharData = getCharData;
    Font.prototype.getFontByName = getFontByName;
    Font.prototype.measureText = measureText;
    Font.prototype.checkLoadedFonts = checkLoadedFonts;
    Font.prototype.loaded = loaded;
    return Font;
  }();

  var PropertyFactory = function () {
    var initFrame = initialDefaultFrame;
    var math_abs = Math.abs;

    function interpolateValue(frameNum, caching) {
      var offsetTime = this.offsetTime;
      var newValue;

      if (this.propType === 'multidimensional') {
        newValue = createTypedArray('float32', this.pv.length);
      }

      var iterationIndex = caching.lastIndex;
      var i = iterationIndex;
      var len = this.keyframes.length - 1,
          flag = true;
      var keyData, nextKeyData;

      while (flag) {
        keyData = this.keyframes[i];
        nextKeyData = this.keyframes[i + 1];

        if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
          if (keyData.h) {
            keyData = nextKeyData;
          }

          iterationIndex = 0;
          break;
        }

        if (nextKeyData.t - offsetTime > frameNum) {
          iterationIndex = i;
          break;
        }

        if (i < len - 1) {
          i += 1;
        } else {
          iterationIndex = 0;
          flag = false;
        }
      }

      var k, kLen, perc, jLen, j, fnc;
      var nextKeyTime = nextKeyData.t - offsetTime;
      var keyTime = keyData.t - offsetTime;
      var endValue;

      if (keyData.to) {
        if (!keyData.bezierData) {
          keyData.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
        }

        var bezierData = keyData.bezierData;

        if (frameNum >= nextKeyTime || frameNum < keyTime) {
          var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
          kLen = bezierData.points[ind].point.length;

          for (k = 0; k < kLen; k += 1) {
            newValue[k] = bezierData.points[ind].point[k];
          } // caching._lastKeyframeIndex = -1;

        } else {
          if (keyData.__fnct) {
            fnc = keyData.__fnct;
          } else {
            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
            keyData.__fnct = fnc;
          }

          perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
          var distanceInLine = bezierData.segmentLength * perc;
          var segmentPerc;
          var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
          j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
          flag = true;
          jLen = bezierData.points.length;

          while (flag) {
            addedLength += bezierData.points[j].partialLength;

            if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
              kLen = bezierData.points[j].point.length;

              for (k = 0; k < kLen; k += 1) {
                newValue[k] = bezierData.points[j].point[k];
              }

              break;
            } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
              segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
              kLen = bezierData.points[j].point.length;

              for (k = 0; k < kLen; k += 1) {
                newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
              }

              break;
            }

            if (j < jLen - 1) {
              j += 1;
            } else {
              flag = false;
            }
          }

          caching._lastPoint = j;
          caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
          caching._lastKeyframeIndex = i;
        }
      } else {
        var outX, outY, inX, inY, keyValue;
        len = keyData.s.length;
        endValue = nextKeyData.s || keyData.e;

        if (this.sh && keyData.h !== 1) {
          if (frameNum >= nextKeyTime) {
            newValue[0] = endValue[0];
            newValue[1] = endValue[1];
            newValue[2] = endValue[2];
          } else if (frameNum <= keyTime) {
            newValue[0] = keyData.s[0];
            newValue[1] = keyData.s[1];
            newValue[2] = keyData.s[2];
          } else {
            var quatStart = createQuaternion(keyData.s);
            var quatEnd = createQuaternion(endValue);
            var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
            quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
          }
        } else {
          for (i = 0; i < len; i += 1) {
            if (keyData.h !== 1) {
              if (frameNum >= nextKeyTime) {
                perc = 1;
              } else if (frameNum < keyTime) {
                perc = 0;
              } else {
                if (keyData.o.x.constructor === Array) {
                  if (!keyData.__fnct) {
                    keyData.__fnct = [];
                  }

                  if (!keyData.__fnct[i]) {
                    outX = typeof keyData.o.x[i] === 'undefined' ? keyData.o.x[0] : keyData.o.x[i];
                    outY = typeof keyData.o.y[i] === 'undefined' ? keyData.o.y[0] : keyData.o.y[i];
                    inX = typeof keyData.i.x[i] === 'undefined' ? keyData.i.x[0] : keyData.i.x[i];
                    inY = typeof keyData.i.y[i] === 'undefined' ? keyData.i.y[0] : keyData.i.y[i];
                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                    keyData.__fnct[i] = fnc;
                  } else {
                    fnc = keyData.__fnct[i];
                  }
                } else {
                  if (!keyData.__fnct) {
                    outX = keyData.o.x;
                    outY = keyData.o.y;
                    inX = keyData.i.x;
                    inY = keyData.i.y;
                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                    keyData.__fnct = fnc;
                  } else {
                    fnc = keyData.__fnct;
                  }
                }

                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
              }
            }

            endValue = nextKeyData.s || keyData.e;
            keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;

            if (len === 1) {
              newValue = keyValue;
            } else {
              newValue[i] = keyValue;
            }
          }
        }
      }

      caching.lastIndex = iterationIndex;
      return newValue;
    } //based on @Toji's https://github.com/toji/gl-matrix/


    function slerp(a, b, t) {
      var out = [];
      var ax = a[0],
          ay = a[1],
          az = a[2],
          aw = a[3],
          bx = b[0],
          by = b[1],
          bz = b[2],
          bw = b[3];
      var omega, cosom, sinom, scale0, scale1;
      cosom = ax * bx + ay * by + az * bz + aw * bw;

      if (cosom < 0.0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      }

      if (1.0 - cosom > 0.000001) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        scale0 = 1.0 - t;
        scale1 = t;
      }

      out[0] = scale0 * ax + scale1 * bx;
      out[1] = scale0 * ay + scale1 * by;
      out[2] = scale0 * az + scale1 * bz;
      out[3] = scale0 * aw + scale1 * bw;
      return out;
    }

    function quaternionToEuler(out, quat) {
      var qx = quat[0];
      var qy = quat[1];
      var qz = quat[2];
      var qw = quat[3];
      var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
      var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
      var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
      out[0] = heading / degToRads;
      out[1] = attitude / degToRads;
      out[2] = bank / degToRads;
    }

    function createQuaternion(values) {
      var heading = values[0] * degToRads;
      var attitude = values[1] * degToRads;
      var bank = values[2] * degToRads;
      var c1 = Math.cos(heading / 2);
      var c2 = Math.cos(attitude / 2);
      var c3 = Math.cos(bank / 2);
      var s1 = Math.sin(heading / 2);
      var s2 = Math.sin(attitude / 2);
      var s3 = Math.sin(bank / 2);
      var w = c1 * c2 * c3 - s1 * s2 * s3;
      var x = s1 * s2 * c3 + c1 * c2 * s3;
      var y = s1 * c2 * c3 + c1 * s2 * s3;
      var z = c1 * s2 * c3 - s1 * c2 * s3;
      return [x, y, z, w];
    }

    function getValueAtCurrentTime() {
      var frameNum = this.comp.renderedFrame - this.offsetTime;
      var initTime = this.keyframes[0].t - this.offsetTime;
      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;

      if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
        if (this._caching.lastFrame >= frameNum) {
          this._caching._lastKeyframeIndex = -1;
          this._caching.lastIndex = 0;
        }

        var renderResult = this.interpolateValue(frameNum, this._caching);
        this.pv = renderResult;
      }

      this._caching.lastFrame = frameNum;
      return this.pv;
    }

    function setVValue(val) {
      var multipliedValue;

      if (this.propType === 'unidimensional') {
        multipliedValue = val * this.mult;

        if (math_abs(this.v - multipliedValue) > 0.00001) {
          this.v = multipliedValue;
          this._mdf = true;
        }
      } else {
        var i = 0,
            len = this.v.length;

        while (i < len) {
          multipliedValue = val[i] * this.mult;

          if (math_abs(this.v[i] - multipliedValue) > 0.00001) {
            this.v[i] = multipliedValue;
            this._mdf = true;
          }

          i += 1;
        }
      }
    }

    function processEffectsSequence() {
      if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
        return;
      }

      if (this.lock) {
        this.setVValue(this.pv);
        return;
      }

      this.lock = true;
      this._mdf = this._isFirstFrame;
      var multipliedValue;
      var i,
          len = this.effectsSequence.length;
      var finalValue = this.kf ? this.pv : this.data.k;

      for (i = 0; i < len; i += 1) {
        finalValue = this.effectsSequence[i](finalValue);
      }

      this.setVValue(finalValue);
      this._isFirstFrame = false;
      this.lock = false;
      this.frameId = this.elem.globalData.frameId;
    }

    function addEffect(effectFunction) {
      this.effectsSequence.push(effectFunction);
      this.container.addDynamicProperty(this);
    }

    function ValueProperty(elem, data, mult, container) {
      this.propType = 'unidimensional';
      this.mult = mult || 1;
      this.data = data;
      this.v = mult ? data.k * mult : data.k;
      this.pv = data.k;
      this._mdf = false;
      this.elem = elem;
      this.container = container;
      this.comp = elem.comp;
      this.k = false;
      this.kf = false;
      this.vel = 0;
      this.effectsSequence = [];
      this._isFirstFrame = true;
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.addEffect = addEffect;
    }

    function MultiDimensionalProperty(elem, data, mult, container) {
      this.propType = 'multidimensional';
      this.mult = mult || 1;
      this.data = data;
      this._mdf = false;
      this.elem = elem;
      this.container = container;
      this.comp = elem.comp;
      this.k = false;
      this.kf = false;
      this.frameId = -1;
      var i,
          len = data.k.length;
      this.v = createTypedArray('float32', len);
      this.pv = createTypedArray('float32', len);
      var arr = createTypedArray('float32', len);
      this.vel = createTypedArray('float32', len);

      for (i = 0; i < len; i += 1) {
        this.v[i] = data.k[i] * this.mult;
        this.pv[i] = data.k[i];
      }

      this._isFirstFrame = true;
      this.effectsSequence = [];
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.addEffect = addEffect;
    }

    function KeyframedValueProperty(elem, data, mult, container) {
      this.propType = 'unidimensional';
      this.keyframes = data.k;
      this.offsetTime = elem.data.st;
      this.frameId = -1;
      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: 0,
        _lastKeyframeIndex: -1
      };
      this.k = true;
      this.kf = true;
      this.data = data;
      this.mult = mult || 1;
      this.elem = elem;
      this.container = container;
      this.comp = elem.comp;
      this.v = initFrame;
      this.pv = initFrame;
      this._isFirstFrame = true;
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.interpolateValue = interpolateValue;
      this.effectsSequence = [getValueAtCurrentTime.bind(this)];
      this.addEffect = addEffect;
    }

    function KeyframedMultidimensionalProperty(elem, data, mult, container) {
      this.propType = 'multidimensional';
      var i,
          len = data.k.length;
      var s, e, to, ti;

      for (i = 0; i < len - 1; i += 1) {
        if (data.k[i].to && data.k[i].s && data.k[i].e) {
          s = data.k[i].s;
          e = data.k[i].e;
          to = data.k[i].to;
          ti = data.k[i].ti;

          if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
            data.k[i].to = null;
            data.k[i].ti = null;
          }

          if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
            if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
              data.k[i].to = null;
              data.k[i].ti = null;
            }
          }
        }
      }

      this.effectsSequence = [getValueAtCurrentTime.bind(this)];
      this.keyframes = data.k;
      this.offsetTime = elem.data.st;
      this.k = true;
      this.kf = true;
      this._isFirstFrame = true;
      this.mult = mult || 1;
      this.elem = elem;
      this.container = container;
      this.comp = elem.comp;
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.interpolateValue = interpolateValue;
      this.frameId = -1;
      var arrLen = data.k[0].s.length;
      this.v = createTypedArray('float32', arrLen);
      this.pv = createTypedArray('float32', arrLen);

      for (i = 0; i < arrLen; i += 1) {
        this.v[i] = initFrame;
        this.pv[i] = initFrame;
      }

      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: createTypedArray('float32', arrLen)
      };
      this.addEffect = addEffect;
    }

    function getProp(elem, data, type, mult, container) {
      var p;

      if (!data.k.length) {
        p = new ValueProperty(elem, data, mult, container);
      } else if (typeof data.k[0] === 'number') {
        p = new MultiDimensionalProperty(elem, data, mult, container);
      } else {
        switch (type) {
          case 0:
            p = new KeyframedValueProperty(elem, data, mult, container);
            break;

          case 1:
            p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
            break;
        }
      }

      if (p.effectsSequence.length) {
        container.addDynamicProperty(p);
      }

      return p;
    }

    var ob = {
      getProp: getProp
    };
    return ob;
  }();

  var TransformPropertyFactory = function () {
    function applyToMatrix(mat) {
      var _mdf = this._mdf;
      this.iterateDynamicProperties();
      this._mdf = this._mdf || _mdf;

      if (this.a) {
        mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
      }

      if (this.s) {
        mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
      }

      if (this.sk) {
        mat.skewFromAxis(-this.sk.v, this.sa.v);
      }

      if (this.r) {
        mat.rotate(-this.r.v);
      } else {
        mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
      }

      if (this.data.p.s) {
        if (this.data.p.z) {
          mat.translate(this.px.v, this.py.v, -this.pz.v);
        } else {
          mat.translate(this.px.v, this.py.v, 0);
        }
      } else {
        mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
      }
    }

    function processKeys(forceRender) {
      if (this.elem.globalData.frameId === this.frameId) {
        return;
      }

      if (this._isDirty) {
        this.precalculateMatrix();
        this._isDirty = false;
      }

      this.iterateDynamicProperties();

      if (this._mdf || forceRender) {
        this.v.cloneFromProps(this.pre.props);

        if (this.appliedTransformations < 1) {
          this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
        }

        if (this.appliedTransformations < 2) {
          this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
        }

        if (this.sk && this.appliedTransformations < 3) {
          this.v.skewFromAxis(-this.sk.v, this.sa.v);
        }

        if (this.r && this.appliedTransformations < 4) {
          this.v.rotate(-this.r.v);
        } else if (!this.r && this.appliedTransformations < 4) {
          this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
        }

        if (this.autoOriented) {
          var v1,
              v2,
              frameRate = this.elem.globalData.frameRate;

          if (this.p && this.p.keyframes && this.p.getValueAtTime) {
            if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
              v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
              v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
            } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
              v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
              v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.01) / frameRate, 0);
            } else {
              v1 = this.p.pv;
              v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
            }
          } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
            v1 = [];
            v2 = [];
            var px = this.px,
                py = this.py,
                frameRate;

            if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
              v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
              v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
              v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
              v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
            } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
              v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
              v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
              v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
              v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
            } else {
              v1 = [px.pv, py.pv];
              v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
              v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
            }
          }

          this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
        }

        if (this.data.p && this.data.p.s) {
          if (this.data.p.z) {
            this.v.translate(this.px.v, this.py.v, -this.pz.v);
          } else {
            this.v.translate(this.px.v, this.py.v, 0);
          }
        } else {
          this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
        }
      }

      this.frameId = this.elem.globalData.frameId;
    }

    function precalculateMatrix() {
      if (!this.a.k) {
        this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
        this.appliedTransformations = 1;
      } else {
        return;
      }

      if (!this.s.effectsSequence.length) {
        this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
        this.appliedTransformations = 2;
      } else {
        return;
      }

      if (this.sk) {
        if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
          this.pre.skewFromAxis(-this.sk.v, this.sa.v);
          this.appliedTransformations = 3;
        } else {
          return;
        }
      }

      if (this.r) {
        if (!this.r.effectsSequence.length) {
          this.pre.rotate(-this.r.v);
          this.appliedTransformations = 4;
        } else {
          return;
        }
      } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
        this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
        this.appliedTransformations = 4;
      }
    }

    function autoOrient() {//
      //var prevP = this.getValueAtTime();
    }

    function addDynamicProperty(prop) {
      this._addDynamicProperty(prop);

      this.elem.addDynamicProperty(prop);
      this._isDirty = true;
    }

    function TransformProperty(elem, data, container) {
      this.elem = elem;
      this.frameId = -1;
      this.propType = 'transform';
      this.data = data;
      this.v = new Matrix(); //Precalculated matrix with non animated properties

      this.pre = new Matrix();
      this.appliedTransformations = 0;
      this.initDynamicPropertyContainer(container || elem);

      if (data.p && data.p.s) {
        this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
        this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);

        if (data.p.z) {
          this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
        }
      } else {
        this.p = PropertyFactory.getProp(elem, data.p || {
          k: [0, 0, 0]
        }, 1, 0, this);
      }

      if (data.rx) {
        this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
        this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
        this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);

        if (data.or.k[0].ti) {
          var i,
              len = data.or.k.length;

          for (i = 0; i < len; i += 1) {
            data.or.k[i].to = data.or.k[i].ti = null;
          }
        }

        this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this); //sh Indicates it needs to be capped between -180 and 180

        this.or.sh = true;
      } else {
        this.r = PropertyFactory.getProp(elem, data.r || {
          k: 0
        }, 0, degToRads, this);
      }

      if (data.sk) {
        this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
        this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
      }

      this.a = PropertyFactory.getProp(elem, data.a || {
        k: [0, 0, 0]
      }, 1, 0, this);
      this.s = PropertyFactory.getProp(elem, data.s || {
        k: [100, 100, 100]
      }, 1, 0.01, this); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.

      if (data.o) {
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
      } else {
        this.o = {
          _mdf: false,
          v: 1
        };
      }

      this._isDirty = true;

      if (!this.dynamicProperties.length) {
        this.getValue(true);
      }
    }

    TransformProperty.prototype = {
      applyToMatrix: applyToMatrix,
      getValue: processKeys,
      precalculateMatrix: precalculateMatrix,
      autoOrient: autoOrient
    };
    extendPrototype([DynamicPropertyContainer], TransformProperty);
    TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
    TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;

    function getTransformProperty(elem, data, container) {
      return new TransformProperty(elem, data, container);
    }

    return {
      getTransformProperty: getTransformProperty
    };
  }();

  function ShapePath() {
    this.c = false;
    this._length = 0;
    this._maxLength = 8;
    this.v = createSizedArray(this._maxLength);
    this.o = createSizedArray(this._maxLength);
    this.i = createSizedArray(this._maxLength);
  }

  ShapePath.prototype.setPathData = function (closed, len) {
    this.c = closed;
    this.setLength(len);
    var i = 0;

    while (i < len) {
      this.v[i] = point_pool.newElement();
      this.o[i] = point_pool.newElement();
      this.i[i] = point_pool.newElement();
      i += 1;
    }
  };

  ShapePath.prototype.setLength = function (len) {
    while (this._maxLength < len) {
      this.doubleArrayLength();
    }

    this._length = len;
  };

  ShapePath.prototype.doubleArrayLength = function () {
    this.v = this.v.concat(createSizedArray(this._maxLength));
    this.i = this.i.concat(createSizedArray(this._maxLength));
    this.o = this.o.concat(createSizedArray(this._maxLength));
    this._maxLength *= 2;
  };

  ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
    var arr;
    this._length = Math.max(this._length, pos + 1);

    if (this._length >= this._maxLength) {
      this.doubleArrayLength();
    }

    switch (type) {
      case 'v':
        arr = this.v;
        break;

      case 'i':
        arr = this.i;
        break;

      case 'o':
        arr = this.o;
        break;
    }

    if (!arr[pos] || arr[pos] && !replace) {
      arr[pos] = point_pool.newElement();
    }

    arr[pos][0] = x;
    arr[pos][1] = y;
  };

  ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
    this.setXYAt(vX, vY, 'v', pos, replace);
    this.setXYAt(oX, oY, 'o', pos, replace);
    this.setXYAt(iX, iY, 'i', pos, replace);
  };

  ShapePath.prototype.reverse = function () {
    var newPath = new ShapePath();
    newPath.setPathData(this.c, this._length);
    var vertices = this.v,
        outPoints = this.o,
        inPoints = this.i;
    var init = 0;

    if (this.c) {
      newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
      init = 1;
    }

    var cnt = this._length - 1;
    var len = this._length;
    var i;

    for (i = init; i < len; i += 1) {
      newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
      cnt -= 1;
    }

    return newPath;
  };

  var ShapePropertyFactory = function () {
    var initFrame = -999999;

    function interpolateShape(frameNum, previousValue, caching) {
      var iterationIndex = caching.lastIndex;
      var keyPropS, keyPropE, isHold, j, k, jLen, kLen, perc, vertexValue;
      var kf = this.keyframes;

      if (frameNum < kf[0].t - this.offsetTime) {
        keyPropS = kf[0].s[0];
        isHold = true;
        iterationIndex = 0;
      } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
        keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
        /*if(kf[kf.length - 1].s){
            keyPropS = kf[kf.length - 1].s[0];
        }else{
            keyPropS = kf[kf.length - 2].e[0];
        }*/

        isHold = true;
      } else {
        var i = iterationIndex;
        var len = kf.length - 1,
            flag = true,
            keyData,
            nextKeyData;

        while (flag) {
          keyData = kf[i];
          nextKeyData = kf[i + 1];

          if (nextKeyData.t - this.offsetTime > frameNum) {
            break;
          }

          if (i < len - 1) {
            i += 1;
          } else {
            flag = false;
          }
        }

        isHold = keyData.h === 1;
        iterationIndex = i;

        if (!isHold) {
          if (frameNum >= nextKeyData.t - this.offsetTime) {
            perc = 1;
          } else if (frameNum < keyData.t - this.offsetTime) {
            perc = 0;
          } else {
            var fnc;

            if (keyData.__fnct) {
              fnc = keyData.__fnct;
            } else {
              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
              keyData.__fnct = fnc;
            }

            perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
          }

          keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
        }

        keyPropS = keyData.s[0];
      }

      jLen = previousValue._length;
      kLen = keyPropS.i[0].length;
      caching.lastIndex = iterationIndex;

      for (j = 0; j < jLen; j += 1) {
        for (k = 0; k < kLen; k += 1) {
          vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
          previousValue.i[j][k] = vertexValue;
          vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
          previousValue.o[j][k] = vertexValue;
          vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
          previousValue.v[j][k] = vertexValue;
        }
      }
    }

    function interpolateShapeCurrentTime() {
      var frameNum = this.comp.renderedFrame - this.offsetTime;
      var initTime = this.keyframes[0].t - this.offsetTime;
      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
      var lastFrame = this._caching.lastFrame;

      if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
        ////
        this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
        this.interpolateShape(frameNum, this.pv, this._caching); ////
      }

      this._caching.lastFrame = frameNum;
      return this.pv;
    }

    function resetShape() {
      this.paths = this.localShapeCollection;
    }

    function shapesEqual(shape1, shape2) {
      if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
        return false;
      }

      var i,
          len = shape1._length;

      for (i = 0; i < len; i += 1) {
        if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {
          return false;
        }
      }

      return true;
    }

    function setVValue(newPath) {
      if (!shapesEqual(this.v, newPath)) {
        this.v = shape_pool.clone(newPath);
        this.localShapeCollection.releaseShapes();
        this.localShapeCollection.addShape(this.v);
        this._mdf = true;
        this.paths = this.localShapeCollection;
      }
    }

    function processEffectsSequence() {
      if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
        return;
      }

      if (this.lock) {
        this.setVValue(this.pv);
        return;
      }

      this.lock = true;
      this._mdf = false;
      var finalValue = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;
      var i,
          len = this.effectsSequence.length;

      for (i = 0; i < len; i += 1) {
        finalValue = this.effectsSequence[i](finalValue);
      }

      this.setVValue(finalValue);
      this.lock = false;
      this.frameId = this.elem.globalData.frameId;
    }

    ;

    function ShapeProperty(elem, data, type) {
      this.propType = 'shape';
      this.comp = elem.comp;
      this.container = elem;
      this.elem = elem;
      this.data = data;
      this.k = false;
      this.kf = false;
      this._mdf = false;
      var pathData = type === 3 ? data.pt.k : data.ks.k;
      this.v = shape_pool.clone(pathData);
      this.pv = shape_pool.clone(this.v);
      this.localShapeCollection = shapeCollection_pool.newShapeCollection();
      this.paths = this.localShapeCollection;
      this.paths.addShape(this.v);
      this.reset = resetShape;
      this.effectsSequence = [];
    }

    function addEffect(effectFunction) {
      this.effectsSequence.push(effectFunction);
      this.container.addDynamicProperty(this);
    }

    ShapeProperty.prototype.interpolateShape = interpolateShape;
    ShapeProperty.prototype.getValue = processEffectsSequence;
    ShapeProperty.prototype.setVValue = setVValue;
    ShapeProperty.prototype.addEffect = addEffect;

    function KeyframedShapeProperty(elem, data, type) {
      this.propType = 'shape';
      this.comp = elem.comp;
      this.elem = elem;
      this.container = elem;
      this.offsetTime = elem.data.st;
      this.keyframes = type === 3 ? data.pt.k : data.ks.k;
      this.k = true;
      this.kf = true;
      var i,
          len = this.keyframes[0].s[0].i.length;
      var jLen = this.keyframes[0].s[0].i[0].length;
      this.v = shape_pool.newElement();
      this.v.setPathData(this.keyframes[0].s[0].c, len);
      this.pv = shape_pool.clone(this.v);
      this.localShapeCollection = shapeCollection_pool.newShapeCollection();
      this.paths = this.localShapeCollection;
      this.paths.addShape(this.v);
      this.lastFrame = initFrame;
      this.reset = resetShape;
      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0
      };
      this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
    }

    KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
    KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
    KeyframedShapeProperty.prototype.setVValue = setVValue;
    KeyframedShapeProperty.prototype.addEffect = addEffect;

    var EllShapeProperty = function () {
      var cPoint = roundCorner;

      function EllShapeProperty(elem, data) {
        /*this.v = {
            v: createSizedArray(4),
            i: createSizedArray(4),
            o: createSizedArray(4),
            c: true
        };*/
        this.v = shape_pool.newElement();
        this.v.setPathData(true, 4);
        this.localShapeCollection = shapeCollection_pool.newShapeCollection();
        this.paths = this.localShapeCollection;
        this.localShapeCollection.addShape(this.v);
        this.d = data.d;
        this.elem = elem;
        this.comp = elem.comp;
        this.frameId = -1;
        this.initDynamicPropertyContainer(elem);
        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);

        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.k = false;
          this.convertEllToPath();
        }
      }

      ;
      EllShapeProperty.prototype = {
        reset: resetShape,
        getValue: function getValue() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }

          this.frameId = this.elem.globalData.frameId;
          this.iterateDynamicProperties();

          if (this._mdf) {
            this.convertEllToPath();
          }
        },
        convertEllToPath: function convertEllToPath() {
          var p0 = this.p.v[0],
              p1 = this.p.v[1],
              s0 = this.s.v[0] / 2,
              s1 = this.s.v[1] / 2;

          var _cw = this.d !== 3;

          var _v = this.v;
          _v.v[0][0] = p0;
          _v.v[0][1] = p1 - s1;
          _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
          _v.v[1][1] = p1;
          _v.v[2][0] = p0;
          _v.v[2][1] = p1 + s1;
          _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
          _v.v[3][1] = p1;
          _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
          _v.i[0][1] = p1 - s1;
          _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
          _v.i[1][1] = p1 - s1 * cPoint;
          _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
          _v.i[2][1] = p1 + s1;
          _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
          _v.i[3][1] = p1 + s1 * cPoint;
          _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
          _v.o[0][1] = p1 - s1;
          _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
          _v.o[1][1] = p1 + s1 * cPoint;
          _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
          _v.o[2][1] = p1 + s1;
          _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
          _v.o[3][1] = p1 - s1 * cPoint;
        }
      };
      extendPrototype([DynamicPropertyContainer], EllShapeProperty);
      return EllShapeProperty;
    }();

    var StarShapeProperty = function () {
      function StarShapeProperty(elem, data) {
        this.v = shape_pool.newElement();
        this.v.setPathData(true, 0);
        this.elem = elem;
        this.comp = elem.comp;
        this.data = data;
        this.frameId = -1;
        this.d = data.d;
        this.initDynamicPropertyContainer(elem);

        if (data.sy === 1) {
          this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
          this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
          this.convertToPath = this.convertStarToPath;
        } else {
          this.convertToPath = this.convertPolygonToPath;
        }

        this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
        this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
        this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
        this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
        this.localShapeCollection = shapeCollection_pool.newShapeCollection();
        this.localShapeCollection.addShape(this.v);
        this.paths = this.localShapeCollection;

        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.k = false;
          this.convertToPath();
        }
      }

      ;
      StarShapeProperty.prototype = {
        reset: resetShape,
        getValue: function getValue() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }

          this.frameId = this.elem.globalData.frameId;
          this.iterateDynamicProperties();

          if (this._mdf) {
            this.convertToPath();
          }
        },
        convertStarToPath: function convertStarToPath() {
          var numPts = Math.floor(this.pt.v) * 2;
          var angle = Math.PI * 2 / numPts;
          /*this.v.v.length = numPts;
          this.v.i.length = numPts;
          this.v.o.length = numPts;*/

          var longFlag = true;
          var longRad = this.or.v;
          var shortRad = this.ir.v;
          var longRound = this.os.v;
          var shortRound = this.is.v;
          var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
          var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
          var i,
              rad,
              roundness,
              perimSegment,
              currentAng = -Math.PI / 2;
          currentAng += this.r.v;
          var dir = this.data.d === 3 ? -1 : 1;
          this.v._length = 0;

          for (i = 0; i < numPts; i += 1) {
            rad = longFlag ? longRad : shortRad;
            roundness = longFlag ? longRound : shortRound;
            perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
            var x = rad * Math.cos(currentAng);
            var y = rad * Math.sin(currentAng);
            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
            x += +this.p.v[0];
            y += +this.p.v[1];
            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
            /*this.v.v[i] = [x,y];
            this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
            this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
            this.v._length = numPts;*/

            longFlag = !longFlag;
            currentAng += angle * dir;
          }
        },
        convertPolygonToPath: function convertPolygonToPath() {
          var numPts = Math.floor(this.pt.v);
          var angle = Math.PI * 2 / numPts;
          var rad = this.or.v;
          var roundness = this.os.v;
          var perimSegment = 2 * Math.PI * rad / (numPts * 4);
          var i,
              currentAng = -Math.PI / 2;
          var dir = this.data.d === 3 ? -1 : 1;
          currentAng += this.r.v;
          this.v._length = 0;

          for (i = 0; i < numPts; i += 1) {
            var x = rad * Math.cos(currentAng);
            var y = rad * Math.sin(currentAng);
            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
            x += +this.p.v[0];
            y += +this.p.v[1];
            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
            currentAng += angle * dir;
          }

          this.paths.length = 0;
          this.paths[0] = this.v;
        }
      };
      extendPrototype([DynamicPropertyContainer], StarShapeProperty);
      return StarShapeProperty;
    }();

    var RectShapeProperty = function () {
      function RectShapeProperty(elem, data) {
        this.v = shape_pool.newElement();
        this.v.c = true;
        this.localShapeCollection = shapeCollection_pool.newShapeCollection();
        this.localShapeCollection.addShape(this.v);
        this.paths = this.localShapeCollection;
        this.elem = elem;
        this.comp = elem.comp;
        this.frameId = -1;
        this.d = data.d;
        this.initDynamicPropertyContainer(elem);
        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
        this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);

        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.k = false;
          this.convertRectToPath();
        }
      }

      ;
      RectShapeProperty.prototype = {
        convertRectToPath: function convertRectToPath() {
          var p0 = this.p.v[0],
              p1 = this.p.v[1],
              v0 = this.s.v[0] / 2,
              v1 = this.s.v[1] / 2;
          var round = bm_min(v0, v1, this.r.v);
          var cPoint = round * (1 - roundCorner);
          this.v._length = 0;

          if (this.d === 2 || this.d === 1) {
            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);

            if (round !== 0) {
              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
            } else {
              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
            }
          } else {
            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);

            if (round !== 0) {
              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
              this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
            } else {
              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
              this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
            }
          }
        },
        getValue: function getValue(frameNum) {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }

          this.frameId = this.elem.globalData.frameId;
          this.iterateDynamicProperties();

          if (this._mdf) {
            this.convertRectToPath();
          }
        },
        reset: resetShape
      };
      extendPrototype([DynamicPropertyContainer], RectShapeProperty);
      return RectShapeProperty;
    }();

    function getShapeProp(elem, data, type) {
      var prop;

      if (type === 3 || type === 4) {
        var dataProp = type === 3 ? data.pt : data.ks;
        var keys = dataProp.k;

        if (keys.length) {
          prop = new KeyframedShapeProperty(elem, data, type);
        } else {
          prop = new ShapeProperty(elem, data, type);
        }
      } else if (type === 5) {
        prop = new RectShapeProperty(elem, data);
      } else if (type === 6) {
        prop = new EllShapeProperty(elem, data);
      } else if (type === 7) {
        prop = new StarShapeProperty(elem, data);
      }

      if (prop.k) {
        elem.addDynamicProperty(prop);
      }

      return prop;
    }

    function getConstructorFunction() {
      return ShapeProperty;
    }

    function getKeyframedConstructorFunction() {
      return KeyframedShapeProperty;
    }

    var ob = {};
    ob.getShapeProp = getShapeProp;
    ob.getConstructorFunction = getConstructorFunction;
    ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
    return ob;
  }();

  var ShapeModifiers = function () {
    var ob = {};
    var modifiers = {};
    ob.registerModifier = registerModifier;
    ob.getModifier = getModifier;

    function registerModifier(nm, factory) {
      if (!modifiers[nm]) {
        modifiers[nm] = factory;
      }
    }

    function getModifier(nm, elem, data) {
      return new modifiers[nm](elem, data);
    }

    return ob;
  }();

  function ShapeModifier() {}

  ShapeModifier.prototype.initModifierProperties = function () {};

  ShapeModifier.prototype.addShapeToModifier = function () {};

  ShapeModifier.prototype.addShape = function (data) {
    if (!this.closed) {
      var shapeData = {
        shape: data.sh,
        data: data,
        localShapeCollection: shapeCollection_pool.newShapeCollection()
      };
      this.shapes.push(shapeData);
      this.addShapeToModifier(shapeData);

      if (this._isAnimated) {
        data.setAsAnimated();
      }
    }
  };

  ShapeModifier.prototype.init = function (elem, data) {
    this.shapes = [];
    this.elem = elem;
    this.initDynamicPropertyContainer(elem);
    this.initModifierProperties(elem, data);
    this.frameId = initialDefaultFrame;
    this.closed = false;
    this.k = false;

    if (this.dynamicProperties.length) {
      this.k = true;
    } else {
      this.getValue(true);
    }
  };

  ShapeModifier.prototype.processKeys = function () {
    if (this.elem.globalData.frameId === this.frameId) {
      return;
    }

    this.frameId = this.elem.globalData.frameId;
    this.iterateDynamicProperties();
  };

  extendPrototype([DynamicPropertyContainer], ShapeModifier);

  function TrimModifier() {}

  extendPrototype([ShapeModifier], TrimModifier);

  TrimModifier.prototype.initModifierProperties = function (elem, data) {
    this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
    this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
    this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
    this.sValue = 0;
    this.eValue = 0;
    this.getValue = this.processKeys;
    this.m = data.m;
    this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
  };

  TrimModifier.prototype.addShapeToModifier = function (shapeData) {
    shapeData.pathsData = [];
  };

  TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
    var segments = [];

    if (e <= 1) {
      segments.push({
        s: s,
        e: e
      });
    } else if (s >= 1) {
      segments.push({
        s: s - 1,
        e: e - 1
      });
    } else {
      segments.push({
        s: s,
        e: 1
      });
      segments.push({
        s: 0,
        e: e - 1
      });
    }

    var shapeSegments = [];
    var i,
        len = segments.length,
        segmentOb;

    for (i = 0; i < len; i += 1) {
      segmentOb = segments[i];

      if (segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength) {} else {
        var shapeS, shapeE;

        if (segmentOb.s * totalModifierLength <= addedLength) {
          shapeS = 0;
        } else {
          shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
        }

        if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
          shapeE = 1;
        } else {
          shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
        }

        shapeSegments.push([shapeS, shapeE]);
      }
    }

    if (!shapeSegments.length) {
      shapeSegments.push([0, 0]);
    }

    return shapeSegments;
  };

  TrimModifier.prototype.releasePathsData = function (pathsData) {
    var i,
        len = pathsData.length;

    for (i = 0; i < len; i += 1) {
      segments_length_pool.release(pathsData[i]);
    }

    pathsData.length = 0;
    return pathsData;
  };

  TrimModifier.prototype.processShapes = function (_isFirstFrame) {
    var s, e;

    if (this._mdf || _isFirstFrame) {
      var o = this.o.v % 360 / 360;

      if (o < 0) {
        o += 1;
      }

      s = (this.s.v > 1 ? 1 : this.s.v < 0 ? 0 : this.s.v) + o;
      e = (this.e.v > 1 ? 1 : this.e.v < 0 ? 0 : this.e.v) + o;

      if (s === e) {}

      if (s > e) {
        var _s = s;
        s = e;
        e = _s;
      }

      s = Math.round(s * 10000) * 0.0001;
      e = Math.round(e * 10000) * 0.0001;
      this.sValue = s;
      this.eValue = e;
    } else {
      s = this.sValue;
      e = this.eValue;
    }

    var shapePaths;
    var i,
        len = this.shapes.length,
        j,
        jLen;
    var pathsData,
        pathData,
        totalShapeLength,
        totalModifierLength = 0;

    if (e === s) {
      for (i = 0; i < len; i += 1) {
        this.shapes[i].localShapeCollection.releaseShapes();
        this.shapes[i].shape._mdf = true;
        this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
      }
    } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
      var segments = [],
          shapeData,
          localShapeCollection;

      for (i = 0; i < len; i += 1) {
        shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used

        if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
          shapeData.shape.paths = shapeData.localShapeCollection;
        } else {
          shapePaths = shapeData.shape.paths;
          jLen = shapePaths._length;
          totalShapeLength = 0;

          if (!shapeData.shape._mdf && shapeData.pathsData.length) {
            totalShapeLength = shapeData.totalShapeLength;
          } else {
            pathsData = this.releasePathsData(shapeData.pathsData);

            for (j = 0; j < jLen; j += 1) {
              pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
              pathsData.push(pathData);
              totalShapeLength += pathData.totalLength;
            }

            shapeData.totalShapeLength = totalShapeLength;
            shapeData.pathsData = pathsData;
          }

          totalModifierLength += totalShapeLength;
          shapeData.shape._mdf = true;
        }
      }

      var shapeS = s,
          shapeE = e,
          addedLength = 0,
          edges;

      for (i = len - 1; i >= 0; i -= 1) {
        shapeData = this.shapes[i];

        if (shapeData.shape._mdf) {
          localShapeCollection = shapeData.localShapeCollection;
          localShapeCollection.releaseShapes(); //if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group

          if (this.m === 2 && len > 1) {
            edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
            addedLength += shapeData.totalShapeLength;
          } else {
            edges = [[shapeS, shapeE]];
          }

          jLen = edges.length;

          for (j = 0; j < jLen; j += 1) {
            shapeS = edges[j][0];
            shapeE = edges[j][1];
            segments.length = 0;

            if (shapeE <= 1) {
              segments.push({
                s: shapeData.totalShapeLength * shapeS,
                e: shapeData.totalShapeLength * shapeE
              });
            } else if (shapeS >= 1) {
              segments.push({
                s: shapeData.totalShapeLength * (shapeS - 1),
                e: shapeData.totalShapeLength * (shapeE - 1)
              });
            } else {
              segments.push({
                s: shapeData.totalShapeLength * shapeS,
                e: shapeData.totalShapeLength
              });
              segments.push({
                s: 0,
                e: shapeData.totalShapeLength * (shapeE - 1)
              });
            }

            var newShapesData = this.addShapes(shapeData, segments[0]);

            if (segments[0].s !== segments[0].e) {
              if (segments.length > 1) {
                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];

                if (lastShapeInCollection.c) {
                  var lastShape = newShapesData.pop();
                  this.addPaths(newShapesData, localShapeCollection);
                  newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                } else {
                  this.addPaths(newShapesData, localShapeCollection);
                  newShapesData = this.addShapes(shapeData, segments[1]);
                }
              }

              this.addPaths(newShapesData, localShapeCollection);
            }
          }

          shapeData.shape.paths = localShapeCollection;
        }
      }
    } else if (this._mdf) {
      for (i = 0; i < len; i += 1) {
        //Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
        //Don't remove this even if it's losing cached info.
        this.shapes[i].pathsData.length = 0;
        this.shapes[i].shape._mdf = true;
      }
    }
  };

  TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
    var i,
        len = newPaths.length;

    for (i = 0; i < len; i += 1) {
      localShapeCollection.addShape(newPaths[i]);
    }
  };

  TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
    shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
    shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);

    if (newShape) {
      shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
    }

    shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
  };

  TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
    shapePath.setXYAt(points[1], points[5], 'o', pos);
    shapePath.setXYAt(points[2], points[6], 'i', pos + 1);

    if (newShape) {
      shapePath.setXYAt(points[0], points[4], 'v', pos);
    }

    shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
  };

  TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
    var pathsData = shapeData.pathsData;
    var shapePaths = shapeData.shape.paths.shapes;
    var i,
        len = shapeData.shape.paths._length,
        j,
        jLen;
    var addedLength = 0;
    var currentLengthData, segmentCount;
    var lengths;
    var segment;
    var shapes = [];
    var initPos;
    var newShape = true;

    if (!shapePath) {
      shapePath = shape_pool.newElement();
      segmentCount = 0;
      initPos = 0;
    } else {
      segmentCount = shapePath._length;
      initPos = shapePath._length;
    }

    shapes.push(shapePath);

    for (i = 0; i < len; i += 1) {
      lengths = pathsData[i].lengths;
      shapePath.c = shapePaths[i].c;
      jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;

      for (j = 1; j < jLen; j += 1) {
        currentLengthData = lengths[j - 1];

        if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
          addedLength += currentLengthData.addedLength;
          shapePath.c = false;
        } else if (addedLength > shapeSegment.e) {
          shapePath.c = false;
          break;
        } else {
          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
            newShape = false;
          } else {
            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

            newShape = false;
            shapePath.c = false;
          }

          addedLength += currentLengthData.addedLength;
          segmentCount += 1;
        }
      }

      if (shapePaths[i].c && lengths.length) {
        currentLengthData = lengths[j - 1];

        if (addedLength <= shapeSegment.e) {
          var segmentLength = lengths[j - 1].addedLength;

          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
            newShape = false;
          } else {
            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

            newShape = false;
            shapePath.c = false;
          }
        } else {
          shapePath.c = false;
        }

        addedLength += currentLengthData.addedLength;
        segmentCount += 1;
      }

      if (shapePath._length) {
        shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
        shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
      }

      if (addedLength > shapeSegment.e) {
        break;
      }

      if (i < len - 1) {
        shapePath = shape_pool.newElement();
        newShape = true;
        shapes.push(shapePath);
        segmentCount = 0;
      }
    }

    return shapes;
  };

  ShapeModifiers.registerModifier('tm', TrimModifier);

  function RoundCornersModifier() {}

  extendPrototype([ShapeModifier], RoundCornersModifier);

  RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
    this.getValue = this.processKeys;
    this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
    this._isAnimated = !!this.rd.effectsSequence.length;
  };

  RoundCornersModifier.prototype.processPath = function (path, round) {
    var cloned_path = shape_pool.newElement();
    cloned_path.c = path.c;
    var i,
        len = path._length;
    var currentV,
        currentI,
        currentO,
        closerV,
        newV,
        newO,
        newI,
        distance,
        newPosPerc,
        index = 0;
    var vX, vY, oX, oY, iX, iY;

    for (i = 0; i < len; i += 1) {
      currentV = path.v[i];
      currentO = path.o[i];
      currentI = path.i[i];

      if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
        if ((i === 0 || i === len - 1) && !path.c) {
          cloned_path.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
          /*cloned_path.v[index] = currentV;
          cloned_path.o[index] = currentO;
          cloned_path.i[index] = currentI;*/

          index += 1;
        } else {
          if (i === 0) {
            closerV = path.v[len - 1];
          } else {
            closerV = path.v[i - 1];
          }

          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
          vX = iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
          vY = iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
          oX = vX - (vX - currentV[0]) * roundCorner;
          oY = vY - (vY - currentV[1]) * roundCorner;
          cloned_path.setTripleAt(vX, vY, oX, oY, iX, iY, index);
          index += 1;

          if (i === len - 1) {
            closerV = path.v[0];
          } else {
            closerV = path.v[i + 1];
          }

          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
          vX = oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
          vY = oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
          iX = vX - (vX - currentV[0]) * roundCorner;
          iY = vY - (vY - currentV[1]) * roundCorner;
          cloned_path.setTripleAt(vX, vY, oX, oY, iX, iY, index);
          index += 1;
        }
      } else {
        cloned_path.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
        index += 1;
      }
    }

    return cloned_path;
  };

  RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
    var shapePaths;
    var i,
        len = this.shapes.length;
    var j, jLen;
    var rd = this.rd.v;

    if (rd !== 0) {
      var shapeData, newPaths, localShapeCollection;

      for (i = 0; i < len; i += 1) {
        shapeData = this.shapes[i];
        newPaths = shapeData.shape.paths;
        localShapeCollection = shapeData.localShapeCollection;

        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
          localShapeCollection.releaseShapes();
          shapeData.shape._mdf = true;
          shapePaths = shapeData.shape.paths.shapes;
          jLen = shapeData.shape.paths._length;

          for (j = 0; j < jLen; j += 1) {
            localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
          }
        }

        shapeData.shape.paths = shapeData.localShapeCollection;
      }
    }

    if (!this.dynamicProperties.length) {
      this._mdf = false;
    }
  };

  ShapeModifiers.registerModifier('rd', RoundCornersModifier);

  function RepeaterModifier() {}

  extendPrototype([ShapeModifier], RepeaterModifier);

  RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
    this.getValue = this.processKeys;
    this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
    this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
    this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
    this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
    this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
    this.data = data;

    if (!this.dynamicProperties.length) {
      this.getValue(true);
    }

    this._isAnimated = !!this.dynamicProperties.length;
    this.pMatrix = new Matrix();
    this.rMatrix = new Matrix();
    this.sMatrix = new Matrix();
    this.tMatrix = new Matrix();
    this.matrix = new Matrix();
  };

  RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
    var dir = inv ? -1 : 1;
    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
    rMatrix.rotate(-transform.r.v * dir * perc);
    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
    sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
  };

  RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
    this.elem = elem;
    this.arr = arr;
    this.pos = pos;
    this.elemsData = elemsData;
    this._currentCopies = 0;
    this._elements = [];
    this._groups = [];
    this.frameId = -1;
    this.initDynamicPropertyContainer(elem);
    this.initModifierProperties(elem, arr[pos]);
    var cont = 0;

    while (pos > 0) {
      pos -= 1; //this._elements.unshift(arr.splice(pos,1)[0]);

      this._elements.unshift(arr[pos]);

      cont += 1;
    }

    if (this.dynamicProperties.length) {
      this.k = true;
    } else {
      this.getValue(true);
    }
  };

  RepeaterModifier.prototype.resetElements = function (elements) {
    var i,
        len = elements.length;

    for (i = 0; i < len; i += 1) {
      elements[i]._processed = false;

      if (elements[i].ty === 'gr') {
        this.resetElements(elements[i].it);
      }
    }
  };

  RepeaterModifier.prototype.cloneElements = function (elements) {
    var i,
        len = elements.length;
    var newElements = JSON.parse(JSON.stringify(elements));
    this.resetElements(newElements);
    return newElements;
  };

  RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
    var i,
        len = elements.length;

    for (i = 0; i < len; i += 1) {
      elements[i]._render = renderFlag;

      if (elements[i].ty === 'gr') {
        this.changeGroupRender(elements[i].it, renderFlag);
      }
    }
  };

  RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
    var items, itemsTransform, i, dir, cont;

    if (this._mdf || _isFirstFrame) {
      var copies = Math.ceil(this.c.v);

      if (this._groups.length < copies) {
        while (this._groups.length < copies) {
          var group = {
            it: this.cloneElements(this._elements),
            ty: 'gr'
          };
          group.it.push({
            "a": {
              "a": 0,
              "ix": 1,
              "k": [0, 0]
            },
            "nm": "Transform",
            "o": {
              "a": 0,
              "ix": 7,
              "k": 100
            },
            "p": {
              "a": 0,
              "ix": 2,
              "k": [0, 0]
            },
            "r": {
              "a": 1,
              "ix": 6,
              "k": [{
                s: 0,
                e: 0,
                t: 0
              }, {
                s: 0,
                e: 0,
                t: 1
              }]
            },
            "s": {
              "a": 0,
              "ix": 3,
              "k": [100, 100]
            },
            "sa": {
              "a": 0,
              "ix": 5,
              "k": 0
            },
            "sk": {
              "a": 0,
              "ix": 4,
              "k": 0
            },
            "ty": "tr"
          });
          this.arr.splice(0, 0, group);

          this._groups.splice(0, 0, group);

          this._currentCopies += 1;
        }

        this.elem.reloadShapes();
      }

      cont = 0;
      var renderFlag;

      for (i = 0; i <= this._groups.length - 1; i += 1) {
        renderFlag = cont < copies;
        this._groups[i]._render = renderFlag;
        this.changeGroupRender(this._groups[i].it, renderFlag);
        cont += 1;
      }

      this._currentCopies = copies; ////

      var offset = this.o.v;
      var offsetModulo = offset % 1;
      var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
      var k;
      var tMat = this.tr.v.props;
      var pProps = this.pMatrix.props;
      var rProps = this.rMatrix.props;
      var sProps = this.sMatrix.props;
      this.pMatrix.reset();
      this.rMatrix.reset();
      this.sMatrix.reset();
      this.tMatrix.reset();
      this.matrix.reset();
      var iteration = 0;

      if (offset > 0) {
        while (iteration < roundOffset) {
          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
          iteration += 1;
        }

        if (offsetModulo) {
          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
          iteration += offsetModulo;
        }
      } else if (offset < 0) {
        while (iteration > roundOffset) {
          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
          iteration -= 1;
        }

        if (offsetModulo) {
          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
          iteration -= offsetModulo;
        }
      }

      i = this.data.m === 1 ? 0 : this._currentCopies - 1;
      dir = this.data.m === 1 ? 1 : -1;
      cont = this._currentCopies;
      var j, jLen;

      while (cont) {
        items = this.elemsData[i].it;
        itemsTransform = items[items.length - 1].transform.mProps.v.props;
        jLen = itemsTransform.length;
        items[items.length - 1].transform.mProps._mdf = true;
        items[items.length - 1].transform.op._mdf = true;
        items[items.length - 1].transform.op.v = this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));

        if (iteration !== 0) {
          if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
          }

          this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
          this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
          this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);

          for (j = 0; j < jLen; j += 1) {
            itemsTransform[j] = this.matrix.props[j];
          }

          this.matrix.reset();
        } else {
          this.matrix.reset();

          for (j = 0; j < jLen; j += 1) {
            itemsTransform[j] = this.matrix.props[j];
          }
        }

        iteration += 1;
        cont -= 1;
        i += dir;
      }
    } else {
      cont = this._currentCopies;
      i = 0;
      dir = 1;

      while (cont) {
        items = this.elemsData[i].it;
        itemsTransform = items[items.length - 1].transform.mProps.v.props;
        items[items.length - 1].transform.mProps._mdf = false;
        items[items.length - 1].transform.op._mdf = false;
        cont -= 1;
        i += dir;
      }
    }
  };

  RepeaterModifier.prototype.addShape = function () {};

  ShapeModifiers.registerModifier('rp', RepeaterModifier);

  function ShapeCollection() {
    this._length = 0;
    this._maxLength = 4;
    this.shapes = createSizedArray(this._maxLength);
  }

  ShapeCollection.prototype.addShape = function (shapeData) {
    if (this._length === this._maxLength) {
      this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
      this._maxLength *= 2;
    }

    this.shapes[this._length] = shapeData;
    this._length += 1;
  };

  ShapeCollection.prototype.releaseShapes = function () {
    var i;

    for (i = 0; i < this._length; i += 1) {
      shape_pool.release(this.shapes[i]);
    }

    this._length = 0;
  };

  function DashProperty(elem, data, renderer, container) {
    this.elem = elem;
    this.frameId = -1;
    this.dataProps = createSizedArray(data.length);
    this.renderer = renderer;
    this.k = false;
    this.dashStr = '';
    this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
    this.dashoffset = createTypedArray('float32', 1);
    this.initDynamicPropertyContainer(container);
    var i,
        len = data.length || 0,
        prop;

    for (i = 0; i < len; i += 1) {
      prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
      this.k = prop.k || this.k;
      this.dataProps[i] = {
        n: data[i].n,
        p: prop
      };
    }

    if (!this.k) {
      this.getValue(true);
    }

    this._isAnimated = this.k;
  }

  DashProperty.prototype.getValue = function (forceRender) {
    if (this.elem.globalData.frameId === this.frameId && !forceRender) {
      return;
    }

    this.frameId = this.elem.globalData.frameId;
    this.iterateDynamicProperties();
    this._mdf = this._mdf || forceRender;

    if (this._mdf) {
      var i = 0,
          len = this.dataProps.length;

      if (this.renderer === 'svg') {
        this.dashStr = '';
      }

      for (i = 0; i < len; i += 1) {
        if (this.dataProps[i].n != 'o') {
          if (this.renderer === 'svg') {
            this.dashStr += ' ' + this.dataProps[i].p.v;
          } else {
            this.dashArray[i] = this.dataProps[i].p.v;
          }
        } else {
          this.dashoffset[0] = this.dataProps[i].p.v;
        }
      }
    }
  };

  extendPrototype([DynamicPropertyContainer], DashProperty);

  function GradientProperty(elem, data, container) {
    this.data = data;
    this.c = createTypedArray('uint8c', data.p * 4);
    var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
    this.o = createTypedArray('float32', cLength);
    this._cmdf = false;
    this._omdf = false;
    this._collapsable = this.checkCollapsable();
    this._hasOpacity = cLength;
    this.initDynamicPropertyContainer(container);
    this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
    this.k = this.prop.k;
    this.getValue(true);
  }

  GradientProperty.prototype.comparePoints = function (values, points) {
    var i = 0,
        len = this.o.length / 2,
        diff;

    while (i < len) {
      diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);

      if (diff > 0.01) {
        return false;
      }

      i += 1;
    }

    return true;
  };

  GradientProperty.prototype.checkCollapsable = function () {
    if (this.o.length / 2 !== this.c.length / 4) {
      return false;
    }

    if (this.data.k.k[0].s) {
      var i = 0,
          len = this.data.k.k.length;

      while (i < len) {
        if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
          return false;
        }

        i += 1;
      }
    } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
      return false;
    }

    return true;
  };

  GradientProperty.prototype.getValue = function (forceRender) {
    this.prop.getValue();
    this._mdf = false;
    this._cmdf = false;
    this._omdf = false;

    if (this.prop._mdf || forceRender) {
      var i,
          len = this.data.p * 4;
      var mult, val;

      for (i = 0; i < len; i += 1) {
        mult = i % 4 === 0 ? 100 : 255;
        val = Math.round(this.prop.v[i] * mult);

        if (this.c[i] !== val) {
          this.c[i] = val;
          this._cmdf = !forceRender;
        }
      }

      if (this.o.length) {
        len = this.prop.v.length;

        for (i = this.data.p * 4; i < len; i += 1) {
          mult = i % 2 === 0 ? 100 : 1;
          val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];

          if (this.o[i - this.data.p * 4] !== val) {
            this.o[i - this.data.p * 4] = val;
            this._omdf = !forceRender;
          }
        }
      }

      this._mdf = !forceRender;
    }
  };

  extendPrototype([DynamicPropertyContainer], GradientProperty);

  var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {
    if (length === 0) {
      return '';
    }

    var _o = pathNodes.o;
    var _i = pathNodes.i;
    var _v = pathNodes.v;
    var i,
        shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);

    for (i = 1; i < length; i += 1) {
      shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[i][0], _i[i][1]) + " " + mat.applyToPointStringified(_v[i][0], _v[i][1]);
    }

    if (closed && length) {
      shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
      shapeString += 'z';
    }

    return shapeString;
  };

  var ImagePreloader = function () {
    var proxyImage = function () {
      var canvas = createTag('canvas');
      canvas.width = 1;
      canvas.height = 1;
      var ctx = canvas.getContext('2d');
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(0, 0, 1, 1);
      return canvas;
    }();

    function imageLoaded() {
      this.loadedAssets += 1;

      if (this.loadedAssets === this.totalImages) {
        if (this.imagesLoadedCb) {
          this.imagesLoadedCb(null);
        }
      }
    }

    function getAssetsPath(assetData, assetsPath, original_path) {
      var path = '';

      if (assetData.e) {
        path = assetData.p;
      } else if (assetsPath) {
        var imagePath = assetData.p;

        if (imagePath.indexOf('images/') !== -1) {
          imagePath = imagePath.split('/')[1];
        }

        path = assetsPath + imagePath;
      } else {
        path = original_path;
        path += assetData.u ? assetData.u : '';
        path += assetData.p;
      }

      return path;
    }

    function createImageData(assetData) {
      var path = getAssetsPath(assetData, this.assetsPath, this.path);
      var img = createTag('img');
      img.crossOrigin = 'anonymous';
      img.addEventListener('load', this._imageLoaded.bind(this), false);
      img.addEventListener('error', function () {
        ob.img = proxyImage;

        this._imageLoaded();
      }.bind(this), false);
      img.src = path;
      var ob = {
        img: img,
        assetData: assetData
      };
      return ob;
    }

    function loadAssets(assets, cb) {
      this.imagesLoadedCb = cb;
      var i,
          len = assets.length;

      for (i = 0; i < len; i += 1) {
        if (!assets[i].layers) {
          this.totalImages += 1;
          this.images.push(this._createImageData(assets[i]));
        }
      }
    }

    function setPath(path) {
      this.path = path || '';
    }

    function setAssetsPath(path) {
      this.assetsPath = path || '';
    }

    function getImage(assetData) {
      var i = 0,
          len = this.images.length;

      while (i < len) {
        if (this.images[i].assetData === assetData) {
          return this.images[i].img;
        }

        i += 1;
      }
    }

    function destroy() {
      this.imagesLoadedCb = null;
      this.images.length = 0;
    }

    function loaded() {
      return this.totalImages === this.loadedAssets;
    }

    return function ImagePreloader() {
      this.loadAssets = loadAssets;
      this.setAssetsPath = setAssetsPath;
      this.setPath = setPath;
      this.loaded = loaded;
      this.destroy = destroy;
      this.getImage = getImage;
      this._createImageData = createImageData;
      this._imageLoaded = imageLoaded;
      this.assetsPath = '';
      this.path = '';
      this.totalImages = 0;
      this.loadedAssets = 0;
      this.imagesLoadedCb = null;
      this.images = [];
    };
  }();

  var featureSupport = function () {
    var ob = {
      maskType: true
    };

    if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
      ob.maskType = false;
    }

    return ob;
  }();

  var filtersFactory = function () {
    var ob = {};
    ob.createFilter = createFilter;
    ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

    function createFilter(filId) {
      var fil = createNS('filter');
      fil.setAttribute('id', filId);
      fil.setAttribute('filterUnits', 'objectBoundingBox');
      fil.setAttribute('x', '0%');
      fil.setAttribute('y', '0%');
      fil.setAttribute('width', '100%');
      fil.setAttribute('height', '100%');
      return fil;
    }

    function createAlphaToLuminanceFilter() {
      var feColorMatrix = createNS('feColorMatrix');
      feColorMatrix.setAttribute('type', 'matrix');
      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
      feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
      return feColorMatrix;
    }

    return ob;
  }();

  var assetLoader = function () {
    function formatResponse(xhr) {
      if (xhr.response && _typeof(xhr.response) === 'object') {
        return xhr.response;
      } else if (xhr.response && typeof xhr.response === 'string') {
        return JSON.parse(xhr.response);
      } else if (xhr.responseText) {
        return JSON.parse(xhr.responseText);
      }
    }

    function loadAsset(path, callback, errorCallback) {
      var response;
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, true); // set responseType after calling open or IE will break.

      xhr.responseType = "json";
      xhr.send();

      xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
          if (xhr.status == 200) {
            response = formatResponse(xhr);
            callback(response);
          } else {
            try {
              response = formatResponse(xhr);
              callback(response);
            } catch (err) {
              if (errorCallback) {
                errorCallback(err);
              }
            }
          }
        }
      };
    }

    return {
      load: loadAsset
    };
  }();

  function TextAnimatorProperty(textData, renderType, elem) {
    this._isFirstFrame = true;
    this._hasMaskedPath = false;
    this._frameId = -1;
    this._textData = textData;
    this._renderType = renderType;
    this._elem = elem;
    this._animatorsData = createSizedArray(this._textData.a.length);
    this._pathData = {};
    this._moreOptions = {
      alignment: {}
    };
    this.renderedLetters = [];
    this.lettersChangedFlag = false;
    this.initDynamicPropertyContainer(elem);
  }

  TextAnimatorProperty.prototype.searchProperties = function () {
    var i,
        len = this._textData.a.length,
        animatorProps;
    var getProp = PropertyFactory.getProp;

    for (i = 0; i < len; i += 1) {
      animatorProps = this._textData.a[i];
      this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
    }

    if (this._textData.p && 'm' in this._textData.p) {
      this._pathData = {
        f: getProp(this._elem, this._textData.p.f, 0, 0, this),
        l: getProp(this._elem, this._textData.p.l, 0, 0, this),
        r: this._textData.p.r,
        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
      };
      this._hasMaskedPath = true;
    } else {
      this._hasMaskedPath = false;
    }

    this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
  };

  TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
    this.lettersChangedFlag = lettersChangedFlag;

    if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
      return;
    }

    this._isFirstFrame = false;
    var alignment = this._moreOptions.alignment.v;
    var animators = this._animatorsData;
    var textData = this._textData;
    var matrixHelper = this.mHelper;
    var renderType = this._renderType;
    var renderedLettersCount = this.renderedLetters.length;
    var data = this.data;
    var xPos, yPos;
    var i, len;
    var letters = documentData.l,
        pathInfo,
        currentLength,
        currentPoint,
        segmentLength,
        flag,
        pointInd,
        segmentInd,
        prevPoint,
        points,
        segments,
        partialLength,
        totalLength,
        perc,
        tanAngle,
        mask;

    if (this._hasMaskedPath) {
      mask = this._pathData.m;

      if (!this._pathData.n || this._pathData._mdf) {
        var paths = mask.v;

        if (this._pathData.r) {
          paths = paths.reverse();
        } // TODO: release bezier data cached from previous pathInfo: this._pathData.pi


        pathInfo = {
          tLength: 0,
          segments: []
        };
        len = paths._length - 1;
        var bezierData;
        totalLength = 0;

        for (i = 0; i < len; i += 1) {
          bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
          pathInfo.tLength += bezierData.segmentLength;
          pathInfo.segments.push(bezierData);
          totalLength += bezierData.segmentLength;
        }

        i = len;

        if (mask.v.c) {
          bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
          pathInfo.tLength += bezierData.segmentLength;
          pathInfo.segments.push(bezierData);
          totalLength += bezierData.segmentLength;
        }

        this._pathData.pi = pathInfo;
      }

      pathInfo = this._pathData.pi;
      currentLength = this._pathData.f.v;
      segmentInd = 0;
      pointInd = 1;
      segmentLength = 0;
      flag = true;
      segments = pathInfo.segments;

      if (currentLength < 0 && mask.v.c) {
        if (pathInfo.tLength < Math.abs(currentLength)) {
          currentLength = -Math.abs(currentLength) % pathInfo.tLength;
        }

        segmentInd = segments.length - 1;
        points = segments[segmentInd].points;
        pointInd = points.length - 1;

        while (currentLength < 0) {
          currentLength += points[pointInd].partialLength;
          pointInd -= 1;

          if (pointInd < 0) {
            segmentInd -= 1;
            points = segments[segmentInd].points;
            pointInd = points.length - 1;
          }
        }
      }

      points = segments[segmentInd].points;
      prevPoint = points[pointInd - 1];
      currentPoint = points[pointInd];
      partialLength = currentPoint.partialLength;
    }

    len = letters.length;
    xPos = 0;
    yPos = 0;
    var yOff = documentData.finalSize * 1.2 * 0.714;
    var firstLine = true;
    var animatorProps, animatorSelector;
    var j, jLen;
    var letterValue;
    jLen = animators.length;
    var lastLetter;
    var mult,
        ind = -1,
        offf,
        xPathPos,
        yPathPos;
    var initPathPos = currentLength,
        initSegmentInd = segmentInd,
        initPointInd = pointInd,
        currentLine = -1;
    var elemOpacity;
    var sc, sw, fc, k;
    var lineLength = 0;
    var letterSw,
        letterSc,
        letterFc,
        letterM = '',
        letterP = this.defaultPropsArray,
        letterO; //

    if (documentData.j === 2 || documentData.j === 1) {
      var animatorJustifyOffset = 0;
      var animatorFirstCharOffset = 0;
      var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
      var lastIndex = 0;
      var isNewLine = true;

      for (i = 0; i < len; i += 1) {
        if (letters[i].n) {
          if (animatorJustifyOffset) {
            animatorJustifyOffset += animatorFirstCharOffset;
          }

          while (lastIndex < i) {
            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
            lastIndex += 1;
          }

          animatorJustifyOffset = 0;
          isNewLine = true;
        } else {
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;

            if (animatorProps.t.propType) {
              if (isNewLine && documentData.j === 2) {
                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
              }

              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

              if (mult.length) {
                animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
              } else {
                animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
              }
            }
          }

          isNewLine = false;
        }
      }

      if (animatorJustifyOffset) {
        animatorJustifyOffset += animatorFirstCharOffset;
      }

      while (lastIndex < i) {
        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
        lastIndex += 1;
      }
    } //


    for (i = 0; i < len; i += 1) {
      matrixHelper.reset();
      elemOpacity = 1;

      if (letters[i].n) {
        xPos = 0;
        yPos += documentData.yOffset;
        yPos += firstLine ? 1 : 0;
        currentLength = initPathPos;
        firstLine = false;
        lineLength = 0;

        if (this._hasMaskedPath) {
          segmentInd = initSegmentInd;
          pointInd = initPointInd;
          points = segments[segmentInd].points;
          prevPoint = points[pointInd - 1];
          currentPoint = points[pointInd];
          partialLength = currentPoint.partialLength;
          segmentLength = 0;
        }

        letterO = letterSw = letterFc = letterM = '';
        letterP = this.defaultPropsArray;
      } else {
        if (this._hasMaskedPath) {
          if (currentLine !== letters[i].line) {
            switch (documentData.j) {
              case 1:
                currentLength += totalLength - documentData.lineWidths[letters[i].line];
                break;

              case 2:
                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
                break;
            }

            currentLine = letters[i].line;
          }

          if (ind !== letters[i].ind) {
            if (letters[ind]) {
              currentLength += letters[ind].extra;
            }

            currentLength += letters[i].an / 2;
            ind = letters[i].ind;
          }

          currentLength += alignment[0] * letters[i].an / 200;
          var animatorOffset = 0;

          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;

            if (animatorProps.p.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

              if (mult.length) {
                animatorOffset += animatorProps.p.v[0] * mult[0];
              } else {
                animatorOffset += animatorProps.p.v[0] * mult;
              }
            }

            if (animatorProps.a.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

              if (mult.length) {
                animatorOffset += animatorProps.a.v[0] * mult[0];
              } else {
                animatorOffset += animatorProps.a.v[0] * mult;
              }
            }
          }

          flag = true;

          while (flag) {
            if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
              perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
              xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
              yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
              matrixHelper.translate(-alignment[0] * letters[i].an / 200, -(alignment[1] * yOff / 100));
              flag = false;
            } else if (points) {
              segmentLength += currentPoint.partialLength;
              pointInd += 1;

              if (pointInd >= points.length) {
                pointInd = 0;
                segmentInd += 1;

                if (!segments[segmentInd]) {
                  if (mask.v.c) {
                    pointInd = 0;
                    segmentInd = 0;
                    points = segments[segmentInd].points;
                  } else {
                    segmentLength -= currentPoint.partialLength;
                    points = null;
                  }
                } else {
                  points = segments[segmentInd].points;
                }
              }

              if (points) {
                prevPoint = currentPoint;
                currentPoint = points[pointInd];
                partialLength = currentPoint.partialLength;
              }
            }
          }

          offf = letters[i].an / 2 - letters[i].add;
          matrixHelper.translate(-offf, 0, 0);
        } else {
          offf = letters[i].an / 2 - letters[i].add;
          matrixHelper.translate(-offf, 0, 0); // Grouping alignment

          matrixHelper.translate(-alignment[0] * letters[i].an / 200, -alignment[1] * yOff / 100, 0);
        }

        lineLength += letters[i].l / 2;

        for (j = 0; j < jLen; j += 1) {
          animatorProps = animators[j].a;

          if (animatorProps.t.propType) {
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars); //This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"

            if (xPos !== 0 || documentData.j !== 0) {
              if (this._hasMaskedPath) {
                if (mult.length) {
                  currentLength += animatorProps.t.v * mult[0];
                } else {
                  currentLength += animatorProps.t.v * mult;
                }
              } else {
                if (mult.length) {
                  xPos += animatorProps.t.v * mult[0];
                } else {
                  xPos += animatorProps.t.v * mult;
                }
              }
            }
          }
        }

        lineLength += letters[i].l / 2;

        if (documentData.strokeWidthAnim) {
          sw = documentData.sw || 0;
        }

        if (documentData.strokeColorAnim) {
          if (documentData.sc) {
            sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
          } else {
            sc = [0, 0, 0];
          }
        }

        if (documentData.fillColorAnim && documentData.fc) {
          fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
        }

        for (j = 0; j < jLen; j += 1) {
          animatorProps = animators[j].a;

          if (animatorProps.a.propType) {
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

            if (mult.length) {
              matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
            } else {
              matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
            }
          }
        }

        for (j = 0; j < jLen; j += 1) {
          animatorProps = animators[j].a;

          if (animatorProps.s.propType) {
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

            if (mult.length) {
              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
            } else {
              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
            }
          }
        }

        for (j = 0; j < jLen; j += 1) {
          animatorProps = animators[j].a;
          animatorSelector = animators[j].s;
          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

          if (animatorProps.sk.propType) {
            if (mult.length) {
              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
            } else {
              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
            }
          }

          if (animatorProps.r.propType) {
            if (mult.length) {
              matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
            } else {
              matrixHelper.rotateZ(-animatorProps.r.v * mult);
            }
          }

          if (animatorProps.ry.propType) {
            if (mult.length) {
              matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
            } else {
              matrixHelper.rotateY(animatorProps.ry.v * mult);
            }
          }

          if (animatorProps.rx.propType) {
            if (mult.length) {
              matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
            } else {
              matrixHelper.rotateX(animatorProps.rx.v * mult);
            }
          }

          if (animatorProps.o.propType) {
            if (mult.length) {
              elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
            } else {
              elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
            }
          }

          if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
            if (mult.length) {
              sw += animatorProps.sw.v * mult[0];
            } else {
              sw += animatorProps.sw.v * mult;
            }
          }

          if (documentData.strokeColorAnim && animatorProps.sc.propType) {
            for (k = 0; k < 3; k += 1) {
              if (mult.length) {
                sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k]) * mult[0];
              } else {
                sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k]) * mult;
              }
            }
          }

          if (documentData.fillColorAnim && documentData.fc) {
            if (animatorProps.fc.propType) {
              for (k = 0; k < 3; k += 1) {
                if (mult.length) {
                  fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k]) * mult[0];
                } else {
                  fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k]) * mult;
                }
              }
            }

            if (animatorProps.fh.propType) {
              if (mult.length) {
                fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
              } else {
                fc = addHueToRGB(fc, animatorProps.fh.v * mult);
              }
            }

            if (animatorProps.fs.propType) {
              if (mult.length) {
                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
              } else {
                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
              }
            }

            if (animatorProps.fb.propType) {
              if (mult.length) {
                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
              } else {
                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
              }
            }
          }
        }

        for (j = 0; j < jLen; j += 1) {
          animatorProps = animators[j].a;

          if (animatorProps.p.propType) {
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

            if (this._hasMaskedPath) {
              if (mult.length) {
                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
              } else {
                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
              }
            } else {
              if (mult.length) {
                matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
              } else {
                matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
              }
            }
          }
        }

        if (documentData.strokeWidthAnim) {
          letterSw = sw < 0 ? 0 : sw;
        }

        if (documentData.strokeColorAnim) {
          letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
        }

        if (documentData.fillColorAnim && documentData.fc) {
          letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
        }

        if (this._hasMaskedPath) {
          matrixHelper.translate(0, -documentData.ls);
          matrixHelper.translate(0, alignment[1] * yOff / 100 + yPos, 0);

          if (textData.p.p) {
            tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
            var rot = Math.atan(tanAngle) * 180 / Math.PI;

            if (currentPoint.point[0] < prevPoint.point[0]) {
              rot += 180;
            }

            matrixHelper.rotate(-rot * Math.PI / 180);
          }

          matrixHelper.translate(xPathPos, yPathPos, 0);
          currentLength -= alignment[0] * letters[i].an / 200;

          if (letters[i + 1] && ind !== letters[i + 1].ind) {
            currentLength += letters[i].an / 2;
            currentLength += documentData.tr / 1000 * documentData.finalSize;
          }
        } else {
          matrixHelper.translate(xPos, yPos, 0);

          if (documentData.ps) {
            //matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
          }

          switch (documentData.j) {
            case 1:
              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
              break;

            case 2:
              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
              break;
          }

          matrixHelper.translate(0, -documentData.ls);
          matrixHelper.translate(offf, 0, 0);
          matrixHelper.translate(alignment[0] * letters[i].an / 200, alignment[1] * yOff / 100, 0);
          xPos += letters[i].l + documentData.tr / 1000 * documentData.finalSize;
        }

        if (renderType === 'html') {
          letterM = matrixHelper.toCSS();
        } else if (renderType === 'svg') {
          letterM = matrixHelper.to2dCSS();
        } else {
          letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
        }

        letterO = elemOpacity;
      }

      if (renderedLettersCount <= i) {
        letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
        this.renderedLetters.push(letterValue);
        renderedLettersCount += 1;
        this.lettersChangedFlag = true;
      } else {
        letterValue = this.renderedLetters[i];
        this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
      }
    }
  };

  TextAnimatorProperty.prototype.getValue = function () {
    if (this._elem.globalData.frameId === this._frameId) {
      return;
    }

    this._frameId = this._elem.globalData.frameId;
    this.iterateDynamicProperties();
  };

  TextAnimatorProperty.prototype.mHelper = new Matrix();
  TextAnimatorProperty.prototype.defaultPropsArray = [];
  extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

  function TextAnimatorDataProperty(elem, animatorProps, container) {
    var defaultData = {
      propType: false
    };
    var getProp = PropertyFactory.getProp;
    var textAnimator_animatables = animatorProps.a;
    this.a = {
      r: textAnimator_animatables.r ? getProp(elem, textAnimator_animatables.r, 0, degToRads, container) : defaultData,
      rx: textAnimator_animatables.rx ? getProp(elem, textAnimator_animatables.rx, 0, degToRads, container) : defaultData,
      ry: textAnimator_animatables.ry ? getProp(elem, textAnimator_animatables.ry, 0, degToRads, container) : defaultData,
      sk: textAnimator_animatables.sk ? getProp(elem, textAnimator_animatables.sk, 0, degToRads, container) : defaultData,
      sa: textAnimator_animatables.sa ? getProp(elem, textAnimator_animatables.sa, 0, degToRads, container) : defaultData,
      s: textAnimator_animatables.s ? getProp(elem, textAnimator_animatables.s, 1, 0.01, container) : defaultData,
      a: textAnimator_animatables.a ? getProp(elem, textAnimator_animatables.a, 1, 0, container) : defaultData,
      o: textAnimator_animatables.o ? getProp(elem, textAnimator_animatables.o, 0, 0.01, container) : defaultData,
      p: textAnimator_animatables.p ? getProp(elem, textAnimator_animatables.p, 1, 0, container) : defaultData,
      sw: textAnimator_animatables.sw ? getProp(elem, textAnimator_animatables.sw, 0, 0, container) : defaultData,
      sc: textAnimator_animatables.sc ? getProp(elem, textAnimator_animatables.sc, 1, 0, container) : defaultData,
      fc: textAnimator_animatables.fc ? getProp(elem, textAnimator_animatables.fc, 1, 0, container) : defaultData,
      fh: textAnimator_animatables.fh ? getProp(elem, textAnimator_animatables.fh, 0, 0, container) : defaultData,
      fs: textAnimator_animatables.fs ? getProp(elem, textAnimator_animatables.fs, 0, 0.01, container) : defaultData,
      fb: textAnimator_animatables.fb ? getProp(elem, textAnimator_animatables.fb, 0, 0.01, container) : defaultData,
      t: textAnimator_animatables.t ? getProp(elem, textAnimator_animatables.t, 0, 0, container) : defaultData
    };
    this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
    this.s.t = animatorProps.s.t;
  }

  function LetterProps(o, sw, sc, fc, m, p) {
    this.o = o;
    this.sw = sw;
    this.sc = sc;
    this.fc = fc;
    this.m = m;
    this.p = p;
    this._mdf = {
      o: true,
      sw: !!sw,
      sc: !!sc,
      fc: !!fc,
      m: true,
      p: true
    };
  }

  LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
    this._mdf.o = false;
    this._mdf.sw = false;
    this._mdf.sc = false;
    this._mdf.fc = false;
    this._mdf.m = false;
    this._mdf.p = false;
    var updated = false;

    if (this.o !== o) {
      this.o = o;
      this._mdf.o = true;
      updated = true;
    }

    if (this.sw !== sw) {
      this.sw = sw;
      this._mdf.sw = true;
      updated = true;
    }

    if (this.sc !== sc) {
      this.sc = sc;
      this._mdf.sc = true;
      updated = true;
    }

    if (this.fc !== fc) {
      this.fc = fc;
      this._mdf.fc = true;
      updated = true;
    }

    if (this.m !== m) {
      this.m = m;
      this._mdf.m = true;
      updated = true;
    }

    if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
      this.p = p;
      this._mdf.p = true;
      updated = true;
    }

    return updated;
  };

  function TextProperty(elem, data) {
    this._frameId = initialDefaultFrame;
    this.pv = '';
    this.v = '';
    this.kf = false;
    this._isFirstFrame = true;
    this._mdf = false;
    this.data = data;
    this.elem = elem;
    this.comp = this.elem.comp;
    this.keysIndex = 0;
    this.canResize = false;
    this.minimumFontSize = 1;
    this.effectsSequence = [];
    this.currentData = {
      ascent: 0,
      boxWidth: this.defaultBoxWidth,
      f: '',
      fStyle: '',
      fWeight: '',
      fc: '',
      j: '',
      justifyOffset: '',
      l: [],
      lh: 0,
      lineWidths: [],
      ls: '',
      of: '',
      s: '',
      sc: '',
      sw: 0,
      t: 0,
      tr: 0,
      sz: 0,
      ps: null,
      fillColorAnim: false,
      strokeColorAnim: false,
      strokeWidthAnim: false,
      yOffset: 0,
      finalSize: 0,
      finalText: [],
      finalLineHeight: 0,
      __complete: false
    };
    this.copyData(this.currentData, this.data.d.k[0].s);

    if (!this.searchProperty()) {
      this.completeTextData(this.currentData);
    }
  }

  TextProperty.prototype.defaultBoxWidth = [0, 0];

  TextProperty.prototype.copyData = function (obj, data) {
    for (var s in data) {
      if (data.hasOwnProperty(s)) {
        obj[s] = data[s];
      }
    }

    return obj;
  };

  TextProperty.prototype.setCurrentData = function (data) {
    if (!data.__complete) {
      this.completeTextData(data);
    }

    this.currentData = data;
    this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
    this._mdf = true;
  };

  TextProperty.prototype.searchProperty = function () {
    return this.searchKeyframes();
  };

  TextProperty.prototype.searchKeyframes = function () {
    this.kf = this.data.d.k.length > 1;

    if (this.kf) {
      this.addEffect(this.getKeyframeValue.bind(this));
    }

    return this.kf;
  };

  TextProperty.prototype.addEffect = function (effectFunction) {
    this.effectsSequence.push(effectFunction);
    this.elem.addDynamicProperty(this);
  };

  TextProperty.prototype.getValue = function (_finalValue) {
    if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
      return;
    }

    this.currentData.t = this.data.d.k[this.keysIndex].s.t;
    var currentValue = this.currentData;
    var currentIndex = this.keysIndex;

    if (this.lock) {
      this.setCurrentData(this.currentData);
      return;
    }

    this.lock = true;
    this._mdf = false;
    var multipliedValue;
    var i,
        len = this.effectsSequence.length;
    var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;

    for (i = 0; i < len; i += 1) {
      //Checking if index changed to prevent creating a new object every time the expression updates.
      if (currentIndex !== this.keysIndex) {
        finalValue = this.effectsSequence[i](finalValue, finalValue.t);
      } else {
        finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
      }
    }

    if (currentValue !== finalValue) {
      this.setCurrentData(finalValue);
    }

    this.pv = this.v = this.currentData;
    this.lock = false;
    this.frameId = this.elem.globalData.frameId;
  };

  TextProperty.prototype.getKeyframeValue = function () {
    var textKeys = this.data.d.k,
        textDocumentData;
    var frameNum = this.elem.comp.renderedFrame;
    var i = 0,
        len = textKeys.length;

    while (i <= len - 1) {
      textDocumentData = textKeys[i].s;

      if (i === len - 1 || textKeys[i + 1].t > frameNum) {
        break;
      }

      i += 1;
    }

    if (this.keysIndex !== i) {
      this.keysIndex = i;
    }

    return this.data.d.k[this.keysIndex].s;
  };

  TextProperty.prototype.buildFinalText = function (text) {
    var combinedCharacters = FontManager.getCombinedCharacterCodes();
    var charactersArray = [];
    var i = 0,
        len = text.length;

    while (i < len) {
      if (combinedCharacters.indexOf(text.charCodeAt(i)) !== -1) {
        charactersArray[charactersArray.length - 1] += text.charAt(i);
      } else {
        charactersArray.push(text.charAt(i));
      }

      i += 1;
    }

    return charactersArray;
  };

  TextProperty.prototype.completeTextData = function (documentData) {
    documentData.__complete = true;
    var fontManager = this.elem.globalData.fontManager;
    var data = this.data;
    var letters = [];
    var i, len;
    var newLineFlag,
        index = 0,
        val;
    var anchorGrouping = data.m.g;
    var currentSize = 0,
        currentPos = 0,
        currentLine = 0,
        lineWidths = [];
    var lineWidth = 0;
    var maxLineWidth = 0;
    var j, jLen;
    var fontData = fontManager.getFontByName(documentData.f);
    var charData,
        cLength = 0;
    var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];
    var fWeight = 'normal',
        fStyle = 'normal';
    len = styles.length;
    var styleName;

    for (i = 0; i < len; i += 1) {
      styleName = styles[i].toLowerCase();

      switch (styleName) {
        case 'italic':
          fStyle = 'italic';
          break;

        case 'bold':
          fWeight = '700';
          break;

        case 'black':
          fWeight = '900';
          break;

        case 'medium':
          fWeight = '500';
          break;

        case 'regular':
        case 'normal':
          fWeight = '400';
          break;

        case 'light':
        case 'thin':
          fWeight = '200';
          break;
      }
    }

    documentData.fWeight = fontData.fWeight || fWeight;
    documentData.fStyle = fStyle;
    len = documentData.t.length;
    documentData.finalSize = documentData.s;
    documentData.finalText = this.buildFinalText(documentData.t);
    documentData.finalLineHeight = documentData.lh;
    var trackingOffset = documentData.tr / 1000 * documentData.finalSize;
    var charCode;

    if (documentData.sz) {
      var flag = true;
      var boxWidth = documentData.sz[0];
      var boxHeight = documentData.sz[1];
      var currentHeight, finalText;

      while (flag) {
        finalText = this.buildFinalText(documentData.t);
        currentHeight = 0;
        lineWidth = 0;
        len = finalText.length;
        trackingOffset = documentData.tr / 1000 * documentData.finalSize;
        var lastSpaceIndex = -1;

        for (i = 0; i < len; i += 1) {
          charCode = finalText[i].charCodeAt(0);
          newLineFlag = false;

          if (finalText[i] === ' ') {
            lastSpaceIndex = i;
          } else if (charCode === 13 || charCode === 3) {
            lineWidth = 0;
            newLineFlag = true;
            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
          }

          if (fontManager.chars) {
            charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
          } else {
            //tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
            cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
          }

          if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
            if (lastSpaceIndex === -1) {
              len += 1;
            } else {
              i = lastSpaceIndex;
            }

            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
            finalText.splice(i, lastSpaceIndex === i ? 1 : 0, "\r"); //finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);

            lastSpaceIndex = -1;
            lineWidth = 0;
          } else {
            lineWidth += cLength;
            lineWidth += trackingOffset;
          }
        }

        currentHeight += fontData.ascent * documentData.finalSize / 100;

        if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
          documentData.finalSize -= 1;
          documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
        } else {
          documentData.finalText = finalText;
          len = documentData.finalText.length;
          flag = false;
        }
      }
    }

    lineWidth = -trackingOffset;
    cLength = 0;
    var uncollapsedSpaces = 0;
    var currentChar;

    for (i = 0; i < len; i += 1) {
      newLineFlag = false;
      currentChar = documentData.finalText[i];
      charCode = currentChar.charCodeAt(0);

      if (currentChar === ' ') {
        val = "\xA0";
      } else if (charCode === 13 || charCode === 3) {
        uncollapsedSpaces = 0;
        lineWidths.push(lineWidth);
        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
        lineWidth = -2 * trackingOffset;
        val = '';
        newLineFlag = true;
        currentLine += 1;
      } else {
        val = documentData.finalText[i];
      }

      if (fontManager.chars) {
        charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
      } else {
        //var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
        //tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
        cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
      } //


      if (currentChar === ' ') {
        uncollapsedSpaces += cLength + trackingOffset;
      } else {
        lineWidth += cLength + trackingOffset + uncollapsedSpaces;
        uncollapsedSpaces = 0;
      }

      letters.push({
        l: cLength,
        an: cLength,
        add: currentSize,
        n: newLineFlag,
        anIndexes: [],
        val: val,
        line: currentLine,
        animatorJustifyOffset: 0
      });

      if (anchorGrouping == 2) {
        currentSize += cLength;

        if (val === '' || val === "\xA0" || i === len - 1) {
          if (val === '' || val === "\xA0") {
            currentSize -= cLength;
          }

          while (currentPos <= i) {
            letters[currentPos].an = currentSize;
            letters[currentPos].ind = index;
            letters[currentPos].extra = cLength;
            currentPos += 1;
          }

          index += 1;
          currentSize = 0;
        }
      } else if (anchorGrouping == 3) {
        currentSize += cLength;

        if (val === '' || i === len - 1) {
          if (val === '') {
            currentSize -= cLength;
          }

          while (currentPos <= i) {
            letters[currentPos].an = currentSize;
            letters[currentPos].ind = index;
            letters[currentPos].extra = cLength;
            currentPos += 1;
          }

          currentSize = 0;
          index += 1;
        }
      } else {
        letters[index].ind = index;
        letters[index].extra = 0;
        index += 1;
      }
    }

    documentData.l = letters;
    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
    lineWidths.push(lineWidth);

    if (documentData.sz) {
      documentData.boxWidth = documentData.sz[0];
      documentData.justifyOffset = 0;
    } else {
      documentData.boxWidth = maxLineWidth;

      switch (documentData.j) {
        case 1:
          documentData.justifyOffset = -documentData.boxWidth;
          break;

        case 2:
          documentData.justifyOffset = -documentData.boxWidth / 2;
          break;

        default:
          documentData.justifyOffset = 0;
      }
    }

    documentData.lineWidths = lineWidths;
    var animators = data.a,
        animatorData,
        letterData;
    jLen = animators.length;
    var based,
        ind,
        indexes = [];

    for (j = 0; j < jLen; j += 1) {
      animatorData = animators[j];

      if (animatorData.a.sc) {
        documentData.strokeColorAnim = true;
      }

      if (animatorData.a.sw) {
        documentData.strokeWidthAnim = true;
      }

      if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
        documentData.fillColorAnim = true;
      }

      ind = 0;
      based = animatorData.s.b;

      for (i = 0; i < len; i += 1) {
        letterData = letters[i];
        letterData.anIndexes[j] = ind;

        if (based == 1 && letterData.val !== '' || based == 2 && letterData.val !== '' && letterData.val !== "\xA0" || based == 3 && (letterData.n || letterData.val == "\xA0" || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
          if (animatorData.s.rn === 1) {
            indexes.push(ind);
          }

          ind += 1;
        }
      }

      data.a[j].s.totalChars = ind;
      var currentInd = -1,
          newInd;

      if (animatorData.s.rn === 1) {
        for (i = 0; i < len; i += 1) {
          letterData = letters[i];

          if (currentInd != letterData.anIndexes[j]) {
            currentInd = letterData.anIndexes[j];
            newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
          }

          letterData.anIndexes[j] = newInd;
        }
      }
    }

    documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
    documentData.ls = documentData.ls || 0;
    documentData.ascent = fontData.ascent * documentData.finalSize / 100;
  };

  TextProperty.prototype.updateDocumentData = function (newData, index) {
    index = index === undefined ? this.keysIndex : index;
    var dData = this.copyData({}, this.data.d.k[index].s);
    dData = this.copyData(dData, newData);
    this.data.d.k[index].s = dData;
    this.recalculate(index);
    this.elem.addDynamicProperty(this);
  };

  TextProperty.prototype.recalculate = function (index) {
    var dData = this.data.d.k[index].s;
    dData.__complete = false;
    this.keysIndex = 0;
    this._isFirstFrame = true;
    this.getValue(dData);
  };

  TextProperty.prototype.canResizeFont = function (_canResize) {
    this.canResize = _canResize;
    this.recalculate(this.keysIndex);
    this.elem.addDynamicProperty(this);
  };

  TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
    this.minimumFontSize = Math.floor(_fontValue) || 1;
    this.recalculate(this.keysIndex);
    this.elem.addDynamicProperty(this);
  };

  var TextSelectorProp = function () {
    var max = Math.max;
    var min = Math.min;
    var floor = Math.floor;

    function TextSelectorProp(elem, data) {
      this._currentTextLength = -1;
      this.k = false;
      this.data = data;
      this.elem = elem;
      this.comp = elem.comp;
      this.finalS = 0;
      this.finalE = 0;
      this.initDynamicPropertyContainer(elem);
      this.s = PropertyFactory.getProp(elem, data.s || {
        k: 0
      }, 0, 0, this);

      if ('e' in data) {
        this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
      } else {
        this.e = {
          v: 100
        };
      }

      this.o = PropertyFactory.getProp(elem, data.o || {
        k: 0
      }, 0, 0, this);
      this.xe = PropertyFactory.getProp(elem, data.xe || {
        k: 0
      }, 0, 0, this);
      this.ne = PropertyFactory.getProp(elem, data.ne || {
        k: 0
      }, 0, 0, this);
      this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);

      if (!this.dynamicProperties.length) {
        this.getValue();
      }
    }

    TextSelectorProp.prototype = {
      getMult: function getMult(ind) {
        if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
          this.getValue();
        } //var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);


        var easer = BezierFactory.getBezierEasing(this.ne.v / 100, 0, 1 - this.xe.v / 100, 1).get;
        var mult = 0;
        var s = this.finalS;
        var e = this.finalE;
        var type = this.data.sh;

        if (type == 2) {
          if (e === s) {
            mult = ind >= e ? 1 : 0;
          } else {
            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
          }

          mult = easer(mult);
        } else if (type == 3) {
          if (e === s) {
            mult = ind >= e ? 0 : 1;
          } else {
            mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
          }

          mult = easer(mult);
        } else if (type == 4) {
          if (e === s) {
            mult = 0;
          } else {
            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));

            if (mult < 0.5) {
              mult *= 2;
            } else {
              mult = 1 - 2 * (mult - 0.5);
            }
          }

          mult = easer(mult);
        } else if (type == 5) {
          if (e === s) {
            mult = 0;
          } else {
            var tot = e - s;
            /*ind += 0.5;
            mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind;*/

            ind = min(max(0, ind + 0.5 - s), e - s);
            var x = -tot / 2 + ind;
            var a = tot / 2;
            mult = Math.sqrt(1 - x * x / (a * a));
          }

          mult = easer(mult);
        } else if (type == 6) {
          if (e === s) {
            mult = 0;
          } else {
            ind = min(max(0, ind + 0.5 - s), e - s);
            mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2;
            /*
             ind = Math.min(Math.max(s,ind),e-1);
             mult = (1+(Math.cos((Math.PI+Math.PI*2*(ind-s)/(e-1-s)))))/2;
             mult = Math.max(mult,(1/(e-1-s))/(e-1-s));*/
          }

          mult = easer(mult);
        } else {
          if (ind >= floor(s)) {
            if (ind - s < 0) {
              mult = 1 - (s - ind);
            } else {
              mult = max(0, min(e - ind, 1));
            }
          }

          mult = easer(mult);
        }

        return mult * this.a.v;
      },
      getValue: function getValue(newCharsFlag) {
        this.iterateDynamicProperties();
        this._mdf = newCharsFlag || this._mdf;
        this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;

        if (newCharsFlag && this.data.r === 2) {
          this.e.v = this._currentTextLength;
        }

        var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
        var o = this.o.v / divisor;
        var s = this.s.v / divisor + o;
        var e = this.e.v / divisor + o;

        if (s > e) {
          var _s = s;
          s = e;
          e = _s;
        }

        this.finalS = s;
        this.finalE = e;
      }
    };
    extendPrototype([DynamicPropertyContainer], TextSelectorProp);

    function getTextSelectorProp(elem, data, arr) {
      return new TextSelectorProp(elem, data, arr);
    }

    return {
      getTextSelectorProp: getTextSelectorProp
    };
  }();

  var pool_factory = function () {
    return function (initialLength, _create, _release, _clone) {
      var _length = 0;
      var _maxLength = initialLength;
      var pool = createSizedArray(_maxLength);
      var ob = {
        newElement: newElement,
        release: release
      };

      function newElement() {
        var element;

        if (_length) {
          _length -= 1;
          element = pool[_length];
        } else {
          element = _create();
        }

        return element;
      }

      function release(element) {
        if (_length === _maxLength) {
          pool = pooling["double"](pool);
          _maxLength = _maxLength * 2;
        }

        if (_release) {
          _release(element);
        }

        pool[_length] = element;
        _length += 1;
      }

      function clone() {
        var clonedElement = newElement();
        return _clone(clonedElement);
      }

      return ob;
    };
  }();

  var pooling = function () {
    function _double(arr) {
      return arr.concat(createSizedArray(arr.length));
    }

    return {
      "double": _double
    };
  }();

  var point_pool = function () {
    function create() {
      return createTypedArray('float32', 2);
    }

    return pool_factory(8, create);
  }();

  var shape_pool = function () {
    function create() {
      return new ShapePath();
    }

    function release(shapePath) {
      var len = shapePath._length,
          i;

      for (i = 0; i < len; i += 1) {
        point_pool.release(shapePath.v[i]);
        point_pool.release(shapePath.i[i]);
        point_pool.release(shapePath.o[i]);
        shapePath.v[i] = null;
        shapePath.i[i] = null;
        shapePath.o[i] = null;
      }

      shapePath._length = 0;
      shapePath.c = false;
    }

    function clone(shape) {
      var cloned = factory.newElement();
      var i,
          len = shape._length === undefined ? shape.v.length : shape._length;
      cloned.setLength(len);
      cloned.c = shape.c;
      var pt;

      for (i = 0; i < len; i += 1) {
        cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
      }

      return cloned;
    }

    var factory = pool_factory(4, create, release);
    factory.clone = clone;
    return factory;
  }();

  var shapeCollection_pool = function () {
    var ob = {
      newShapeCollection: newShapeCollection,
      release: release
    };
    var _length = 0;
    var _maxLength = 4;
    var pool = createSizedArray(_maxLength);

    function newShapeCollection() {
      var shapeCollection;

      if (_length) {
        _length -= 1;
        shapeCollection = pool[_length];
      } else {
        shapeCollection = new ShapeCollection();
      }

      return shapeCollection;
    }

    function release(shapeCollection) {
      var i,
          len = shapeCollection._length;

      for (i = 0; i < len; i += 1) {
        shape_pool.release(shapeCollection.shapes[i]);
      }

      shapeCollection._length = 0;

      if (_length === _maxLength) {
        pool = pooling["double"](pool);
        _maxLength = _maxLength * 2;
      }

      pool[_length] = shapeCollection;
      _length += 1;
    }

    return ob;
  }();

  var segments_length_pool = function () {
    function create() {
      return {
        lengths: [],
        totalLength: 0
      };
    }

    function release(element) {
      var i,
          len = element.lengths.length;

      for (i = 0; i < len; i += 1) {
        bezier_length_pool.release(element.lengths[i]);
      }

      element.lengths.length = 0;
    }

    return pool_factory(8, create, release);
  }();

  var bezier_length_pool = function () {
    function create() {
      return {
        addedLength: 0,
        percents: createTypedArray('float32', defaultCurveSegments),
        lengths: createTypedArray('float32', defaultCurveSegments)
      };
    }

    return pool_factory(8, create);
  }();

  function BaseRenderer() {}

  BaseRenderer.prototype.checkLayers = function (num) {
    var i,
        len = this.layers.length,
        data;
    this.completeLayers = true;

    for (i = len - 1; i >= 0; i--) {
      if (!this.elements[i]) {
        data = this.layers[i];

        if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {
          this.buildItem(i);
        }
      }

      this.completeLayers = this.elements[i] ? this.completeLayers : false;
    }

    this.checkPendingElements();
  };

  BaseRenderer.prototype.createItem = function (layer) {
    switch (layer.ty) {
      case 2:
        return this.createImage(layer);

      case 0:
        return this.createComp(layer);

      case 1:
        return this.createSolid(layer);

      case 3:
        return this.createNull(layer);

      case 4:
        return this.createShape(layer);

      case 5:
        return this.createText(layer);

      case 13:
        return this.createCamera(layer);
    }

    return this.createNull(layer);
  };

  BaseRenderer.prototype.createCamera = function () {
    throw new Error('You\'re using a 3d camera. Try the html renderer.');
  };

  BaseRenderer.prototype.buildAllItems = function () {
    var i,
        len = this.layers.length;

    for (i = 0; i < len; i += 1) {
      this.buildItem(i);
    }

    this.checkPendingElements();
  };

  BaseRenderer.prototype.includeLayers = function (newLayers) {
    this.completeLayers = false;
    var i,
        len = newLayers.length;
    var j,
        jLen = this.layers.length;

    for (i = 0; i < len; i += 1) {
      j = 0;

      while (j < jLen) {
        if (this.layers[j].id == newLayers[i].id) {
          this.layers[j] = newLayers[i];
          break;
        }

        j += 1;
      }
    }
  };

  BaseRenderer.prototype.setProjectInterface = function (pInterface) {
    this.globalData.projectInterface = pInterface;
  };

  BaseRenderer.prototype.initItems = function () {
    if (!this.globalData.progressiveLoad) {
      this.buildAllItems();
    }
  };

  BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
    var elements = this.elements;
    var layers = this.layers;
    var i = 0,
        len = layers.length;

    while (i < len) {
      if (layers[i].ind == parentName) {
        if (!elements[i] || elements[i] === true) {
          this.buildItem(i);
          this.addPendingElement(element);
        } else {
          hierarchy.push(elements[i]);
          elements[i].setAsParent();

          if (layers[i].parent !== undefined) {
            this.buildElementParenting(element, layers[i].parent, hierarchy);
          } else {
            element.setHierarchy(hierarchy);
          }
        }
      }

      i += 1;
    }
  };

  BaseRenderer.prototype.addPendingElement = function (element) {
    this.pendingElements.push(element);
  };

  BaseRenderer.prototype.searchExtraCompositions = function (assets) {
    var i,
        len = assets.length;

    for (i = 0; i < len; i += 1) {
      if (assets[i].xt) {
        var comp = this.createComp(assets[i]);
        comp.initExpressions();
        this.globalData.projectInterface.registerComposition(comp);
      }
    }
  };

  BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
    this.globalData.fontManager = new FontManager();
    this.globalData.fontManager.addChars(animData.chars);
    this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
    this.globalData.imageLoader = this.animationItem.imagePreloader;
    this.globalData.frameId = 0;
    this.globalData.frameRate = animData.fr;
    this.globalData.nm = animData.nm;
    this.globalData.compSize = {
      w: animData.w,
      h: animData.h
    };
  };

  function SVGRenderer(animationItem, config) {
    this.animationItem = animationItem;
    this.layers = null;
    this.renderedFrame = -1;
    this.svgElement = createNS('svg');
    var ariaLabel = '';

    if (config && config.title) {
      var titleElement = createNS('title');
      var titleId = createElementID();
      titleElement.setAttribute('id', titleId);
      titleElement.textContent = config.title;
      this.svgElement.appendChild(titleElement);
      ariaLabel += titleId;
    }

    if (config && config.description) {
      var descElement = createNS('desc');
      var descId = createElementID();
      descElement.setAttribute('id', descId);
      descElement.textContent = config.description;
      this.svgElement.appendChild(descElement);
      ariaLabel += ' ' + descId;
    }

    if (ariaLabel) {
      this.svgElement.setAttribute('aria-labelledby', ariaLabel);
    }

    var defs = createNS('defs');
    this.svgElement.appendChild(defs);
    var maskElement = createNS('g');
    this.svgElement.appendChild(maskElement);
    this.layerElement = maskElement;
    this.renderConfig = {
      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
      progressiveLoad: config && config.progressiveLoad || false,
      hideOnTransparent: config && config.hideOnTransparent === false ? false : true,
      viewBoxOnly: config && config.viewBoxOnly || false,
      viewBoxSize: config && config.viewBoxSize || false,
      className: config && config.className || ''
    };
    this.globalData = {
      _mdf: false,
      frameNum: -1,
      defs: defs,
      renderConfig: this.renderConfig
    };
    this.elements = [];
    this.pendingElements = [];
    this.destroyed = false;
    this.rendererType = 'svg';
  }

  extendPrototype([BaseRenderer], SVGRenderer);

  SVGRenderer.prototype.createNull = function (data) {
    return new NullElement(data, this.globalData, this);
  };

  SVGRenderer.prototype.createShape = function (data) {
    return new SVGShapeElement(data, this.globalData, this);
  };

  SVGRenderer.prototype.createText = function (data) {
    return new SVGTextElement(data, this.globalData, this);
  };

  SVGRenderer.prototype.createImage = function (data) {
    return new IImageElement(data, this.globalData, this);
  };

  SVGRenderer.prototype.createComp = function (data) {
    return new SVGCompElement(data, this.globalData, this);
  };

  SVGRenderer.prototype.createSolid = function (data) {
    return new ISolidElement(data, this.globalData, this);
  };

  SVGRenderer.prototype.configAnimation = function (animData) {
    this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

    if (this.renderConfig.viewBoxSize) {
      this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
    } else {
      this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
    }

    if (!this.renderConfig.viewBoxOnly) {
      this.svgElement.setAttribute('width', animData.w);
      this.svgElement.setAttribute('height', animData.h);
      this.svgElement.style.width = '100%';
      this.svgElement.style.height = '100%';
      this.svgElement.style.transform = 'translate3d(0,0,0)';
    }

    if (this.renderConfig.className) {
      this.svgElement.setAttribute('class', this.renderConfig.className);
    }

    this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio); //this.layerElement.style.transform = 'translate3d(0,0,0)';
    //this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";

    this.animationItem.wrapper.appendChild(this.svgElement); //Mask animation

    var defs = this.globalData.defs;
    this.setupGlobalData(animData, defs);
    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
    this.data = animData;
    var maskElement = createNS('clipPath');
    var rect = createNS('rect');
    rect.setAttribute('width', animData.w);
    rect.setAttribute('height', animData.h);
    rect.setAttribute('x', 0);
    rect.setAttribute('y', 0);
    var maskId = createElementID();
    maskElement.setAttribute('id', maskId);
    maskElement.appendChild(rect);
    this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + maskId + ")");
    defs.appendChild(maskElement);
    this.layers = animData.layers;
    this.elements = createSizedArray(animData.layers.length);
  };

  SVGRenderer.prototype.destroy = function () {
    this.animationItem.wrapper.innerHTML = '';
    this.layerElement = null;
    this.globalData.defs = null;
    var i,
        len = this.layers ? this.layers.length : 0;

    for (i = 0; i < len; i++) {
      if (this.elements[i]) {
        this.elements[i].destroy();
      }
    }

    this.elements.length = 0;
    this.destroyed = true;
    this.animationItem = null;
  };

  SVGRenderer.prototype.updateContainerSize = function () {};

  SVGRenderer.prototype.buildItem = function (pos) {
    var elements = this.elements;

    if (elements[pos] || this.layers[pos].ty == 99) {
      return;
    }

    elements[pos] = true;
    var element = this.createItem(this.layers[pos]);
    elements[pos] = element;

    if (expressionsPlugin) {
      if (this.layers[pos].ty === 0) {
        this.globalData.projectInterface.registerComposition(element);
      }

      element.initExpressions();
    }

    this.appendElementInPos(element, pos);

    if (this.layers[pos].tt) {
      if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
        this.buildItem(pos - 1);
        this.addPendingElement(element);
      } else {
        element.setMatte(elements[pos - 1].layerId);
      }
    }
  };

  SVGRenderer.prototype.checkPendingElements = function () {
    while (this.pendingElements.length) {
      var element = this.pendingElements.pop();
      element.checkParenting();

      if (element.data.tt) {
        var i = 0,
            len = this.elements.length;

        while (i < len) {
          if (this.elements[i] === element) {
            element.setMatte(this.elements[i - 1].layerId);
            break;
          }

          i += 1;
        }
      }
    }
  };

  SVGRenderer.prototype.renderFrame = function (num) {
    if (this.renderedFrame === num || this.destroyed) {
      return;
    }

    if (num === null) {
      num = this.renderedFrame;
    } else {
      this.renderedFrame = num;
    } // console.log('-------');
    // console.log('FRAME ',num);


    this.globalData.frameNum = num;
    this.globalData.frameId += 1;
    this.globalData.projectInterface.currentFrame = num;
    this.globalData._mdf = false;
    var i,
        len = this.layers.length;

    if (!this.completeLayers) {
      this.checkLayers(num);
    }

    for (i = len - 1; i >= 0; i--) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].prepareFrame(num - this.layers[i].st);
      }
    }

    if (this.globalData._mdf) {
      for (i = 0; i < len; i += 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].renderFrame();
        }
      }
    }
  };

  SVGRenderer.prototype.appendElementInPos = function (element, pos) {
    var newElement = element.getBaseElement();

    if (!newElement) {
      return;
    }

    var i = 0;
    var nextElement;

    while (i < pos) {
      if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
        nextElement = this.elements[i].getBaseElement();
      }

      i += 1;
    }

    if (nextElement) {
      this.layerElement.insertBefore(newElement, nextElement);
    } else {
      this.layerElement.appendChild(newElement);
    }
  };

  SVGRenderer.prototype.hide = function () {
    this.layerElement.style.display = 'none';
  };

  SVGRenderer.prototype.show = function () {
    this.layerElement.style.display = 'block';
  };

  function CanvasRenderer(animationItem, config) {
    this.animationItem = animationItem;
    this.renderConfig = {
      clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,
      context: config && config.context || null,
      progressiveLoad: config && config.progressiveLoad || false,
      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
      className: config && config.className || ''
    };
    this.renderConfig.dpr = config && config.dpr || 1;

    if (this.animationItem.wrapper) {
      this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
    }

    this.renderedFrame = -1;
    this.globalData = {
      frameNum: -1,
      _mdf: false,
      renderConfig: this.renderConfig,
      currentGlobalAlpha: -1
    };
    this.contextData = new CVContextData();
    this.elements = [];
    this.pendingElements = [];
    this.transformMat = new Matrix();
    this.completeLayers = false;
    this.rendererType = 'canvas';
  }

  extendPrototype([BaseRenderer], CanvasRenderer);

  CanvasRenderer.prototype.createShape = function (data) {
    return new CVShapeElement(data, this.globalData, this);
  };

  CanvasRenderer.prototype.createText = function (data) {
    return new CVTextElement(data, this.globalData, this);
  };

  CanvasRenderer.prototype.createImage = function (data) {
    return new CVImageElement(data, this.globalData, this);
  };

  CanvasRenderer.prototype.createComp = function (data) {
    return new CVCompElement(data, this.globalData, this);
  };

  CanvasRenderer.prototype.createSolid = function (data) {
    return new CVSolidElement(data, this.globalData, this);
  };

  CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

  CanvasRenderer.prototype.ctxTransform = function (props) {
    if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
      return;
    }

    if (!this.renderConfig.clearCanvas) {
      this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
      return;
    }

    this.transformMat.cloneFromProps(props);
    var cProps = this.contextData.cTr.props;
    this.transformMat.transform(cProps[0], cProps[1], cProps[2], cProps[3], cProps[4], cProps[5], cProps[6], cProps[7], cProps[8], cProps[9], cProps[10], cProps[11], cProps[12], cProps[13], cProps[14], cProps[15]); //this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);

    this.contextData.cTr.cloneFromProps(this.transformMat.props);
    var trProps = this.contextData.cTr.props;
    this.canvasContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
  };

  CanvasRenderer.prototype.ctxOpacity = function (op) {
    /*if(op === 1){
        return;
    }*/
    if (!this.renderConfig.clearCanvas) {
      this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
      this.globalData.currentGlobalAlpha = this.contextData.cO;
      return;
    }

    this.contextData.cO *= op < 0 ? 0 : op;

    if (this.globalData.currentGlobalAlpha !== this.contextData.cO) {
      this.canvasContext.globalAlpha = this.contextData.cO;
      this.globalData.currentGlobalAlpha = this.contextData.cO;
    }
  };

  CanvasRenderer.prototype.reset = function () {
    if (!this.renderConfig.clearCanvas) {
      this.canvasContext.restore();
      return;
    }

    this.contextData.reset();
  };

  CanvasRenderer.prototype.save = function (actionFlag) {
    if (!this.renderConfig.clearCanvas) {
      this.canvasContext.save();
      return;
    }

    if (actionFlag) {
      this.canvasContext.save();
    }

    var props = this.contextData.cTr.props;

    if (this.contextData._length <= this.contextData.cArrPos) {
      this.contextData.duplicate();
    }

    var i,
        arr = this.contextData.saved[this.contextData.cArrPos];

    for (i = 0; i < 16; i += 1) {
      arr[i] = props[i];
    }

    this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
    this.contextData.cArrPos += 1;
  };

  CanvasRenderer.prototype.restore = function (actionFlag) {
    if (!this.renderConfig.clearCanvas) {
      this.canvasContext.restore();
      return;
    }

    if (actionFlag) {
      this.canvasContext.restore();
      this.globalData.blendMode = 'source-over';
    }

    this.contextData.cArrPos -= 1;
    var popped = this.contextData.saved[this.contextData.cArrPos];
    var i,
        arr = this.contextData.cTr.props;

    for (i = 0; i < 16; i += 1) {
      arr[i] = popped[i];
    }

    this.canvasContext.setTransform(popped[0], popped[1], popped[4], popped[5], popped[12], popped[13]);
    popped = this.contextData.savedOp[this.contextData.cArrPos];
    this.contextData.cO = popped;

    if (this.globalData.currentGlobalAlpha !== popped) {
      this.canvasContext.globalAlpha = popped;
      this.globalData.currentGlobalAlpha = popped;
    }
  };

  CanvasRenderer.prototype.configAnimation = function (animData) {
    if (this.animationItem.wrapper) {
      this.animationItem.container = createTag('canvas');
      this.animationItem.container.style.width = '100%';
      this.animationItem.container.style.height = '100%'; //this.animationItem.container.style.transform = 'translate3d(0,0,0)';
      //this.animationItem.container.style.webkitTransform = 'translate3d(0,0,0)';

      this.animationItem.container.style.transformOrigin = this.animationItem.container.style.mozTransformOrigin = this.animationItem.container.style.webkitTransformOrigin = this.animationItem.container.style['-webkit-transform'] = "0px 0px 0px";
      this.animationItem.wrapper.appendChild(this.animationItem.container);
      this.canvasContext = this.animationItem.container.getContext('2d');

      if (this.renderConfig.className) {
        this.animationItem.container.setAttribute('class', this.renderConfig.className);
      }
    } else {
      this.canvasContext = this.renderConfig.context;
    }

    this.data = animData;
    this.layers = animData.layers;
    this.transformCanvas = {
      w: animData.w,
      h: animData.h,
      sx: 0,
      sy: 0,
      tx: 0,
      ty: 0
    };
    this.setupGlobalData(animData, document.body);
    this.globalData.canvasContext = this.canvasContext;
    this.globalData.renderer = this;
    this.globalData.isDashed = false;
    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
    this.globalData.transformCanvas = this.transformCanvas;
    this.elements = createSizedArray(animData.layers.length);
    this.updateContainerSize();
  };

  CanvasRenderer.prototype.updateContainerSize = function () {
    this.reset();
    var elementWidth, elementHeight;

    if (this.animationItem.wrapper && this.animationItem.container) {
      elementWidth = this.animationItem.wrapper.offsetWidth;
      elementHeight = this.animationItem.wrapper.offsetHeight;
      this.animationItem.container.setAttribute('width', elementWidth * this.renderConfig.dpr);
      this.animationItem.container.setAttribute('height', elementHeight * this.renderConfig.dpr);
    } else {
      elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
      elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
    }

    var elementRel, animationRel;

    if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
      var par = this.renderConfig.preserveAspectRatio.split(' ');
      var fillType = par[1] || 'meet';
      var pos = par[0] || 'xMidYMid';
      var xPos = pos.substr(0, 4);
      var yPos = pos.substr(4);
      elementRel = elementWidth / elementHeight;
      animationRel = this.transformCanvas.w / this.transformCanvas.h;

      if (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice') {
        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
        this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
      } else {
        this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
      }

      if (xPos === 'xMid' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
      } else if (xPos === 'xMax' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
      } else {
        this.transformCanvas.tx = 0;
      }

      if (yPos === 'YMid' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
      } else if (yPos === 'YMax' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
      } else {
        this.transformCanvas.ty = 0;
      }
    } else if (this.renderConfig.preserveAspectRatio == 'none') {
      this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
      this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
      this.transformCanvas.tx = 0;
      this.transformCanvas.ty = 0;
    } else {
      this.transformCanvas.sx = this.renderConfig.dpr;
      this.transformCanvas.sy = this.renderConfig.dpr;
      this.transformCanvas.tx = 0;
      this.transformCanvas.ty = 0;
    }

    this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
    /*var i, len = this.elements.length;
    for(i=0;i<len;i+=1){
        if(this.elements[i] && this.elements[i].data.ty === 0){
            this.elements[i].resize(this.globalData.transformCanvas);
        }
    }*/

    this.ctxTransform(this.transformCanvas.props);
    this.canvasContext.beginPath();
    this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
    this.canvasContext.closePath();
    this.canvasContext.clip();
    this.renderFrame(this.renderedFrame, true);
  };

  CanvasRenderer.prototype.destroy = function () {
    if (this.renderConfig.clearCanvas) {
      this.animationItem.wrapper.innerHTML = '';
    }

    var i,
        len = this.layers ? this.layers.length : 0;

    for (i = len - 1; i >= 0; i -= 1) {
      if (this.elements[i]) {
        this.elements[i].destroy();
      }
    }

    this.elements.length = 0;
    this.globalData.canvasContext = null;
    this.animationItem.container = null;
    this.destroyed = true;
  };

  CanvasRenderer.prototype.renderFrame = function (num, forceRender) {
    if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
      return;
    }

    this.renderedFrame = num;
    this.globalData.frameNum = num - this.animationItem._isFirstFrame;
    this.globalData.frameId += 1;
    this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
    this.globalData.projectInterface.currentFrame = num; // console.log('--------');
    // console.log('NEW: ',num);

    var i,
        len = this.layers.length;

    if (!this.completeLayers) {
      this.checkLayers(num);
    }

    for (i = 0; i < len; i++) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].prepareFrame(num - this.layers[i].st);
      }
    }

    if (this.globalData._mdf) {
      if (this.renderConfig.clearCanvas === true) {
        this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
      } else {
        this.save();
      }

      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].renderFrame();
        }
      }

      if (this.renderConfig.clearCanvas !== true) {
        this.restore();
      }
    }
  };

  CanvasRenderer.prototype.buildItem = function (pos) {
    var elements = this.elements;

    if (elements[pos] || this.layers[pos].ty == 99) {
      return;
    }

    var element = this.createItem(this.layers[pos], this, this.globalData);
    elements[pos] = element;
    element.initExpressions();
    /*if(this.layers[pos].ty === 0){
        element.resize(this.globalData.transformCanvas);
    }*/
  };

  CanvasRenderer.prototype.checkPendingElements = function () {
    while (this.pendingElements.length) {
      var element = this.pendingElements.pop();
      element.checkParenting();
    }
  };

  CanvasRenderer.prototype.hide = function () {
    this.animationItem.container.style.display = 'none';
  };

  CanvasRenderer.prototype.show = function () {
    this.animationItem.container.style.display = 'block';
  };

  function HybridRenderer(animationItem, config) {
    this.animationItem = animationItem;
    this.layers = null;
    this.renderedFrame = -1;
    this.renderConfig = {
      className: config && config.className || '',
      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
      hideOnTransparent: config && config.hideOnTransparent === false ? false : true
    };
    this.globalData = {
      _mdf: false,
      frameNum: -1,
      renderConfig: this.renderConfig
    };
    this.pendingElements = [];
    this.elements = [];
    this.threeDElements = [];
    this.destroyed = false;
    this.camera = null;
    this.supports3d = true;
    this.rendererType = 'html';
  }

  extendPrototype([BaseRenderer], HybridRenderer);
  HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;

  HybridRenderer.prototype.checkPendingElements = function () {
    while (this.pendingElements.length) {
      var element = this.pendingElements.pop();
      element.checkParenting();
    }
  };

  HybridRenderer.prototype.appendElementInPos = function (element, pos) {
    var newDOMElement = element.getBaseElement();

    if (!newDOMElement) {
      return;
    }

    var layer = this.layers[pos];

    if (!layer.ddd || !this.supports3d) {
      if (this.threeDElements) {
        this.addTo3dContainer(newDOMElement, pos);
      } else {
        var i = 0;
        var nextDOMElement, nextLayer, tmpDOMElement;

        while (i < pos) {
          if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
            nextLayer = this.elements[i];
            tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
            nextDOMElement = tmpDOMElement || nextDOMElement;
          }

          i += 1;
        }

        if (nextDOMElement) {
          if (!layer.ddd || !this.supports3d) {
            this.layerElement.insertBefore(newDOMElement, nextDOMElement);
          }
        } else {
          if (!layer.ddd || !this.supports3d) {
            this.layerElement.appendChild(newDOMElement);
          }
        }
      }
    } else {
      this.addTo3dContainer(newDOMElement, pos);
    }
  };

  HybridRenderer.prototype.createShape = function (data) {
    if (!this.supports3d) {
      return new SVGShapeElement(data, this.globalData, this);
    }

    return new HShapeElement(data, this.globalData, this);
  };

  HybridRenderer.prototype.createText = function (data) {
    if (!this.supports3d) {
      return new SVGTextElement(data, this.globalData, this);
    }

    return new HTextElement(data, this.globalData, this);
  };

  HybridRenderer.prototype.createCamera = function (data) {
    this.camera = new HCameraElement(data, this.globalData, this);
    return this.camera;
  };

  HybridRenderer.prototype.createImage = function (data) {
    if (!this.supports3d) {
      return new IImageElement(data, this.globalData, this);
    }

    return new HImageElement(data, this.globalData, this);
  };

  HybridRenderer.prototype.createComp = function (data) {
    if (!this.supports3d) {
      return new SVGCompElement(data, this.globalData, this);
    }

    return new HCompElement(data, this.globalData, this);
  };

  HybridRenderer.prototype.createSolid = function (data) {
    if (!this.supports3d) {
      return new ISolidElement(data, this.globalData, this);
    }

    return new HSolidElement(data, this.globalData, this);
  };

  HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

  HybridRenderer.prototype.getThreeDContainerByPos = function (pos) {
    var i = 0,
        len = this.threeDElements.length;

    while (i < len) {
      if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
        return this.threeDElements[i].perspectiveElem;
      }

      i += 1;
    }
  };

  HybridRenderer.prototype.createThreeDContainer = function (pos, type) {
    var perspectiveElem = createTag('div');
    styleDiv(perspectiveElem);
    var container = createTag('div');
    styleDiv(container);

    if (type === '3d') {
      perspectiveElem.style.width = this.globalData.compSize.w + 'px';
      perspectiveElem.style.height = this.globalData.compSize.h + 'px';
      perspectiveElem.style.transformOrigin = perspectiveElem.style.mozTransformOrigin = perspectiveElem.style.webkitTransformOrigin = "50% 50%";
      container.style.transform = container.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
    }

    perspectiveElem.appendChild(container); //this.resizerElem.appendChild(perspectiveElem);

    var threeDContainerData = {
      container: container,
      perspectiveElem: perspectiveElem,
      startPos: pos,
      endPos: pos,
      type: type
    };
    this.threeDElements.push(threeDContainerData);
    return threeDContainerData;
  };

  HybridRenderer.prototype.build3dContainers = function () {
    var i,
        len = this.layers.length;
    var lastThreeDContainerData;
    var currentContainer = '';

    for (i = 0; i < len; i += 1) {
      if (this.layers[i].ddd && this.layers[i].ty !== 3) {
        if (currentContainer !== '3d') {
          currentContainer = '3d';
          lastThreeDContainerData = this.createThreeDContainer(i, '3d');
        }

        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
      } else {
        if (currentContainer !== '2d') {
          currentContainer = '2d';
          lastThreeDContainerData = this.createThreeDContainer(i, '2d');
        }

        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
      }
    }

    len = this.threeDElements.length;

    for (i = len - 1; i >= 0; i--) {
      this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
    }
  };

  HybridRenderer.prototype.addTo3dContainer = function (elem, pos) {
    var i = 0,
        len = this.threeDElements.length;

    while (i < len) {
      if (pos <= this.threeDElements[i].endPos) {
        var j = this.threeDElements[i].startPos;
        var nextElement;

        while (j < pos) {
          if (this.elements[j] && this.elements[j].getBaseElement) {
            nextElement = this.elements[j].getBaseElement();
          }

          j += 1;
        }

        if (nextElement) {
          this.threeDElements[i].container.insertBefore(elem, nextElement);
        } else {
          this.threeDElements[i].container.appendChild(elem);
        }

        break;
      }

      i += 1;
    }
  };

  HybridRenderer.prototype.configAnimation = function (animData) {
    var resizerElem = createTag('div');
    var wrapper = this.animationItem.wrapper;
    resizerElem.style.width = animData.w + 'px';
    resizerElem.style.height = animData.h + 'px';
    this.resizerElem = resizerElem;
    styleDiv(resizerElem);
    resizerElem.style.transformStyle = resizerElem.style.webkitTransformStyle = resizerElem.style.mozTransformStyle = "flat";

    if (this.renderConfig.className) {
      resizerElem.setAttribute('class', this.renderConfig.className);
    }

    wrapper.appendChild(resizerElem);
    resizerElem.style.overflow = 'hidden';
    var svg = createNS('svg');
    svg.setAttribute('width', '1');
    svg.setAttribute('height', '1');
    styleDiv(svg);
    this.resizerElem.appendChild(svg);
    var defs = createNS('defs');
    svg.appendChild(defs);
    this.data = animData; //Mask animation

    this.setupGlobalData(animData, svg);
    this.globalData.defs = defs;
    this.layers = animData.layers;
    this.layerElement = this.resizerElem;
    this.build3dContainers();
    this.updateContainerSize();
  };

  HybridRenderer.prototype.destroy = function () {
    this.animationItem.wrapper.innerHTML = '';
    this.animationItem.container = null;
    this.globalData.defs = null;
    var i,
        len = this.layers ? this.layers.length : 0;

    for (i = 0; i < len; i++) {
      this.elements[i].destroy();
    }

    this.elements.length = 0;
    this.destroyed = true;
    this.animationItem = null;
  };

  HybridRenderer.prototype.updateContainerSize = function () {
    var elementWidth = this.animationItem.wrapper.offsetWidth;
    var elementHeight = this.animationItem.wrapper.offsetHeight;
    var elementRel = elementWidth / elementHeight;
    var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
    var sx, sy, tx, ty;

    if (animationRel > elementRel) {
      sx = elementWidth / this.globalData.compSize.w;
      sy = elementWidth / this.globalData.compSize.w;
      tx = 0;
      ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
    } else {
      sx = elementHeight / this.globalData.compSize.h;
      sy = elementHeight / this.globalData.compSize.h;
      tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
      ty = 0;
    }

    this.resizerElem.style.transform = this.resizerElem.style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
  };

  HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;

  HybridRenderer.prototype.hide = function () {
    this.resizerElem.style.display = 'none';
  };

  HybridRenderer.prototype.show = function () {
    this.resizerElem.style.display = 'block';
  };

  HybridRenderer.prototype.initItems = function () {
    this.buildAllItems();

    if (this.camera) {
      this.camera.setup();
    } else {
      var cWidth = this.globalData.compSize.w;
      var cHeight = this.globalData.compSize.h;
      var i,
          len = this.threeDElements.length;

      for (i = 0; i < len; i += 1) {
        this.threeDElements[i].perspectiveElem.style.perspective = this.threeDElements[i].perspectiveElem.style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
      }
    }
  };

  HybridRenderer.prototype.searchExtraCompositions = function (assets) {
    var i,
        len = assets.length;
    var floatingContainer = createTag('div');

    for (i = 0; i < len; i += 1) {
      if (assets[i].xt) {
        var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
        comp.initExpressions();
        this.globalData.projectInterface.registerComposition(comp);
      }
    }
  };

  function MaskElement(data, element, globalData) {
    this.data = data;
    this.element = element;
    this.globalData = globalData;
    this.storedData = [];
    this.masksProperties = this.data.masksProperties || [];
    this.maskElement = null;
    var defs = this.globalData.defs;
    var i,
        len = this.masksProperties ? this.masksProperties.length : 0;
    this.viewData = createSizedArray(len);
    this.solidPath = '';
    var path,
        properties = this.masksProperties;
    var count = 0;
    var currentMasks = [];
    var j, jLen;
    var layerId = createElementID();
    var rect, expansor, feMorph, x;
    var maskType = 'clipPath',
        maskRef = 'clip-path';

    for (i = 0; i < len; i++) {
      if (properties[i].mode !== 'a' && properties[i].mode !== 'n' || properties[i].inv || properties[i].o.k !== 100) {
        maskType = 'mask';
        maskRef = 'mask';
      }

      if ((properties[i].mode == 's' || properties[i].mode == 'i') && count === 0) {
        rect = createNS('rect');
        rect.setAttribute('fill', '#ffffff');
        rect.setAttribute('width', this.element.comp.data.w || 0);
        rect.setAttribute('height', this.element.comp.data.h || 0);
        currentMasks.push(rect);
      } else {
        rect = null;
      }

      path = createNS('path');

      if (properties[i].mode == 'n') {
        // TODO move this to a factory or to a constructor
        this.viewData[i] = {
          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
          elem: path,
          lastPath: ''
        };
        defs.appendChild(path);
        continue;
      }

      count += 1;
      path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
      path.setAttribute('clip-rule', 'nonzero');
      var filterID;

      if (properties[i].x.k !== 0) {
        maskType = 'mask';
        maskRef = 'mask';
        x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
        filterID = createElementID();
        expansor = createNS('filter');
        expansor.setAttribute('id', filterID);
        feMorph = createNS('feMorphology');
        feMorph.setAttribute('operator', 'dilate');
        feMorph.setAttribute('in', 'SourceGraphic');
        feMorph.setAttribute('radius', '0');
        expansor.appendChild(feMorph);
        defs.appendChild(expansor);
        path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
      } else {
        feMorph = null;
        x = null;
      } // TODO move this to a factory or to a constructor


      this.storedData[i] = {
        elem: path,
        x: x,
        expan: feMorph,
        lastPath: '',
        lastOperator: '',
        filterId: filterID,
        lastRadius: 0
      };

      if (properties[i].mode == 'i') {
        jLen = currentMasks.length;
        var g = createNS('g');

        for (j = 0; j < jLen; j += 1) {
          g.appendChild(currentMasks[j]);
        }

        var mask = createNS('mask');
        mask.setAttribute('mask-type', 'alpha');
        mask.setAttribute('id', layerId + '_' + count);
        mask.appendChild(path);
        defs.appendChild(mask);
        g.setAttribute('mask', 'url(' + locationHref + '#' + layerId + '_' + count + ')');
        currentMasks.length = 0;
        currentMasks.push(g);
      } else {
        currentMasks.push(path);
      }

      if (properties[i].inv && !this.solidPath) {
        this.solidPath = this.createLayerSolidPath();
      } // TODO move this to a factory or to a constructor


      this.viewData[i] = {
        elem: path,
        lastPath: '',
        op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
        prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
        invRect: rect
      };

      if (!this.viewData[i].prop.k) {
        this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
      }
    }

    this.maskElement = createNS(maskType);
    len = currentMasks.length;

    for (i = 0; i < len; i += 1) {
      this.maskElement.appendChild(currentMasks[i]);
    }

    if (count > 0) {
      this.maskElement.setAttribute('id', layerId);
      this.element.maskedElement.setAttribute(maskRef, "url(" + locationHref + "#" + layerId + ")");
      defs.appendChild(this.maskElement);
    }

    if (this.viewData.length) {
      this.element.addRenderableComponent(this);
    }
  }

  MaskElement.prototype.getMaskProperty = function (pos) {
    return this.viewData[pos].prop;
  };

  MaskElement.prototype.renderFrame = function (isFirstFrame) {
    var finalMat = this.element.finalTransform.mat;
    var i,
        len = this.masksProperties.length;

    for (i = 0; i < len; i++) {
      if (this.viewData[i].prop._mdf || isFirstFrame) {
        this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
      }

      if (this.viewData[i].op._mdf || isFirstFrame) {
        this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
      }

      if (this.masksProperties[i].mode !== 'n') {
        if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
          this.viewData[i].invRect.setAttribute('x', -finalMat.props[12]);
          this.viewData[i].invRect.setAttribute('y', -finalMat.props[13]);
        }

        if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
          var feMorph = this.storedData[i].expan;

          if (this.storedData[i].x.v < 0) {
            if (this.storedData[i].lastOperator !== 'erode') {
              this.storedData[i].lastOperator = 'erode';
              this.storedData[i].elem.setAttribute('filter', 'url(' + locationHref + '#' + this.storedData[i].filterId + ')');
            }

            feMorph.setAttribute('radius', -this.storedData[i].x.v);
          } else {
            if (this.storedData[i].lastOperator !== 'dilate') {
              this.storedData[i].lastOperator = 'dilate';
              this.storedData[i].elem.setAttribute('filter', null);
            }

            this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
          }
        }
      }
    }
  };

  MaskElement.prototype.getMaskelement = function () {
    return this.maskElement;
  };

  MaskElement.prototype.createLayerSolidPath = function () {
    var path = 'M0,0 ';
    path += ' h' + this.globalData.compSize.w;
    path += ' v' + this.globalData.compSize.h;
    path += ' h-' + this.globalData.compSize.w;
    path += ' v-' + this.globalData.compSize.h + ' ';
    return path;
  };

  MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
    var pathString = " M" + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
    var i, len;
    len = pathNodes._length;

    for (i = 1; i < len; i += 1) {
      //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
      pathString += " C" + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + " " + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + " " + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
    } //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];


    if (pathNodes.c && len > 1) {
      pathString += " C" + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + " " + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
    } //pathNodes.__renderedString = pathString;


    if (viewData.lastPath !== pathString) {
      var pathShapeValue = '';

      if (viewData.elem) {
        if (pathNodes.c) {
          pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
        }

        viewData.elem.setAttribute('d', pathShapeValue);
      }

      viewData.lastPath = pathString;
    }
  };

  MaskElement.prototype.destroy = function () {
    this.element = null;
    this.globalData = null;
    this.maskElement = null;
    this.data = null;
    this.masksProperties = null;
  };
  /**
   * @file
   * Handles AE's layer parenting property.
   *
   */


  function HierarchyElement() {}

  HierarchyElement.prototype = {
    /**
        * @function
        * Initializes hierarchy properties
        *
        */
    initHierarchy: function initHierarchy() {
      //element's parent list
      this.hierarchy = []; //if element is parent of another layer _isParent will be true

      this._isParent = false;
      this.checkParenting();
    },

    /**
        * @function
        * Sets layer's hierarchy.
        * @param {array} hierarch
        * layer's parent list
        *
        */
    setHierarchy: function setHierarchy(hierarchy) {
      this.hierarchy = hierarchy;
    },

    /**
        * @function
        * Sets layer as parent.
        *
        */
    setAsParent: function setAsParent() {
      this._isParent = true;
    },

    /**
        * @function
        * Searches layer's parenting chain
        *
        */
    checkParenting: function checkParenting() {
      if (this.data.parent !== undefined) {
        this.comp.buildElementParenting(this, this.data.parent, []);
      }
    }
  };
  /**
   * @file
   * Handles element's layer frame update.
   * Checks layer in point and out point
   *
   */

  function FrameElement() {}

  FrameElement.prototype = {
    /**
     * @function
     * Initializes frame related properties.
     *
     */
    initFrame: function initFrame() {
      //set to true when inpoint is rendered
      this._isFirstFrame = false; //list of animated properties

      this.dynamicProperties = []; // If layer has been modified in current tick this will be true

      this._mdf = false;
    },

    /**
     * @function
     * Calculates all dynamic values
     *
     * @param {number} num
     * current frame number in Layer's time
     * @param {boolean} isVisible
     * if layers is currently in range
     *
     */
    prepareProperties: function prepareProperties(num, isVisible) {
      var i,
          len = this.dynamicProperties.length;

      for (i = 0; i < len; i += 1) {
        if (isVisible || this._isParent && this.dynamicProperties[i].propType === 'transform') {
          this.dynamicProperties[i].getValue();

          if (this.dynamicProperties[i]._mdf) {
            this.globalData._mdf = true;
            this._mdf = true;
          }
        }
      }
    },
    addDynamicProperty: function addDynamicProperty(prop) {
      if (this.dynamicProperties.indexOf(prop) === -1) {
        this.dynamicProperties.push(prop);
      }
    }
  };

  function TransformElement() {}

  TransformElement.prototype = {
    initTransform: function initTransform() {
      this.finalTransform = {
        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
          o: 0
        },
        _matMdf: false,
        _opMdf: false,
        mat: new Matrix()
      };

      if (this.data.ao) {
        this.finalTransform.mProp.autoOriented = true;
      } //TODO: check TYPE 11: Guided elements


      if (this.data.ty !== 11) {//this.createElements();
      }
    },
    renderTransform: function renderTransform() {
      this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
      this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;

      if (this.hierarchy) {
        var mat;
        var finalMat = this.finalTransform.mat;
        var i = 0,
            len = this.hierarchy.length; //Checking if any of the transformation matrices in the hierarchy chain has changed.

        if (!this.finalTransform._matMdf) {
          while (i < len) {
            if (this.hierarchy[i].finalTransform.mProp._mdf) {
              this.finalTransform._matMdf = true;
              break;
            }

            i += 1;
          }
        }

        if (this.finalTransform._matMdf) {
          mat = this.finalTransform.mProp.v.props;
          finalMat.cloneFromProps(mat);

          for (i = 0; i < len; i += 1) {
            mat = this.hierarchy[i].finalTransform.mProp.v.props;
            finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
          }
        }
      }
    },
    globalToLocal: function globalToLocal(pt) {
      var transforms = [];
      transforms.push(this.finalTransform);
      var flag = true;
      var comp = this.comp;

      while (flag) {
        if (comp.finalTransform) {
          if (comp.data.hasMask) {
            transforms.splice(0, 0, comp.finalTransform);
          }

          comp = comp.comp;
        } else {
          flag = false;
        }
      }

      var i,
          len = transforms.length,
          ptNew;

      for (i = 0; i < len; i += 1) {
        ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); //ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);

        pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
      }

      return pt;
    },
    mHelper: new Matrix()
  };

  function RenderableElement() {}

  RenderableElement.prototype = {
    initRenderable: function initRenderable() {
      //layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
      this.isInRange = false; //layer's display state

      this.hidden = false; // If layer's transparency equals 0, it can be hidden

      this.isTransparent = false; //list of animated components

      this.renderableComponents = [];
    },
    addRenderableComponent: function addRenderableComponent(component) {
      if (this.renderableComponents.indexOf(component) === -1) {
        this.renderableComponents.push(component);
      }
    },
    removeRenderableComponent: function removeRenderableComponent(component) {
      if (this.renderableComponents.indexOf(component) !== -1) {
        this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
      }
    },
    prepareRenderableFrame: function prepareRenderableFrame(num) {
      this.checkLayerLimits(num);
    },
    checkTransparency: function checkTransparency() {
      if (this.finalTransform.mProp.o.v <= 0) {
        if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
          this.isTransparent = true;
          this.hide();
        }
      } else if (this.isTransparent) {
        this.isTransparent = false;
        this.show();
      }
    },

    /**
     * @function
     * Initializes frame related properties.
     *
     * @param {number} num
     * current frame number in Layer's time
     *
     */
    checkLayerLimits: function checkLayerLimits(num) {
      if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
        if (this.isInRange !== true) {
          this.globalData._mdf = true;
          this._mdf = true;
          this.isInRange = true;
          this.show();
        }
      } else {
        if (this.isInRange !== false) {
          this.globalData._mdf = true;
          this.isInRange = false;
          this.hide();
        }
      }
    },
    renderRenderable: function renderRenderable() {
      var i,
          len = this.renderableComponents.length;

      for (i = 0; i < len; i += 1) {
        this.renderableComponents[i].renderFrame(this._isFirstFrame);
      }
      /*this.maskManager.renderFrame(this.finalTransform.mat);
      this.renderableEffectsManager.renderFrame(this._isFirstFrame);*/

    },
    sourceRectAtTime: function sourceRectAtTime() {
      return {
        top: 0,
        left: 0,
        width: 100,
        height: 100
      };
    },
    getLayerSize: function getLayerSize() {
      if (this.data.ty === 5) {
        return {
          w: this.data.textData.width,
          h: this.data.textData.height
        };
      } else {
        return {
          w: this.data.width,
          h: this.data.height
        };
      }
    }
  };

  function RenderableDOMElement() {}

  (function () {
    var _prototype = {
      initElement: function initElement(data, globalData, comp) {
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.initTransform(data, globalData, comp);
        this.initHierarchy();
        this.initRenderable();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        this.createContent();
        this.hide();
      },
      hide: function hide() {
        if (!this.hidden && (!this.isInRange || this.isTransparent)) {
          var elem = this.baseElement || this.layerElement;
          elem.style.display = 'none';
          this.hidden = true;
        }
      },
      show: function show() {
        if (this.isInRange && !this.isTransparent) {
          if (!this.data.hd) {
            var elem = this.baseElement || this.layerElement;
            elem.style.display = 'block';
          }

          this.hidden = false;
          this._isFirstFrame = true;
        }
      },
      renderFrame: function renderFrame() {
        //If it is exported as hidden (data.hd === true) no need to render
        //If it is not visible no need to render
        if (this.data.hd || this.hidden) {
          return;
        }

        this.renderTransform();
        this.renderRenderable();
        this.renderElement();
        this.renderInnerContent();

        if (this._isFirstFrame) {
          this._isFirstFrame = false;
        }
      },
      renderInnerContent: function renderInnerContent() {},
      prepareFrame: function prepareFrame(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
        this.checkTransparency();
      },
      destroy: function destroy() {
        this.innerElem = null;
        this.destroyBaseElement();
      }
    };
    extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
  })();

  function ProcessedElement(element, position) {
    this.elem = element;
    this.pos = position;
  }

  function SVGStyleData(data, level) {
    this.data = data;
    this.type = data.ty;
    this.d = '';
    this.lvl = level;
    this._mdf = false;
    this.closed = data.hd === true;
    this.pElem = createNS('path');
    this.msElem = null;
  }

  SVGStyleData.prototype.reset = function () {
    this.d = '';
    this._mdf = false;
  };

  function SVGShapeData(transformers, level, shape) {
    this.caches = [];
    this.styles = [];
    this.transformers = transformers;
    this.lStr = '';
    this.sh = shape;
    this.lvl = level; //TODO find if there are some cases where _isAnimated can be false.
    // For now, since shapes add up with other shapes. They have to be calculated every time.
    // One way of finding out is checking if all styles associated to this shape depend only of this shape

    this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated

    var i = 0,
        len = transformers.length;

    while (i < len) {
      if (transformers[i].mProps.dynamicProperties.length) {
        this._isAnimated = true;
        break;
      }

      i += 1;
    }
  }

  SVGShapeData.prototype.setAsAnimated = function () {
    this._isAnimated = true;
  };

  function SVGTransformData(mProps, op, container) {
    this.transform = {
      mProps: mProps,
      op: op,
      container: container
    };
    this.elements = [];
    this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
  }

  function SVGStrokeStyleData(elem, data, styleOb) {
    this.initDynamicPropertyContainer(elem);
    this.getValue = this.iterateDynamicProperties;
    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
    this.d = new DashProperty(elem, data.d || {}, 'svg', this);
    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
    this.style = styleOb;
    this._isAnimated = !!this._isAnimated;
  }

  extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

  function SVGFillStyleData(elem, data, styleOb) {
    this.initDynamicPropertyContainer(elem);
    this.getValue = this.iterateDynamicProperties;
    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
    this.style = styleOb;
  }

  extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

  function SVGGradientFillStyleData(elem, data, styleOb) {
    this.initDynamicPropertyContainer(elem);
    this.getValue = this.iterateDynamicProperties;
    this.initGradientData(elem, data, styleOb);
  }

  SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
    this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
    this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
    this.h = PropertyFactory.getProp(elem, data.h || {
      k: 0
    }, 0, 0.01, this);
    this.a = PropertyFactory.getProp(elem, data.a || {
      k: 0
    }, 0, degToRads, this);
    this.g = new GradientProperty(elem, data.g, this);
    this.style = styleOb;
    this.stops = [];
    this.setGradientData(styleOb.pElem, data);
    this.setGradientOpacity(data, styleOb);
    this._isAnimated = !!this._isAnimated;
  };

  SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
    var gradientId = createElementID();
    var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
    gfill.setAttribute('id', gradientId);
    gfill.setAttribute('spreadMethod', 'pad');
    gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
    var stops = [];
    var stop, j, jLen;
    jLen = data.g.p * 4;

    for (j = 0; j < jLen; j += 4) {
      stop = createNS('stop');
      gfill.appendChild(stop);
      stops.push(stop);
    }

    pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + gradientId + ')');
    this.gf = gfill;
    this.cst = stops;
  };

  SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
    if (this.g._hasOpacity && !this.g._collapsable) {
      var stop, j, jLen;
      var mask = createNS("mask");
      var maskElement = createNS('path');
      mask.appendChild(maskElement);
      var opacityId = createElementID();
      var maskId = createElementID();
      mask.setAttribute('id', maskId);
      var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
      opFill.setAttribute('id', opacityId);
      opFill.setAttribute('spreadMethod', 'pad');
      opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
      jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
      var stops = this.stops;

      for (j = data.g.p * 4; j < jLen; j += 2) {
        stop = createNS('stop');
        stop.setAttribute('stop-color', 'rgb(255,255,255)');
        opFill.appendChild(stop);
        stops.push(stop);
      }

      maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + opacityId + ')');
      this.of = opFill;
      this.ms = mask;
      this.ost = stops;
      this.maskId = maskId;
      styleOb.msElem = maskElement;
    }
  };

  extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

  function SVGGradientStrokeStyleData(elem, data, styleOb) {
    this.initDynamicPropertyContainer(elem);
    this.getValue = this.iterateDynamicProperties;
    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
    this.d = new DashProperty(elem, data.d || {}, 'svg', this);
    this.initGradientData(elem, data, styleOb);
    this._isAnimated = !!this._isAnimated;
  }

  extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

  function ShapeGroupData() {
    this.it = [];
    this.prevViewData = [];
    this.gr = createNS('g');
  }

  var SVGElementsRenderer = function () {
    var _identityMatrix = new Matrix();

    var _matrixHelper = new Matrix();

    var ob = {
      createRenderFunction: createRenderFunction
    };

    function createRenderFunction(data) {
      var ty = data.ty;

      switch (data.ty) {
        case 'fl':
          return renderFill;

        case 'gf':
          return renderGradient;

        case 'gs':
          return renderGradientStroke;

        case 'st':
          return renderStroke;

        case 'sh':
        case 'el':
        case 'rc':
        case 'sr':
          return renderPath;

        case 'tr':
          return renderContentTransform;
      }
    }

    function renderContentTransform(styleData, itemData, isFirstFrame) {
      if (isFirstFrame || itemData.transform.op._mdf) {
        itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
      }

      if (isFirstFrame || itemData.transform.mProps._mdf) {
        itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
      }
    }

    function renderPath(styleData, itemData, isFirstFrame) {
      var j,
          jLen,
          pathStringTransformed,
          redraw,
          pathNodes,
          l,
          lLen = itemData.styles.length;
      var lvl = itemData.lvl;
      var paths, mat, props, iterations, k;

      for (l = 0; l < lLen; l += 1) {
        redraw = itemData.sh._mdf || isFirstFrame;

        if (itemData.styles[l].lvl < lvl) {
          mat = _matrixHelper.reset();
          iterations = lvl - itemData.styles[l].lvl;
          k = itemData.transformers.length - 1;

          while (!redraw && iterations > 0) {
            redraw = itemData.transformers[k].mProps._mdf || redraw;
            iterations--;
            k--;
          }

          if (redraw) {
            iterations = lvl - itemData.styles[l].lvl;
            k = itemData.transformers.length - 1;

            while (iterations > 0) {
              props = itemData.transformers[k].mProps.v.props;
              mat.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
              iterations--;
              k--;
            }
          }
        } else {
          mat = _identityMatrix;
        }

        paths = itemData.sh.paths;
        jLen = paths._length;

        if (redraw) {
          pathStringTransformed = '';

          for (j = 0; j < jLen; j += 1) {
            pathNodes = paths.shapes[j];

            if (pathNodes && pathNodes._length) {
              pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
            }
          }

          itemData.caches[l] = pathStringTransformed;
        } else {
          pathStringTransformed = itemData.caches[l];
        }

        itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
      }
    }

    function renderFill(styleData, itemData, isFirstFrame) {
      var styleElem = itemData.style;

      if (itemData.c._mdf || isFirstFrame) {
        styleElem.pElem.setAttribute('fill', 'rgb(' + bm_floor(itemData.c.v[0]) + ',' + bm_floor(itemData.c.v[1]) + ',' + bm_floor(itemData.c.v[2]) + ')');
      }

      if (itemData.o._mdf || isFirstFrame) {
        styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
      }
    }

    ;

    function renderGradientStroke(styleData, itemData, isFirstFrame) {
      renderGradient(styleData, itemData, isFirstFrame);
      renderStroke(styleData, itemData, isFirstFrame);
    }

    function renderGradient(styleData, itemData, isFirstFrame) {
      var gfill = itemData.gf;
      var hasOpacity = itemData.g._hasOpacity;
      var pt1 = itemData.s.v,
          pt2 = itemData.e.v;

      if (itemData.o._mdf || isFirstFrame) {
        var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
        itemData.style.pElem.setAttribute(attr, itemData.o.v);
      }

      if (itemData.s._mdf || isFirstFrame) {
        var attr1 = styleData.t === 1 ? 'x1' : 'cx';
        var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
        gfill.setAttribute(attr1, pt1[0]);
        gfill.setAttribute(attr2, pt1[1]);

        if (hasOpacity && !itemData.g._collapsable) {
          itemData.of.setAttribute(attr1, pt1[0]);
          itemData.of.setAttribute(attr2, pt1[1]);
        }
      }

      var stops, i, len, stop;

      if (itemData.g._cmdf || isFirstFrame) {
        stops = itemData.cst;
        var cValues = itemData.g.c;
        len = stops.length;

        for (i = 0; i < len; i += 1) {
          stop = stops[i];
          stop.setAttribute('offset', cValues[i * 4] + '%');
          stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
        }
      }

      if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
        var oValues = itemData.g.o;

        if (itemData.g._collapsable) {
          stops = itemData.cst;
        } else {
          stops = itemData.ost;
        }

        len = stops.length;

        for (i = 0; i < len; i += 1) {
          stop = stops[i];

          if (!itemData.g._collapsable) {
            stop.setAttribute('offset', oValues[i * 2] + '%');
          }

          stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
        }
      }

      if (styleData.t === 1) {
        if (itemData.e._mdf || isFirstFrame) {
          gfill.setAttribute('x2', pt2[0]);
          gfill.setAttribute('y2', pt2[1]);

          if (hasOpacity && !itemData.g._collapsable) {
            itemData.of.setAttribute('x2', pt2[0]);
            itemData.of.setAttribute('y2', pt2[1]);
          }
        }
      } else {
        var rad;

        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
          rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
          gfill.setAttribute('r', rad);

          if (hasOpacity && !itemData.g._collapsable) {
            itemData.of.setAttribute('r', rad);
          }
        }

        if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
          if (!rad) {
            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
          }

          var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
          var percent = itemData.h.v >= 1 ? 0.99 : itemData.h.v <= -1 ? -0.99 : itemData.h.v;
          var dist = rad * percent;
          var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
          var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
          gfill.setAttribute('fx', x);
          gfill.setAttribute('fy', y);

          if (hasOpacity && !itemData.g._collapsable) {
            itemData.of.setAttribute('fx', x);
            itemData.of.setAttribute('fy', y);
          }
        } //gfill.setAttribute('fy','200');

      }
    }

    ;

    function renderStroke(styleData, itemData, isFirstFrame) {
      var styleElem = itemData.style;
      var d = itemData.d;

      if (d && (d._mdf || isFirstFrame) && d.dashStr) {
        styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
      }

      if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
        styleElem.pElem.setAttribute('stroke', 'rgb(' + bm_floor(itemData.c.v[0]) + ',' + bm_floor(itemData.c.v[1]) + ',' + bm_floor(itemData.c.v[2]) + ')');
      }

      if (itemData.o._mdf || isFirstFrame) {
        styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
      }

      if (itemData.w._mdf || isFirstFrame) {
        styleElem.pElem.setAttribute('stroke-width', itemData.w.v);

        if (styleElem.msElem) {
          styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
        }
      }
    }

    ;
    return ob;
  }();

  function ShapeTransformManager() {
    this.sequences = {};
    this.sequenceList = [];
    this.transform_key_count = 0;
  }

  ShapeTransformManager.prototype = {
    addTransformSequence: function addTransformSequence(transforms) {
      var i,
          len = transforms.length;
      var key = '_';

      for (i = 0; i < len; i += 1) {
        key += transforms[i].transform.key + '_';
      }

      var sequence = this.sequences[key];

      if (!sequence) {
        sequence = {
          transforms: [].concat(transforms),
          finalTransform: new Matrix(),
          _mdf: false
        };
        this.sequences[key] = sequence;
        this.sequenceList.push(sequence);
      }

      return sequence;
    },
    processSequence: function processSequence(sequence, isFirstFrame) {
      var i = 0,
          len = sequence.transforms.length,
          _mdf = isFirstFrame;

      while (i < len && !isFirstFrame) {
        if (sequence.transforms[i].transform.mProps._mdf) {
          _mdf = true;
          break;
        }

        i += 1;
      }

      if (_mdf) {
        var props;
        sequence.finalTransform.reset();

        for (i = len - 1; i >= 0; i -= 1) {
          props = sequence.transforms[i].transform.mProps.v.props;
          sequence.finalTransform.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
        }
      }

      sequence._mdf = _mdf;
    },
    processSequences: function processSequences(isFirstFrame) {
      var i,
          len = this.sequenceList.length;

      for (i = 0; i < len; i += 1) {
        this.processSequence(this.sequenceList[i], isFirstFrame);
      }
    },
    getNewKey: function getNewKey() {
      return '_' + this.transform_key_count++;
    }
  };

  function CVShapeData(element, data, styles, transformsManager) {
    this.styledShapes = [];
    this.tr = [0, 0, 0, 0, 0, 0];
    var ty = 4;

    if (data.ty == 'rc') {
      ty = 5;
    } else if (data.ty == 'el') {
      ty = 6;
    } else if (data.ty == 'sr') {
      ty = 7;
    }

    this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
    var i,
        len = styles.length,
        styledShape;

    for (i = 0; i < len; i += 1) {
      if (!styles[i].closed) {
        styledShape = {
          transforms: transformsManager.addTransformSequence(styles[i].transforms),
          trNodes: []
        };
        this.styledShapes.push(styledShape);
        styles[i].elements.push(styledShape);
      }
    }
  }

  CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

  function BaseElement() {}

  BaseElement.prototype = {
    checkMasks: function checkMasks() {
      if (!this.data.hasMask) {
        return false;
      }

      var i = 0,
          len = this.data.masksProperties.length;

      while (i < len) {
        if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {
          return true;
        }

        i += 1;
      }

      return false;
    },
    initExpressions: function initExpressions() {
      this.layerInterface = LayerExpressionInterface(this);

      if (this.data.hasMask && this.maskManager) {
        this.layerInterface.registerMaskInterface(this.maskManager);
      }

      var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
      this.layerInterface.registerEffectsInterface(effectsInterface);

      if (this.data.ty === 0 || this.data.xt) {
        this.compInterface = CompExpressionInterface(this);
      } else if (this.data.ty === 4) {
        this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
        this.layerInterface.content = this.layerInterface.shapeInterface;
      } else if (this.data.ty === 5) {
        this.layerInterface.textInterface = TextExpressionInterface(this);
        this.layerInterface.text = this.layerInterface.textInterface;
      }
    },
    setBlendMode: function setBlendMode() {
      var blendModeValue = getBlendMode(this.data.bm);
      var elem = this.baseElement || this.layerElement;
      elem.style['mix-blend-mode'] = blendModeValue;
    },
    initBaseData: function initBaseData(data, globalData, comp) {
      this.globalData = globalData;
      this.comp = comp;
      this.data = data;
      this.layerId = createElementID(); //Stretch factor for old animations missing this property.

      if (!this.data.sr) {
        this.data.sr = 1;
      } // effects manager


      this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
    },
    getType: function getType() {
      return this.type;
    },
    sourceRectAtTime: function sourceRectAtTime() {}
  };

  function NullElement(data, globalData, comp) {
    this.initFrame();
    this.initBaseData(data, globalData, comp);
    this.initFrame();
    this.initTransform(data, globalData, comp);
    this.initHierarchy();
  }

  NullElement.prototype.prepareFrame = function (num) {
    this.prepareProperties(num, true);
  };

  NullElement.prototype.renderFrame = function () {};

  NullElement.prototype.getBaseElement = function () {
    return null;
  };

  NullElement.prototype.destroy = function () {};

  NullElement.prototype.sourceRectAtTime = function () {};

  NullElement.prototype.hide = function () {};

  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

  function SVGBaseElement() {}

  SVGBaseElement.prototype = {
    initRendererElement: function initRendererElement() {
      this.layerElement = createNS('g');
    },
    createContainerElements: function createContainerElements() {
      this.matteElement = createNS('g');
      this.transformedElement = this.layerElement;
      this.maskedElement = this.layerElement;
      this._sizeChanged = false;
      var layerElementParent = null; //If this layer acts as a mask for the following layer

      var filId, fil, gg;

      if (this.data.td) {
        if (this.data.td == 3 || this.data.td == 1) {
          var masker = createNS('mask');
          masker.setAttribute('id', this.layerId);
          masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha');
          masker.appendChild(this.layerElement);
          layerElementParent = masker;
          this.globalData.defs.appendChild(masker); // This is only for IE and Edge when mask if of type alpha

          if (!featureSupport.maskType && this.data.td == 1) {
            masker.setAttribute('mask-type', 'luminance');
            filId = createElementID();
            fil = filtersFactory.createFilter(filId);
            this.globalData.defs.appendChild(fil);
            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
            gg = createNS('g');
            gg.appendChild(this.layerElement);
            layerElementParent = gg;
            masker.appendChild(gg);
            gg.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
          }
        } else if (this.data.td == 2) {
          var maskGroup = createNS('mask');
          maskGroup.setAttribute('id', this.layerId);
          maskGroup.setAttribute('mask-type', 'alpha');
          var maskGrouper = createNS('g');
          maskGroup.appendChild(maskGrouper);
          filId = createElementID();
          fil = filtersFactory.createFilter(filId); ////
          // This solution doesn't work on Android when meta tag with viewport attribute is set

          /*var feColorMatrix = createNS('feColorMatrix');
          feColorMatrix.setAttribute('type', 'matrix');
          feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
          feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
          fil.appendChild(feColorMatrix);*/
          ////

          var feCTr = createNS('feComponentTransfer');
          feCTr.setAttribute('in', 'SourceGraphic');
          fil.appendChild(feCTr);
          var feFunc = createNS('feFuncA');
          feFunc.setAttribute('type', 'table');
          feFunc.setAttribute('tableValues', '1.0 0.0');
          feCTr.appendChild(feFunc); ////

          this.globalData.defs.appendChild(fil);
          var alphaRect = createNS('rect');
          alphaRect.setAttribute('width', this.comp.data.w);
          alphaRect.setAttribute('height', this.comp.data.h);
          alphaRect.setAttribute('x', '0');
          alphaRect.setAttribute('y', '0');
          alphaRect.setAttribute('fill', '#ffffff');
          alphaRect.setAttribute('opacity', '0');
          maskGrouper.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
          maskGrouper.appendChild(alphaRect);
          maskGrouper.appendChild(this.layerElement);
          layerElementParent = maskGrouper;

          if (!featureSupport.maskType) {
            maskGroup.setAttribute('mask-type', 'luminance');
            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
            gg = createNS('g');
            maskGrouper.appendChild(alphaRect);
            gg.appendChild(this.layerElement);
            layerElementParent = gg;
            maskGrouper.appendChild(gg);
          }

          this.globalData.defs.appendChild(maskGroup);
        }
      } else if (this.data.tt) {
        this.matteElement.appendChild(this.layerElement);
        layerElementParent = this.matteElement;
        this.baseElement = this.matteElement;
      } else {
        this.baseElement = this.layerElement;
      }

      if (this.data.ln) {
        this.layerElement.setAttribute('id', this.data.ln);
      }

      if (this.data.cl) {
        this.layerElement.setAttribute('class', this.data.cl);
      } //Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped


      if (this.data.ty === 0 && !this.data.hd) {
        var cp = createNS('clipPath');
        var pt = createNS('path');
        pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0' + ' L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
        var clipId = createElementID();
        cp.setAttribute('id', clipId);
        cp.appendChild(pt);
        this.globalData.defs.appendChild(cp);

        if (this.checkMasks()) {
          var cpGroup = createNS('g');
          cpGroup.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
          cpGroup.appendChild(this.layerElement);
          this.transformedElement = cpGroup;

          if (layerElementParent) {
            layerElementParent.appendChild(this.transformedElement);
          } else {
            this.baseElement = this.transformedElement;
          }
        } else {
          this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
        }
      }

      if (this.data.bm !== 0) {
        this.setBlendMode();
      }
    },
    renderElement: function renderElement() {
      if (this.finalTransform._matMdf) {
        this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS());
      }

      if (this.finalTransform._opMdf) {
        this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v);
      }
    },
    destroyBaseElement: function destroyBaseElement() {
      this.layerElement = null;
      this.matteElement = null;
      this.maskManager.destroy();
    },
    getBaseElement: function getBaseElement() {
      if (this.data.hd) {
        return null;
      }

      return this.baseElement;
    },
    createRenderableComponents: function createRenderableComponents() {
      this.maskManager = new MaskElement(this.data, this, this.globalData);
      this.renderableEffectsManager = new SVGEffects(this);
    },
    setMatte: function setMatte(id) {
      if (!this.matteElement) {
        return;
      }

      this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + id + ")");
    }
  };

  function IShapeElement() {}

  IShapeElement.prototype = {
    addShapeToModifiers: function addShapeToModifiers(data) {
      var i,
          len = this.shapeModifiers.length;

      for (i = 0; i < len; i += 1) {
        this.shapeModifiers[i].addShape(data);
      }
    },
    isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {
      var i = 0,
          len = this.shapeModifiers.length;

      while (i < len) {
        if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
          return true;
        }
      }

      return false;
    },
    renderModifiers: function renderModifiers() {
      if (!this.shapeModifiers.length) {
        return;
      }

      var i,
          len = this.shapes.length;

      for (i = 0; i < len; i += 1) {
        this.shapes[i].sh.reset();
      }

      len = this.shapeModifiers.length;

      for (i = len - 1; i >= 0; i -= 1) {
        this.shapeModifiers[i].processShapes(this._isFirstFrame);
      }
    },
    lcEnum: {
      '1': 'butt',
      '2': 'round',
      '3': 'square'
    },
    ljEnum: {
      '1': 'miter',
      '2': 'round',
      '3': 'bevel'
    },
    searchProcessedElement: function searchProcessedElement(elem) {
      var elements = this.processedElements;
      var i = 0,
          len = elements.length;

      while (i < len) {
        if (elements[i].elem === elem) {
          return elements[i].pos;
        }

        i += 1;
      }

      return 0;
    },
    addProcessedElement: function addProcessedElement(elem, pos) {
      var elements = this.processedElements;
      var i = elements.length;

      while (i) {
        i -= 1;

        if (elements[i].elem === elem) {
          elements[i].pos = pos;
          return;
        }
      }

      elements.push(new ProcessedElement(elem, pos));
    },
    prepareFrame: function prepareFrame(num) {
      this.prepareRenderableFrame(num);
      this.prepareProperties(num, this.isInRange);
    }
  };

  function ITextElement() {}

  ITextElement.prototype.initElement = function (data, globalData, comp) {
    this.lettersChangedFlag = true;
    this.initFrame();
    this.initBaseData(data, globalData, comp);
    this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
    this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
    this.initTransform(data, globalData, comp);
    this.initHierarchy();
    this.initRenderable();
    this.initRendererElement();
    this.createContainerElements();
    this.createRenderableComponents();
    this.createContent();
    this.hide();
    this.textAnimator.searchProperties(this.dynamicProperties);
  };

  ITextElement.prototype.prepareFrame = function (num) {
    this._mdf = false;
    this.prepareRenderableFrame(num);
    this.prepareProperties(num, this.isInRange);

    if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
      this.buildNewText();
      this.textProperty._isFirstFrame = false;
      this.textProperty._mdf = false;
    }
  };

  ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
    var j,
        jLen = shapes.length;
    var k, kLen, pathNodes;
    var shapeStr = '';

    for (j = 0; j < jLen; j += 1) {
      pathNodes = shapes[j].ks.k;
      shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
    }

    return shapeStr;
  };

  ITextElement.prototype.updateDocumentData = function (newData, index) {
    this.textProperty.updateDocumentData(newData, index);
  };

  ITextElement.prototype.canResizeFont = function (_canResize) {
    this.textProperty.canResizeFont(_canResize);
  };

  ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
    this.textProperty.setMinimumFontSize(_fontSize);
  };

  ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
    if (documentData.ps) {
      matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
    }

    matrixHelper.translate(0, -documentData.ls, 0);

    switch (documentData.j) {
      case 1:
        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
        break;

      case 2:
        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
        break;
    }

    matrixHelper.translate(xPos, yPos, 0);
  };

  ITextElement.prototype.buildColor = function (colorData) {
    return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
  };

  ITextElement.prototype.emptyProp = new LetterProps();

  ITextElement.prototype.destroy = function () {};

  function ICompElement() {}

  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);

  ICompElement.prototype.initElement = function (data, globalData, comp) {
    this.initFrame();
    this.initBaseData(data, globalData, comp);
    this.initTransform(data, globalData, comp);
    this.initRenderable();
    this.initHierarchy();
    this.initRendererElement();
    this.createContainerElements();
    this.createRenderableComponents();

    if (this.data.xt || !globalData.progressiveLoad) {
      this.buildAllItems();
    }

    this.hide();
  };
  /*ICompElement.prototype.hide = function(){
      if(!this.hidden){
          this.hideElement();
          var i,len = this.elements.length;
          for( i = 0; i < len; i+=1 ){
              if(this.elements[i]){
                  this.elements[i].hide();
              }
          }
      }
  };*/


  ICompElement.prototype.prepareFrame = function (num) {
    this._mdf = false;
    this.prepareRenderableFrame(num);
    this.prepareProperties(num, this.isInRange);

    if (!this.isInRange && !this.data.xt) {
      return;
    }

    if (!this.tm._placeholder) {
      var timeRemapped = this.tm.v;

      if (timeRemapped === this.data.op) {
        timeRemapped = this.data.op - 1;
      }

      this.renderedFrame = timeRemapped;
    } else {
      this.renderedFrame = num / this.data.sr;
    }

    var i,
        len = this.elements.length;

    if (!this.completeLayers) {
      this.checkLayers(this.renderedFrame);
    } //This iteration needs to be backwards because of how expressions connect between each other


    for (i = len - 1; i >= 0; i -= 1) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);

        if (this.elements[i]._mdf) {
          this._mdf = true;
        }
      }
    }
  };

  ICompElement.prototype.renderInnerContent = function () {
    var i,
        len = this.layers.length;

    for (i = 0; i < len; i += 1) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].renderFrame();
      }
    }
  };

  ICompElement.prototype.setElements = function (elems) {
    this.elements = elems;
  };

  ICompElement.prototype.getElements = function () {
    return this.elements;
  };

  ICompElement.prototype.destroyElements = function () {
    var i,
        len = this.layers.length;

    for (i = 0; i < len; i += 1) {
      if (this.elements[i]) {
        this.elements[i].destroy();
      }
    }
  };

  ICompElement.prototype.destroy = function () {
    this.destroyElements();
    this.destroyBaseElement();
  };

  function IImageElement(data, globalData, comp) {
    this.assetData = globalData.getAssetData(data.refId);
    this.initElement(data, globalData, comp);
    this.sourceRect = {
      top: 0,
      left: 0,
      width: this.assetData.w,
      height: this.assetData.h
    };
  }

  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);

  IImageElement.prototype.createContent = function () {
    var assetPath = this.globalData.getAssetsPath(this.assetData);
    this.innerElem = createNS('image');
    this.innerElem.setAttribute('width', this.assetData.w + "px");
    this.innerElem.setAttribute('height', this.assetData.h + "px");
    this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
    this.layerElement.appendChild(this.innerElem);
  };

  IImageElement.prototype.sourceRectAtTime = function () {
    return this.sourceRect;
  };

  function ISolidElement(data, globalData, comp) {
    this.initElement(data, globalData, comp);
  }

  extendPrototype([IImageElement], ISolidElement);

  ISolidElement.prototype.createContent = function () {
    var rect = createNS('rect'); ////rect.style.width = this.data.sw;
    ////rect.style.height = this.data.sh;
    ////rect.style.fill = this.data.sc;

    rect.setAttribute('width', this.data.sw);
    rect.setAttribute('height', this.data.sh);
    rect.setAttribute('fill', this.data.sc);
    this.layerElement.appendChild(rect);
  };

  function SVGCompElement(data, globalData, comp) {
    this.layers = data.layers;
    this.supports3d = true;
    this.completeLayers = false;
    this.pendingElements = [];
    this.elements = this.layers ? createSizedArray(this.layers.length) : []; //this.layerElement = createNS('g');

    this.initElement(data, globalData, comp);
    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
      _placeholder: true
    };
  }

  extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);

  function SVGTextElement(data, globalData, comp) {
    this.textSpans = [];
    this.renderType = 'svg';
    this.initElement(data, globalData, comp);
  }

  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextElement);

  SVGTextElement.prototype.createContent = function () {
    if (this.data.singleShape && !this.globalData.fontManager.chars) {
      this.textContainer = createNS('text');
    }
  };

  SVGTextElement.prototype.buildTextContents = function (textArray) {
    var i = 0,
        len = textArray.length;
    var textContents = [],
        currentTextContent = '';

    while (i < len) {
      if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
        textContents.push(currentTextContent);
        currentTextContent = '';
      } else {
        currentTextContent += textArray[i];
      }

      i += 1;
    }

    textContents.push(currentTextContent);
    return textContents;
  };

  SVGTextElement.prototype.buildNewText = function () {
    var i, len;
    var documentData = this.textProperty.currentData;
    this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);

    if (documentData.fc) {
      this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
    } else {
      this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
    }

    if (documentData.sc) {
      this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
      this.layerElement.setAttribute('stroke-width', documentData.sw);
    }

    this.layerElement.setAttribute('font-size', documentData.finalSize);
    var fontData = this.globalData.fontManager.getFontByName(documentData.f);

    if (fontData.fClass) {
      this.layerElement.setAttribute('class', fontData.fClass);
    } else {
      this.layerElement.setAttribute('font-family', fontData.fFamily);
      var fWeight = documentData.fWeight,
          fStyle = documentData.fStyle;
      this.layerElement.setAttribute('font-style', fStyle);
      this.layerElement.setAttribute('font-weight', fWeight);
    }

    this.layerElement.setAttribute('arial-label', documentData.t);
    var letters = documentData.l || [];
    var usesGlyphs = !!this.globalData.fontManager.chars;
    len = letters.length;
    var tSpan;
    var matrixHelper = this.mHelper;
    var shapes,
        shapeStr = '',
        singleShape = this.data.singleShape;
    var xPos = 0,
        yPos = 0,
        firstLine = true;
    var trackingOffset = documentData.tr / 1000 * documentData.finalSize;

    if (singleShape && !usesGlyphs && !documentData.sz) {
      var tElement = this.textContainer;
      var justify = 'start';

      switch (documentData.j) {
        case 1:
          justify = 'end';
          break;

        case 2:
          justify = 'middle';
          break;
      }

      tElement.setAttribute('text-anchor', justify);
      tElement.setAttribute('letter-spacing', trackingOffset);
      var textContent = this.buildTextContents(documentData.finalText);
      len = textContent.length;
      yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;

      for (i = 0; i < len; i += 1) {
        tSpan = this.textSpans[i] || createNS('tspan');
        tSpan.textContent = textContent[i];
        tSpan.setAttribute('x', 0);
        tSpan.setAttribute('y', yPos);
        tSpan.style.display = 'inherit';
        tElement.appendChild(tSpan);
        this.textSpans[i] = tSpan;
        yPos += documentData.finalLineHeight;
      }

      this.layerElement.appendChild(tElement);
    } else {
      var cachedSpansLength = this.textSpans.length;
      var shapeData, charData;

      for (i = 0; i < len; i += 1) {
        if (!usesGlyphs || !singleShape || i === 0) {
          tSpan = cachedSpansLength > i ? this.textSpans[i] : createNS(usesGlyphs ? 'path' : 'text');

          if (cachedSpansLength <= i) {
            tSpan.setAttribute('stroke-linecap', 'butt');
            tSpan.setAttribute('stroke-linejoin', 'round');
            tSpan.setAttribute('stroke-miterlimit', '4');
            this.textSpans[i] = tSpan;
            this.layerElement.appendChild(tSpan);
          }

          tSpan.style.display = 'inherit';
        }

        matrixHelper.reset();
        matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);

        if (singleShape) {
          if (letters[i].n) {
            xPos = -trackingOffset;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            firstLine = false;
          }

          this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
          xPos += letters[i].l || 0; //xPos += letters[i].val === ' ' ? 0 : trackingOffset;

          xPos += trackingOffset;
        }

        if (usesGlyphs) {
          charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
          shapeData = charData && charData.data || {};
          shapes = shapeData.shapes ? shapeData.shapes[0].it : [];

          if (!singleShape) {
            tSpan.setAttribute('d', this.createPathShape(matrixHelper, shapes));
          } else {
            shapeStr += this.createPathShape(matrixHelper, shapes);
          }
        } else {
          if (singleShape) {
            tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
          }

          tSpan.textContent = letters[i].val;
          tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        } //

      }

      if (singleShape && tSpan) {
        tSpan.setAttribute('d', shapeStr);
      }
    }

    while (i < this.textSpans.length) {
      this.textSpans[i].style.display = 'none';
      i += 1;
    }

    this._sizeChanged = true;
  };

  SVGTextElement.prototype.sourceRectAtTime = function (time) {
    this.prepareFrame(this.comp.renderedFrame - this.data.st);
    this.renderInnerContent();

    if (this._sizeChanged) {
      this._sizeChanged = false;
      var textBox = this.layerElement.getBBox();
      this.bbox = {
        top: textBox.y,
        left: textBox.x,
        width: textBox.width,
        height: textBox.height
      };
    }

    return this.bbox;
  };

  SVGTextElement.prototype.renderInnerContent = function () {
    if (!this.data.singleShape) {
      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);

      if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
        this._sizeChanged = true;
        var i, len;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter, textSpan;

        for (i = 0; i < len; i += 1) {
          if (letters[i].n) {
            continue;
          }

          renderedLetter = renderedLetters[i];
          textSpan = this.textSpans[i];

          if (renderedLetter._mdf.m) {
            textSpan.setAttribute('transform', renderedLetter.m);
          }

          if (renderedLetter._mdf.o) {
            textSpan.setAttribute('opacity', renderedLetter.o);
          }

          if (renderedLetter._mdf.sw) {
            textSpan.setAttribute('stroke-width', renderedLetter.sw);
          }

          if (renderedLetter._mdf.sc) {
            textSpan.setAttribute('stroke', renderedLetter.sc);
          }

          if (renderedLetter._mdf.fc) {
            textSpan.setAttribute('fill', renderedLetter.fc);
          }
        }
      }
    }
  };

  function SVGShapeElement(data, globalData, comp) {
    //List of drawable elements
    this.shapes = []; // Full shape data

    this.shapesData = data.shapes; //List of styles that will be applied to shapes

    this.stylesList = []; //List of modifiers that will be applied to shapes

    this.shapeModifiers = []; //List of items in shape tree

    this.itemsData = []; //List of items in previous shape tree

    this.processedElements = []; // List of animated components

    this.animatedContents = [];
    this.initElement(data, globalData, comp); //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
    // List of elements that have been created

    this.prevViewData = []; //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
  }

  extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);

  SVGShapeElement.prototype.initSecondaryElement = function () {};

  SVGShapeElement.prototype.identityMatrix = new Matrix();

  SVGShapeElement.prototype.buildExpressionInterface = function () {};

  SVGShapeElement.prototype.createContent = function () {
    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
    this.filterUniqueShapes();
  };
  /*
  This method searches for multiple shapes that affect a single element and one of them is animated
  */


  SVGShapeElement.prototype.filterUniqueShapes = function () {
    var i,
        len = this.shapes.length,
        shape;
    var j,
        jLen = this.stylesList.length;
    var style,
        count = 0;
    var tempShapes = [];
    var areAnimated = false;

    for (j = 0; j < jLen; j += 1) {
      style = this.stylesList[j];
      areAnimated = false;
      tempShapes.length = 0;

      for (i = 0; i < len; i += 1) {
        shape = this.shapes[i];

        if (shape.styles.indexOf(style) !== -1) {
          tempShapes.push(shape);
          areAnimated = shape._isAnimated || areAnimated;
        }
      }

      if (tempShapes.length > 1 && areAnimated) {
        this.setShapesAsAnimated(tempShapes);
      }
    }
  };

  SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
    var i,
        len = shapes.length;

    for (i = 0; i < len; i += 1) {
      shapes[i].setAsAnimated();
    }
  };

  SVGShapeElement.prototype.createStyleElement = function (data, level) {
    //TODO: prevent drawing of hidden styles
    var elementData;
    var styleOb = new SVGStyleData(data, level);
    var pathElement = styleOb.pElem;

    if (data.ty === 'st') {
      elementData = new SVGStrokeStyleData(this, data, styleOb);
    } else if (data.ty === 'fl') {
      elementData = new SVGFillStyleData(this, data, styleOb);
    } else if (data.ty === 'gf' || data.ty === 'gs') {
      var gradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
      elementData = new gradientConstructor(this, data, styleOb);
      this.globalData.defs.appendChild(elementData.gf);

      if (elementData.maskId) {
        this.globalData.defs.appendChild(elementData.ms);
        this.globalData.defs.appendChild(elementData.of);
        pathElement.setAttribute('mask', 'url(' + locationHref + '#' + elementData.maskId + ')');
      }
    }

    if (data.ty === 'st' || data.ty === 'gs') {
      pathElement.setAttribute('stroke-linecap', this.lcEnum[data.lc] || 'round');
      pathElement.setAttribute('stroke-linejoin', this.ljEnum[data.lj] || 'round');
      pathElement.setAttribute('fill-opacity', '0');

      if (data.lj === 1) {
        pathElement.setAttribute('stroke-miterlimit', data.ml);
      }
    }

    if (data.r === 2) {
      pathElement.setAttribute('fill-rule', 'evenodd');
    }

    if (data.ln) {
      pathElement.setAttribute('id', data.ln);
    }

    if (data.cl) {
      pathElement.setAttribute('class', data.cl);
    }

    if (data.bm) {
      pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
    }

    this.stylesList.push(styleOb);
    this.addToAnimatedContents(data, elementData);
    return elementData;
  };

  SVGShapeElement.prototype.createGroupElement = function (data) {
    var elementData = new ShapeGroupData();

    if (data.ln) {
      elementData.gr.setAttribute('id', data.ln);
    }

    if (data.cl) {
      elementData.gr.setAttribute('class', data.cl);
    }

    if (data.bm) {
      elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
    }

    return elementData;
  };

  SVGShapeElement.prototype.createTransformElement = function (data, container) {
    var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
    var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
    this.addToAnimatedContents(data, elementData);
    return elementData;
  };

  SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
    var ty = 4;

    if (data.ty === 'rc') {
      ty = 5;
    } else if (data.ty === 'el') {
      ty = 6;
    } else if (data.ty === 'sr') {
      ty = 7;
    }

    var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
    var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
    this.shapes.push(elementData);
    this.addShapeToModifiers(elementData);
    this.addToAnimatedContents(data, elementData);
    return elementData;
  };

  SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
    var i = 0,
        len = this.animatedContents.length;

    while (i < len) {
      if (this.animatedContents[i].element === element) {
        return;
      }

      i += 1;
    }

    this.animatedContents.push({
      fn: SVGElementsRenderer.createRenderFunction(data),
      element: element,
      data: data
    });
  };

  SVGShapeElement.prototype.setElementStyles = function (elementData) {
    var arr = elementData.styles;
    var j,
        jLen = this.stylesList.length;

    for (j = 0; j < jLen; j += 1) {
      if (!this.stylesList[j].closed) {
        arr.push(this.stylesList[j]);
      }
    }
  };

  SVGShapeElement.prototype.reloadShapes = function () {
    this._isFirstFrame = true;
    var i,
        len = this.itemsData.length;

    for (i = 0; i < len; i += 1) {
      this.prevViewData[i] = this.itemsData[i];
    }

    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
    this.filterUniqueShapes();
    len = this.dynamicProperties.length;

    for (i = 0; i < len; i += 1) {
      this.dynamicProperties[i].getValue();
    }

    this.renderModifiers();
  };

  SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
    var ownTransformers = [].concat(transformers);
    var i,
        len = arr.length - 1;
    var j, jLen;
    var ownStyles = [],
        ownModifiers = [],
        styleOb,
        currentTransform,
        modifier,
        processedPos;

    for (i = len; i >= 0; i -= 1) {
      processedPos = this.searchProcessedElement(arr[i]);

      if (!processedPos) {
        arr[i]._render = render;
      } else {
        itemsData[i] = prevViewData[processedPos - 1];
      }

      if (arr[i].ty == 'fl' || arr[i].ty == 'st' || arr[i].ty == 'gf' || arr[i].ty == 'gs') {
        if (!processedPos) {
          itemsData[i] = this.createStyleElement(arr[i], level);
        } else {
          itemsData[i].style.closed = false;
        }

        if (arr[i]._render) {
          container.appendChild(itemsData[i].style.pElem);
        }

        ownStyles.push(itemsData[i].style);
      } else if (arr[i].ty == 'gr') {
        if (!processedPos) {
          itemsData[i] = this.createGroupElement(arr[i]);
        } else {
          jLen = itemsData[i].it.length;

          for (j = 0; j < jLen; j += 1) {
            itemsData[i].prevViewData[j] = itemsData[i].it[j];
          }
        }

        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);

        if (arr[i]._render) {
          container.appendChild(itemsData[i].gr);
        }
      } else if (arr[i].ty == 'tr') {
        if (!processedPos) {
          itemsData[i] = this.createTransformElement(arr[i], container);
        }

        currentTransform = itemsData[i].transform;
        ownTransformers.push(currentTransform);
      } else if (arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr') {
        if (!processedPos) {
          itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
        }

        this.setElementStyles(itemsData[i]);
      } else if (arr[i].ty == 'tm' || arr[i].ty == 'rd' || arr[i].ty == 'ms') {
        if (!processedPos) {
          modifier = ShapeModifiers.getModifier(arr[i].ty);
          modifier.init(this, arr[i]);
          itemsData[i] = modifier;
          this.shapeModifiers.push(modifier);
        } else {
          modifier = itemsData[i];
          modifier.closed = false;
        }

        ownModifiers.push(modifier);
      } else if (arr[i].ty == 'rp') {
        if (!processedPos) {
          modifier = ShapeModifiers.getModifier(arr[i].ty);
          itemsData[i] = modifier;
          modifier.init(this, arr, i, itemsData);
          this.shapeModifiers.push(modifier);
          render = false;
        } else {
          modifier = itemsData[i];
          modifier.closed = true;
        }

        ownModifiers.push(modifier);
      }

      this.addProcessedElement(arr[i], i + 1);
    }

    len = ownStyles.length;

    for (i = 0; i < len; i += 1) {
      ownStyles[i].closed = true;
    }

    len = ownModifiers.length;

    for (i = 0; i < len; i += 1) {
      ownModifiers[i].closed = true;
    }
  };

  SVGShapeElement.prototype.renderInnerContent = function () {
    this.renderModifiers();
    var i,
        len = this.stylesList.length;

    for (i = 0; i < len; i += 1) {
      this.stylesList[i].reset();
    }

    this.renderShape();

    for (i = 0; i < len; i += 1) {
      if (this.stylesList[i]._mdf || this._isFirstFrame) {
        if (this.stylesList[i].msElem) {
          this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d); //Adding M0 0 fixes same mask bug on all browsers

          this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
        }

        this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
      }
    }
  };

  SVGShapeElement.prototype.renderShape = function () {
    var i,
        len = this.animatedContents.length;
    var animatedContent;

    for (i = 0; i < len; i += 1) {
      animatedContent = this.animatedContents[i];

      if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
        animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
      }
    }
  };

  SVGShapeElement.prototype.destroy = function () {
    this.destroyBaseElement();
    this.shapesData = null;
    this.itemsData = null;
  };

  function SVGTintFilter(filter, filterManager) {
    this.filterManager = filterManager;
    var feColorMatrix = createNS('feColorMatrix');
    feColorMatrix.setAttribute('type', 'matrix');
    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
    feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
    feColorMatrix.setAttribute('result', 'f1');
    filter.appendChild(feColorMatrix);
    feColorMatrix = createNS('feColorMatrix');
    feColorMatrix.setAttribute('type', 'matrix');
    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
    feColorMatrix.setAttribute('result', 'f2');
    filter.appendChild(feColorMatrix);
    this.matrixFilter = feColorMatrix;

    if (filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k) {
      var feMerge = createNS('feMerge');
      filter.appendChild(feMerge);
      var feMergeNode;
      feMergeNode = createNS('feMergeNode');
      feMergeNode.setAttribute('in', 'SourceGraphic');
      feMerge.appendChild(feMergeNode);
      feMergeNode = createNS('feMergeNode');
      feMergeNode.setAttribute('in', 'f2');
      feMerge.appendChild(feMergeNode);
    }
  }

  SVGTintFilter.prototype.renderFrame = function (forceRender) {
    if (forceRender || this.filterManager._mdf) {
      var colorBlack = this.filterManager.effectElements[0].p.v;
      var colorWhite = this.filterManager.effectElements[1].p.v;
      var opacity = this.filterManager.effectElements[2].p.v / 100;
      this.matrixFilter.setAttribute('values', colorWhite[0] - colorBlack[0] + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 ' + opacity + ' 0');
    }
  };

  function SVGFillFilter(filter, filterManager) {
    this.filterManager = filterManager;
    var feColorMatrix = createNS('feColorMatrix');
    feColorMatrix.setAttribute('type', 'matrix');
    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
    filter.appendChild(feColorMatrix);
    this.matrixFilter = feColorMatrix;
  }

  SVGFillFilter.prototype.renderFrame = function (forceRender) {
    if (forceRender || this.filterManager._mdf) {
      var color = this.filterManager.effectElements[2].p.v;
      var opacity = this.filterManager.effectElements[6].p.v;
      this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
    }
  };

  function SVGStrokeEffect(elem, filterManager) {
    this.initialized = false;
    this.filterManager = filterManager;
    this.elem = elem;
    this.paths = [];
  }

  SVGStrokeEffect.prototype.initialize = function () {
    var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
    var path, groupPath, i, len;

    if (this.filterManager.effectElements[1].p.v === 1) {
      len = this.elem.maskManager.masksProperties.length;
      i = 0;
    } else {
      i = this.filterManager.effectElements[0].p.v - 1;
      len = i + 1;
    }

    groupPath = createNS('g');
    groupPath.setAttribute('fill', 'none');
    groupPath.setAttribute('stroke-linecap', 'round');
    groupPath.setAttribute('stroke-dashoffset', 1);

    for (i; i < len; i += 1) {
      path = createNS('path');
      groupPath.appendChild(path);
      this.paths.push({
        p: path,
        m: i
      });
    }

    if (this.filterManager.effectElements[10].p.v === 3) {
      var mask = createNS('mask');
      var id = createElementID();
      mask.setAttribute('id', id);
      mask.setAttribute('mask-type', 'alpha');
      mask.appendChild(groupPath);
      this.elem.globalData.defs.appendChild(mask);
      var g = createNS('g');
      g.setAttribute('mask', 'url(' + locationHref + '#' + id + ')');

      while (elemChildren[0]) {
        g.appendChild(elemChildren[0]);
      }

      this.elem.layerElement.appendChild(g);
      this.masker = mask;
      groupPath.setAttribute('stroke', '#fff');
    } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
      if (this.filterManager.effectElements[10].p.v === 2) {
        elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;

        while (elemChildren.length) {
          this.elem.layerElement.removeChild(elemChildren[0]);
        }
      }

      this.elem.layerElement.appendChild(groupPath);
      this.elem.layerElement.removeAttribute('mask');
      groupPath.setAttribute('stroke', '#fff');
    }

    this.initialized = true;
    this.pathMasker = groupPath;
  };

  SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
    if (!this.initialized) {
      this.initialize();
    }

    var i,
        len = this.paths.length;
    var mask, path;

    for (i = 0; i < len; i += 1) {
      if (this.paths[i].m === -1) {
        continue;
      }

      mask = this.elem.maskManager.viewData[this.paths[i].m];
      path = this.paths[i].p;

      if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
        path.setAttribute('d', mask.lastPath);
      }

      if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
        var dasharrayValue;

        if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
          var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) / 100;
          var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) / 100;
          var l = path.getTotalLength();
          dasharrayValue = '0 0 0 ' + l * s + ' ';
          var lineLength = l * (e - s);
          var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v / 100;
          var units = Math.floor(lineLength / segment);
          var j;

          for (j = 0; j < units; j += 1) {
            dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v / 100 + ' ';
          }

          dasharrayValue += '0 ' + l * 10 + ' 0 0';
        } else {
          dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v / 100;
        }

        path.setAttribute('stroke-dasharray', dasharrayValue);
      }
    }

    if (forceRender || this.filterManager.effectElements[4].p._mdf) {
      this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
    }

    if (forceRender || this.filterManager.effectElements[6].p._mdf) {
      this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
    }

    if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
      if (forceRender || this.filterManager.effectElements[3].p._mdf) {
        var color = this.filterManager.effectElements[3].p.v;
        this.pathMasker.setAttribute('stroke', 'rgb(' + bm_floor(color[0] * 255) + ',' + bm_floor(color[1] * 255) + ',' + bm_floor(color[2] * 255) + ')');
      }
    }
  };

  function SVGTritoneFilter(filter, filterManager) {
    this.filterManager = filterManager;
    var feColorMatrix = createNS('feColorMatrix');
    feColorMatrix.setAttribute('type', 'matrix');
    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
    feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
    feColorMatrix.setAttribute('result', 'f1');
    filter.appendChild(feColorMatrix);
    var feComponentTransfer = createNS('feComponentTransfer');
    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
    filter.appendChild(feComponentTransfer);
    this.matrixFilter = feComponentTransfer;
    var feFuncR = createNS('feFuncR');
    feFuncR.setAttribute('type', 'table');
    feComponentTransfer.appendChild(feFuncR);
    this.feFuncR = feFuncR;
    var feFuncG = createNS('feFuncG');
    feFuncG.setAttribute('type', 'table');
    feComponentTransfer.appendChild(feFuncG);
    this.feFuncG = feFuncG;
    var feFuncB = createNS('feFuncB');
    feFuncB.setAttribute('type', 'table');
    feComponentTransfer.appendChild(feFuncB);
    this.feFuncB = feFuncB;
  }

  SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
    if (forceRender || this.filterManager._mdf) {
      var color1 = this.filterManager.effectElements[0].p.v;
      var color2 = this.filterManager.effectElements[1].p.v;
      var color3 = this.filterManager.effectElements[2].p.v;
      var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
      var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
      var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
      this.feFuncR.setAttribute('tableValues', tableR);
      this.feFuncG.setAttribute('tableValues', tableG);
      this.feFuncB.setAttribute('tableValues', tableB); //var opacity = this.filterManager.effectElements[2].p.v/100;
      //this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
    }
  };

  function SVGProLevelsFilter(filter, filterManager) {
    this.filterManager = filterManager;
    var effectElements = this.filterManager.effectElements;
    var feComponentTransfer = createNS('feComponentTransfer');
    var feFuncR, feFuncG, feFuncB;

    if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
      this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
    }

    if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
      this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
    }

    if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
      this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
    }

    if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
      this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
    }

    if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
      filter.appendChild(feComponentTransfer);
      feComponentTransfer = createNS('feComponentTransfer');
    }

    if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
      filter.appendChild(feComponentTransfer);
      this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
      this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
      this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
    }
  }

  SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
    var feFunc = createNS(type);
    feFunc.setAttribute('type', 'table');
    feComponentTransfer.appendChild(feFunc);
    return feFunc;
  };

  SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
    var cnt = 0;
    var segments = 256;
    var perc;
    var min = Math.min(inputBlack, inputWhite);
    var max = Math.max(inputBlack, inputWhite);
    var table = Array.call(null, {
      length: segments
    });
    var colorValue;
    var pos = 0;
    var outputDelta = outputWhite - outputBlack;
    var inputDelta = inputWhite - inputBlack;

    while (cnt <= 256) {
      perc = cnt / 256;

      if (perc <= min) {
        colorValue = inputDelta < 0 ? outputWhite : outputBlack;
      } else if (perc >= max) {
        colorValue = inputDelta < 0 ? outputBlack : outputWhite;
      } else {
        colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
      }

      table[pos++] = colorValue;
      cnt += 256 / (segments - 1);
    }

    return table.join(' ');
  };

  SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
    if (forceRender || this.filterManager._mdf) {
      var val, cnt, perc, bezier;
      var effectElements = this.filterManager.effectElements;

      if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
        val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
        this.feFuncRComposed.setAttribute('tableValues', val);
        this.feFuncGComposed.setAttribute('tableValues', val);
        this.feFuncBComposed.setAttribute('tableValues', val);
      }

      if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
        val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
        this.feFuncR.setAttribute('tableValues', val);
      }

      if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
        val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
        this.feFuncG.setAttribute('tableValues', val);
      }

      if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
        val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
        this.feFuncB.setAttribute('tableValues', val);
      }

      if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
        val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
        this.feFuncA.setAttribute('tableValues', val);
      }
    }
  };

  function SVGDropShadowEffect(filter, filterManager) {
    filter.setAttribute('x', '-100%');
    filter.setAttribute('y', '-100%');
    filter.setAttribute('width', '400%');
    filter.setAttribute('height', '400%');
    this.filterManager = filterManager;
    var feGaussianBlur = createNS('feGaussianBlur');
    feGaussianBlur.setAttribute('in', 'SourceAlpha');
    feGaussianBlur.setAttribute('result', 'drop_shadow_1');
    feGaussianBlur.setAttribute('stdDeviation', '0');
    this.feGaussianBlur = feGaussianBlur;
    filter.appendChild(feGaussianBlur);
    var feOffset = createNS('feOffset');
    feOffset.setAttribute('dx', '25');
    feOffset.setAttribute('dy', '0');
    feOffset.setAttribute('in', 'drop_shadow_1');
    feOffset.setAttribute('result', 'drop_shadow_2');
    this.feOffset = feOffset;
    filter.appendChild(feOffset);
    var feFlood = createNS('feFlood');
    feFlood.setAttribute('flood-color', '#00ff00');
    feFlood.setAttribute('flood-opacity', '1');
    feFlood.setAttribute('result', 'drop_shadow_3');
    this.feFlood = feFlood;
    filter.appendChild(feFlood);
    var feComposite = createNS('feComposite');
    feComposite.setAttribute('in', 'drop_shadow_3');
    feComposite.setAttribute('in2', 'drop_shadow_2');
    feComposite.setAttribute('operator', 'in');
    feComposite.setAttribute('result', 'drop_shadow_4');
    filter.appendChild(feComposite);
    var feMerge = createNS('feMerge');
    filter.appendChild(feMerge);
    var feMergeNode;
    feMergeNode = createNS('feMergeNode');
    feMerge.appendChild(feMergeNode);
    feMergeNode = createNS('feMergeNode');
    feMergeNode.setAttribute('in', 'SourceGraphic');
    this.feMergeNode = feMergeNode;
    this.feMerge = feMerge;
    this.originalNodeAdded = false;
    feMerge.appendChild(feMergeNode);
  }

  SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
    if (forceRender || this.filterManager._mdf) {
      if (forceRender || this.filterManager.effectElements[4].p._mdf) {
        this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
      }

      if (forceRender || this.filterManager.effectElements[0].p._mdf) {
        var col = this.filterManager.effectElements[0].p.v;
        this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
      }

      if (forceRender || this.filterManager.effectElements[1].p._mdf) {
        this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
      }

      if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
        var distance = this.filterManager.effectElements[3].p.v;
        var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
        var x = distance * Math.cos(angle);
        var y = distance * Math.sin(angle);
        this.feOffset.setAttribute('dx', x);
        this.feOffset.setAttribute('dy', y);
      }
      /*if(forceRender || this.filterManager.effectElements[5].p._mdf){
          if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
              this.feMerge.removeChild(this.feMergeNode);
              this.originalNodeAdded = false;
          } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
              this.feMerge.appendChild(this.feMergeNode);
              this.originalNodeAdded = true;
          }
      }*/

    }
  };

  var _svgMatteSymbols = [];

  function SVGMatte3Effect(filterElem, filterManager, elem) {
    this.initialized = false;
    this.filterManager = filterManager;
    this.filterElem = filterElem;
    this.elem = elem;
    elem.matteElement = createNS('g');
    elem.matteElement.appendChild(elem.layerElement);
    elem.matteElement.appendChild(elem.transformedElement);
    elem.baseElement = elem.matteElement;
  }

  SVGMatte3Effect.prototype.findSymbol = function (mask) {
    var i = 0,
        len = _svgMatteSymbols.length;

    while (i < len) {
      if (_svgMatteSymbols[i] === mask) {
        return _svgMatteSymbols[i];
      }

      i += 1;
    }

    return null;
  };

  SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
    var parentNode = mask.layerElement.parentNode;

    if (!parentNode) {
      return;
    }

    var children = parentNode.children;
    var i = 0,
        len = children.length;

    while (i < len) {
      if (children[i] === mask.layerElement) {
        break;
      }

      i += 1;
    }

    var nextChild;

    if (i <= len - 2) {
      nextChild = children[i + 1];
    }

    var useElem = createNS('use');
    useElem.setAttribute('href', '#' + symbolId);

    if (nextChild) {
      parentNode.insertBefore(useElem, nextChild);
    } else {
      parentNode.appendChild(useElem);
    }
  };

  SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
    if (!this.findSymbol(mask)) {
      var symbolId = createElementID();
      var masker = createNS('mask');
      masker.setAttribute('id', mask.layerId);
      masker.setAttribute('mask-type', 'alpha');

      _svgMatteSymbols.push(mask);

      var defs = elem.globalData.defs;
      defs.appendChild(masker);
      var symbol = createNS('symbol');
      symbol.setAttribute('id', symbolId);
      this.replaceInParent(mask, symbolId);
      symbol.appendChild(mask.layerElement);
      defs.appendChild(symbol);
      var useElem = createNS('use');
      useElem.setAttribute('href', '#' + symbolId);
      masker.appendChild(useElem);
      mask.data.hd = false;
      mask.show();
    }

    elem.setMatte(mask.layerId);
  };

  SVGMatte3Effect.prototype.initialize = function () {
    var ind = this.filterManager.effectElements[0].p.v;
    var elements = this.elem.comp.elements;
    var i = 0,
        len = elements.length;

    while (i < len) {
      if (elements[i] && elements[i].data.ind === ind) {
        this.setElementAsMask(this.elem, elements[i]);
      }

      i += 1;
    }

    this.initialized = true;
  };

  SVGMatte3Effect.prototype.renderFrame = function () {
    if (!this.initialized) {
      this.initialize();
    }
  };

  function SVGEffects(elem) {
    var i,
        len = elem.data.ef ? elem.data.ef.length : 0;
    var filId = createElementID();
    var fil = filtersFactory.createFilter(filId);
    var count = 0;
    this.filters = [];
    var filterManager;

    for (i = 0; i < len; i += 1) {
      filterManager = null;

      if (elem.data.ef[i].ty === 20) {
        count += 1;
        filterManager = new SVGTintFilter(fil, elem.effectsManager.effectElements[i]);
      } else if (elem.data.ef[i].ty === 21) {
        count += 1;
        filterManager = new SVGFillFilter(fil, elem.effectsManager.effectElements[i]);
      } else if (elem.data.ef[i].ty === 22) {
        filterManager = new SVGStrokeEffect(elem, elem.effectsManager.effectElements[i]);
      } else if (elem.data.ef[i].ty === 23) {
        count += 1;
        filterManager = new SVGTritoneFilter(fil, elem.effectsManager.effectElements[i]);
      } else if (elem.data.ef[i].ty === 24) {
        count += 1;
        filterManager = new SVGProLevelsFilter(fil, elem.effectsManager.effectElements[i]);
      } else if (elem.data.ef[i].ty === 25) {
        count += 1;
        filterManager = new SVGDropShadowEffect(fil, elem.effectsManager.effectElements[i]);
      } else if (elem.data.ef[i].ty === 28) {
        //count += 1;
        filterManager = new SVGMatte3Effect(fil, elem.effectsManager.effectElements[i], elem);
      }

      if (filterManager) {
        this.filters.push(filterManager);
      }
    }

    if (count) {
      elem.globalData.defs.appendChild(fil);
      elem.layerElement.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
    }

    if (this.filters.length) {
      elem.addRenderableComponent(this);
    }
  }

  SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
    var i,
        len = this.filters.length;

    for (i = 0; i < len; i += 1) {
      this.filters[i].renderFrame(_isFirstFrame);
    }
  };

  function CVContextData() {
    this.saved = [];
    this.cArrPos = 0;
    this.cTr = new Matrix();
    this.cO = 1;
    var i,
        len = 15;
    this.savedOp = createTypedArray('float32', len);

    for (i = 0; i < len; i += 1) {
      this.saved[i] = createTypedArray('float32', 16);
    }

    this._length = len;
  }

  CVContextData.prototype.duplicate = function () {
    var newLength = this._length * 2;
    var currentSavedOp = this.savedOp;
    this.savedOp = createTypedArray('float32', newLength);
    this.savedOp.set(currentSavedOp);
    var i = 0;

    for (i = this._length; i < newLength; i += 1) {
      this.saved[i] = createTypedArray('float32', 16);
    }

    this._length = newLength;
  };

  CVContextData.prototype.reset = function () {
    this.cArrPos = 0;
    this.cTr.reset();
    this.cO = 1;
  };

  function CVBaseElement() {}

  CVBaseElement.prototype = {
    createElements: function createElements() {},
    initRendererElement: function initRendererElement() {},
    createContainerElements: function createContainerElements() {
      this.canvasContext = this.globalData.canvasContext;
      this.renderableEffectsManager = new CVEffects(this);
    },
    createContent: function createContent() {},
    setBlendMode: function setBlendMode() {
      var globalData = this.globalData;

      if (globalData.blendMode !== this.data.bm) {
        globalData.blendMode = this.data.bm;
        var blendModeValue = getBlendMode(this.data.bm);
        globalData.canvasContext.globalCompositeOperation = blendModeValue;
      }
    },
    createRenderableComponents: function createRenderableComponents() {
      this.maskManager = new CVMaskElement(this.data, this);
    },
    hideElement: function hideElement() {
      if (!this.hidden && (!this.isInRange || this.isTransparent)) {
        this.hidden = true;
      }
    },
    showElement: function showElement() {
      if (this.isInRange && !this.isTransparent) {
        this.hidden = false;
        this._isFirstFrame = true;
        this.maskManager._isFirstFrame = true;
      }
    },
    renderFrame: function renderFrame() {
      if (this.hidden || this.data.hd) {
        return;
      }

      this.renderTransform();
      this.renderRenderable();
      this.setBlendMode();
      this.globalData.renderer.save();
      this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
      this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);
      this.renderInnerContent();
      this.globalData.renderer.restore();

      if (this.maskManager.hasMasks) {
        this.globalData.renderer.restore(true);
      }

      if (this._isFirstFrame) {
        this._isFirstFrame = false;
      }
    },
    destroy: function destroy() {
      this.canvasContext = null;
      this.data = null;
      this.globalData = null;
      this.maskManager.destroy();
    },
    mHelper: new Matrix()
  };
  CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
  CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

  function CVImageElement(data, globalData, comp) {
    this.failed = false;
    this.assetData = globalData.getAssetData(data.refId);
    this.img = globalData.imageLoader.getImage(this.assetData);
    this.initElement(data, globalData, comp);
  }

  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
  CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
  CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

  CVImageElement.prototype.createContent = function () {
    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
      var canvas = createTag('canvas');
      canvas.width = this.assetData.w;
      canvas.height = this.assetData.h;
      var ctx = canvas.getContext('2d');
      var imgW = this.img.width;
      var imgH = this.img.height;
      var imgRel = imgW / imgH;
      var canvasRel = this.assetData.w / this.assetData.h;
      var widthCrop, heightCrop;
      var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;

      if (imgRel > canvasRel && par === 'xMidYMid slice' || imgRel < canvasRel && par !== 'xMidYMid slice') {
        heightCrop = imgH;
        widthCrop = heightCrop * canvasRel;
      } else {
        widthCrop = imgW;
        heightCrop = widthCrop / canvasRel;
      }

      ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
      this.img = canvas;
    }
  };

  CVImageElement.prototype.renderInnerContent = function (parentMatrix) {
    if (this.failed) {
      return;
    }

    this.canvasContext.drawImage(this.img, 0, 0);
  };

  CVImageElement.prototype.destroy = function () {
    this.img = null;
  };

  function CVCompElement(data, globalData, comp) {
    this.completeLayers = false;
    this.layers = data.layers;
    this.pendingElements = [];
    this.elements = createSizedArray(this.layers.length);
    this.initElement(data, globalData, comp);
    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
      _placeholder: true
    };
  }

  extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement);

  CVCompElement.prototype.renderInnerContent = function () {
    var i,
        len = this.layers.length;

    for (i = len - 1; i >= 0; i -= 1) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].renderFrame();
      }
    }
  };

  CVCompElement.prototype.destroy = function () {
    var i,
        len = this.layers.length;

    for (i = len - 1; i >= 0; i -= 1) {
      if (this.elements[i]) {
        this.elements[i].destroy();
      }
    }

    this.layers = null;
    this.elements = null;
  };

  function CVMaskElement(data, element) {
    this.data = data;
    this.element = element;
    this.masksProperties = this.data.masksProperties || [];
    this.viewData = createSizedArray(this.masksProperties.length);
    var i,
        len = this.masksProperties.length,
        hasMasks = false;

    for (i = 0; i < len; i++) {
      if (this.masksProperties[i].mode !== 'n') {
        hasMasks = true;
      }

      this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
    }

    this.hasMasks = hasMasks;

    if (hasMasks) {
      this.element.addRenderableComponent(this);
    }
  }

  CVMaskElement.prototype.renderFrame = function () {
    if (!this.hasMasks) {
      return;
    }

    var transform = this.element.finalTransform.mat;
    var ctx = this.element.canvasContext;
    var i,
        len = this.masksProperties.length;
    var pt, pts, data;
    ctx.beginPath();

    for (i = 0; i < len; i++) {
      if (this.masksProperties[i].mode !== 'n') {
        if (this.masksProperties[i].inv) {
          ctx.moveTo(0, 0);
          ctx.lineTo(this.element.globalData.compSize.w, 0);
          ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
          ctx.lineTo(0, this.element.globalData.compSize.h);
          ctx.lineTo(0, 0);
        }

        data = this.viewData[i].v;
        pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
        ctx.moveTo(pt[0], pt[1]);
        var j,
            jLen = data._length;

        for (j = 1; j < jLen; j++) {
          pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
          ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
        }

        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
      }
    }

    this.element.globalData.renderer.save(true);
    ctx.clip();
  };

  CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;

  CVMaskElement.prototype.destroy = function () {
    this.element = null;
  };

  function CVShapeElement(data, globalData, comp) {
    this.shapes = [];
    this.shapesData = data.shapes;
    this.stylesList = [];
    this.itemsData = [];
    this.prevViewData = [];
    this.shapeModifiers = [];
    this.processedElements = [];
    this.transformsManager = new ShapeTransformManager();
    this.initElement(data, globalData, comp);
  }

  extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
  CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
  CVShapeElement.prototype.transformHelper = {
    opacity: 1,
    _opMdf: false
  };
  CVShapeElement.prototype.dashResetter = [];

  CVShapeElement.prototype.createContent = function () {
    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
  };

  CVShapeElement.prototype.createStyleElement = function (data, transforms) {
    var styleElem = {
      data: data,
      type: data.ty,
      preTransforms: this.transformsManager.addTransformSequence(transforms),
      transforms: [],
      elements: [],
      closed: data.hd === true
    };
    var elementData = {};

    if (data.ty == 'fl' || data.ty == 'st') {
      elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);

      if (!elementData.c.k) {
        styleElem.co = 'rgb(' + bm_floor(elementData.c.v[0]) + ',' + bm_floor(elementData.c.v[1]) + ',' + bm_floor(elementData.c.v[2]) + ')';
      }
    } else if (data.ty === 'gf' || data.ty === 'gs') {
      elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
      elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
      elementData.h = PropertyFactory.getProp(this, data.h || {
        k: 0
      }, 0, 0.01, this);
      elementData.a = PropertyFactory.getProp(this, data.a || {
        k: 0
      }, 0, degToRads, this);
      elementData.g = new GradientProperty(this, data.g, this);
    }

    elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);

    if (data.ty == 'st' || data.ty == 'gs') {
      styleElem.lc = this.lcEnum[data.lc] || 'round';
      styleElem.lj = this.ljEnum[data.lj] || 'round';

      if (data.lj == 1) {
        styleElem.ml = data.ml;
      }

      elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);

      if (!elementData.w.k) {
        styleElem.wi = elementData.w.v;
      }

      if (data.d) {
        var d = new DashProperty(this, data.d, 'canvas', this);
        elementData.d = d;

        if (!elementData.d.k) {
          styleElem.da = elementData.d.dashArray;
          styleElem["do"] = elementData.d.dashoffset[0];
        }
      }
    } else {
      styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
    }

    this.stylesList.push(styleElem);
    elementData.style = styleElem;
    return elementData;
  };

  CVShapeElement.prototype.createGroupElement = function (data) {
    var elementData = {
      it: [],
      prevViewData: []
    };
    return elementData;
  };

  CVShapeElement.prototype.createTransformElement = function (data) {
    var elementData = {
      transform: {
        opacity: 1,
        _opMdf: false,
        key: this.transformsManager.getNewKey(),
        op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
        mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
      }
    };
    return elementData;
  };

  CVShapeElement.prototype.createShapeElement = function (data) {
    var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
    this.shapes.push(elementData);
    this.addShapeToModifiers(elementData);
    return elementData;
  };

  CVShapeElement.prototype.reloadShapes = function () {
    this._isFirstFrame = true;
    var i,
        len = this.itemsData.length;

    for (i = 0; i < len; i += 1) {
      this.prevViewData[i] = this.itemsData[i];
    }

    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
    len = this.dynamicProperties.length;

    for (i = 0; i < len; i += 1) {
      this.dynamicProperties[i].getValue();
    }

    this.renderModifiers();
    this.transformsManager.processSequences(this._isFirstFrame);
  };

  CVShapeElement.prototype.addTransformToStyleList = function (transform) {
    var i,
        len = this.stylesList.length;

    for (i = 0; i < len; i += 1) {
      if (!this.stylesList[i].closed) {
        this.stylesList[i].transforms.push(transform);
      }
    }
  };

  CVShapeElement.prototype.removeTransformFromStyleList = function () {
    var i,
        len = this.stylesList.length;

    for (i = 0; i < len; i += 1) {
      if (!this.stylesList[i].closed) {
        this.stylesList[i].transforms.pop();
      }
    }
  };

  CVShapeElement.prototype.closeStyles = function (styles) {
    var i,
        len = styles.length,
        j,
        jLen;

    for (i = 0; i < len; i += 1) {
      styles[i].closed = true;
    }
  };

  CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
    var i,
        len = arr.length - 1;
    var j, jLen;
    var ownStyles = [],
        ownModifiers = [],
        processedPos,
        modifier,
        currentTransform;
    var ownTransforms = [].concat(transforms);

    for (i = len; i >= 0; i -= 1) {
      processedPos = this.searchProcessedElement(arr[i]);

      if (!processedPos) {
        arr[i]._shouldRender = shouldRender;
      } else {
        itemsData[i] = prevViewData[processedPos - 1];
      }

      if (arr[i].ty == 'fl' || arr[i].ty == 'st' || arr[i].ty == 'gf' || arr[i].ty == 'gs') {
        if (!processedPos) {
          itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
        } else {
          itemsData[i].style.closed = false;
        }

        ownStyles.push(itemsData[i].style);
      } else if (arr[i].ty == 'gr') {
        if (!processedPos) {
          itemsData[i] = this.createGroupElement(arr[i]);
        } else {
          jLen = itemsData[i].it.length;

          for (j = 0; j < jLen; j += 1) {
            itemsData[i].prevViewData[j] = itemsData[i].it[j];
          }
        }

        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
      } else if (arr[i].ty == 'tr') {
        if (!processedPos) {
          currentTransform = this.createTransformElement(arr[i]);
          itemsData[i] = currentTransform;
        }

        ownTransforms.push(itemsData[i]);
        this.addTransformToStyleList(itemsData[i]);
      } else if (arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr') {
        if (!processedPos) {
          itemsData[i] = this.createShapeElement(arr[i]);
        }
      } else if (arr[i].ty == 'tm' || arr[i].ty == 'rd') {
        if (!processedPos) {
          modifier = ShapeModifiers.getModifier(arr[i].ty);
          modifier.init(this, arr[i]);
          itemsData[i] = modifier;
          this.shapeModifiers.push(modifier);
        } else {
          modifier = itemsData[i];
          modifier.closed = false;
        }

        ownModifiers.push(modifier);
      } else if (arr[i].ty == 'rp') {
        if (!processedPos) {
          modifier = ShapeModifiers.getModifier(arr[i].ty);
          itemsData[i] = modifier;
          modifier.init(this, arr, i, itemsData);
          this.shapeModifiers.push(modifier);
          shouldRender = false;
        } else {
          modifier = itemsData[i];
          modifier.closed = true;
        }

        ownModifiers.push(modifier);
      }

      this.addProcessedElement(arr[i], i + 1);
    }

    this.removeTransformFromStyleList();
    this.closeStyles(ownStyles);
    len = ownModifiers.length;

    for (i = 0; i < len; i += 1) {
      ownModifiers[i].closed = true;
    }
  };

  CVShapeElement.prototype.renderInnerContent = function () {
    this.transformHelper.opacity = 1;
    this.transformHelper._opMdf = false;
    this.renderModifiers();
    this.transformsManager.processSequences(this._isFirstFrame);
    this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
  };

  CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
    var props, groupMatrix;

    if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
      groupTransform.opacity = parentTransform.opacity;
      groupTransform.opacity *= groupTransform.op.v;
      groupTransform._opMdf = true;
    }
  };

  CVShapeElement.prototype.drawLayer = function () {
    var i,
        len = this.stylesList.length;
    var j,
        jLen,
        k,
        kLen,
        elems,
        nodes,
        renderer = this.globalData.renderer,
        ctx = this.globalData.canvasContext,
        type,
        currentStyle;

    for (i = 0; i < len; i += 1) {
      currentStyle = this.stylesList[i];
      type = currentStyle.type; //Skipping style when
      //Stroke width equals 0
      //style should not be rendered (extra unused repeaters)
      //current opacity equals 0
      //global opacity equals 0

      if ((type === 'st' || type === 'gs') && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0) {
        continue;
      }

      renderer.save();
      elems = currentStyle.elements;

      if (type === 'st' || type === 'gs') {
        ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
        ctx.lineWidth = currentStyle.wi;
        ctx.lineCap = currentStyle.lc;
        ctx.lineJoin = currentStyle.lj;
        ctx.miterLimit = currentStyle.ml || 0;
      } else {
        ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
      }

      renderer.ctxOpacity(currentStyle.coOp);

      if (type !== 'st' && type !== 'gs') {
        ctx.beginPath();
      }

      renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
      jLen = elems.length;

      for (j = 0; j < jLen; j += 1) {
        if (type === 'st' || type === 'gs') {
          ctx.beginPath();

          if (currentStyle.da) {
            ctx.setLineDash(currentStyle.da);
            ctx.lineDashOffset = currentStyle["do"];
          }
        }

        nodes = elems[j].trNodes;
        kLen = nodes.length;

        for (k = 0; k < kLen; k += 1) {
          if (nodes[k].t == 'm') {
            ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
          } else if (nodes[k].t == 'c') {
            ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
          } else {
            ctx.closePath();
          }
        }

        if (type === 'st' || type === 'gs') {
          ctx.stroke();

          if (currentStyle.da) {
            ctx.setLineDash(this.dashResetter);
          }
        }
      }

      if (type !== 'st' && type !== 'gs') {
        ctx.fill(currentStyle.r);
      }

      renderer.restore();
    }
  };

  CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
    var i,
        len = items.length - 1;
    var groupTransform;
    groupTransform = parentTransform;

    for (i = len; i >= 0; i -= 1) {
      if (items[i].ty == 'tr') {
        groupTransform = data[i].transform;
        this.renderShapeTransform(parentTransform, groupTransform);
      } else if (items[i].ty == 'sh' || items[i].ty == 'el' || items[i].ty == 'rc' || items[i].ty == 'sr') {
        this.renderPath(items[i], data[i]);
      } else if (items[i].ty == 'fl') {
        this.renderFill(items[i], data[i], groupTransform);
      } else if (items[i].ty == 'st') {
        this.renderStroke(items[i], data[i], groupTransform);
      } else if (items[i].ty == 'gf' || items[i].ty == 'gs') {
        this.renderGradientFill(items[i], data[i], groupTransform);
      } else if (items[i].ty == 'gr') {
        this.renderShape(groupTransform, items[i].it, data[i].it);
      } else if (items[i].ty == 'tm') {//
      }
    }

    if (isMain) {
      this.drawLayer();
    }
  };

  CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
    if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
      var shapeNodes = styledShape.trNodes;
      var paths = shape.paths;
      var i,
          len,
          j,
          jLen = paths._length;
      shapeNodes.length = 0;
      var groupTransformMat = styledShape.transforms.finalTransform;

      for (j = 0; j < jLen; j += 1) {
        var pathNodes = paths.shapes[j];

        if (pathNodes && pathNodes.v) {
          len = pathNodes._length;

          for (i = 1; i < len; i += 1) {
            if (i === 1) {
              shapeNodes.push({
                t: 'm',
                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
              });
            }

            shapeNodes.push({
              t: 'c',
              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
            });
          }

          if (len === 1) {
            shapeNodes.push({
              t: 'm',
              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
            });
          }

          if (pathNodes.c && len) {
            shapeNodes.push({
              t: 'c',
              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
            });
            shapeNodes.push({
              t: 'z'
            });
          }
        }
      }

      styledShape.trNodes = shapeNodes;
    }
  };

  CVShapeElement.prototype.renderPath = function (pathData, itemData) {
    if (pathData.hd !== true && pathData._shouldRender) {
      var i,
          len = itemData.styledShapes.length;

      for (i = 0; i < len; i += 1) {
        this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
      }
    }
  };

  CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
    var styleElem = itemData.style;

    if (itemData.c._mdf || this._isFirstFrame) {
      styleElem.co = 'rgb(' + bm_floor(itemData.c.v[0]) + ',' + bm_floor(itemData.c.v[1]) + ',' + bm_floor(itemData.c.v[2]) + ')';
    }

    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
      styleElem.coOp = itemData.o.v * groupTransform.opacity;
    }
  };

  CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
    var styleElem = itemData.style;

    if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
      var ctx = this.globalData.canvasContext;
      var grd;
      var pt1 = itemData.s.v,
          pt2 = itemData.e.v;

      if (styleData.t === 1) {
        grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
      } else {
        var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
        var percent = itemData.h.v >= 1 ? 0.99 : itemData.h.v <= -1 ? -0.99 : itemData.h.v;
        var dist = rad * percent;
        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
        var grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
      }

      var i,
          len = styleData.g.p;
      var cValues = itemData.g.c;
      var opacity = 1;

      for (i = 0; i < len; i += 1) {
        if (itemData.g._hasOpacity && itemData.g._collapsable) {
          opacity = itemData.g.o[i * 2 + 1];
        }

        grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
      }

      styleElem.grd = grd;
    }

    styleElem.coOp = itemData.o.v * groupTransform.opacity;
  };

  CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
    var styleElem = itemData.style;
    var d = itemData.d;

    if (d && (d._mdf || this._isFirstFrame)) {
      styleElem.da = d.dashArray;
      styleElem["do"] = d.dashoffset[0];
    }

    if (itemData.c._mdf || this._isFirstFrame) {
      styleElem.co = 'rgb(' + bm_floor(itemData.c.v[0]) + ',' + bm_floor(itemData.c.v[1]) + ',' + bm_floor(itemData.c.v[2]) + ')';
    }

    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
      styleElem.coOp = itemData.o.v * groupTransform.opacity;
    }

    if (itemData.w._mdf || this._isFirstFrame) {
      styleElem.wi = itemData.w.v;
    }
  };

  CVShapeElement.prototype.destroy = function () {
    this.shapesData = null;
    this.globalData = null;
    this.canvasContext = null;
    this.stylesList.length = 0;
    this.itemsData.length = 0;
  };

  function CVSolidElement(data, globalData, comp) {
    this.initElement(data, globalData, comp);
  }

  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
  CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
  CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

  CVSolidElement.prototype.renderInnerContent = function () {
    var ctx = this.canvasContext;
    ctx.fillStyle = this.data.sc;
    ctx.fillRect(0, 0, this.data.sw, this.data.sh); //
  };

  function CVTextElement(data, globalData, comp) {
    this.textSpans = [];
    this.yOffset = 0;
    this.fillColorAnim = false;
    this.strokeColorAnim = false;
    this.strokeWidthAnim = false;
    this.stroke = false;
    this.fill = false;
    this.justifyOffset = 0;
    this.currentRender = null;
    this.renderType = 'canvas';
    this.values = {
      fill: 'rgba(0,0,0,0)',
      stroke: 'rgba(0,0,0,0)',
      sWidth: 0,
      fValue: ''
    };
    this.initElement(data, globalData, comp);
  }

  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
  CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');

  CVTextElement.prototype.buildNewText = function () {
    var documentData = this.textProperty.currentData;
    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
    var hasFill = false;

    if (documentData.fc) {
      hasFill = true;
      this.values.fill = this.buildColor(documentData.fc);
    } else {
      this.values.fill = 'rgba(0,0,0,0)';
    }

    this.fill = hasFill;
    var hasStroke = false;

    if (documentData.sc) {
      hasStroke = true;
      this.values.stroke = this.buildColor(documentData.sc);
      this.values.sWidth = documentData.sw;
    }

    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
    var i, len;
    var letters = documentData.l;
    var matrixHelper = this.mHelper;
    this.stroke = hasStroke;
    this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
    len = documentData.finalText.length; //this.tHelper.font = this.values.fValue;

    var charData,
        shapeData,
        k,
        kLen,
        shapes,
        j,
        jLen,
        pathNodes,
        commands,
        pathArr,
        singleShape = this.data.singleShape;
    var trackingOffset = documentData.tr / 1000 * documentData.finalSize;
    var xPos = 0,
        yPos = 0,
        firstLine = true;
    var cnt = 0;

    for (i = 0; i < len; i += 1) {
      charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
      shapeData = charData && charData.data || {};
      matrixHelper.reset();

      if (singleShape && letters[i].n) {
        xPos = -trackingOffset;
        yPos += documentData.yOffset;
        yPos += firstLine ? 1 : 0;
        firstLine = false;
      }

      shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
      jLen = shapes.length;
      matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);

      if (singleShape) {
        this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
      }

      commands = createSizedArray(jLen);

      for (j = 0; j < jLen; j += 1) {
        kLen = shapes[j].ks.k.i.length;
        pathNodes = shapes[j].ks.k;
        pathArr = [];

        for (k = 1; k < kLen; k += 1) {
          if (k == 1) {
            pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
          }

          pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
        }

        pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
        commands[j] = pathArr;
      }

      if (singleShape) {
        xPos += letters[i].l;
        xPos += trackingOffset;
      }

      if (this.textSpans[cnt]) {
        this.textSpans[cnt].elem = commands;
      } else {
        this.textSpans[cnt] = {
          elem: commands
        };
      }

      cnt += 1;
    }
  };

  CVTextElement.prototype.renderInnerContent = function () {
    var ctx = this.canvasContext;
    var finalMat = this.finalTransform.mat.props;
    ctx.font = this.values.fValue;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.miterLimit = 4;

    if (!this.data.singleShape) {
      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
    }

    var i, len, j, jLen, k, kLen;
    var renderedLetters = this.textAnimator.renderedLetters;
    var letters = this.textProperty.currentData.l;
    len = letters.length;
    var renderedLetter;
    var lastFill = null,
        lastStroke = null,
        lastStrokeW = null,
        commands,
        pathArr;

    for (i = 0; i < len; i += 1) {
      if (letters[i].n) {
        continue;
      }

      renderedLetter = renderedLetters[i];

      if (renderedLetter) {
        this.globalData.renderer.save();
        this.globalData.renderer.ctxTransform(renderedLetter.p);
        this.globalData.renderer.ctxOpacity(renderedLetter.o);
      }

      if (this.fill) {
        if (renderedLetter && renderedLetter.fc) {
          if (lastFill !== renderedLetter.fc) {
            lastFill = renderedLetter.fc;
            ctx.fillStyle = renderedLetter.fc;
          }
        } else if (lastFill !== this.values.fill) {
          lastFill = this.values.fill;
          ctx.fillStyle = this.values.fill;
        }

        commands = this.textSpans[i].elem;
        jLen = commands.length;
        this.globalData.canvasContext.beginPath();

        for (j = 0; j < jLen; j += 1) {
          pathArr = commands[j];
          kLen = pathArr.length;
          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);

          for (k = 2; k < kLen; k += 6) {
            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
          }
        }

        this.globalData.canvasContext.closePath();
        this.globalData.canvasContext.fill(); ///ctx.fillText(this.textSpans[i].val,0,0);
      }

      if (this.stroke) {
        if (renderedLetter && renderedLetter.sw) {
          if (lastStrokeW !== renderedLetter.sw) {
            lastStrokeW = renderedLetter.sw;
            ctx.lineWidth = renderedLetter.sw;
          }
        } else if (lastStrokeW !== this.values.sWidth) {
          lastStrokeW = this.values.sWidth;
          ctx.lineWidth = this.values.sWidth;
        }

        if (renderedLetter && renderedLetter.sc) {
          if (lastStroke !== renderedLetter.sc) {
            lastStroke = renderedLetter.sc;
            ctx.strokeStyle = renderedLetter.sc;
          }
        } else if (lastStroke !== this.values.stroke) {
          lastStroke = this.values.stroke;
          ctx.strokeStyle = this.values.stroke;
        }

        commands = this.textSpans[i].elem;
        jLen = commands.length;
        this.globalData.canvasContext.beginPath();

        for (j = 0; j < jLen; j += 1) {
          pathArr = commands[j];
          kLen = pathArr.length;
          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);

          for (k = 2; k < kLen; k += 6) {
            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
          }
        }

        this.globalData.canvasContext.closePath();
        this.globalData.canvasContext.stroke(); ///ctx.strokeText(letters[i].val,0,0);
      }

      if (renderedLetter) {
        this.globalData.renderer.restore();
      }
    }
  };

  function CVEffects() {}

  CVEffects.prototype.renderFrame = function () {};

  function HBaseElement(data, globalData, comp) {}

  HBaseElement.prototype = {
    checkBlendMode: function checkBlendMode() {},
    initRendererElement: function initRendererElement() {
      this.baseElement = createTag(this.data.tg || 'div');

      if (this.data.hasMask) {
        this.svgElement = createNS('svg');
        this.layerElement = createNS('g');
        this.maskedElement = this.layerElement;
        this.svgElement.appendChild(this.layerElement);
        this.baseElement.appendChild(this.svgElement);
      } else {
        this.layerElement = this.baseElement;
      }

      styleDiv(this.baseElement);
    },
    createContainerElements: function createContainerElements() {
      this.renderableEffectsManager = new CVEffects(this);
      this.transformedElement = this.baseElement;
      this.maskedElement = this.layerElement;

      if (this.data.ln) {
        this.layerElement.setAttribute('id', this.data.ln);
      }

      if (this.data.cl) {
        this.layerElement.setAttribute('class', this.data.cl);
      }

      if (this.data.bm !== 0) {
        this.setBlendMode();
      }
    },
    renderElement: function renderElement() {
      if (this.finalTransform._matMdf) {
        this.transformedElement.style.transform = this.transformedElement.style.webkitTransform = this.finalTransform.mat.toCSS();
      }

      if (this.finalTransform._opMdf) {
        this.transformedElement.style.opacity = this.finalTransform.mProp.o.v;
      }
    },
    renderFrame: function renderFrame() {
      //If it is exported as hidden (data.hd === true) no need to render
      //If it is not visible no need to render
      if (this.data.hd || this.hidden) {
        return;
      }

      this.renderTransform();
      this.renderRenderable();
      this.renderElement();
      this.renderInnerContent();

      if (this._isFirstFrame) {
        this._isFirstFrame = false;
      }
    },
    destroy: function destroy() {
      this.layerElement = null;
      this.transformedElement = null;

      if (this.matteElement) {
        this.matteElement = null;
      }

      if (this.maskManager) {
        this.maskManager.destroy();
        this.maskManager = null;
      }
    },
    createRenderableComponents: function createRenderableComponents() {
      this.maskManager = new MaskElement(this.data, this, this.globalData);
    },
    addEffects: function addEffects() {},
    setMatte: function setMatte() {}
  };
  HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
  HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
  HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;

  function HSolidElement(data, globalData, comp) {
    this.initElement(data, globalData, comp);
  }

  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);

  HSolidElement.prototype.createContent = function () {
    var rect;

    if (this.data.hasMask) {
      rect = createNS('rect');
      rect.setAttribute('width', this.data.sw);
      rect.setAttribute('height', this.data.sh);
      rect.setAttribute('fill', this.data.sc);
      this.svgElement.setAttribute('width', this.data.sw);
      this.svgElement.setAttribute('height', this.data.sh);
    } else {
      rect = createTag('div');
      rect.style.width = this.data.sw + 'px';
      rect.style.height = this.data.sh + 'px';
      rect.style.backgroundColor = this.data.sc;
    }

    this.layerElement.appendChild(rect);
  };

  function HCompElement(data, globalData, comp) {
    this.layers = data.layers;
    this.supports3d = !data.hasMask;
    this.completeLayers = false;
    this.pendingElements = [];
    this.elements = this.layers ? createSizedArray(this.layers.length) : [];
    this.initElement(data, globalData, comp);
    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
      _placeholder: true
    };
  }

  extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement);
  HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;

  HCompElement.prototype.createContainerElements = function () {
    this._createBaseContainerElements(); //divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';


    if (this.data.hasMask) {
      this.svgElement.setAttribute('width', this.data.w);
      this.svgElement.setAttribute('height', this.data.h);
      this.transformedElement = this.baseElement;
    } else {
      this.transformedElement = this.layerElement;
    }
  };

  HCompElement.prototype.addTo3dContainer = function (elem, pos) {
    var j = 0;
    var nextElement;

    while (j < pos) {
      if (this.elements[j] && this.elements[j].getBaseElement) {
        nextElement = this.elements[j].getBaseElement();
      }

      j += 1;
    }

    if (nextElement) {
      this.layerElement.insertBefore(elem, nextElement);
    } else {
      this.layerElement.appendChild(elem);
    }
  };

  function HShapeElement(data, globalData, comp) {
    //List of drawable elements
    this.shapes = []; // Full shape data

    this.shapesData = data.shapes; //List of styles that will be applied to shapes

    this.stylesList = []; //List of modifiers that will be applied to shapes

    this.shapeModifiers = []; //List of items in shape tree

    this.itemsData = []; //List of items in previous shape tree

    this.processedElements = []; // List of animated components

    this.animatedContents = [];
    this.shapesContainer = createNS('g');
    this.initElement(data, globalData, comp); //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
    // List of elements that have been created

    this.prevViewData = [];
    this.currentBBox = {
      x: 999999,
      y: -999999,
      h: 0,
      w: 0
    };
  }

  extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
  HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;

  HShapeElement.prototype.createContent = function () {
    var cont;
    this.baseElement.style.fontSize = 0;

    if (this.data.hasMask) {
      this.layerElement.appendChild(this.shapesContainer);
      cont = this.svgElement;
    } else {
      cont = createNS('svg');
      var size = this.comp.data ? this.comp.data : this.globalData.compSize;
      cont.setAttribute('width', size.w);
      cont.setAttribute('height', size.h);
      cont.appendChild(this.shapesContainer);
      this.layerElement.appendChild(cont);
    }

    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
    this.filterUniqueShapes();
    this.shapeCont = cont;
  };

  HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
    var i,
        len = transformers.length;

    for (i = 0; i < len; i += 1) {
      point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
    }

    return point;
  };

  HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
    var shape = item.sh.v;
    var transformers = item.transformers;
    var i,
        len = shape._length,
        vPoint,
        oPoint,
        nextIPoint,
        nextVPoint,
        bounds;

    if (len <= 1) {
      return;
    }

    for (i = 0; i < len - 1; i += 1) {
      vPoint = this.getTransformedPoint(transformers, shape.v[i]);
      oPoint = this.getTransformedPoint(transformers, shape.o[i]);
      nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
      nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
    }

    if (shape.c) {
      vPoint = this.getTransformedPoint(transformers, shape.v[i]);
      oPoint = this.getTransformedPoint(transformers, shape.o[i]);
      nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
      nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
    }
  };

  HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
    this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
    var bounds = this.shapeBoundingBox;
    boundingBox.x = bm_min(bounds.left, boundingBox.x);
    boundingBox.xMax = bm_max(bounds.right, boundingBox.xMax);
    boundingBox.y = bm_min(bounds.top, boundingBox.y);
    boundingBox.yMax = bm_max(bounds.bottom, boundingBox.yMax);
  };

  HShapeElement.prototype.shapeBoundingBox = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  HShapeElement.prototype.tempBoundingBox = {
    x: 0,
    xMax: 0,
    y: 0,
    yMax: 0,
    width: 0,
    height: 0
  };

  HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
    var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];

    for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
      b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
      a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
      c = 3 * p1[i] - 3 * p0[i];
      b = b | 0;
      a = a | 0;
      c = c | 0;

      if (a === 0) {
        if (b === 0) {
          continue;
        }

        t = -c / b;

        if (0 < t && t < 1) {
          bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
        }

        continue;
      }

      b2ac = b * b - 4 * c * a;

      if (b2ac < 0) {
        continue;
      }

      t1 = (-b + bm_sqrt(b2ac)) / (2 * a);
      if (0 < t1 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
      t2 = (-b - bm_sqrt(b2ac)) / (2 * a);
      if (0 < t2 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
    }

    this.shapeBoundingBox.left = bm_min.apply(null, bounds[0]);
    this.shapeBoundingBox.top = bm_min.apply(null, bounds[1]);
    this.shapeBoundingBox.right = bm_max.apply(null, bounds[0]);
    this.shapeBoundingBox.bottom = bm_max.apply(null, bounds[1]);
  };

  HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
    return bm_pow(1 - t, 3) * p0[i] + 3 * bm_pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bm_pow(t, 2) * p2[i] + bm_pow(t, 3) * p3[i];
  };

  HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
    var i,
        len = itemsData.length,
        path;

    for (i = 0; i < len; i += 1) {
      if (itemsData[i] && itemsData[i].sh) {
        this.calculateShapeBoundingBox(itemsData[i], boundingBox);
      } else if (itemsData[i] && itemsData[i].it) {
        this.calculateBoundingBox(itemsData[i].it, boundingBox);
      }
    }
  };

  HShapeElement.prototype.currentBoxContains = function (box) {
    return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
  };

  HShapeElement.prototype.renderInnerContent = function () {
    this._renderShapeFrame();

    if (!this.hidden && (this._isFirstFrame || this._mdf)) {
      var tempBoundingBox = this.tempBoundingBox;
      var max = 999999;
      tempBoundingBox.x = max;
      tempBoundingBox.xMax = -max;
      tempBoundingBox.y = max;
      tempBoundingBox.yMax = -max;
      this.calculateBoundingBox(this.itemsData, tempBoundingBox);
      tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
      tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y; //var tempBoundingBox = this.shapeCont.getBBox();

      if (this.currentBoxContains(tempBoundingBox)) {
        return;
      }

      var changed = false;

      if (this.currentBBox.w !== tempBoundingBox.width) {
        this.currentBBox.w = tempBoundingBox.width;
        this.shapeCont.setAttribute('width', tempBoundingBox.width);
        changed = true;
      }

      if (this.currentBBox.h !== tempBoundingBox.height) {
        this.currentBBox.h = tempBoundingBox.height;
        this.shapeCont.setAttribute('height', tempBoundingBox.height);
        changed = true;
      }

      if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
        this.currentBBox.w = tempBoundingBox.width;
        this.currentBBox.h = tempBoundingBox.height;
        this.currentBBox.x = tempBoundingBox.x;
        this.currentBBox.y = tempBoundingBox.y;
        this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
        this.shapeCont.style.transform = this.shapeCont.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
      }
    }
  };

  function HTextElement(data, globalData, comp) {
    this.textSpans = [];
    this.textPaths = [];
    this.currentBBox = {
      x: 999999,
      y: -999999,
      h: 0,
      w: 0
    };
    this.renderType = 'svg';
    this.isMasked = false;
    this.initElement(data, globalData, comp);
  }

  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);

  HTextElement.prototype.createContent = function () {
    this.isMasked = this.checkMasks();

    if (this.isMasked) {
      this.renderType = 'svg';
      this.compW = this.comp.data.w;
      this.compH = this.comp.data.h;
      this.svgElement.setAttribute('width', this.compW);
      this.svgElement.setAttribute('height', this.compH);
      var g = createNS('g');
      this.maskedElement.appendChild(g);
      this.innerElem = g;
    } else {
      this.renderType = 'html';
      this.innerElem = this.layerElement;
    }

    this.checkParenting();
  };

  HTextElement.prototype.buildNewText = function () {
    var documentData = this.textProperty.currentData;
    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
    var innerElemStyle = this.innerElem.style;
    innerElemStyle.color = innerElemStyle.fill = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';

    if (documentData.sc) {
      innerElemStyle.stroke = this.buildColor(documentData.sc);
      innerElemStyle.strokeWidth = documentData.sw + 'px';
    }

    var fontData = this.globalData.fontManager.getFontByName(documentData.f);

    if (!this.globalData.fontManager.chars) {
      innerElemStyle.fontSize = documentData.finalSize + 'px';
      innerElemStyle.lineHeight = documentData.finalSize + 'px';

      if (fontData.fClass) {
        this.innerElem.className = fontData.fClass;
      } else {
        innerElemStyle.fontFamily = fontData.fFamily;
        var fWeight = documentData.fWeight,
            fStyle = documentData.fStyle;
        innerElemStyle.fontStyle = fStyle;
        innerElemStyle.fontWeight = fWeight;
      }
    }

    var i, len;
    var letters = documentData.l;
    len = letters.length;
    var tSpan, tParent, tCont;
    var matrixHelper = this.mHelper;
    var shapes,
        shapeStr = '';
    var cnt = 0;

    for (i = 0; i < len; i += 1) {
      if (this.globalData.fontManager.chars) {
        if (!this.textPaths[cnt]) {
          tSpan = createNS('path');
          tSpan.setAttribute('stroke-linecap', 'butt');
          tSpan.setAttribute('stroke-linejoin', 'round');
          tSpan.setAttribute('stroke-miterlimit', '4');
        } else {
          tSpan = this.textPaths[cnt];
        }

        if (!this.isMasked) {
          if (this.textSpans[cnt]) {
            tParent = this.textSpans[cnt];
            tCont = tParent.children[0];
          } else {
            tParent = createTag('div');
            tCont = createNS('svg');
            tCont.appendChild(tSpan);
            styleDiv(tParent);
          }
        }
      } else {
        if (!this.isMasked) {
          if (this.textSpans[cnt]) {
            tParent = this.textSpans[cnt];
            tSpan = this.textPaths[cnt];
          } else {
            tParent = createTag('span');
            styleDiv(tParent);
            tSpan = createTag('span');
            styleDiv(tSpan);
            tParent.appendChild(tSpan);
          }
        } else {
          tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
        }
      } //tSpan.setAttribute('visibility', 'hidden');


      if (this.globalData.fontManager.chars) {
        var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
        var shapeData;

        if (charData) {
          shapeData = charData.data;
        } else {
          shapeData = null;
        }

        matrixHelper.reset();

        if (shapeData && shapeData.shapes) {
          shapes = shapeData.shapes[0].it;
          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
          shapeStr = this.createPathShape(matrixHelper, shapes);
          tSpan.setAttribute('d', shapeStr);
        }

        if (!this.isMasked) {
          this.innerElem.appendChild(tParent);

          if (shapeData && shapeData.shapes) {
            //document.body.appendChild is needed to get exact measure of shape
            document.body.appendChild(tCont);
            var boundingBox = tCont.getBBox();
            tCont.setAttribute('width', boundingBox.width + 2);
            tCont.setAttribute('height', boundingBox.height + 2);
            tCont.setAttribute('viewBox', boundingBox.x - 1 + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
            tCont.style.transform = tCont.style.webkitTransform = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
            letters[i].yOffset = boundingBox.y - 1;
          } else {
            tCont.setAttribute('width', 1);
            tCont.setAttribute('height', 1);
          }

          tParent.appendChild(tCont);
        } else {
          this.innerElem.appendChild(tSpan);
        }
      } else {
        tSpan.textContent = letters[i].val;
        tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");

        if (!this.isMasked) {
          this.innerElem.appendChild(tParent); //

          tSpan.style.transform = tSpan.style.webkitTransform = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
        } else {
          this.innerElem.appendChild(tSpan);
        }
      } //


      if (!this.isMasked) {
        this.textSpans[cnt] = tParent;
      } else {
        this.textSpans[cnt] = tSpan;
      }

      this.textSpans[cnt].style.display = 'block';
      this.textPaths[cnt] = tSpan;
      cnt += 1;
    }

    while (cnt < this.textSpans.length) {
      this.textSpans[cnt].style.display = 'none';
      cnt += 1;
    }
  };

  HTextElement.prototype.renderInnerContent = function () {
    if (this.data.singleShape) {
      if (!this._isFirstFrame && !this.lettersChangedFlag) {
        return;
      } else {
        // Todo Benchmark if using this is better than getBBox
        if (this.isMasked && this.finalTransform._matMdf) {
          this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
          this.svgElement.style.transform = this.svgElement.style.webkitTransform = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
        }
      }
    }

    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);

    if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
      return;
    }

    var i,
        len,
        count = 0;
    var renderedLetters = this.textAnimator.renderedLetters;
    var letters = this.textProperty.currentData.l;
    len = letters.length;
    var renderedLetter, textSpan, textPath;

    for (i = 0; i < len; i += 1) {
      if (letters[i].n) {
        count += 1;
        continue;
      }

      textSpan = this.textSpans[i];
      textPath = this.textPaths[i];
      renderedLetter = renderedLetters[count];
      count += 1;

      if (renderedLetter._mdf.m) {
        if (!this.isMasked) {
          textSpan.style.transform = textSpan.style.webkitTransform = renderedLetter.m;
        } else {
          textSpan.setAttribute('transform', renderedLetter.m);
        }
      } ////textSpan.setAttribute('opacity',renderedLetter.o);


      textSpan.style.opacity = renderedLetter.o;

      if (renderedLetter.sw && renderedLetter._mdf.sw) {
        textPath.setAttribute('stroke-width', renderedLetter.sw);
      }

      if (renderedLetter.sc && renderedLetter._mdf.sc) {
        textPath.setAttribute('stroke', renderedLetter.sc);
      }

      if (renderedLetter.fc && renderedLetter._mdf.fc) {
        textPath.setAttribute('fill', renderedLetter.fc);
        textPath.style.color = renderedLetter.fc;
      }
    }

    if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
      var boundingBox = this.innerElem.getBBox();

      if (this.currentBBox.w !== boundingBox.width) {
        this.currentBBox.w = boundingBox.width;
        this.svgElement.setAttribute('width', boundingBox.width);
      }

      if (this.currentBBox.h !== boundingBox.height) {
        this.currentBBox.h = boundingBox.height;
        this.svgElement.setAttribute('height', boundingBox.height);
      }

      var margin = 1;

      if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
        this.currentBBox.w = boundingBox.width + margin * 2;
        this.currentBBox.h = boundingBox.height + margin * 2;
        this.currentBBox.x = boundingBox.x - margin;
        this.currentBBox.y = boundingBox.y - margin;
        this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
        this.svgElement.style.transform = this.svgElement.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
      }
    }
  };

  function HImageElement(data, globalData, comp) {
    this.assetData = globalData.getAssetData(data.refId);
    this.initElement(data, globalData, comp);
  }

  extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);

  HImageElement.prototype.createContent = function () {
    var assetPath = this.globalData.getAssetsPath(this.assetData);
    var img = new Image();

    if (this.data.hasMask) {
      this.imageElem = createNS('image');
      this.imageElem.setAttribute('width', this.assetData.w + "px");
      this.imageElem.setAttribute('height', this.assetData.h + "px");
      this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
      this.layerElement.appendChild(this.imageElem);
      this.baseElement.setAttribute('width', this.assetData.w);
      this.baseElement.setAttribute('height', this.assetData.h);
    } else {
      this.layerElement.appendChild(img);
    }

    img.src = assetPath;

    if (this.data.ln) {
      this.baseElement.setAttribute('id', this.data.ln);
    }
  };

  function HCameraElement(data, globalData, comp) {
    this.initFrame();
    this.initBaseData(data, globalData, comp);
    this.initHierarchy();
    var getProp = PropertyFactory.getProp;
    this.pe = getProp(this, data.pe, 0, 0, this);

    if (data.ks.p.s) {
      this.px = getProp(this, data.ks.p.x, 1, 0, this);
      this.py = getProp(this, data.ks.p.y, 1, 0, this);
      this.pz = getProp(this, data.ks.p.z, 1, 0, this);
    } else {
      this.p = getProp(this, data.ks.p, 1, 0, this);
    }

    if (data.ks.a) {
      this.a = getProp(this, data.ks.a, 1, 0, this);
    }

    if (data.ks.or.k.length && data.ks.or.k[0].to) {
      var i,
          len = data.ks.or.k.length;

      for (i = 0; i < len; i += 1) {
        data.ks.or.k[i].to = null;
        data.ks.or.k[i].ti = null;
      }
    }

    this.or = getProp(this, data.ks.or, 1, degToRads, this);
    this.or.sh = true;
    this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
    this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
    this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
    this.mat = new Matrix();
    this._prevMat = new Matrix();
    this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.

    this.finalTransform = {
      mProp: this
    };
  }

  extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);

  HCameraElement.prototype.setup = function () {
    var i,
        len = this.comp.threeDElements.length,
        comp;

    for (i = 0; i < len; i += 1) {
      //[perspectiveElem,container]
      comp = this.comp.threeDElements[i];

      if (comp.type === '3d') {
        comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v + 'px';
        comp.container.style.transformOrigin = comp.container.style.mozTransformOrigin = comp.container.style.webkitTransformOrigin = "0px 0px 0px";
        comp.perspectiveElem.style.transform = comp.perspectiveElem.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
      }
    }
  };

  HCameraElement.prototype.createElements = function () {};

  HCameraElement.prototype.hide = function () {};

  HCameraElement.prototype.renderFrame = function () {
    var _mdf = this._isFirstFrame;
    var i, len;

    if (this.hierarchy) {
      len = this.hierarchy.length;

      for (i = 0; i < len; i += 1) {
        _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
      }
    }

    if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
      this.mat.reset();

      if (this.hierarchy) {
        var mat;
        len = this.hierarchy.length - 1;

        for (i = len; i >= 0; i -= 1) {
          /*mat = this.hierarchy[i].finalTransform.mProp.v.props;
          console.log(mat)
          this.mat.transform(-mat[0],-mat[1],-mat[2],-mat[3],-mat[4],-mat[5],-mat[6],-mat[7],-mat[8],-mat[9],-mat[10],-mat[11],-mat[12],-mat[13],-mat[14],mat[15]);
          console.log(this.mat.props)*/
          var mTransf = this.hierarchy[i].finalTransform.mProp;
          this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
          this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
          this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
          this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
          this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
        }
      }

      if (this.p) {
        this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
      } else {
        this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
      }

      if (this.a) {
        var diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
        var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)); //var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));

        var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
        var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
        var m_rotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
        var m_rotationY = Math.atan2(lookDir[0], -lookDir[2]);
        this.mat.rotateY(m_rotationY).rotateX(-m_rotationX);
      }

      this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
      this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
      this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
      this.mat.translate(0, 0, this.pe.v);
      var hasMatrixChanged = !this._prevMat.equals(this.mat);

      if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
        len = this.comp.threeDElements.length;
        var comp;

        for (i = 0; i < len; i += 1) {
          comp = this.comp.threeDElements[i];

          if (comp.type === '3d') {
            if (hasMatrixChanged) {
              comp.container.style.transform = comp.container.style.webkitTransform = this.mat.toCSS();
            }

            if (this.pe._mdf) {
              comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v + 'px';
            }
          }
        }

        this.mat.clone(this._prevMat);
      }
    }

    this._isFirstFrame = false;
  };

  HCameraElement.prototype.prepareFrame = function (num) {
    this.prepareProperties(num, true);
  };

  HCameraElement.prototype.destroy = function () {};

  HCameraElement.prototype.getBaseElement = function () {
    return null;
  };

  function HEffects() {}

  HEffects.prototype.renderFrame = function () {};

  var animationManager = function () {
    var moduleOb = {};
    var registeredAnimations = [];
    var initTime = 0;
    var len = 0;
    var playingAnimationsNum = 0;
    var _stopped = true;
    var _isFrozen = false;

    function removeElement(ev) {
      var i = 0;
      var animItem = ev.target;

      while (i < len) {
        if (registeredAnimations[i].animation === animItem) {
          registeredAnimations.splice(i, 1);
          i -= 1;
          len -= 1;

          if (!animItem.isPaused) {
            subtractPlayingCount();
          }
        }

        i += 1;
      }
    }

    function registerAnimation(element, animationData) {
      if (!element) {
        return null;
      }

      var i = 0;

      while (i < len) {
        /**
         * PROTO.IO
         * Added to avoid a single animation being registered multiple times, and to skip animations without an element
         */
        if (registeredAnimations[i].elem !== null) {
          if (registeredAnimations[i].elem == element) {
            return registeredAnimations[i].animation;
          }

          if (registeredAnimations[i].elem.getAttribute('data-name') === element.getAttribute('data-name')) {
            destroy(element.getAttribute('data-name'));
          }
        }

        i += 1;
      }

      var animItem = new AnimationItem();
      setupAnimation(animItem, element);
      animItem.setData(element, animationData);
      return animItem;
    }

    function getRegisteredAnimations() {
      var i,
          len = registeredAnimations.length;
      var animations = [];

      for (i = 0; i < len; i += 1) {
        animations.push(registeredAnimations[i].animation);
      }

      return animations;
    }

    function addPlayingCount() {
      playingAnimationsNum += 1;
      activate();
    }

    function subtractPlayingCount() {
      playingAnimationsNum -= 1;
    }

    function setupAnimation(animItem, element) {
      animItem.addEventListener('destroy', removeElement);
      animItem.addEventListener('_active', addPlayingCount);
      animItem.addEventListener('_idle', subtractPlayingCount);
      registeredAnimations.push({
        elem: element,
        animation: animItem
      });
      len += 1;
    }

    function loadAnimation(params) {
      var animItem = new AnimationItem();
      setupAnimation(animItem, null);
      animItem.setParams(params);
      return animItem;
    }

    function setSpeed(val, animation) {
      var i;

      for (i = 0; i < len; i += 1) {
        registeredAnimations[i].animation.setSpeed(val, animation);
      }
    }

    function setDirection(val, animation) {
      var i;

      for (i = 0; i < len; i += 1) {
        registeredAnimations[i].animation.setDirection(val, animation);
      }
    }

    function play(animation) {
      var i;

      for (i = 0; i < len; i += 1) {
        registeredAnimations[i].animation.play(animation);
      }
    }

    function resume(nowTime) {
      var elapsedTime = nowTime - initTime;
      var i;

      for (i = 0; i < len; i += 1) {
        registeredAnimations[i].animation.advanceTime(elapsedTime);
      }

      initTime = nowTime;

      if (playingAnimationsNum && !_isFrozen) {
        window.requestAnimationFrame(resume);
      } else {
        _stopped = true;
      }
    }

    function first(nowTime) {
      initTime = nowTime;
      window.requestAnimationFrame(resume);
    }

    function pause(animation) {
      var i;

      for (i = 0; i < len; i += 1) {
        registeredAnimations[i].animation.pause(animation);
      }
    }

    function goToAndStop(value, isFrame, animation) {
      var i;

      for (i = 0; i < len; i += 1) {
        registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
      }
    }

    function stop(animation) {
      var i;

      for (i = 0; i < len; i += 1) {
        registeredAnimations[i].animation.stop(animation);
      }
    }

    function togglePause(animation) {
      var i;

      for (i = 0; i < len; i += 1) {
        registeredAnimations[i].animation.togglePause(animation);
      }
    }

    function destroy(animation) {
      var i;

      for (i = len - 1; i >= 0; i -= 1) {
        registeredAnimations[i].animation.destroy(animation);
      }
    }

    function searchAnimations(animationData, standalone, renderer) {
      var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin')));
      var i,
          len = animElements.length;

      for (i = 0; i < len; i += 1) {
        if (renderer) {
          animElements[i].setAttribute('data-bm-type', renderer);
        }

        registerAnimation(animElements[i], animationData);
      }

      if (standalone && len === 0) {
        if (!renderer) {
          renderer = 'svg';
        }

        var body = document.getElementsByTagName('body')[0];
        body.innerHTML = '';
        var div = createTag('div');
        div.style.width = '100%';
        div.style.height = '100%';
        div.setAttribute('data-bm-type', renderer);
        body.appendChild(div);
        registerAnimation(div, animationData);
      }
    }

    function resize() {
      var i;

      for (i = 0; i < len; i += 1) {
        registeredAnimations[i].animation.resize();
      }
    }

    function activate() {
      if (!_isFrozen && playingAnimationsNum) {
        if (_stopped) {
          window.requestAnimationFrame(first);
          _stopped = false;
        }
      }
    }

    function freeze() {
      _isFrozen = true;
    }

    function unfreeze() {
      _isFrozen = false;
      activate();
    }

    moduleOb.registerAnimation = registerAnimation;
    moduleOb.loadAnimation = loadAnimation;
    moduleOb.setSpeed = setSpeed;
    moduleOb.setDirection = setDirection;
    moduleOb.play = play;
    moduleOb.pause = pause;
    moduleOb.stop = stop;
    moduleOb.togglePause = togglePause;
    moduleOb.searchAnimations = searchAnimations;
    moduleOb.resize = resize; //moduleOb.start = start;

    moduleOb.goToAndStop = goToAndStop;
    moduleOb.destroy = destroy;
    moduleOb.freeze = freeze;
    moduleOb.unfreeze = unfreeze;
    moduleOb.getRegisteredAnimations = getRegisteredAnimations;
    return moduleOb;
  }();

  var AnimationItem = function AnimationItem() {
    this._cbs = [];
    this.name = '';
    this.path = '';
    this.isLoaded = false;
    this.currentFrame = 0;
    this.currentRawFrame = 0;
    this.totalFrames = 0;
    this.frameRate = 0;
    this.frameMult = 0;
    this.playSpeed = 1;
    this.playDirection = 1;
    this.playCount = 0;
    this.animationData = {};
    this.assets = [];
    this.isPaused = true;
    this.autoplay = false;
    this.loop = true;
    this.renderer = null;
    this.animationID = createElementID();
    this.assetsPath = '';
    this.timeCompleted = 0;
    this.segmentPos = 0;
    this.subframeEnabled = subframeEnabled;
    this.segments = [];
    this._idle = true;
    this._completedLoop = false;
    this.projectInterface = ProjectInterface();
    this.imagePreloader = new ImagePreloader();
  };

  extendPrototype([BaseEvent], AnimationItem);

  AnimationItem.prototype.setParams = function (params) {
    if (params.context) {
      this.context = params.context;
    }

    if (params.wrapper || params.container) {
      this.wrapper = params.wrapper || params.container;
    }

    var animType = params.animType ? params.animType : params.renderer ? params.renderer : 'svg';

    switch (animType) {
      case 'canvas':
        this.renderer = new CanvasRenderer(this, params.rendererSettings);
        break;

      case 'svg':
        this.renderer = new SVGRenderer(this, params.rendererSettings);
        break;

      default:
        this.renderer = new HybridRenderer(this, params.rendererSettings);
        break;
    }

    this.renderer.setProjectInterface(this.projectInterface);
    this.animType = animType;

    if (params.loop === '' || params.loop === null) {} else if (params.loop === false) {
      this.loop = false;
    } else if (params.loop === true) {
      this.loop = true;
    } else {
      this.loop = parseInt(params.loop);
    }

    this.autoplay = 'autoplay' in params ? params.autoplay : true;
    this.name = params.name ? params.name : '';
    this.autoloadSegments = params.hasOwnProperty('autoloadSegments') ? params.autoloadSegments : true;
    this.assetsPath = params.assetsPath;

    if (params.animationData) {
      this.configAnimation(params.animationData);
    } else if (params.path) {
      /**
       * PROTO.IO
       * Causes issues with Asset Manager by adding "/data.json" at the end of a call regardless of parameters
       */
      // if(params.path.substr(-4) != 'json'){
      //     if (params.path.substr(-1, 1) != '/') {
      //         params.path += '/';
      //     }
      //     params.path += 'data.json';
      // }
      if (params.path.lastIndexOf('\\') != -1) {
        this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
      } else {
        this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
      }

      this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
      this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));
      assetLoader.load(params.path, this.configAnimation.bind(this), function () {
        this.trigger('data_failed');
      }.bind(this));
    }
  };

  AnimationItem.prototype.setData = function (wrapper, animationData) {
    var params = {
      wrapper: wrapper,
      animationData: animationData ? _typeof(animationData) === "object" ? animationData : JSON.parse(animationData) : null
    };
    var wrapperAttributes = wrapper.attributes;
    params.path = wrapperAttributes.getNamedItem('data-animation-path') ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') ? wrapperAttributes.getNamedItem('data-bm-path').value : wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
    params.animType = wrapperAttributes.getNamedItem('data-anim-type') ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') ? wrapperAttributes.getNamedItem('bm-type').value : wrapperAttributes.getNamedItem('data-bm-renderer') ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : 'canvas';
    var loop = wrapperAttributes.getNamedItem('data-anim-loop') ? wrapperAttributes.getNamedItem('data-anim-loop').value : wrapperAttributes.getNamedItem('data-bm-loop') ? wrapperAttributes.getNamedItem('data-bm-loop').value : wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';

    if (loop === '') {} else if (loop === 'false') {
      params.loop = false;
    } else if (loop === 'true') {
      params.loop = true;
    } else {
      params.loop = parseInt(loop);
    }

    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') ? wrapperAttributes.getNamedItem('data-anim-autoplay').value : wrapperAttributes.getNamedItem('data-bm-autoplay') ? wrapperAttributes.getNamedItem('data-bm-autoplay').value : wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
    params.autoplay = autoplay !== "false";
    params.name = wrapperAttributes.getNamedItem('data-name') ? wrapperAttributes.getNamedItem('data-name').value : wrapperAttributes.getNamedItem('data-bm-name') ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value : '';
    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') ? wrapperAttributes.getNamedItem('data-anim-prerender').value : wrapperAttributes.getNamedItem('data-bm-prerender') ? wrapperAttributes.getNamedItem('data-bm-prerender').value : wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';

    if (prerender === 'false') {
      params.prerender = false;
    }

    this.setParams(params);
  };

  AnimationItem.prototype.includeLayers = function (data) {
    if (data.op > this.animationData.op) {
      this.animationData.op = data.op;
      this.totalFrames = Math.floor(data.op - this.animationData.ip);
    }

    var layers = this.animationData.layers;
    var i,
        len = layers.length;
    var newLayers = data.layers;
    var j,
        jLen = newLayers.length;

    for (j = 0; j < jLen; j += 1) {
      i = 0;

      while (i < len) {
        if (layers[i].id == newLayers[j].id) {
          layers[i] = newLayers[j];
          break;
        }

        i += 1;
      }
    }

    if (data.chars || data.fonts) {
      this.renderer.globalData.fontManager.addChars(data.chars);
      this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
    }

    if (data.assets) {
      len = data.assets.length;

      for (i = 0; i < len; i += 1) {
        this.animationData.assets.push(data.assets[i]);
      }
    }

    this.animationData.__complete = false;
    dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);
    this.renderer.includeLayers(data.layers);

    if (expressionsPlugin) {
      expressionsPlugin.initExpressions(this);
    }

    this.loadNextSegment();
  };

  AnimationItem.prototype.loadNextSegment = function () {
    var segments = this.animationData.segments;

    if (!segments || segments.length === 0 || !this.autoloadSegments) {
      this.trigger('data_ready');
      this.timeCompleted = this.totalFrames;
      return;
    }

    var segment = segments.shift();
    this.timeCompleted = segment.time * this.frameRate;
    var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
    this.segmentPos += 1;
    assetLoader.load(segmentPath, this.includeLayers.bind(this), function () {
      this.trigger('data_failed');
    }.bind(this));
  };

  AnimationItem.prototype.loadSegments = function () {
    var segments = this.animationData.segments;

    if (!segments) {
      this.timeCompleted = this.totalFrames;
    }

    this.loadNextSegment();
  };

  AnimationItem.prototype.imagesLoaded = function () {
    this.trigger('loaded_images');
    this.checkLoaded();
  };

  AnimationItem.prototype.preloadImages = function () {
    this.imagePreloader.setAssetsPath(this.assetsPath);
    this.imagePreloader.setPath(this.path);
    this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
  };

  AnimationItem.prototype.configAnimation = function (animData) {
    if (!this.renderer) {
      return;
    }

    animData = animData || {
      layers: []
    };
    this.animationData = animData;
    this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
    this.renderer.configAnimation(animData);

    if (!animData.assets) {
      animData.assets = [];
    }

    this.renderer.searchExtraCompositions(animData.assets);
    this.assets = this.animationData.assets;
    this.frameRate = this.animationData.fr;
    this.firstFrame = Math.round(this.animationData.ip);
    this.frameMult = this.animationData.fr / 1000;
    this.trigger('config_ready');
    this.preloadImages();
    this.loadSegments();
    this.updaFrameModifier();
    this.waitForFontsLoaded();
  };

  AnimationItem.prototype.waitForFontsLoaded = function () {
    if (!this.renderer) {
      return;
    }

    if (this.renderer.globalData.fontManager.loaded()) {
      this.checkLoaded();
    } else {
      setTimeout(this.waitForFontsLoaded.bind(this), 20);
    }
  };

  AnimationItem.prototype.checkLoaded = function () {
    if (!this.isLoaded && this.renderer.globalData.fontManager.loaded() && (this.imagePreloader.loaded() || this.renderer.rendererType !== 'canvas')) {
      this.isLoaded = true;
      dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);

      if (expressionsPlugin) {
        expressionsPlugin.initExpressions(this);
      }

      this.renderer.initItems();
      setTimeout(function () {
        this.trigger('DOMLoaded');
      }.bind(this), 0);
      this.gotoFrame();

      if (this.autoplay) {
        this.play();
      }
    }
  };

  AnimationItem.prototype.resize = function () {
    this.renderer.updateContainerSize();
  };

  AnimationItem.prototype.setSubframe = function (flag) {
    this.subframeEnabled = flag ? true : false;
  };

  AnimationItem.prototype.gotoFrame = function () {
    this.currentFrame = this.subframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;

    if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
      this.currentFrame = this.timeCompleted;
    }

    this.trigger('enterFrame');
    this.renderFrame();
  };

  AnimationItem.prototype.renderFrame = function () {
    if (this.isLoaded === false) {
      return;
    }

    this.renderer.renderFrame(this.currentFrame + this.firstFrame);
  };

  AnimationItem.prototype.play = function (name) {
    if (name && this.name != name) {
      return;
    }

    if (this.isPaused === true) {
      this.isPaused = false;

      if (this._idle) {
        this._idle = false;
        this.trigger('_active');
      }
    }
  };

  AnimationItem.prototype.pause = function (name) {
    if (name && this.name != name) {
      return;
    }

    if (this.isPaused === false) {
      this.isPaused = true;
      this._idle = true;
      this.trigger('_idle');
    }
  };

  AnimationItem.prototype.togglePause = function (name) {
    if (name && this.name != name) {
      return;
    }

    if (this.isPaused === true) {
      this.play();
    } else {
      this.pause();
    }
  };

  AnimationItem.prototype.stop = function (name) {
    if (name && this.name != name) {
      return;
    }

    this.pause();
    this.playCount = 0;
    this._completedLoop = false;
    this.setCurrentRawFrameValue(0);
  };

  AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
    if (name && this.name != name) {
      return;
    }

    if (isFrame) {
      this.setCurrentRawFrameValue(value);
    } else {
      this.setCurrentRawFrameValue(value * this.frameModifier);
    }

    this.pause();
  };

  AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
    this.goToAndStop(value, isFrame, name);
    this.play();
  };

  AnimationItem.prototype.advanceTime = function (value) {
    if (this.isPaused === true || this.isLoaded === false) {
      return;
    }

    var nextValue = this.currentRawFrame + value * this.frameModifier;
    var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
    // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.

    if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
      if (!this.loop || this.playCount === this.loop) {
        if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
          _isComplete = true;
          nextValue = this.totalFrames - 1;
        }
      } else if (nextValue >= this.totalFrames) {
        this.playCount += 1;

        if (!this.checkSegments(nextValue % this.totalFrames)) {
          this.setCurrentRawFrameValue(nextValue % this.totalFrames);
          this._completedLoop = true;
          this.trigger('loopComplete');
        }
      } else {
        this.setCurrentRawFrameValue(nextValue);
      }
    } else if (nextValue < 0) {
      if (!this.checkSegments(nextValue % this.totalFrames)) {
        if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
          this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);

          if (!this._completedLoop) {
            this._completedLoop = true;
          } else {
            this.trigger('loopComplete');
          }
        } else {
          _isComplete = true;
          nextValue = 0;
        }
      }
    } else {
      this.setCurrentRawFrameValue(nextValue);
    }

    if (_isComplete) {
      this.setCurrentRawFrameValue(nextValue);
      this.pause();
      this.trigger('complete');
    }
  };

  AnimationItem.prototype.adjustSegment = function (arr, offset) {
    this.playCount = 0;

    if (arr[1] < arr[0]) {
      if (this.frameModifier > 0) {
        if (this.playSpeed < 0) {
          this.setSpeed(-this.playSpeed);
        } else {
          this.setDirection(-1);
        }
      }

      this.timeCompleted = this.totalFrames = arr[0] - arr[1];
      this.firstFrame = arr[1];
      this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
    } else if (arr[1] > arr[0]) {
      if (this.frameModifier < 0) {
        if (this.playSpeed < 0) {
          this.setSpeed(-this.playSpeed);
        } else {
          this.setDirection(1);
        }
      }

      this.timeCompleted = this.totalFrames = arr[1] - arr[0];
      this.firstFrame = arr[0];
      this.setCurrentRawFrameValue(0.001 + offset);
    }

    this.trigger('segmentStart');
  };

  AnimationItem.prototype.setSegment = function (init, end) {
    var pendingFrame = -1;

    if (this.isPaused) {
      if (this.currentRawFrame + this.firstFrame < init) {
        pendingFrame = init;
      } else if (this.currentRawFrame + this.firstFrame > end) {
        pendingFrame = end - init;
      }
    }

    this.firstFrame = init;
    this.timeCompleted = this.totalFrames = end - init;

    if (pendingFrame !== -1) {
      this.goToAndStop(pendingFrame, true);
    }
  };

  AnimationItem.prototype.playSegments = function (arr, forceFlag) {
    if (forceFlag) {
      this.segments.length = 0;
    }

    if (_typeof(arr[0]) === 'object') {
      var i,
          len = arr.length;

      for (i = 0; i < len; i += 1) {
        this.segments.push(arr[i]);
      }
    } else {
      this.segments.push(arr);
    }

    if (this.segments.length && forceFlag) {
      this.adjustSegment(this.segments.shift(), 0);
    }

    if (this.isPaused) {
      this.play();
    }
  };

  AnimationItem.prototype.resetSegments = function (forceFlag) {
    this.segments.length = 0;
    this.segments.push([this.animationData.ip, this.animationData.op]); //this.segments.push([this.animationData.ip*this.frameRate,Math.floor(this.animationData.op - this.animationData.ip+this.animationData.ip*this.frameRate)]);

    if (forceFlag) {
      this.checkSegments(0);
    }
  };

  AnimationItem.prototype.checkSegments = function (offset) {
    if (this.segments.length) {
      this.adjustSegment(this.segments.shift(), offset);
      return true;
    }

    return false;
  };

  AnimationItem.prototype.destroy = function (name) {
    if (name && this.name != name || !this.renderer) {
      return;
    }

    this.renderer.destroy();
    this.imagePreloader.destroy();
    this.trigger('destroy');
    this._cbs = null;
    this.onEnterFrame = this.onLoopComplete = this.onComplete = this.onSegmentStart = this.onDestroy = null;
    this.renderer = null;
  };

  AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
    this.currentRawFrame = value;
    this.gotoFrame();
  };

  AnimationItem.prototype.setSpeed = function (val) {
    this.playSpeed = val;
    this.updaFrameModifier();
  };

  AnimationItem.prototype.setDirection = function (val) {
    this.playDirection = val < 0 ? -1 : 1;
    this.updaFrameModifier();
  };

  AnimationItem.prototype.updaFrameModifier = function () {
    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
  };

  AnimationItem.prototype.getPath = function () {
    return this.path;
  };

  AnimationItem.prototype.getAssetsPath = function (assetData) {
    var path = '';

    if (assetData.e) {
      path = assetData.p;
    } else if (this.assetsPath) {
      var imagePath = assetData.p;

      if (imagePath.indexOf('images/') !== -1) {
        imagePath = imagePath.split('/')[1];
      }

      path = this.assetsPath + imagePath;
    } else {
      path = this.path;
      path += assetData.u ? assetData.u : '';
      path += assetData.p;
    }

    return path;
  };

  AnimationItem.prototype.getAssetData = function (id) {
    var i = 0,
        len = this.assets.length;

    while (i < len) {
      if (id == this.assets[i].id) {
        return this.assets[i];
      }

      i += 1;
    }
  };

  AnimationItem.prototype.hide = function () {
    this.renderer.hide();
  };

  AnimationItem.prototype.show = function () {
    this.renderer.show();
  };

  AnimationItem.prototype.getDuration = function (isFrame) {
    return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
  };

  AnimationItem.prototype.trigger = function (name) {
    if (this._cbs && this._cbs[name]) {
      switch (name) {
        case 'enterFrame':
          this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
          break;

        case 'loopComplete':
          this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
          break;

        case 'complete':
          this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
          break;

        case 'segmentStart':
          this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
          break;

        case 'destroy':
          this.triggerEvent(name, new BMDestroyEvent(name, this));
          break;

        default:
          this.triggerEvent(name);
      }
    }

    if (name === 'enterFrame' && this.onEnterFrame) {
      this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
    }

    if (name === 'loopComplete' && this.onLoopComplete) {
      this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
    }

    if (name === 'complete' && this.onComplete) {
      this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
    }

    if (name === 'segmentStart' && this.onSegmentStart) {
      this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
    }

    if (name === 'destroy' && this.onDestroy) {
      this.onDestroy.call(this, new BMDestroyEvent(name, this));
    }
  };

  var Expressions = function () {
    var ob = {};
    ob.initExpressions = initExpressions;

    function initExpressions(animation) {
      var stackCount = 0;
      var registers = [];

      function pushExpression() {
        stackCount += 1;
      }

      function popExpression() {
        stackCount -= 1;

        if (stackCount === 0) {
          releaseInstances();
        }
      }

      function registerExpressionProperty(expression) {
        if (registers.indexOf(expression) === -1) {
          registers.push(expression);
        }
      }

      function releaseInstances() {
        var i,
            len = registers.length;

        for (i = 0; i < len; i += 1) {
          registers[i].release();
        }

        registers.length = 0;
      }

      animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
      animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
      animation.renderer.globalData.pushExpression = pushExpression;
      animation.renderer.globalData.popExpression = popExpression;
      animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
    }

    return ob;
  }();

  expressionsPlugin = Expressions;

  var ExpressionManager = function () {
    'use strict';

    var ob = {};
    var Math = BMMath;
    var window = null;
    var document = null;

    function $bm_isInstanceOfArray(arr) {
      /**
       * PROTO.IO
       * "arr" is sometimes undefined
       */
      return arr && (arr.constructor === Array || arr.constructor === Float32Array);
    }

    function isNumerable(tOfV, v) {
      return tOfV === 'number' || tOfV === 'boolean' || tOfV === 'string' || v instanceof Number;
    }

    function $bm_neg(a) {
      var tOfA = _typeof(a);

      if (tOfA === 'number' || tOfA === 'boolean' || a instanceof Number) {
        return -a;
      }

      if ($bm_isInstanceOfArray(a)) {
        var i,
            lenA = a.length;
        var retArr = [];

        for (i = 0; i < lenA; i += 1) {
          retArr[i] = -a[i];
        }

        return retArr;
      }

      if (a.propType) {
        return a.v;
      }
    }

    var easeInBez = BezierFactory.getBezierEasing(0.333, 0, .833, .833, 'easeIn').get;
    var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, .667, 1, 'easeOut').get;
    var easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, 'easeInOut').get;

    function sum(a, b) {
      var tOfA = _typeof(a);

      var tOfB = _typeof(b);

      if (tOfA === 'string' || tOfB === 'string') {
        return a + b;
      }

      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
        return a + b;
      }

      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
        a = a.slice(0);
        a[0] = a[0] + b;
        return a;
      }

      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
        b = b.slice(0);
        b[0] = a + b[0];
        return b;
      }

      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
        var i = 0,
            lenA = a.length,
            lenB = b.length;
        var retArr = [];

        while (i < lenA || i < lenB) {
          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
            retArr[i] = a[i] + b[i];
          } else {
            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
          }

          i += 1;
        }

        return retArr;
      }

      return 0;
    }

    var add = sum;

    function sub(a, b) {
      var tOfA = _typeof(a);

      var tOfB = _typeof(b);

      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
        if (tOfA === 'string') {
          a = parseInt(a);
        }

        if (tOfB === 'string') {
          b = parseInt(b);
        }

        return a - b;
      }

      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
        a = a.slice(0);
        a[0] = a[0] - b;
        return a;
      }

      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
        b = b.slice(0);
        b[0] = a - b[0];
        return b;
      }

      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
        var i = 0,
            lenA = a.length,
            lenB = b.length;
        var retArr = [];

        while (i < lenA || i < lenB) {
          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
            retArr[i] = a[i] - b[i];
          } else {
            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
          }

          i += 1;
        }

        return retArr;
      }

      return 0;
    }

    function mul(a, b) {
      var tOfA = _typeof(a);

      var tOfB = _typeof(b);

      var arr;

      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
        return a * b;
      }

      var i, len;

      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
        len = a.length;
        arr = createTypedArray('float32', len);

        for (i = 0; i < len; i += 1) {
          arr[i] = a[i] * b;
        }

        return arr;
      }

      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
        len = b.length;
        arr = createTypedArray('float32', len);

        for (i = 0; i < len; i += 1) {
          arr[i] = a * b[i];
        }

        return arr;
      }

      return 0;
    }

    function div(a, b) {
      var tOfA = _typeof(a);

      var tOfB = _typeof(b);

      var arr;

      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
        return a / b;
      }

      var i, len;

      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
        len = a.length;
        arr = createTypedArray('float32', len);

        for (i = 0; i < len; i += 1) {
          arr[i] = a[i] / b;
        }

        return arr;
      }

      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
        len = b.length;
        arr = createTypedArray('float32', len);

        for (i = 0; i < len; i += 1) {
          arr[i] = a / b[i];
        }

        return arr;
      }

      return 0;
    }

    function mod(a, b) {
      if (typeof a === 'string') {
        a = parseInt(a);
      }

      if (typeof b === 'string') {
        b = parseInt(b);
      }

      return a % b;
    }

    var $bm_sum = sum;
    var $bm_sub = sub;
    var $bm_mul = mul;
    var $bm_div = div;
    var $bm_mod = mod;

    function clamp(num, min, max) {
      if (min > max) {
        var mm = max;
        max = min;
        min = mm;
      }

      return Math.min(Math.max(num, min), max);
    }

    function radiansToDegrees(val) {
      return val / degToRads;
    }

    var radians_to_degrees = radiansToDegrees;

    function degreesToRadians(val) {
      return val * degToRads;
    }

    var degrees_to_radians = radiansToDegrees;
    var helperLengthArray = [0, 0, 0, 0, 0, 0];

    function length(arr1, arr2) {
      if (typeof arr1 === 'number' || arr1 instanceof Number) {
        arr2 = arr2 || 0;
        return Math.abs(arr1 - arr2);
      }

      if (!arr2) {
        arr2 = helperLengthArray;
      }

      var i,
          len = Math.min(arr1.length, arr2.length);
      var addedLength = 0;

      for (i = 0; i < len; i += 1) {
        addedLength += Math.pow(arr2[i] - arr1[i], 2);
      }

      return Math.sqrt(addedLength);
    }

    function normalize(vec) {
      return div(vec, length(vec));
    }

    function rgbToHsl(val) {
      var r = val[0];
      var g = val[1];
      var b = val[2];
      var max = Math.max(r, g, b),
          min = Math.min(r, g, b);
      var h,
          s,
          l = (max + min) / 2;

      if (max == min) {
        h = s = 0; // achromatic
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;

          case g:
            h = (b - r) / d + 2;
            break;

          case b:
            h = (r - g) / d + 4;
            break;
        }

        h /= 6;
      }

      return [h, s, l, val[3]];
    }

    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    function hslToRgb(val) {
      var h = val[0];
      var s = val[1];
      var l = val[2];
      var r, g, b;

      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }

      return [r, g, b, val[3]];
    }

    function linear(t, tMin, tMax, value1, value2) {
      if (value1 === undefined || value2 === undefined) {
        value1 = tMin;
        value2 = tMax;
        tMin = 0;
        tMax = 1;
      }

      if (tMax < tMin) {
        var _tMin = tMax;
        tMax = tMin;
        tMin = _tMin;
      }

      if (t <= tMin) {
        return value1;
      } else if (t >= tMax) {
        return value2;
      }

      var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);

      if (!value1.length) {
        return value1 + (value2 - value1) * perc;
      }

      var i,
          len = value1.length;
      var arr = createTypedArray('float32', len);

      for (i = 0; i < len; i += 1) {
        arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
      }

      return arr;
    }

    function random(min, max) {
      if (max === undefined) {
        if (min === undefined) {
          min = 0;
          max = 1;
        } else {
          max = min;
          min = undefined;
        }
      }

      if (max.length) {
        var i,
            len = max.length;

        if (!min) {
          min = createTypedArray('float32', len);
        }

        var arr = createTypedArray('float32', len);
        var rnd = BMMath.random();

        for (i = 0; i < len; i += 1) {
          arr[i] = min[i] + rnd * (max[i] - min[i]);
        }

        return arr;
      }

      if (min === undefined) {
        min = 0;
      }

      var rndm = BMMath.random();
      return min + rndm * (max - min);
    }

    function createPath(points, inTangents, outTangents, closed) {
      var i,
          len = points.length;
      var path = shape_pool.newElement();
      path.setPathData(!!closed, len);
      var arrPlaceholder = [0, 0],
          inVertexPoint,
          outVertexPoint;

      for (i = 0; i < len; i += 1) {
        inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
        outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
        path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
      }

      return path;
    }

    function initiateExpression(elem, data, property) {
      var val = data.x;
      var needsVelocity = /velocity(?![\w\d])/.test(val);

      var _needsRandom = val.indexOf('random') !== -1;

      var elemType = elem.data.ty;
      var transform, $bm_transform, content, effect;
      var thisProperty = property;
      thisProperty.valueAtTime = thisProperty.getValueAtTime;
      Object.defineProperty(thisProperty, 'value', {
        get: function get() {
          return thisProperty.v;
        }
      });
      elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
      elem.comp.displayStartTime = 0;
      var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
      var outPoint = elem.data.op / elem.comp.globalData.frameRate;
      var width = elem.data.sw ? elem.data.sw : 0;
      var height = elem.data.sh ? elem.data.sh : 0;
      var name = elem.data.nm;
      var loopIn, loop_in, loopOut, loop_out, smooth;
      var toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime;
      var __expression_functions = [];

      if (data.xf) {
        var i,
            len = data.xf.length;

        for (i = 0; i < len; i += 1) {
          __expression_functions[i] = eval('(function(){ return ' + data.xf[i] + '}())');
        }
      }

      var scoped_bm_rt;
      var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}' + ']')[0];
      var numKeys = property.kf ? data.k.length : 0;
      var active = !this.data || this.data.hd !== true;

      var wiggle = function wiggle(freq, amp) {
        var i,
            j,
            len = this.pv.length ? this.pv.length : 1;
        var addedAmps = createTypedArray('float32', len);
        freq = 5;
        var iterations = Math.floor(time * freq);
        i = 0;
        j = 0;

        while (i < iterations) {
          //var rnd = BMMath.random();
          for (j = 0; j < len; j += 1) {
            addedAmps[j] += -amp + amp * 2 * BMMath.random(); //addedAmps[j] += -amp + amp*2*rnd;
          }

          i += 1;
        } //var rnd2 = BMMath.random();


        var periods = time * freq;
        var perc = periods - Math.floor(periods);
        var arr = createTypedArray('float32', len);

        if (len > 1) {
          for (j = 0; j < len; j += 1) {
            arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc; //arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
            //arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
          }

          return arr;
        } else {
          return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
        }
      }.bind(this);

      if (thisProperty.loopIn) {
        loopIn = thisProperty.loopIn.bind(thisProperty);
        loop_in = loopIn;
      }

      if (thisProperty.loopOut) {
        loopOut = thisProperty.loopOut.bind(thisProperty);
        loop_out = loopOut;
      }

      if (thisProperty.smooth) {
        smooth = thisProperty.smooth.bind(thisProperty);
      }

      function loopInDuration(type, duration) {
        return loopIn(type, duration, true);
      }

      function loopOutDuration(type, duration) {
        return loopOut(type, duration, true);
      }

      if (this.getValueAtTime) {
        valueAtTime = this.getValueAtTime.bind(this);
      }

      if (this.getVelocityAtTime) {
        velocityAtTime = this.getVelocityAtTime.bind(this);
      }

      var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

      function lookAt(elem1, elem2) {
        var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
        var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
        var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
        return [yaw, pitch, 0];
      }

      function easeOut(t, tMin, tMax, val1, val2) {
        return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
      }

      function easeIn(t, tMin, tMax, val1, val2) {
        return applyEase(easeInBez, t, tMin, tMax, val1, val2);
      }

      function ease(t, tMin, tMax, val1, val2) {
        return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
      }

      function applyEase(fn, t, tMin, tMax, val1, val2) {
        if (val1 === undefined) {
          val1 = tMin;
          val2 = tMax;
        } else {
          t = (t - tMin) / (tMax - tMin);
        }

        t = t > 1 ? 1 : t < 0 ? 0 : t;
        var mult = fn(t);

        if ($bm_isInstanceOfArray(val1)) {
          var i,
              len = val1.length;
          var arr = createTypedArray('float32', len);

          for (i = 0; i < len; i += 1) {
            arr[i] = (val2[i] - val1[i]) * mult + val1[i];
          }

          return arr;
        } else {
          return (val2 - val1) * mult + val1;
        }
      }

      function nearestKey(time) {
        var i,
            len = data.k.length,
            index,
            keyTime;

        if (!data.k.length || typeof data.k[0] === 'number') {
          index = 0;
          keyTime = 0;
        } else {
          index = -1;
          time *= elem.comp.globalData.frameRate;

          if (time < data.k[0].t) {
            index = 1;
            keyTime = data.k[0].t;
          } else {
            for (i = 0; i < len - 1; i += 1) {
              if (time === data.k[i].t) {
                index = i + 1;
                keyTime = data.k[i].t;
                break;
              } else if (time > data.k[i].t && time < data.k[i + 1].t) {
                if (time - data.k[i].t > data.k[i + 1].t - time) {
                  index = i + 2;
                  keyTime = data.k[i + 1].t;
                } else {
                  index = i + 1;
                  keyTime = data.k[i].t;
                }

                break;
              }
            }

            if (index === -1) {
              index = i + 1;
              keyTime = data.k[i].t;
            }
          }
        }

        var ob = {};
        ob.index = index;
        ob.time = keyTime / elem.comp.globalData.frameRate;
        return ob;
      }

      function key(ind) {
        var ob, i, len;

        if (!data.k.length || typeof data.k[0] === 'number') {
          throw new Error('The property has no keyframe at index ' + ind);
        }

        ind -= 1;
        ob = {
          time: data.k[ind].t / elem.comp.globalData.frameRate,
          value: []
        };
        var arr;
        /**
         * PROTO.IO
         * "arr" is sometimes undefined on specific lottie files, so setting it to empty array
         */

        if (ind === data.k.length - 1 && !data.k[ind].h) {
          arr = (data.k[ind].s || data.k[ind].s === 0 ? data.k[ind - 1].s : data.k[ind].e) || [];
        } else {
          arr = data.k[ind].s || [];
        }

        len = arr.length;

        for (i = 0; i < len; i += 1) {
          ob[i] = arr[i];
          ob.value[i] = arr[i];
        }

        return ob;
      }

      function framesToTime(frames, fps) {
        if (!fps) {
          fps = elem.comp.globalData.frameRate;
        }

        return frames / fps;
      }

      function timeToFrames(t, fps) {
        if (!t && t !== 0) {
          t = time;
        }

        if (!fps) {
          fps = elem.comp.globalData.frameRate;
        }

        return t * fps;
      }

      function seedRandom(seed) {
        BMMath.seedrandom(randSeed + seed);
      }

      function sourceRectAtTime() {
        return elem.sourceRectAtTime();
      }

      function substring(init, end) {
        if (typeof value === 'string') {
          if (end === undefined) {
            return value.substring(init);
          }

          return value.substring(init, end);
        }

        return '';
      }

      function substr(init, end) {
        if (typeof value === 'string') {
          if (end === undefined) {
            return value.substr(init);
          }

          return value.substr(init, end);
        }

        return '';
      }

      var time, velocity, value, text, textIndex, textTotal, selectorValue;
      var index = elem.data.ind;
      var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
      var parent;
      var randSeed = Math.floor(Math.random() * 1000000);
      var globalData = elem.globalData;

      function executeExpression(_value) {
        // globalData.pushExpression();
        value = _value;

        if (_needsRandom) {
          seedRandom(randSeed);
        }

        if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
          return value;
        }

        if (this.propType === 'textSelector') {
          textIndex = this.textIndex;
          textTotal = this.textTotal;
          selectorValue = this.selectorValue;
        }

        if (!thisLayer) {
          text = elem.layerInterface.text;
          thisLayer = elem.layerInterface;
          thisComp = elem.comp.compInterface;
          toWorld = thisLayer.toWorld.bind(thisLayer);
          fromWorld = thisLayer.fromWorld.bind(thisLayer);
          fromComp = thisLayer.fromComp.bind(thisLayer);
          toComp = thisLayer.toComp.bind(thisLayer);
          mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
          fromCompToSurface = fromComp;
        }

        if (!transform) {
          transform = elem.layerInterface("ADBE Transform Group");
          $bm_transform = transform;

          if (transform) {
            anchorPoint = transform.anchorPoint;
            /*position = transform.position;
            rotation = transform.rotation;
            scale = transform.scale;*/
          }
        }

        if (elemType === 4 && !content) {
          content = thisLayer("ADBE Root Vectors Group");
        }

        if (!effect) {
          effect = thisLayer(4);
        }

        hasParent = !!(elem.hierarchy && elem.hierarchy.length);

        if (hasParent && !parent) {
          parent = elem.hierarchy[0].layerInterface;
        }

        time = this.comp.renderedFrame / this.comp.globalData.frameRate;

        if (needsVelocity) {
          velocity = velocityAtTime(time);
        }

        expression_function();
        this.frameExpressionId = elem.globalData.frameId; //TODO: Check if it's possible to return on ShapeInterface the .v value

        if (scoped_bm_rt.propType === "shape") {
          scoped_bm_rt = scoped_bm_rt.v;
        } // globalData.popExpression();


        return scoped_bm_rt;
      }

      return executeExpression;
    }

    ob.initiateExpression = initiateExpression;
    return ob;
  }();

  var expressionHelpers = function () {
    function searchExpressions(elem, data, prop) {
      if (data.x) {
        prop.k = true;
        prop.x = true;
        prop.initiateExpression = ExpressionManager.initiateExpression;
        prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
      }
    }

    function getValueAtTime(frameNum) {
      frameNum *= this.elem.globalData.frameRate;
      frameNum -= this.offsetTime;

      if (frameNum !== this._cachingAtTime.lastFrame) {
        this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
        this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
        this._cachingAtTime.lastFrame = frameNum;
      }

      return this._cachingAtTime.value;
    }

    function getSpeedAtTime(frameNum) {
      var delta = -0.01;
      var v1 = this.getValueAtTime(frameNum);
      var v2 = this.getValueAtTime(frameNum + delta);
      var speed = 0;

      if (v1.length) {
        var i;

        for (i = 0; i < v1.length; i += 1) {
          speed += Math.pow(v2[i] - v1[i], 2);
        }

        speed = Math.sqrt(speed) * 100;
      } else {
        speed = 0;
      }

      return speed;
    }

    function getVelocityAtTime(frameNum) {
      if (this.vel !== undefined) {
        return this.vel;
      }

      var delta = -0.001; //frameNum += this.elem.data.st;

      var v1 = this.getValueAtTime(frameNum);
      var v2 = this.getValueAtTime(frameNum + delta);
      var velocity;

      if (v1.length) {
        velocity = createTypedArray('float32', v1.length);
        var i;

        for (i = 0; i < v1.length; i += 1) {
          //removing frameRate
          //if needed, don't add it here
          //velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
          velocity[i] = (v2[i] - v1[i]) / delta;
        }
      } else {
        velocity = (v2 - v1) / delta;
      }

      return velocity;
    }

    function getStaticValueAtTime() {
      return this.pv;
    }

    function setGroupProperty(propertyGroup) {
      this.propertyGroup = propertyGroup;
    }

    return {
      searchExpressions: searchExpressions,
      getSpeedAtTime: getSpeedAtTime,
      getVelocityAtTime: getVelocityAtTime,
      getValueAtTime: getValueAtTime,
      getStaticValueAtTime: getStaticValueAtTime,
      setGroupProperty: setGroupProperty
    };
  }();

  (function addPropertyDecorator() {
    function loopOut(type, duration, durationFlag) {
      if (!this.k || !this.keyframes) {
        return this.pv;
      }

      type = type ? type.toLowerCase() : '';
      var currentFrame = this.comp.renderedFrame;
      var keyframes = this.keyframes;
      var lastKeyFrame = keyframes[keyframes.length - 1].t;

      if (currentFrame <= lastKeyFrame) {
        return this.pv;
      } else {
        var cycleDuration, firstKeyFrame;

        if (!durationFlag) {
          if (!duration || duration > keyframes.length - 1) {
            duration = keyframes.length - 1;
          }

          firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
          cycleDuration = lastKeyFrame - firstKeyFrame;
        } else {
          if (!duration) {
            cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
          } else {
            cycleDuration = Math.abs(lastKeyFrame - elem.comp.globalData.frameRate * duration);
          }

          firstKeyFrame = lastKeyFrame - cycleDuration;
        }

        var i, len, ret;

        if (type === 'pingpong') {
          var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);

          if (iterations % 2 !== 0) {
            return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          }
        } else if (type === 'offset') {
          var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);

          if (this.pv.length) {
            ret = new Array(initV.length);
            len = ret.length;

            for (i = 0; i < len; i += 1) {
              ret[i] = (endV[i] - initV[i]) * repeats + current[i];
            }

            return ret;
          }

          return (endV - initV) * repeats + current;
        } else if (type === 'continue') {
          var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);

          if (this.pv.length) {
            ret = new Array(lastValue.length);
            len = ret.length;

            for (i = 0; i < len; i += 1) {
              ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005;
            }

            return ret;
          }

          return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);
        }

        return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
      }
    }

    function loopIn(type, duration, durationFlag) {
      if (!this.k) {
        return this.pv;
      }

      type = type ? type.toLowerCase() : '';
      var currentFrame = this.comp.renderedFrame;
      var keyframes = this.keyframes;
      var firstKeyFrame = keyframes[0].t;

      if (currentFrame >= firstKeyFrame) {
        return this.pv;
      } else {
        var cycleDuration, lastKeyFrame;

        if (!durationFlag) {
          if (!duration || duration > keyframes.length - 1) {
            duration = keyframes.length - 1;
          }

          lastKeyFrame = keyframes[duration].t;
          cycleDuration = lastKeyFrame - firstKeyFrame;
        } else {
          if (!duration) {
            cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
          } else {
            cycleDuration = Math.abs(elem.comp.globalData.frameRate * duration);
          }

          lastKeyFrame = firstKeyFrame + cycleDuration;
        }

        var i, len, ret;

        if (type === 'pingpong') {
          var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);

          if (iterations % 2 === 0) {
            return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          }
        } else if (type === 'offset') {
          var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;

          if (this.pv.length) {
            ret = new Array(initV.length);
            len = ret.length;

            for (i = 0; i < len; i += 1) {
              ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
            }

            return ret;
          }

          return current - (endV - initV) * repeats;
        } else if (type === 'continue') {
          var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);

          if (this.pv.length) {
            ret = new Array(firstValue.length);
            len = ret.length;

            for (i = 0; i < len; i += 1) {
              ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;
            }

            return ret;
          }

          return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;
        }

        return this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
      }
    }

    function smooth(width, samples) {
      if (!this.k) {
        return this.pv;
      }

      width = (width || 0.4) * 0.5;
      samples = Math.floor(samples || 5);

      if (samples <= 1) {
        return this.pv;
      }

      var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
      var initFrame = currentTime - width;
      var endFrame = currentTime + width;
      var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
      var i = 0,
          j = 0;
      var value;

      if (this.pv.length) {
        value = createTypedArray('float32', this.pv.length);
      } else {
        value = 0;
      }

      var sampleValue;

      while (i < samples) {
        sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);

        if (this.pv.length) {
          for (j = 0; j < this.pv.length; j += 1) {
            value[j] += sampleValue[j];
          }
        } else {
          value += sampleValue;
        }

        i += 1;
      }

      if (this.pv.length) {
        for (j = 0; j < this.pv.length; j += 1) {
          value[j] /= samples;
        }
      } else {
        value /= samples;
      }

      return value;
    }

    function getValueAtTime(frameNum) {
      frameNum *= this.elem.globalData.frameRate;
      frameNum -= this.offsetTime;

      if (frameNum !== this._cachingAtTime.lastFrame) {
        this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
        this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
        this._cachingAtTime.lastFrame = frameNum;
      }

      return this._cachingAtTime.value;
    }

    function getTransformValueAtTime(time) {
      console.warn('Transform at time not supported');
    }

    function getTransformStaticValueAtTime(time) {}

    var getTransformProperty = TransformPropertyFactory.getTransformProperty;

    TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
      var prop = getTransformProperty(elem, data, container);

      if (prop.dynamicProperties.length) {
        prop.getValueAtTime = getTransformValueAtTime.bind(prop);
      } else {
        prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
      }

      prop.setGroupProperty = expressionHelpers.setGroupProperty;
      return prop;
    };

    var propertyGetProp = PropertyFactory.getProp;

    PropertyFactory.getProp = function (elem, data, type, mult, container) {
      var prop = propertyGetProp(elem, data, type, mult, container); //prop.getVelocityAtTime = getVelocityAtTime;
      //prop.loopOut = loopOut;
      //prop.loopIn = loopIn;

      if (prop.kf) {
        prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
      } else {
        prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
      }

      prop.setGroupProperty = expressionHelpers.setGroupProperty;
      prop.loopOut = loopOut;
      prop.loopIn = loopIn;
      prop.smooth = smooth;
      prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
      prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
      prop.numKeys = data.a === 1 ? data.k.length : 0;
      prop.propertyIndex = data.ix;
      var value = 0;

      if (type !== 0) {
        value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
      }

      prop._cachingAtTime = {
        lastFrame: initialDefaultFrame,
        lastIndex: 0,
        value: value
      };
      expressionHelpers.searchExpressions(elem, data, prop);

      if (prop.k) {
        container.addDynamicProperty(prop);
      }

      return prop;
    };

    function getShapeValueAtTime(frameNum) {
      //For now this caching object is created only when needed instead of creating it when the shape is initialized.
      if (!this._cachingAtTime) {
        this._cachingAtTime = {
          shapeValue: shape_pool.clone(this.pv),
          lastIndex: 0,
          lastTime: initialDefaultFrame
        };
      }

      frameNum *= this.elem.globalData.frameRate;
      frameNum -= this.offsetTime;

      if (frameNum !== this._cachingAtTime.lastTime) {
        this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
        this._cachingAtTime.lastTime = frameNum;
        this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
      }

      return this._cachingAtTime.shapeValue;
    }

    var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
    var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

    function ShapeExpressions() {}

    ShapeExpressions.prototype = {
      vertices: function vertices(prop, time) {
        if (this.k) {
          this.getValue();
        }

        var shapePath = this.v;

        if (time !== undefined) {
          shapePath = this.getValueAtTime(time, 0);
        }

        var i,
            len = shapePath._length;
        var vertices = shapePath[prop];
        var points = shapePath.v;
        var arr = createSizedArray(len);

        for (i = 0; i < len; i += 1) {
          if (prop === 'i' || prop === 'o') {
            arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
          } else {
            arr[i] = [vertices[i][0], vertices[i][1]];
          }
        }

        return arr;
      },
      points: function points(time) {
        return this.vertices('v', time);
      },
      inTangents: function inTangents(time) {
        return this.vertices('i', time);
      },
      outTangents: function outTangents(time) {
        return this.vertices('o', time);
      },
      isClosed: function isClosed() {
        return this.v.c;
      },
      pointOnPath: function pointOnPath(perc, time) {
        var shapePath = this.v;

        if (time !== undefined) {
          shapePath = this.getValueAtTime(time, 0);
        }

        if (!this._segmentsLength) {
          this._segmentsLength = bez.getSegmentsLength(shapePath);
        }

        var segmentsLength = this._segmentsLength;
        var lengths = segmentsLength.lengths;
        var lengthPos = segmentsLength.totalLength * perc;
        var i = 0,
            len = lengths.length;
        var j = 0,
            jLen;
        var accumulatedLength = 0,
            pt;

        while (i < len) {
          if (accumulatedLength + lengths[i].addedLength > lengthPos) {
            var initIndex = i;
            var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
            var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
            pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
            break;
          } else {
            accumulatedLength += lengths[i].addedLength;
          }

          i += 1;
        }

        if (!pt) {
          pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
        }

        return pt;
      },
      vectorOnPath: function vectorOnPath(perc, time, vectorType) {
        //perc doesn't use triple equality because it can be a Number object as well as a primitive.
        perc = perc == 1 ? this.v.c ? 0 : 0.999 : perc;
        var pt1 = this.pointOnPath(perc, time);
        var pt2 = this.pointOnPath(perc + 0.001, time);
        var xLength = pt2[0] - pt1[0];
        var yLength = pt2[1] - pt1[1];
        var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
        var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
        return unitVector;
      },
      tangentOnPath: function tangentOnPath(perc, time) {
        return this.vectorOnPath(perc, time, 'tangent');
      },
      normalOnPath: function normalOnPath(perc, time) {
        return this.vectorOnPath(perc, time, 'normal');
      },
      setGroupProperty: expressionHelpers.setGroupProperty,
      getValueAtTime: expressionHelpers.getStaticValueAtTime
    };
    extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
    extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
    KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
    KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;

    ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
      var prop = propertyGetShapeProp(elem, data, type, arr, trims);
      prop.propertyIndex = data.ix;
      prop.lock = false;

      if (type === 3) {
        expressionHelpers.searchExpressions(elem, data.pt, prop);
      } else if (type === 4) {
        expressionHelpers.searchExpressions(elem, data.ks, prop);
      }

      if (prop.k) {
        elem.addDynamicProperty(prop);
      }

      return prop;
    };
  })();

  (function addDecorator() {
    function searchExpressions() {
      if (this.data.d.x) {
        this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
        this.addEffect(this.getExpressionValue.bind(this));
        return true;
      }
    }

    TextProperty.prototype.getExpressionValue = function (currentValue, text) {
      var newValue = this.calculateExpression(text);

      if (currentValue.t !== newValue) {
        var newData = {};
        this.copyData(newData, currentValue);
        newData.t = newValue.toString();
        newData.__complete = false;
        return newData;
      }

      return currentValue;
    };

    TextProperty.prototype.searchProperty = function () {
      var isKeyframed = this.searchKeyframes();
      var hasExpressions = this.searchExpressions();
      this.kf = isKeyframed || hasExpressions;
      return this.kf;
    };

    TextProperty.prototype.searchExpressions = searchExpressions;
  })();

  var ShapeExpressionInterface = function () {
    function iterateElements(shapes, view, propertyGroup) {
      var arr = [];
      var i,
          len = shapes ? shapes.length : 0;

      for (i = 0; i < len; i += 1) {
        if (shapes[i].ty == 'gr') {
          arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
        } else if (shapes[i].ty == 'fl') {
          arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
        } else if (shapes[i].ty == 'st') {
          arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
        } else if (shapes[i].ty == 'tm') {
          arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
        } else if (shapes[i].ty == 'tr') {//arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));
        } else if (shapes[i].ty == 'el') {
          arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
        } else if (shapes[i].ty == 'sr') {
          arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
        } else if (shapes[i].ty == 'sh') {
          arr.push(pathInterfaceFactory(shapes[i], view[i], propertyGroup));
        } else if (shapes[i].ty == 'rc') {
          arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
        } else if (shapes[i].ty == 'rd') {
          arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
        } else if (shapes[i].ty == 'rp') {
          arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
        }
      }

      return arr;
    }

    function contentsInterfaceFactory(shape, view, propertyGroup) {
      var interfaces;

      var interfaceFunction = function _interfaceFunction(value) {
        var i = 0,
            len = interfaces.length;

        while (i < len) {
          if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
            return interfaces[i];
          }

          i += 1;
        }

        if (typeof value === 'number') {
          return interfaces[value - 1];
        }
      };

      interfaceFunction.propertyGroup = function (val) {
        if (val === 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(val - 1);
        }
      };

      interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
      interfaceFunction.numProperties = interfaces.length;
      interfaceFunction.propertyIndex = shape.cix;
      interfaceFunction._name = shape.nm;
      return interfaceFunction;
    }

    function groupInterfaceFactory(shape, view, propertyGroup) {
      var interfaceFunction = function _interfaceFunction(value) {
        switch (value) {
          case 'ADBE Vectors Group':
          case 'Contents':
          case 2:
            return interfaceFunction.content;
          //Not necessary for now. Keeping them here in case a new case appears
          //case 'ADBE Vector Transform Group':
          //case 3:

          default:
            return interfaceFunction.transform;
        }
      };

      interfaceFunction.propertyGroup = function (val) {
        if (val === 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(val - 1);
        }
      };

      var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
      var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
      interfaceFunction.content = content;
      interfaceFunction.transform = transformInterface;
      Object.defineProperty(interfaceFunction, '_name', {
        get: function get() {
          return shape.nm;
        }
      }); //interfaceFunction.content = interfaceFunction;

      interfaceFunction.numProperties = shape.np;
      interfaceFunction.propertyIndex = shape.ix;
      interfaceFunction.nm = shape.nm;
      interfaceFunction.mn = shape.mn;
      return interfaceFunction;
    }

    function fillInterfaceFactory(shape, view, propertyGroup) {
      function interfaceFunction(val) {
        if (val === 'Color' || val === 'color') {
          return interfaceFunction.color;
        } else if (val === 'Opacity' || val === 'opacity') {
          return interfaceFunction.opacity;
        }
      }

      Object.defineProperties(interfaceFunction, {
        'color': {
          get: ExpressionPropertyInterface(view.c)
        },
        'opacity': {
          get: ExpressionPropertyInterface(view.o)
        },
        '_name': {
          value: shape.nm
        },
        'mn': {
          value: shape.mn
        }
      });
      view.c.setGroupProperty(propertyGroup);
      view.o.setGroupProperty(propertyGroup);
      return interfaceFunction;
    }

    function strokeInterfaceFactory(shape, view, propertyGroup) {
      function _propertyGroup(val) {
        if (val === 1) {
          return ob;
        } else {
          return propertyGroup(val - 1);
        }
      }

      function _dashPropertyGroup(val) {
        if (val === 1) {
          return dashOb;
        } else {
          return _propertyGroup(val - 1);
        }
      }

      function addPropertyToDashOb(i) {
        Object.defineProperty(dashOb, shape.d[i].nm, {
          get: ExpressionPropertyInterface(view.d.dataProps[i].p)
        });
      }

      var i,
          len = shape.d ? shape.d.length : 0;
      var dashOb = {};

      for (i = 0; i < len; i += 1) {
        addPropertyToDashOb(i);
        view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
      }

      function interfaceFunction(val) {
        if (val === 'Color' || val === 'color') {
          return interfaceFunction.color;
        } else if (val === 'Opacity' || val === 'opacity') {
          return interfaceFunction.opacity;
        } else if (val === 'Stroke Width' || val === 'stroke width') {
          return interfaceFunction.strokeWidth;
        }
      }

      Object.defineProperties(interfaceFunction, {
        'color': {
          get: ExpressionPropertyInterface(view.c)
        },
        'opacity': {
          get: ExpressionPropertyInterface(view.o)
        },
        'strokeWidth': {
          get: ExpressionPropertyInterface(view.w)
        },
        'dash': {
          get: function get() {
            return dashOb;
          }
        },
        '_name': {
          value: shape.nm
        },
        'mn': {
          value: shape.mn
        }
      });
      view.c.setGroupProperty(_propertyGroup);
      view.o.setGroupProperty(_propertyGroup);
      view.w.setGroupProperty(_propertyGroup);
      return interfaceFunction;
    }

    function trimInterfaceFactory(shape, view, propertyGroup) {
      function _propertyGroup(val) {
        if (val == 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(--val);
        }
      }

      interfaceFunction.propertyIndex = shape.ix;
      view.s.setGroupProperty(_propertyGroup);
      view.e.setGroupProperty(_propertyGroup);
      view.o.setGroupProperty(_propertyGroup);

      function interfaceFunction(val) {
        if (val === shape.e.ix || val === 'End' || val === 'end') {
          return interfaceFunction.end;
        }

        if (val === shape.s.ix) {
          return interfaceFunction.start;
        }

        if (val === shape.o.ix) {
          return interfaceFunction.offset;
        }
      }

      interfaceFunction.propertyIndex = shape.ix;
      interfaceFunction.propertyGroup = propertyGroup;
      Object.defineProperties(interfaceFunction, {
        'start': {
          get: ExpressionPropertyInterface(view.s)
        },
        'end': {
          get: ExpressionPropertyInterface(view.e)
        },
        'offset': {
          get: ExpressionPropertyInterface(view.o)
        },
        '_name': {
          value: shape.nm
        }
      });
      interfaceFunction.mn = shape.mn;
      return interfaceFunction;
    }

    function transformInterfaceFactory(shape, view, propertyGroup) {
      function _propertyGroup(val) {
        if (val == 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(--val);
        }
      }

      view.transform.mProps.o.setGroupProperty(_propertyGroup);
      view.transform.mProps.p.setGroupProperty(_propertyGroup);
      view.transform.mProps.a.setGroupProperty(_propertyGroup);
      view.transform.mProps.s.setGroupProperty(_propertyGroup);
      view.transform.mProps.r.setGroupProperty(_propertyGroup);

      if (view.transform.mProps.sk) {
        view.transform.mProps.sk.setGroupProperty(_propertyGroup);
        view.transform.mProps.sa.setGroupProperty(_propertyGroup);
      }

      view.transform.op.setGroupProperty(_propertyGroup);

      function interfaceFunction(value) {
        if (shape.a.ix === value || value === 'Anchor Point') {
          return interfaceFunction.anchorPoint;
        }

        if (shape.o.ix === value || value === 'Opacity') {
          return interfaceFunction.opacity;
        }

        if (shape.p.ix === value || value === 'Position') {
          return interfaceFunction.position;
        }

        if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
          return interfaceFunction.rotation;
        }

        if (shape.s.ix === value || value === 'Scale') {
          return interfaceFunction.scale;
        }

        if (shape.sk && shape.sk.ix === value || value === 'Skew') {
          return interfaceFunction.skew;
        }

        if (shape.sa && shape.sa.ix === value || value === 'Skew Axis') {
          return interfaceFunction.skewAxis;
        }
      }

      Object.defineProperties(interfaceFunction, {
        'opacity': {
          get: ExpressionPropertyInterface(view.transform.mProps.o)
        },
        'position': {
          get: ExpressionPropertyInterface(view.transform.mProps.p)
        },
        'anchorPoint': {
          get: ExpressionPropertyInterface(view.transform.mProps.a)
        },
        'scale': {
          get: ExpressionPropertyInterface(view.transform.mProps.s)
        },
        'rotation': {
          get: ExpressionPropertyInterface(view.transform.mProps.r)
        },
        'skew': {
          get: ExpressionPropertyInterface(view.transform.mProps.sk)
        },
        'skewAxis': {
          get: ExpressionPropertyInterface(view.transform.mProps.sa)
        },
        '_name': {
          value: shape.nm
        }
      });
      interfaceFunction.ty = 'tr';
      interfaceFunction.mn = shape.mn;
      interfaceFunction.propertyGroup = propertyGroup;
      return interfaceFunction;
    }

    function ellipseInterfaceFactory(shape, view, propertyGroup) {
      function _propertyGroup(val) {
        if (val == 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(--val);
        }
      }

      interfaceFunction.propertyIndex = shape.ix;
      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
      prop.s.setGroupProperty(_propertyGroup);
      prop.p.setGroupProperty(_propertyGroup);

      function interfaceFunction(value) {
        if (shape.p.ix === value) {
          return interfaceFunction.position;
        }

        if (shape.s.ix === value) {
          return interfaceFunction.size;
        }
      }

      Object.defineProperties(interfaceFunction, {
        'size': {
          get: ExpressionPropertyInterface(prop.s)
        },
        'position': {
          get: ExpressionPropertyInterface(prop.p)
        },
        '_name': {
          value: shape.nm
        }
      });
      interfaceFunction.mn = shape.mn;
      return interfaceFunction;
    }

    function starInterfaceFactory(shape, view, propertyGroup) {
      function _propertyGroup(val) {
        if (val == 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(--val);
        }
      }

      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
      interfaceFunction.propertyIndex = shape.ix;
      prop.or.setGroupProperty(_propertyGroup);
      prop.os.setGroupProperty(_propertyGroup);
      prop.pt.setGroupProperty(_propertyGroup);
      prop.p.setGroupProperty(_propertyGroup);
      prop.r.setGroupProperty(_propertyGroup);

      if (shape.ir) {
        prop.ir.setGroupProperty(_propertyGroup);
        prop.is.setGroupProperty(_propertyGroup);
      }

      function interfaceFunction(value) {
        if (shape.p.ix === value) {
          return interfaceFunction.position;
        }

        if (shape.r.ix === value) {
          return interfaceFunction.rotation;
        }

        if (shape.pt.ix === value) {
          return interfaceFunction.points;
        }

        if (shape.or.ix === value || 'ADBE Vector Star Outer Radius' === value) {
          return interfaceFunction.outerRadius;
        }

        if (shape.os.ix === value) {
          return interfaceFunction.outerRoundness;
        }

        if (shape.ir && (shape.ir.ix === value || 'ADBE Vector Star Inner Radius' === value)) {
          return interfaceFunction.innerRadius;
        }

        if (shape.is && shape.is.ix === value) {
          return interfaceFunction.innerRoundness;
        }
      }

      Object.defineProperties(interfaceFunction, {
        'position': {
          get: ExpressionPropertyInterface(prop.p)
        },
        'rotation': {
          get: ExpressionPropertyInterface(prop.r)
        },
        'points': {
          get: ExpressionPropertyInterface(prop.pt)
        },
        'outerRadius': {
          get: ExpressionPropertyInterface(prop.or)
        },
        'outerRoundness': {
          get: ExpressionPropertyInterface(prop.os)
        },
        'innerRadius': {
          get: ExpressionPropertyInterface(prop.ir)
        },
        'innerRoundness': {
          get: ExpressionPropertyInterface(prop.is)
        },
        '_name': {
          value: shape.nm
        }
      });
      interfaceFunction.mn = shape.mn;
      return interfaceFunction;
    }

    function rectInterfaceFactory(shape, view, propertyGroup) {
      function _propertyGroup(val) {
        if (val == 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(--val);
        }
      }

      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
      interfaceFunction.propertyIndex = shape.ix;
      prop.p.setGroupProperty(_propertyGroup);
      prop.s.setGroupProperty(_propertyGroup);
      prop.r.setGroupProperty(_propertyGroup);

      function interfaceFunction(value) {
        if (shape.p.ix === value) {
          return interfaceFunction.position;
        }

        if (shape.r.ix === value) {
          return interfaceFunction.roundness;
        }

        if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
          return interfaceFunction.size;
        }
      }

      Object.defineProperties(interfaceFunction, {
        'position': {
          get: ExpressionPropertyInterface(prop.p)
        },
        'roundness': {
          get: ExpressionPropertyInterface(prop.r)
        },
        'size': {
          get: ExpressionPropertyInterface(prop.s)
        },
        '_name': {
          value: shape.nm
        }
      });
      interfaceFunction.mn = shape.mn;
      return interfaceFunction;
    }

    function roundedInterfaceFactory(shape, view, propertyGroup) {
      function _propertyGroup(val) {
        if (val == 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(--val);
        }
      }

      var prop = view;
      interfaceFunction.propertyIndex = shape.ix;
      prop.rd.setGroupProperty(_propertyGroup);

      function interfaceFunction(value) {
        if (shape.r.ix === value || 'Round Corners 1' === value) {
          return interfaceFunction.radius;
        }
      }

      Object.defineProperties(interfaceFunction, {
        'radius': {
          get: ExpressionPropertyInterface(prop.rd)
        },
        '_name': {
          value: shape.nm
        }
      });
      interfaceFunction.mn = shape.mn;
      return interfaceFunction;
    }

    function repeaterInterfaceFactory(shape, view, propertyGroup) {
      function _propertyGroup(val) {
        if (val == 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(--val);
        }
      }

      var prop = view;
      interfaceFunction.propertyIndex = shape.ix;
      prop.c.setGroupProperty(_propertyGroup);
      prop.o.setGroupProperty(_propertyGroup);

      function interfaceFunction(value) {
        if (shape.c.ix === value || 'Copies' === value) {
          return interfaceFunction.copies;
        } else if (shape.o.ix === value || 'Offset' === value) {
          return interfaceFunction.offset;
        }
      }

      Object.defineProperties(interfaceFunction, {
        'copies': {
          get: ExpressionPropertyInterface(prop.c)
        },
        'offset': {
          get: ExpressionPropertyInterface(prop.o)
        },
        '_name': {
          value: shape.nm
        }
      });
      interfaceFunction.mn = shape.mn;
      return interfaceFunction;
    }

    function pathInterfaceFactory(shape, view, propertyGroup) {
      var prop = view.sh;

      function _propertyGroup(val) {
        if (val == 1) {
          return interfaceFunction;
        } else {
          return propertyGroup(--val);
        }
      }

      prop.setGroupProperty(_propertyGroup);

      function interfaceFunction(val) {
        if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
          return interfaceFunction.path;
        }
      }

      Object.defineProperties(interfaceFunction, {
        'path': {
          get: function get() {
            if (prop.k) {
              prop.getValue();
            }

            return prop;
          }
        },
        'shape': {
          get: function get() {
            if (prop.k) {
              prop.getValue();
            }

            return prop;
          }
        },
        '_name': {
          value: shape.nm
        },
        'ix': {
          value: shape.ix
        },
        'mn': {
          value: shape.mn
        }
      });
      return interfaceFunction;
    }

    return function (shapes, view, propertyGroup) {
      var interfaces;

      function _interfaceFunction(value) {
        if (typeof value === 'number') {
          return interfaces[value - 1];
        } else {
          var i = 0,
              len = interfaces.length;

          while (i < len) {
            if (interfaces[i]._name === value) {
              return interfaces[i];
            }

            i += 1;
          }
        }
      }

      _interfaceFunction.propertyGroup = propertyGroup;
      interfaces = iterateElements(shapes, view, _interfaceFunction);
      _interfaceFunction.numProperties = interfaces.length;
      return _interfaceFunction;
    };
  }();

  var TextExpressionInterface = function () {
    return function (elem) {
      var _prevValue, _sourceText;

      function _thisLayerFunction() {}

      Object.defineProperty(_thisLayerFunction, "sourceText", {
        get: function get() {
          elem.textProperty.getValue();
          var stringValue = elem.textProperty.currentData.t;

          if (stringValue !== _prevValue) {
            elem.textProperty.currentData.t = _prevValue;
            _sourceText = new String(stringValue); //If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive

            _sourceText.value = stringValue ? stringValue : new String(stringValue);
          }

          return _sourceText;
        }
      });
      return _thisLayerFunction;
    };
  }();

  var LayerExpressionInterface = function () {
    function toWorld(arr, time) {
      var toWorldMat = new Matrix();
      toWorldMat.reset();
      var transformMat;

      if (time) {
        //Todo implement value at time on transform properties
        //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);
        transformMat = this._elem.finalTransform.mProp;
      } else {
        transformMat = this._elem.finalTransform.mProp;
      }

      transformMat.applyToMatrix(toWorldMat);

      if (this._elem.hierarchy && this._elem.hierarchy.length) {
        var i,
            len = this._elem.hierarchy.length;

        for (i = 0; i < len; i += 1) {
          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
        }

        return toWorldMat.applyToPointArray(arr[0], arr[1], arr[2] || 0);
      }

      return toWorldMat.applyToPointArray(arr[0], arr[1], arr[2] || 0);
    }

    function fromWorld(arr, time) {
      var toWorldMat = new Matrix();
      toWorldMat.reset();
      var transformMat;

      if (time) {
        //Todo implement value at time on transform properties
        //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);
        transformMat = this._elem.finalTransform.mProp;
      } else {
        transformMat = this._elem.finalTransform.mProp;
      }

      transformMat.applyToMatrix(toWorldMat);

      if (this._elem.hierarchy && this._elem.hierarchy.length) {
        var i,
            len = this._elem.hierarchy.length;

        for (i = 0; i < len; i += 1) {
          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
        }

        return toWorldMat.inversePoint(arr);
      }

      return toWorldMat.inversePoint(arr);
    }

    function fromComp(arr) {
      var toWorldMat = new Matrix();
      toWorldMat.reset();

      this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);

      if (this._elem.hierarchy && this._elem.hierarchy.length) {
        var i,
            len = this._elem.hierarchy.length;

        for (i = 0; i < len; i += 1) {
          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
        }

        return toWorldMat.inversePoint(arr);
      }

      return toWorldMat.inversePoint(arr);
    }

    function sampleImage() {
      return [1, 1, 1, 1];
    }

    return function (elem) {
      var transformInterface;

      function _registerMaskInterface(maskManager) {
        _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
      }

      function _registerEffectsInterface(effects) {
        _thisLayerFunction.effect = effects;
      }

      function _thisLayerFunction(name) {
        switch (name) {
          case "ADBE Root Vectors Group":
          case "Contents":
          case 2:
            return _thisLayerFunction.shapeInterface;

          case 1:
          case 6:
          case "Transform":
          case "transform":
          case "ADBE Transform Group":
            return transformInterface;

          case 4:
          case "ADBE Effect Parade":
          case "effects":
          case "Effects":
            return _thisLayerFunction.effect;
        }
      }

      _thisLayerFunction.toWorld = toWorld;
      _thisLayerFunction.fromWorld = fromWorld;
      _thisLayerFunction.toComp = toWorld;
      _thisLayerFunction.fromComp = fromComp;
      _thisLayerFunction.sampleImage = sampleImage;
      _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
      _thisLayerFunction._elem = elem;
      transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
      var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
      Object.defineProperties(_thisLayerFunction, {
        hasParent: {
          get: function get() {
            return elem.hierarchy.length;
          }
        },
        parent: {
          get: function get() {
            return elem.hierarchy[0].layerInterface;
          }
        },
        rotation: getDescriptor(transformInterface, 'rotation'),
        scale: getDescriptor(transformInterface, 'scale'),
        position: getDescriptor(transformInterface, 'position'),
        opacity: getDescriptor(transformInterface, 'opacity'),
        anchorPoint: anchorPointDescriptor,
        anchor_point: anchorPointDescriptor,
        transform: {
          get: function get() {
            return transformInterface;
          }
        },
        active: {
          get: function get() {
            return elem.isInRange;
          }
        }
      });
      _thisLayerFunction.startTime = elem.data.st;
      _thisLayerFunction.index = elem.data.ind;
      _thisLayerFunction.source = elem.data.refId;
      _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
      _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
      _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
      _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
      _thisLayerFunction._name = elem.data.nm;
      _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
      _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
      return _thisLayerFunction;
    };
  }();

  var CompExpressionInterface = function () {
    return function (comp) {
      function _thisLayerFunction(name) {
        var i = 0,
            len = comp.layers.length;

        while (i < len) {
          if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
            return comp.elements[i].layerInterface;
          }

          i += 1;
        }

        return null; //return {active:false};
      }

      Object.defineProperty(_thisLayerFunction, "_name", {
        value: comp.data.nm
      });
      _thisLayerFunction.layer = _thisLayerFunction;
      _thisLayerFunction.pixelAspect = 1;
      _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
      _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
      _thisLayerFunction.pixelAspect = 1;
      _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
      _thisLayerFunction.displayStartTime = 0;
      _thisLayerFunction.numLayers = comp.layers.length;
      return _thisLayerFunction;
    };
  }();

  var TransformExpressionInterface = function () {
    return function (transform) {
      function _thisFunction(name) {
        switch (name) {
          case "scale":
          case "Scale":
          case "ADBE Scale":
          case 6:
            return _thisFunction.scale;

          case "rotation":
          case "Rotation":
          case "ADBE Rotation":
          case "ADBE Rotate Z":
          case 10:
            return _thisFunction.rotation;

          case "ADBE Rotate X":
            return _thisFunction.xRotation;

          case "ADBE Rotate Y":
            return _thisFunction.yRotation;

          case "position":
          case "Position":
          case "ADBE Position":
          case 2:
            return _thisFunction.position;

          case 'ADBE Position_0':
            return _thisFunction.xPosition;

          case 'ADBE Position_1':
            return _thisFunction.yPosition;

          case 'ADBE Position_2':
            return _thisFunction.zPosition;

          case "anchorPoint":
          case "AnchorPoint":
          case "Anchor Point":
          case "ADBE AnchorPoint":
          case 1:
            return _thisFunction.anchorPoint;

          case "opacity":
          case "Opacity":
          case 11:
            return _thisFunction.opacity;
        }
      }

      Object.defineProperty(_thisFunction, "rotation", {
        get: ExpressionPropertyInterface(transform.r || transform.rz)
      });
      Object.defineProperty(_thisFunction, "zRotation", {
        get: ExpressionPropertyInterface(transform.rz || transform.r)
      });
      Object.defineProperty(_thisFunction, "xRotation", {
        get: ExpressionPropertyInterface(transform.rx)
      });
      Object.defineProperty(_thisFunction, "yRotation", {
        get: ExpressionPropertyInterface(transform.ry)
      });
      Object.defineProperty(_thisFunction, "scale", {
        get: ExpressionPropertyInterface(transform.s)
      });

      if (transform.p) {
        var _transformFactory = ExpressionPropertyInterface(transform.p);
      }

      Object.defineProperty(_thisFunction, "position", {
        get: function get() {
          if (transform.p) {
            return _transformFactory();
          } else {
            return [transform.px.v, transform.py.v, transform.pz ? transform.pz.v : 0];
          }
        }
      });
      Object.defineProperty(_thisFunction, "xPosition", {
        get: ExpressionPropertyInterface(transform.px)
      });
      Object.defineProperty(_thisFunction, "yPosition", {
        get: ExpressionPropertyInterface(transform.py)
      });
      Object.defineProperty(_thisFunction, "zPosition", {
        get: ExpressionPropertyInterface(transform.pz)
      });
      Object.defineProperty(_thisFunction, "anchorPoint", {
        get: ExpressionPropertyInterface(transform.a)
      });
      Object.defineProperty(_thisFunction, "opacity", {
        get: ExpressionPropertyInterface(transform.o)
      });
      Object.defineProperty(_thisFunction, "skew", {
        get: ExpressionPropertyInterface(transform.sk)
      });
      Object.defineProperty(_thisFunction, "skewAxis", {
        get: ExpressionPropertyInterface(transform.sa)
      });
      Object.defineProperty(_thisFunction, "orientation", {
        get: ExpressionPropertyInterface(transform.or)
      });
      return _thisFunction;
    };
  }();

  var ProjectInterface = function () {
    function registerComposition(comp) {
      this.compositions.push(comp);
    }

    return function () {
      function _thisProjectFunction(name) {
        var i = 0,
            len = this.compositions.length;

        while (i < len) {
          if (this.compositions[i].data && this.compositions[i].data.nm === name) {
            if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
              this.compositions[i].prepareFrame(this.currentFrame);
            }

            return this.compositions[i].compInterface;
          }

          i += 1;
        }
      }

      _thisProjectFunction.compositions = [];
      _thisProjectFunction.currentFrame = 0;
      _thisProjectFunction.registerComposition = registerComposition;
      return _thisProjectFunction;
    };
  }();

  var EffectsExpressionInterface = function () {
    var ob = {
      createEffectsInterface: createEffectsInterface
    };

    function createEffectsInterface(elem, propertyGroup) {
      if (elem.effectsManager) {
        var effectElements = [];
        var effectsData = elem.data.ef;
        var i,
            len = elem.effectsManager.effectElements.length;

        for (i = 0; i < len; i += 1) {
          effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
        }

        return function (name) {
          var effects = elem.data.ef || [],
              i = 0,
              len = effects.length;

          while (i < len) {
            if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
              return effectElements[i];
            }

            i += 1;
          }
        };
      }
    }

    function createGroupInterface(data, elements, propertyGroup, elem) {
      var effectElements = [];
      var i,
          len = data.ef.length;

      for (i = 0; i < len; i += 1) {
        if (data.ef[i].ty === 5) {
          effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
        } else {
          effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
        }
      }

      function _propertyGroup(val) {
        if (val === 1) {
          return groupInterface;
        } else {
          return propertyGroup(val - 1);
        }
      }

      var groupInterface = function groupInterface(name) {
        var effects = data.ef,
            i = 0,
            len = effects.length;

        while (i < len) {
          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
            if (effects[i].ty === 5) {
              return effectElements[i];
            } else {
              return effectElements[i]();
            }
          }

          i += 1;
        }

        return effectElements[0]();
      };

      groupInterface.propertyGroup = _propertyGroup;

      if (data.mn === 'ADBE Color Control') {
        Object.defineProperty(groupInterface, 'color', {
          get: function get() {
            return effectElements[0]();
          }
        });
      }

      Object.defineProperty(groupInterface, 'numProperties', {
        get: function get() {
          return data.np;
        }
      });
      groupInterface.active = groupInterface.enabled = data.en !== 0;
      return groupInterface;
    }

    function createValueInterface(element, type, elem, propertyGroup) {
      var expressionProperty = ExpressionPropertyInterface(element.p);

      function interfaceFunction() {
        if (type === 10) {
          return elem.comp.compInterface(element.p.v);
        }

        return expressionProperty();
      }

      if (element.p.setGroupProperty) {
        element.p.setGroupProperty(propertyGroup);
      }

      return interfaceFunction;
    }

    return ob;
  }();

  var MaskManagerInterface = function () {
    function MaskInterface(mask, data) {
      this._mask = mask;
      this._data = data;
    }

    Object.defineProperty(MaskInterface.prototype, 'maskPath', {
      get: function get() {
        if (this._mask.prop.k) {
          this._mask.prop.getValue();
        }

        return this._mask.prop;
      }
    });

    var MaskManager = function MaskManager(maskManager, elem) {
      var _maskManager = maskManager;
      var _elem = elem;

      var _masksInterfaces = createSizedArray(maskManager.viewData.length);

      var i,
          len = maskManager.viewData.length;

      for (i = 0; i < len; i += 1) {
        _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
      }

      var maskFunction = function maskFunction(name) {
        i = 0;

        while (i < len) {
          if (maskManager.masksProperties[i].nm === name) {
            return _masksInterfaces[i];
          }

          i += 1;
        }
      };

      return maskFunction;
    };

    return MaskManager;
  }();

  var ExpressionPropertyInterface = function () {
    var defaultUnidimensionalValue = {
      pv: 0,
      v: 0,
      mult: 1
    };
    var defaultMultidimensionalValue = {
      pv: [0, 0, 0],
      v: [0, 0, 0],
      mult: 1
    };

    function completeProperty(expressionValue, property, type) {
      Object.defineProperty(expressionValue, 'velocity', {
        get: function get() {
          return property.getVelocityAtTime(property.comp.currentFrame);
        }
      });
      expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;

      expressionValue.key = function (pos) {
        if (!expressionValue.numKeys) {
          return 0;
        } else {
          var value = '';

          if ('s' in property.keyframes[pos - 1]) {
            value = property.keyframes[pos - 1].s;
          } else if ('e' in property.keyframes[pos - 2]) {
            value = property.keyframes[pos - 2].e;
          } else {
            value = property.keyframes[pos - 2].s;
          }

          var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value);
          valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
          return valueProp;
        }
      };

      expressionValue.valueAtTime = property.getValueAtTime;
      expressionValue.speedAtTime = property.getSpeedAtTime;
      expressionValue.velocityAtTime = property.getVelocityAtTime;
      expressionValue.propertyGroup = property.propertyGroup;
    }

    function UnidimensionalPropertyInterface(property) {
      if (!property || !('pv' in property)) {
        property = defaultUnidimensionalValue;
      }

      var mult = 1 / property.mult;
      var val = property.pv * mult;
      var expressionValue = new Number(val);
      expressionValue.value = val;
      completeProperty(expressionValue, property, 'unidimensional');
      return function () {
        if (property.k) {
          property.getValue();
        }

        val = property.v * mult;

        if (expressionValue.value !== val) {
          expressionValue = new Number(val);
          expressionValue.value = val;
          completeProperty(expressionValue, property, 'unidimensional');
        }

        return expressionValue;
      };
    }

    function MultidimensionalPropertyInterface(property) {
      if (!property || !('pv' in property)) {
        property = defaultMultidimensionalValue;
      }

      var mult = 1 / property.mult;
      var len = property.pv.length;
      var expressionValue = createTypedArray('float32', len);
      var arrValue = createTypedArray('float32', len);
      expressionValue.value = arrValue;
      completeProperty(expressionValue, property, 'multidimensional');
      return function () {
        if (property.k) {
          property.getValue();
        }

        for (var i = 0; i < len; i += 1) {
          expressionValue[i] = arrValue[i] = property.v[i] * mult;
        }

        return expressionValue;
      };
    } //TODO: try to avoid using this getter


    function defaultGetter() {
      return defaultUnidimensionalValue;
    }

    return function (property) {
      if (!property) {
        return defaultGetter;
      } else if (property.propType === 'unidimensional') {
        return UnidimensionalPropertyInterface(property);
      } else {
        return MultidimensionalPropertyInterface(property);
      }
    };
  }();

  (function () {
    var TextExpressionSelectorProp = function () {
      function getValueProxy(index, total) {
        this.textIndex = index + 1;
        this.textTotal = total;
        this.v = this.getValue() * this.mult;
        return this.v;
      }

      return function TextExpressionSelectorProp(elem, data) {
        this.pv = 1;
        this.comp = elem.comp;
        this.elem = elem;
        this.mult = 0.01;
        this.propType = 'textSelector';
        this.textTotal = data.totalChars;
        this.selectorValue = 100;
        this.lastValue = [1, 1, 1];
        this.k = true;
        this.x = true;
        this.getValue = ExpressionManager.initiateExpression.bind(this)(elem, data, this);
        this.getMult = getValueProxy;
        this.getVelocityAtTime = expressionHelpers.getVelocityAtTime;

        if (this.kf) {
          this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this);
        } else {
          this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this);
        }

        this.setGroupProperty = expressionHelpers.setGroupProperty;
      };
    }();

    var propertyGetTextProp = TextSelectorProp.getTextSelectorProp;

    TextSelectorProp.getTextSelectorProp = function (elem, data, arr) {
      if (data.t === 1) {
        return new TextExpressionSelectorProp(elem, data, arr);
      } else {
        return propertyGetTextProp(elem, data, arr);
      }
    };
  })();

  function SliderEffect(data, elem, container) {
    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  }

  function AngleEffect(data, elem, container) {
    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  }

  function ColorEffect(data, elem, container) {
    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
  }

  function PointEffect(data, elem, container) {
    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
  }

  function LayerIndexEffect(data, elem, container) {
    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  }

  function MaskIndexEffect(data, elem, container) {
    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  }

  function CheckboxEffect(data, elem, container) {
    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
  }

  function NoValueEffect() {
    this.p = {};
  }

  function EffectsManager() {}

  function EffectsManager(data, element) {
    var effects = data.ef || [];
    this.effectElements = [];
    var i,
        len = effects.length;
    var effectItem;

    for (i = 0; i < len; i++) {
      effectItem = new GroupEffect(effects[i], element);
      this.effectElements.push(effectItem);
    }
  }

  function GroupEffect(data, element) {
    this.init(data, element);
  }

  extendPrototype([DynamicPropertyContainer], GroupEffect);
  GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;

  GroupEffect.prototype.init = function (data, element) {
    this.data = data;
    this.effectElements = [];
    this.initDynamicPropertyContainer(element);
    var i,
        len = this.data.ef.length;
    var eff,
        effects = this.data.ef;

    for (i = 0; i < len; i += 1) {
      eff = null;

      switch (effects[i].ty) {
        case 0:
          eff = new SliderEffect(effects[i], element, this);
          break;

        case 1:
          eff = new AngleEffect(effects[i], element, this);
          break;

        case 2:
          eff = new ColorEffect(effects[i], element, this);
          break;

        case 3:
          eff = new PointEffect(effects[i], element, this);
          break;

        case 4:
        case 7:
          eff = new CheckboxEffect(effects[i], element, this);
          break;

        case 10:
          eff = new LayerIndexEffect(effects[i], element, this);
          break;

        case 11:
          eff = new MaskIndexEffect(effects[i], element, this);
          break;

        case 5:
          eff = new EffectsManager(effects[i], element, this);
          break;
        //case 6:

        default:
          eff = new NoValueEffect(effects[i], element, this);
          break;
      }

      if (eff) {
        this.effectElements.push(eff);
      }
    }
  };

  var lottiejs = {};
  var _isFrozen = false;

  function setLocationHref(href) {
    locationHref = href;
  }

  function searchAnimations() {
    if (standalone === true) {
      animationManager.searchAnimations(animationData, standalone, renderer);
    } else {
      animationManager.searchAnimations();
    }
  }

  function setSubframeRendering(flag) {
    subframeEnabled = flag;
  }

  function loadAnimation(params) {
    if (standalone === true) {
      params.animationData = JSON.parse(animationData);
    }

    return animationManager.loadAnimation(params);
  }

  function setQuality(value) {
    if (typeof value === 'string') {
      switch (value) {
        case 'high':
          defaultCurveSegments = 200;
          break;

        case 'medium':
          defaultCurveSegments = 50;
          break;

        case 'low':
          defaultCurveSegments = 10;
          break;
      }
    } else if (!isNaN(value) && value > 1) {
      defaultCurveSegments = value;
    }

    if (defaultCurveSegments >= 50) {
      roundValues(false);
    } else {
      roundValues(true);
    }
  }

  function inBrowser() {
    return typeof navigator !== 'undefined';
  }

  function installPlugin(type, plugin) {
    if (type === 'expressions') {
      expressionsPlugin = plugin;
    }
  }

  function getFactory(name) {
    switch (name) {
      case "propertyFactory":
        return PropertyFactory;

      case "shapePropertyFactory":
        return ShapePropertyFactory;

      case "matrix":
        return Matrix;
    }
  }

  lottiejs.play = animationManager.play;
  lottiejs.pause = animationManager.pause;
  lottiejs.setLocationHref = setLocationHref;
  lottiejs.togglePause = animationManager.togglePause;
  lottiejs.setSpeed = animationManager.setSpeed;
  lottiejs.setDirection = animationManager.setDirection;
  lottiejs.stop = animationManager.stop;
  lottiejs.searchAnimations = searchAnimations;
  lottiejs.registerAnimation = animationManager.registerAnimation;
  lottiejs.loadAnimation = loadAnimation;
  lottiejs.setSubframeRendering = setSubframeRendering;
  lottiejs.resize = animationManager.resize; //lottiejs.start = start;

  lottiejs.goToAndStop = animationManager.goToAndStop;
  lottiejs.destroy = animationManager.destroy;
  lottiejs.setQuality = setQuality;
  lottiejs.inBrowser = inBrowser;
  lottiejs.installPlugin = installPlugin;
  lottiejs.freeze = animationManager.freeze;
  lottiejs.unfreeze = animationManager.unfreeze;
  lottiejs.getRegisteredAnimations = animationManager.getRegisteredAnimations;
  lottiejs.__getFactory = getFactory;
  lottiejs.version = '5.5.1';

  function checkReady() {
    if (document.readyState === "complete") {
      clearInterval(readyStateCheckInterval);
      searchAnimations();
    }
  }

  function getQueryVariable(variable) {
    var vars = queryString.split('&');

    for (var i = 0; i < vars.length; i++) {
      var pair = vars[i].split('=');

      if (decodeURIComponent(pair[0]) == variable) {
        return decodeURIComponent(pair[1]);
      }
    }
  }

  var standalone = '__[STANDALONE]__';
  var animationData = '__[ANIMATIONDATA]__';
  var renderer = '';

  if (standalone) {
    var scripts = document.getElementsByTagName('script');
    var index = scripts.length - 1;
    var myScript = scripts[index] || {
      src: ''
    };
    var queryString = myScript.src.replace(/^[^\?]+\??/, '');
    renderer = getQueryVariable('renderer');
  }

  var readyStateCheckInterval = setInterval(checkReady, 100);
  return lottiejs;
});

/***/ }),

/***/ "./js/plugins/modernizr/modernizr-2.0.6.min.js":
/*!*****************************************************!*\
  !*** ./js/plugins/modernizr/modernizr-2.0.6.min.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*** IMPORTS FROM imports-loader ***/
(function () {
  /* Modernizr 2.0.6 (Custom Build) | MIT & BSD
   * Build: http://www.modernizr.com/download/#-fontface-backgroundsize-borderimage-borderradius-boxshadow-flexbox-hsla-multiplebgs-opacity-rgba-textshadow-cssanimations-csscolumns-generatedcontent-cssgradients-cssreflections-csstransforms-csstransforms3d-csstransitions-applicationcache-canvas-canvastext-draganddrop-hashchange-history-audio-video-indexeddb-input-inputtypes-localstorage-postmessage-sessionstorage-websockets-websqldatabase-webworkers-geolocation-inlinesvg-smil-svg-svgclippaths-touch-webgl-iepp-mq-cssclasses-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes-load
   */
  ;
  window.Modernizr = function (a, b, c) {
    function I() {
      e.input = function (a) {
        for (var b = 0, c = a.length; b < c; b++) {
          t[a[b]] = a[b] in l;
        }

        return t;
      }("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")), e.inputtypes = function (a) {
        for (var d = 0, e, f, h, i = a.length; d < i; d++) {
          l.setAttribute("type", f = a[d]), e = l.type !== "text", e && (l.value = m, l.style.cssText = "position:absolute;visibility:hidden;", /^range$/.test(f) && l.style.WebkitAppearance !== c ? (g.appendChild(l), h = b.defaultView, e = h.getComputedStyle && h.getComputedStyle(l, null).WebkitAppearance !== "textfield" && l.offsetHeight !== 0, g.removeChild(l)) : /^(search|tel)$/.test(f) || (/^(url|email)$/.test(f) ? e = l.checkValidity && l.checkValidity() === !1 : /^color$/.test(f) ? (g.appendChild(l), g.offsetWidth, e = l.value != m, g.removeChild(l)) : e = l.value != m)), s[a[d]] = !!e;
        }

        return s;
      }("search tel url email datetime date month week time datetime-local number range color".split(" "));
    }

    function G(a, b) {
      var c = a.charAt(0).toUpperCase() + a.substr(1),
          d = (a + " " + p.join(c + " ") + c).split(" ");
      return F(d, b);
    }

    function F(a, b) {
      for (var d in a) {
        if (k[a[d]] !== c) return b == "pfx" ? a[d] : !0;
      }

      return !1;
    }

    function E(a, b) {
      return !!~("" + a).indexOf(b);
    }

    function D(a, b) {
      return _typeof(a) === b;
    }

    function C(a, b) {
      return B(o.join(a + ";") + (b || ""));
    }

    function B(a) {
      k.cssText = a;
    }

    var d = "2.0.6",
        e = {},
        f = !0,
        g = b.documentElement,
        h = b.head || b.getElementsByTagName("head")[0],
        i = "modernizr",
        j = b.createElement(i),
        k = j.style,
        l = b.createElement("input"),
        m = ":)",
        n = Object.prototype.toString,
        o = " -webkit- -moz- -o- -ms- -khtml- ".split(" "),
        p = "Webkit Moz O ms Khtml".split(" "),
        q = {
      svg: "http://www.w3.org/2000/svg"
    },
        r = {},
        s = {},
        t = {},
        u = [],
        v = function v(a, c, d, e) {
      var f,
          h,
          j,
          k = b.createElement("div");
      if (parseInt(d, 10)) while (d--) {
        j = b.createElement("div"), j.id = e ? e[d] : i + (d + 1), k.appendChild(j);
      }
      f = ["&shy;", "<style>", a, "</style>"].join(""), k.id = i, k.innerHTML += f, g.appendChild(k), h = c(k, a), k.parentNode.removeChild(k);
      return !!h;
    },
        w = function w(b) {
      if (a.matchMedia) return matchMedia(b).matches;
      var c;
      v("@media " + b + " { #" + i + " { position: absolute; } }", function (b) {
        c = (a.getComputedStyle ? getComputedStyle(b, null) : b.currentStyle).position == "absolute";
      });
      return c;
    },
        x = function () {
      function d(d, e) {
        e = e || b.createElement(a[d] || "div"), d = "on" + d;
        var f = d in e;
        f || (e.setAttribute || (e = b.createElement("div")), e.setAttribute && e.removeAttribute && (e.setAttribute(d, ""), f = D(e[d], "function"), D(e[d], c) || (e[d] = c), e.removeAttribute(d))), e = null;
        return f;
      }

      var a = {
        select: "input",
        change: "input",
        submit: "form",
        reset: "form",
        error: "img",
        load: "img",
        abort: "img"
      };
      return d;
    }(),
        y,
        z = {}.hasOwnProperty,
        A;

    !D(z, c) && !D(z.call, c) ? A = function A(a, b) {
      return z.call(a, b);
    } : A = function A(a, b) {
      return b in a && D(a.constructor.prototype[b], c);
    };

    var H = function (c, d) {
      var f = c.join(""),
          g = d.length;
      v(f, function (c, d) {
        var f = b.styleSheets[b.styleSheets.length - 1],
            h = f.cssRules && f.cssRules[0] ? f.cssRules[0].cssText : f.cssText || "",
            i = c.childNodes,
            j = {};

        while (g--) {
          j[i[g].id] = i[g];
        }

        e.touch = "ontouchstart" in a || j.touch.offsetTop === 9, e.csstransforms3d = j.csstransforms3d.offsetLeft === 9, e.generatedcontent = j.generatedcontent.offsetHeight >= 1, e.fontface = /src/i.test(h) && h.indexOf(d.split(" ")[0]) === 0;
      }, g, d);
    }(['@font-face {font-family:"font";src:url("https://")}', ["@media (", o.join("touch-enabled),("), i, ")", "{#touch{top:9px;position:absolute}}"].join(""), ["@media (", o.join("transform-3d),("), i, ")", "{#csstransforms3d{left:9px;position:absolute}}"].join(""), ['#generatedcontent:after{content:"', m, '";visibility:hidden}'].join("")], ["fontface", "touch", "csstransforms3d", "generatedcontent"]);

    r.flexbox = function () {
      function c(a, b, c, d) {
        a.style.cssText = o.join(b + ":" + c + ";") + (d || "");
      }

      function a(a, b, c, d) {
        b += ":", a.style.cssText = (b + o.join(c + ";" + b)).slice(0, -b.length) + (d || "");
      }

      var d = b.createElement("div"),
          e = b.createElement("div");
      a(d, "display", "box", "width:42px;padding:0;"), c(e, "box-flex", "1", "width:10px;"), d.appendChild(e), g.appendChild(d);
      var f = e.offsetWidth === 42;
      d.removeChild(e), g.removeChild(d);
      return f;
    }, r.canvas = function () {
      var a = b.createElement("canvas");
      return !!a.getContext && !!a.getContext("2d");
    }, r.canvastext = function () {
      return !!e.canvas && !!D(b.createElement("canvas").getContext("2d").fillText, "function");
    }, r.webgl = function () {
      return !!a.WebGLRenderingContext;
    }, r.touch = function () {
      return e.touch;
    }, r.geolocation = function () {
      return !!navigator.geolocation;
    }, r.postmessage = function () {
      return !!a.postMessage;
    }, r.websqldatabase = function () {
      var b = !!a.openDatabase;
      return b;
    }, r.indexedDB = function () {
      for (var b = -1, c = p.length; ++b < c;) {
        if (a[p[b].toLowerCase() + "IndexedDB"]) return !0;
      }

      return !!a.indexedDB;
    }, r.hashchange = function () {
      return x("hashchange", a) && (b.documentMode === c || b.documentMode > 7);
    }, r.history = function () {
      return !!a.history && !!history.pushState;
    }, r.draganddrop = function () {
      return x("dragstart") && x("drop");
    }, r.websockets = function () {
      for (var b = -1, c = p.length; ++b < c;) {
        if (a[p[b] + "WebSocket"]) return !0;
      }

      return "WebSocket" in a;
    }, r.rgba = function () {
      B("background-color:rgba(150,255,150,.5)");
      return E(k.backgroundColor, "rgba");
    }, r.hsla = function () {
      B("background-color:hsla(120,40%,100%,.5)");
      return E(k.backgroundColor, "rgba") || E(k.backgroundColor, "hsla");
    }, r.multiplebgs = function () {
      B("background:url(https://),url(https://),red url(https://)");
      return /(url\s*\(.*?){3}/.test(k.background);
    }, r.backgroundsize = function () {
      return G("backgroundSize");
    }, r.borderimage = function () {
      return G("borderImage");
    }, r.borderradius = function () {
      return G("borderRadius");
    }, r.boxshadow = function () {
      return G("boxShadow");
    }, r.textshadow = function () {
      return b.createElement("div").style.textShadow === "";
    }, r.opacity = function () {
      C("opacity:.55");
      return /^0.55$/.test(k.opacity);
    }, r.cssanimations = function () {
      return G("animationName");
    }, r.csscolumns = function () {
      return G("columnCount");
    }, r.cssgradients = function () {
      var a = "background-image:",
          b = "gradient(linear,left top,right bottom,from(#9f9),to(white));",
          c = "linear-gradient(left top,#9f9, white);";
      B((a + o.join(b + a) + o.join(c + a)).slice(0, -a.length));
      return E(k.backgroundImage, "gradient");
    }, r.cssreflections = function () {
      return G("boxReflect");
    }, r.csstransforms = function () {
      return !!F(["transformProperty", "WebkitTransform", "MozTransform", "OTransform", "msTransform"]);
    }, r.csstransforms3d = function () {
      var a = !!F(["perspectiveProperty", "WebkitPerspective", "MozPerspective", "OPerspective", "msPerspective"]);
      a && "webkitPerspective" in g.style && (a = e.csstransforms3d);
      return a;
    }, r.csstransitions = function () {
      return G("transitionProperty");
    }, r.fontface = function () {
      return e.fontface;
    }, r.generatedcontent = function () {
      return e.generatedcontent;
    }, r.video = function () {
      var a = b.createElement("video"),
          c = !1;

      try {
        if (c = !!a.canPlayType) {
          c = new Boolean(c), c.ogg = a.canPlayType('video/ogg; codecs="theora"');
          var d = 'video/mp4; codecs="avc1.42E01E';
          c.h264 = a.canPlayType(d + '"') || a.canPlayType(d + ', mp4a.40.2"'), c.webm = a.canPlayType('video/webm; codecs="vp8, vorbis"');
        }
      } catch (e) {}

      return c;
    }, r.audio = function () {
      var a = b.createElement("audio"),
          c = !1;

      try {
        if (c = !!a.canPlayType) c = new Boolean(c), c.ogg = a.canPlayType('audio/ogg; codecs="vorbis"'), c.mp3 = a.canPlayType("audio/mpeg;"), c.wav = a.canPlayType('audio/wav; codecs="1"'), c.m4a = a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;");
      } catch (d) {}

      return c;
    }, r.localstorage = function () {
      try {
        return !!localStorage.getItem;
      } catch (a) {
        return !1;
      }
    }, r.sessionstorage = function () {
      try {
        return !!sessionStorage.getItem;
      } catch (a) {
        return !1;
      }
    }, r.webworkers = function () {
      return !!a.Worker;
    }, r.applicationcache = function () {
      return !!a.applicationCache;
    }, r.svg = function () {
      return !!b.createElementNS && !!b.createElementNS(q.svg, "svg").createSVGRect;
    }, r.inlinesvg = function () {
      var a = b.createElement("div");
      a.innerHTML = "<svg/>";
      return (a.firstChild && a.firstChild.namespaceURI) == q.svg;
    }, r.smil = function () {
      return !!b.createElementNS && /SVG/.test(n.call(b.createElementNS(q.svg, "animate")));
    }, r.svgclippaths = function () {
      return !!b.createElementNS && /SVG/.test(n.call(b.createElementNS(q.svg, "clipPath")));
    };

    for (var J in r) {
      A(r, J) && (y = J.toLowerCase(), e[y] = r[J](), u.push((e[y] ? "" : "no-") + y));
    }

    e.input || I(), B(""), j = l = null, a.attachEvent && function () {
      var a = b.createElement("div");
      a.innerHTML = "<elem></elem>";
      return a.childNodes.length !== 1;
    }() && function (a, b) {
      function s(a) {
        var b = -1;

        while (++b < g) {
          a.createElement(f[b]);
        }
      }

      a.iepp = a.iepp || {};
      var d = a.iepp,
          e = d.html5elements || "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
          f = e.split("|"),
          g = f.length,
          h = new RegExp("(^|\\s)(" + e + ")", "gi"),
          i = new RegExp("<(/*)(" + e + ")", "gi"),
          j = /^\s*[\{\}]\s*$/,
          k = new RegExp("(^|[^\\n]*?\\s)(" + e + ")([^\\n]*)({[\\n\\w\\W]*?})", "gi"),
          l = b.createDocumentFragment(),
          m = b.documentElement,
          n = m.firstChild,
          o = b.createElement("body"),
          p = b.createElement("style"),
          q = /print|all/,
          r;
      d.getCSS = function (a, b) {
        if (a + "" === c) return "";
        var e = -1,
            f = a.length,
            g,
            h = [];

        while (++e < f) {
          g = a[e];
          if (g.disabled) continue;
          b = g.media || b, q.test(b) && h.push(d.getCSS(g.imports, b), g.cssText), b = "all";
        }

        return h.join("");
      }, d.parseCSS = function (a) {
        var b = [],
            c;

        while ((c = k.exec(a)) != null) {
          b.push(((j.exec(c[1]) ? "\n" : c[1]) + c[2] + c[3]).replace(h, "$1.iepp_$2") + c[4]);
        }

        return b.join("\n");
      }, d.writeHTML = function () {
        var a = -1;
        r = r || b.body;

        while (++a < g) {
          var c = b.getElementsByTagName(f[a]),
              d = c.length,
              e = -1;

          while (++e < d) {
            c[e].className.indexOf("iepp_") < 0 && (c[e].className += " iepp_" + f[a]);
          }
        }

        l.appendChild(r), m.appendChild(o), o.className = r.className, o.id = r.id, o.innerHTML = r.innerHTML.replace(i, "<$1font");
      }, d._beforePrint = function () {
        p.styleSheet.cssText = d.parseCSS(d.getCSS(b.styleSheets, "all")), d.writeHTML();
      }, d.restoreHTML = function () {
        o.innerHTML = "", m.removeChild(o), m.appendChild(r);
      }, d._afterPrint = function () {
        d.restoreHTML(), p.styleSheet.cssText = "";
      }, s(b), s(l);
      d.disablePP || (n.insertBefore(p, n.firstChild), p.media = "print", p.className = "iepp-printshim", a.attachEvent("onbeforeprint", d._beforePrint), a.attachEvent("onafterprint", d._afterPrint));
    }(a, b), e._version = d, e._prefixes = o, e._domPrefixes = p, e.mq = w, e.hasEvent = x, e.testProp = function (a) {
      return F([a]);
    }, e.testAllProps = G, e.testStyles = v, g.className = g.className.replace(/\bno-js\b/, "") + (f ? " js " + u.join(" ") : "");
    return e;
  }(this, this.document), function (a, b, c) {
    function k(a) {
      return !a || a == "loaded" || a == "complete";
    }

    function j() {
      var a = 1,
          b = -1;

      while (p.length - ++b) {
        if (p[b].s && !(a = p[b].r)) break;
      }

      a && g();
    }

    function i(a) {
      var c = b.createElement("script"),
          d;
      c.src = a.s, c.onreadystatechange = c.onload = function () {
        !d && k(c.readyState) && (d = 1, j(), c.onload = c.onreadystatechange = null);
      }, m(function () {
        d || (d = 1, j());
      }, _H.errorTimeout), a.e ? c.onload() : n.parentNode.insertBefore(c, n);
    }

    function h(a) {
      var c = b.createElement("link"),
          d;
      c.href = a.s, c.rel = "stylesheet", c.type = "text/css";

      if (!a.e && (w || r)) {
        var e = function e(a) {
          m(function () {
            if (!d) try {
              a.sheet.cssRules.length ? (d = 1, j()) : e(a);
            } catch (b) {
              b.code == 1e3 || b.message == "security" || b.message == "denied" ? (d = 1, m(function () {
                j();
              }, 0)) : e(a);
            }
          }, 0);
        };

        e(c);
      } else c.onload = function () {
        d || (d = 1, m(function () {
          j();
        }, 0));
      }, a.e && c.onload();

      m(function () {
        d || (d = 1, j());
      }, _H.errorTimeout), !a.e && n.parentNode.insertBefore(c, n);
    }

    function g() {
      var a = p.shift();
      q = 1, a ? a.t ? m(function () {
        a.t == "c" ? h(a) : i(a);
      }, 0) : (a(), j()) : q = 0;
    }

    function f(a, c, d, e, f, h) {
      function i() {
        !o && k(l.readyState) && (r.r = o = 1, !q && j(), l.onload = l.onreadystatechange = null, m(function () {
          u.removeChild(l);
        }, 0));
      }

      var l = b.createElement(a),
          o = 0,
          r = {
        t: d,
        s: c,
        e: h
      };
      l.src = l.data = c, !s && (l.style.display = "none"), l.width = l.height = "0", a != "object" && (l.type = d), l.onload = l.onreadystatechange = i, a == "img" ? l.onerror = i : a == "script" && (l.onerror = function () {
        r.e = r.r = 1, g();
      }), p.splice(e, 0, r), u.insertBefore(l, s ? null : n), m(function () {
        o || (u.removeChild(l), r.r = r.e = o = 1, j());
      }, _H.errorTimeout);
    }

    function e(a, b, c) {
      var d = b == "c" ? z : y;
      q = 0, b = b || "j", C(a) ? f(d, a, b, this.i++, l, c) : (p.splice(this.i++, 0, a), p.length == 1 && g());
      return this;
    }

    function d() {
      var a = _H;
      a.loader = {
        load: e,
        i: 0
      };
      return a;
    }

    var l = b.documentElement,
        m = a.setTimeout,
        n = b.getElementsByTagName("script")[0],
        o = {}.toString,
        p = [],
        q = 0,
        r = "MozAppearance" in l.style,
        s = r && !!b.createRange().compareNode,
        t = r && !s,
        u = s ? l : n.parentNode,
        v = a.opera && o.call(a.opera) == "[object Opera]",
        w = "webkitAppearance" in l.style,
        x = w && "async" in b.createElement("script"),
        y = r ? "object" : v || x ? "img" : "script",
        z = w ? "img" : y,
        A = Array.isArray || function (a) {
      return o.call(a) == "[object Array]";
    },
        B = function B(a) {
      return Object(a) === a;
    },
        C = function C(a) {
      return typeof a == "string";
    },
        D = function D(a) {
      return o.call(a) == "[object Function]";
    },
        E = [],
        F = {},
        _G,
        _H;

    _H = function H(a) {
      function f(a) {
        var b = a.split("!"),
            c = E.length,
            d = b.pop(),
            e = b.length,
            f = {
          url: d,
          origUrl: d,
          prefixes: b
        },
            g,
            h;

        for (h = 0; h < e; h++) {
          g = F[b[h]], g && (f = g(f));
        }

        for (h = 0; h < c; h++) {
          f = E[h](f);
        }

        return f;
      }

      function e(a, b, e, g, h) {
        var i = f(a),
            j = i.autoCallback;

        if (!i.bypass) {
          b && (b = D(b) ? b : b[a] || b[g] || b[a.split("/").pop().split("?")[0]]);
          if (i.instead) return i.instead(a, b, e, g, h);
          e.load(i.url, i.forceCSS || !i.forceJS && /css$/.test(i.url) ? "c" : c, i.noexec), (D(b) || D(j)) && e.load(function () {
            d(), b && b(i.origUrl, h, g), j && j(i.origUrl, h, g);
          });
        }
      }

      function b(a, b) {
        function c(a) {
          if (C(a)) e(a, h, b, 0, d);else if (B(a)) for (i in a) {
            a.hasOwnProperty(i) && e(a[i], h, b, i, d);
          }
        }

        var d = !!a.test,
            f = d ? a.yep : a.nope,
            g = a.load || a.both,
            h = a.callback,
            i;
        c(f), c(g), a.complete && b.load(a.complete);
      }

      var g,
          h,
          i = this.yepnope.loader;
      if (C(a)) e(a, 0, i, 0);else if (A(a)) for (g = 0; g < a.length; g++) {
        h = a[g], C(h) ? e(h, 0, i, 0) : A(h) ? _H(h) : B(h) && b(h, i);
      } else B(a) && b(a, i);
    }, _H.addPrefix = function (a, b) {
      F[a] = b;
    }, _H.addFilter = function (a) {
      E.push(a);
    }, _H.errorTimeout = 1e4, b.readyState == null && b.addEventListener && (b.readyState = "loading", b.addEventListener("DOMContentLoaded", _G = function G() {
      b.removeEventListener("DOMContentLoaded", _G, 0), b.readyState = "complete";
    }, 0)), a.yepnope = d();
  }(this, this.document), Modernizr.load = function () {
    yepnope.apply(window, [].slice.call(arguments, 0));
  };
  /*** EXPORTS FROM exports-loader ***/

  module.exports = window.Modernizr;
}).call(window);

/***/ }),

/***/ "./js/plugins/waves/waves-custom.js":
/*!******************************************!*\
  !*** ./js/plugins/waves/waves-custom.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * Waves v0.5.5
 * http://fian.my.id/Waves 
 * 
 * Copyright 2014 Alfiana E. Sibuea and other contributors 
 * Released under the MIT license 
 * https://github.com/fians/Waves/blob/master/LICENSE 
 */
;

(function (window) {
  'use strict';

  var Waves = Waves || {}; //var $$ = document.querySelectorAll.bind(document);
  // Find exact position of element

  function isWindow(obj) {
    return obj !== null && obj === obj.window;
  }

  function getWindow(elem) {
    return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }

  function offset(elem) {
    var docElem,
        win,
        box = {
      top: 0,
      left: 0
    },
        doc = elem && elem.ownerDocument;
    docElem = doc.documentElement;

    if (_typeof(elem.getBoundingClientRect) !== ( true ? "undefined" : undefined)) {
      box = elem.getBoundingClientRect();
    }

    win = getWindow(doc);
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  }

  function convertStyle(obj) {
    var style = '';

    for (var a in obj) {
      if (obj.hasOwnProperty(a)) {
        style += a + ':' + obj[a] + ';';
      }
    }

    return style;
  }

  var Effect = {
    // Effect delay
    duration: 500,
    show: function show(e) {
      // Disable right click
      if (e.button === 2) {
        return false;
      }

      var el = this;
      var ripple = $(this).find('.waves-ripple.waves-ripple-ripple').get(0);
      var staticripple = $(this).find('.waves-ripple.waves-ripple-static').get(0); // Get click coordinate and element witdh

      var pos = offset(el);
      var relativeY = e.pageY - pos.top;
      var relativeX = e.pageX - pos.left; // Support for touch devices

      if ('touches' in e) {
        relativeY = e.touches[0].pageY - pos.top;
        relativeX = e.touches[0].pageX - pos.left;
      }

      var scale = Math.max(el.clientWidth, el.clientHeight) / 100 * 3;
      new TimelineMax().set(ripple, {
        scale: 0,
        top: relativeY,
        left: relativeX,
        opacity: 0
      }).to(ripple, Effect.duration / 1000, {
        scale: scale,
        opacity: 1,
        force3D: prx.greensockForce3D
      });
      new TimelineMax().set(staticripple, {
        scale: scale,
        opacity: 0
      }).to(staticripple, 200 / 1000, {
        opacity: 0.3,
        force3D: prx.greensockForce3D
      });
    },
    hide: function hide() {
      var el = this;
      var ripple = $(this).find('.waves-ripple.waves-ripple-ripple').get(0);
      var staticripple = $(this).find('.waves-ripple.waves-ripple-static').get(0);

      if (!ripple) {
        return false;
      }

      var delay = 200;
      new TimelineMax().to(ripple, 200 / 1000, {
        opacity: 0,
        delay: delay / 1000,
        force3D: prx.greensockForce3D
      });
      new TimelineMax().to(staticripple, 200 / 1000, {
        opacity: 0,
        delay: delay / 1000,
        force3D: prx.greensockForce3D
      });
    },
    // Little hack to make <input> can perform waves effect
    wrapInput: function wrapInput(elements) {
      for (var a = 0; a < elements.length; a++) {
        var el = elements[a];

        if (el.tagName.toLowerCase() === 'input') {
          var parent = el.parentNode; // If input already have parent just pass through

          if (parent.tagName.toLowerCase() === 'i' && parent.className.indexOf('waves-effect') !== -1) {
            return false;
          } // Put element class and style to the specified parent


          var wrapper = document.createElement('i');
          wrapper.className = el.className + ' waves-input-wrapper';
          var elementStyle = el.getAttribute('style');

          if (!elementStyle) {
            elementStyle = '';
          }

          wrapper.setAttribute('style', elementStyle);
          el.className = 'waves-button-input';
          el.removeAttribute('style'); // Put element as child

          parent.replaceChild(wrapper, el);
          wrapper.appendChild(el);
        }
      }
    },
    create: function create(elements) {
      for (var a = 0; a < elements.length; a++) {
        var el = $(elements[a]).find('.prx-material-ripple-roundoverflow').get(0) || elements[a]; // Create ripple

        var ripple = document.createElement('div');
        ripple.className = 'waves-ripple waves-ripple-ripple';
        el.appendChild(ripple); // ANNAM Create static ripple

        var staticripple = document.createElement('div');
        staticripple.className = 'waves-ripple waves-ripple-static waves-notransition';
        el.appendChild(staticripple);
      }
    }
  };

  Waves.displayEffect = function (options) {
    options = options || {};

    if ('duration' in options) {
      Effect.duration = options.duration;
    } // ANNAM - add itemid in options to only initialize on specific item


    var target = typeof options.itemid != "undefined" ? options.itemid : '.waves-effect'; //Wrap input inside <i> tag

    Effect.wrapInput($(target).get());
    Effect.create($(target).get());
    Array.prototype.forEach.call($(target).get(), function (i) {
      if ('ontouchstart' in window) {
        i.addEventListener('touchstart', Effect.show, false);
        i.addEventListener('touchend', Effect.hide, false);
        i.addEventListener('touchcancel', Effect.hide, false);
      } else {
        i.addEventListener('mousedown', Effect.show, false);
        i.addEventListener('mouseup', Effect.hide, false);
        i.addEventListener('mouseleave', Effect.hide, false);
      }
    });
  };

  window.Waves = Waves;
})(window);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./js/plugins/webfontloader/webfontloader.1.6.28.js":
/*!**********************************************************!*\
  !*** ./js/plugins/webfontloader/webfontloader.1.6.28.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */
(function () {
  function aa(a, b, c) {
    return a.call.apply(a.bind, arguments);
  }

  function ba(a, b, c) {
    if (!a) throw Error();

    if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);
      return function () {
        var c = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(c, d);
        return a.apply(b, c);
      };
    }

    return function () {
      return a.apply(b, arguments);
    };
  }

  function p(a, b, c) {
    p = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? aa : ba;
    return p.apply(null, arguments);
  }

  var q = Date.now || function () {
    return +new Date();
  };

  function ca(a, b) {
    this.a = a;
    this.o = b || a;
    this.c = this.o.document;
  }

  var da = !!window.FontFace;

  function t(a, b, c, d) {
    b = a.c.createElement(b);
    if (c) for (var e in c) {
      c.hasOwnProperty(e) && ("style" == e ? b.style.cssText = c[e] : b.setAttribute(e, c[e]));
    }
    d && b.appendChild(a.c.createTextNode(d));
    return b;
  }

  function u(a, b, c) {
    a = a.c.getElementsByTagName(b)[0];
    a || (a = document.documentElement);
    a.insertBefore(c, a.lastChild);
  }

  function v(a) {
    a.parentNode && a.parentNode.removeChild(a);
  }

  function w(a, b, c) {
    b = b || [];
    c = c || [];

    for (var d = a.className.split(/\s+/), e = 0; e < b.length; e += 1) {
      for (var f = !1, g = 0; g < d.length; g += 1) {
        if (b[e] === d[g]) {
          f = !0;
          break;
        }
      }

      f || d.push(b[e]);
    }

    b = [];

    for (e = 0; e < d.length; e += 1) {
      f = !1;

      for (g = 0; g < c.length; g += 1) {
        if (d[e] === c[g]) {
          f = !0;
          break;
        }
      }

      f || b.push(d[e]);
    }

    a.className = b.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "");
  }

  function y(a, b) {
    for (var c = a.className.split(/\s+/), d = 0, e = c.length; d < e; d++) {
      if (c[d] == b) return !0;
    }

    return !1;
  }

  function ea(a) {
    return a.o.location.hostname || a.a.location.hostname;
  }

  function z(a, b, c) {
    function d() {
      m && e && f && (m(g), m = null);
    }

    b = t(a, "link", {
      rel: "stylesheet",
      href: b,
      media: "all"
    });
    var e = !1,
        f = !0,
        g = null,
        m = c || null;
    da ? (b.onload = function () {
      e = !0;
      d();
    }, b.onerror = function () {
      e = !0;
      g = Error("Stylesheet failed to load");
      d();
    }) : setTimeout(function () {
      e = !0;
      d();
    }, 0);
    u(a, "head", b);
  }

  function A(a, b, c, d) {
    var e = a.c.getElementsByTagName("head")[0];

    if (e) {
      var f = t(a, "script", {
        src: b
      }),
          g = !1;

      f.onload = f.onreadystatechange = function () {
        g || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (g = !0, c && c(null), f.onload = f.onreadystatechange = null, "HEAD" == f.parentNode.tagName && e.removeChild(f));
      };

      e.appendChild(f);
      setTimeout(function () {
        g || (g = !0, c && c(Error("Script load timeout")));
      }, d || 5E3);
      return f;
    }

    return null;
  }

  ;

  function B() {
    this.a = 0;
    this.c = null;
  }

  function C(a) {
    a.a++;
    return function () {
      a.a--;
      D(a);
    };
  }

  function E(a, b) {
    a.c = b;
    D(a);
  }

  function D(a) {
    0 == a.a && a.c && (a.c(), a.c = null);
  }

  ;

  function F(a) {
    this.a = a || "-";
  }

  F.prototype.c = function (a) {
    for (var b = [], c = 0; c < arguments.length; c++) {
      b.push(arguments[c].replace(/[\W_]+/g, "").toLowerCase());
    }

    return b.join(this.a);
  };

  function G(a, b) {
    this.c = a;
    this.f = 4;
    this.a = "n";
    var c = (b || "n4").match(/^([nio])([1-9])$/i);
    c && (this.a = c[1], this.f = parseInt(c[2], 10));
  }

  function fa(a) {
    return H(a) + " " + (a.f + "00") + " 300px " + I(a.c);
  }

  function I(a) {
    var b = [];
    a = a.split(/,\s*/);

    for (var c = 0; c < a.length; c++) {
      var d = a[c].replace(/['"]/g, "");
      -1 != d.indexOf(" ") || /^\d/.test(d) ? b.push("'" + d + "'") : b.push(d);
    }

    return b.join(",");
  }

  function J(a) {
    return a.a + a.f;
  }

  function H(a) {
    var b = "normal";
    "o" === a.a ? b = "oblique" : "i" === a.a && (b = "italic");
    return b;
  }

  function ga(a) {
    var b = 4,
        c = "n",
        d = null;
    a && ((d = a.match(/(normal|oblique|italic)/i)) && d[1] && (c = d[1].substr(0, 1).toLowerCase()), (d = a.match(/([1-9]00|normal|bold)/i)) && d[1] && (/bold/i.test(d[1]) ? b = 7 : /[1-9]00/.test(d[1]) && (b = parseInt(d[1].substr(0, 1), 10))));
    return c + b;
  }

  ;

  function ha(a, b) {
    this.c = a;
    this.f = a.o.document.documentElement;
    this.h = b;
    this.a = new F("-");
    this.j = !1 !== b.events;
    this.g = !1 !== b.classes;
  }

  function ia(a) {
    a.g && w(a.f, [a.a.c("wf", "loading")]);
    K(a, "loading");
  }

  function L(a) {
    if (a.g) {
      var b = y(a.f, a.a.c("wf", "active")),
          c = [],
          d = [a.a.c("wf", "loading")];
      b || c.push(a.a.c("wf", "inactive"));
      w(a.f, c, d);
    }

    K(a, "inactive");
  }

  function K(a, b, c) {
    if (a.j && a.h[b]) if (c) a.h[b](c.c, J(c));else a.h[b]();
  }

  ;

  function ja() {
    this.c = {};
  }

  function ka(a, b, c) {
    var d = [],
        e;

    for (e in b) {
      if (b.hasOwnProperty(e)) {
        var f = a.c[e];
        f && d.push(f(b[e], c));
      }
    }

    return d;
  }

  ;

  function M(a, b) {
    this.c = a;
    this.f = b;
    this.a = t(this.c, "span", {
      "aria-hidden": "true"
    }, this.f);
  }

  function N(a) {
    u(a.c, "body", a.a);
  }

  function O(a) {
    return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + I(a.c) + ";" + ("font-style:" + H(a) + ";font-weight:" + (a.f + "00") + ";");
  }

  ;

  function P(a, b, c, d, e, f) {
    this.g = a;
    this.j = b;
    this.a = d;
    this.c = c;
    this.f = e || 3E3;
    this.h = f || void 0;
  }

  P.prototype.start = function () {
    var a = this.c.o.document,
        b = this,
        c = q(),
        d = new Promise(function (d, e) {
      function f() {
        q() - c >= b.f ? e() : a.fonts.load(fa(b.a), b.h).then(function (a) {
          1 <= a.length ? d() : setTimeout(f, 25);
        }, function () {
          e();
        });
      }

      f();
    }),
        e = null,
        f = new Promise(function (a, d) {
      e = setTimeout(d, b.f);
    });
    Promise.race([f, d]).then(function () {
      e && (clearTimeout(e), e = null);
      b.g(b.a);
    }, function () {
      b.j(b.a);
    });
  };

  function Q(a, b, c, d, e, f, g) {
    this.v = a;
    this.B = b;
    this.c = c;
    this.a = d;
    this.s = g || "BESbswy";
    this.f = {};
    this.w = e || 3E3;
    this.u = f || null;
    this.m = this.j = this.h = this.g = null;
    this.g = new M(this.c, this.s);
    this.h = new M(this.c, this.s);
    this.j = new M(this.c, this.s);
    this.m = new M(this.c, this.s);
    a = new G(this.a.c + ",serif", J(this.a));
    a = O(a);
    this.g.a.style.cssText = a;
    a = new G(this.a.c + ",sans-serif", J(this.a));
    a = O(a);
    this.h.a.style.cssText = a;
    a = new G("serif", J(this.a));
    a = O(a);
    this.j.a.style.cssText = a;
    a = new G("sans-serif", J(this.a));
    a = O(a);
    this.m.a.style.cssText = a;
    N(this.g);
    N(this.h);
    N(this.j);
    N(this.m);
  }

  var R = {
    D: "serif",
    C: "sans-serif"
  },
      S = null;

  function T() {
    if (null === S) {
      var a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
      S = !!a && (536 > parseInt(a[1], 10) || 536 === parseInt(a[1], 10) && 11 >= parseInt(a[2], 10));
    }

    return S;
  }

  Q.prototype.start = function () {
    this.f.serif = this.j.a.offsetWidth;
    this.f["sans-serif"] = this.m.a.offsetWidth;
    this.A = q();
    U(this);
  };

  function la(a, b, c) {
    for (var d in R) {
      if (R.hasOwnProperty(d) && b === a.f[R[d]] && c === a.f[R[d]]) return !0;
    }

    return !1;
  }

  function U(a) {
    var b = a.g.a.offsetWidth,
        c = a.h.a.offsetWidth,
        d;
    (d = b === a.f.serif && c === a.f["sans-serif"]) || (d = T() && la(a, b, c));
    d ? q() - a.A >= a.w ? T() && la(a, b, c) && (null === a.u || a.u.hasOwnProperty(a.a.c)) ? V(a, a.v) : V(a, a.B) : ma(a) : V(a, a.v);
  }

  function ma(a) {
    setTimeout(p(function () {
      U(this);
    }, a), 50);
  }

  function V(a, b) {
    setTimeout(p(function () {
      v(this.g.a);
      v(this.h.a);
      v(this.j.a);
      v(this.m.a);
      b(this.a);
    }, a), 0);
  }

  ;

  function W(a, b, c) {
    this.c = a;
    this.a = b;
    this.f = 0;
    this.m = this.j = !1;
    this.s = c;
  }

  var X = null;

  W.prototype.g = function (a) {
    var b = this.a;
    b.g && w(b.f, [b.a.c("wf", a.c, J(a).toString(), "active")], [b.a.c("wf", a.c, J(a).toString(), "loading"), b.a.c("wf", a.c, J(a).toString(), "inactive")]);
    K(b, "fontactive", a);
    this.m = !0;
    na(this);
  };

  W.prototype.h = function (a) {
    var b = this.a;

    if (b.g) {
      var c = y(b.f, b.a.c("wf", a.c, J(a).toString(), "active")),
          d = [],
          e = [b.a.c("wf", a.c, J(a).toString(), "loading")];
      c || d.push(b.a.c("wf", a.c, J(a).toString(), "inactive"));
      w(b.f, d, e);
    }

    K(b, "fontinactive", a);
    na(this);
  };

  function na(a) {
    0 == --a.f && a.j && (a.m ? (a = a.a, a.g && w(a.f, [a.a.c("wf", "active")], [a.a.c("wf", "loading"), a.a.c("wf", "inactive")]), K(a, "active")) : L(a.a));
  }

  ;

  function oa(a) {
    this.j = a;
    this.a = new ja();
    this.h = 0;
    this.f = this.g = !0;
  }

  oa.prototype.load = function (a) {
    this.c = new ca(this.j, a.context || this.j);
    this.g = !1 !== a.events;
    this.f = !1 !== a.classes;
    pa(this, new ha(this.c, a), a);
  };

  function qa(a, b, c, d, e) {
    var f = 0 == --a.h;
    (a.f || a.g) && setTimeout(function () {
      var a = e || null,
          m = d || null || {};
      if (0 === c.length && f) L(b.a);else {
        b.f += c.length;
        f && (b.j = f);
        var h,
            l = [];

        for (h = 0; h < c.length; h++) {
          var k = c[h],
              n = m[k.c],
              r = b.a,
              x = k;
          r.g && w(r.f, [r.a.c("wf", x.c, J(x).toString(), "loading")]);
          K(r, "fontloading", x);
          r = null;
          if (null === X) if (window.FontFace) {
            var x = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                xa = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
            X = x ? 42 < parseInt(x[1], 10) : xa ? !1 : !0;
          } else X = !1;
          X ? r = new P(p(b.g, b), p(b.h, b), b.c, k, b.s, n) : r = new Q(p(b.g, b), p(b.h, b), b.c, k, b.s, a, n);
          l.push(r);
        }

        for (h = 0; h < l.length; h++) {
          l[h].start();
        }
      }
    }, 0);
  }

  function pa(a, b, c) {
    var d = [],
        e = c.timeout;
    ia(b);
    var d = ka(a.a, c, a.c),
        f = new W(a.c, b, e);
    a.h = d.length;
    b = 0;

    for (c = d.length; b < c; b++) {
      d[b].load(function (b, d, c) {
        qa(a, f, b, d, c);
      });
    }
  }

  ;

  function ra(a, b) {
    this.c = a;
    this.a = b;
  }

  ra.prototype.load = function (a) {
    function b() {
      if (f["__mti_fntLst" + d]) {
        var c = f["__mti_fntLst" + d](),
            e = [],
            h;
        if (c) for (var l = 0; l < c.length; l++) {
          var k = c[l].fontfamily;
          void 0 != c[l].fontStyle && void 0 != c[l].fontWeight ? (h = c[l].fontStyle + c[l].fontWeight, e.push(new G(k, h))) : e.push(new G(k));
        }
        a(e);
      } else setTimeout(function () {
        b();
      }, 50);
    }

    var c = this,
        d = c.a.projectId,
        e = c.a.version;

    if (d) {
      var f = c.c.o;
      A(this.c, (c.a.api || "https://fast.fonts.net/jsapi") + "/" + d + ".js" + (e ? "?v=" + e : ""), function (e) {
        e ? a([]) : (f["__MonotypeConfiguration__" + d] = function () {
          return c.a;
        }, b());
      }).id = "__MonotypeAPIScript__" + d;
    } else a([]);
  };

  function sa(a, b) {
    this.c = a;
    this.a = b;
  }

  sa.prototype.load = function (a) {
    var b,
        c,
        d = this.a.urls || [],
        e = this.a.families || [],
        f = this.a.testStrings || {},
        g = new B();
    b = 0;

    for (c = d.length; b < c; b++) {
      z(this.c, d[b], C(g));
    }

    var m = [];
    b = 0;

    for (c = e.length; b < c; b++) {
      if (d = e[b].split(":"), d[1]) for (var h = d[1].split(","), l = 0; l < h.length; l += 1) {
        m.push(new G(d[0], h[l]));
      } else m.push(new G(d[0]));
    }

    E(g, function () {
      a(m, f);
    });
  };

  function ta(a, b) {
    a ? this.c = a : this.c = ua;
    this.a = [];
    this.f = [];
    this.g = b || "";
  }

  var ua = "https://fonts.googleapis.com/css";

  function va(a, b) {
    for (var c = b.length, d = 0; d < c; d++) {
      var e = b[d].split(":");
      3 == e.length && a.f.push(e.pop());
      var f = "";
      2 == e.length && "" != e[1] && (f = ":");
      a.a.push(e.join(f));
    }
  }

  function wa(a) {
    if (0 == a.a.length) throw Error("No fonts to load!");
    if (-1 != a.c.indexOf("kit=")) return a.c;

    for (var b = a.a.length, c = [], d = 0; d < b; d++) {
      c.push(a.a[d].replace(/ /g, "+"));
    }

    b = a.c + "?family=" + c.join("%7C");
    0 < a.f.length && (b += "&subset=" + a.f.join(","));
    0 < a.g.length && (b += "&text=" + encodeURIComponent(a.g));
    return b;
  }

  ;

  function ya(a) {
    this.f = a;
    this.a = [];
    this.c = {};
  }

  var za = {
    latin: "BESbswy",
    "latin-ext": "\xE7\xF6\xFC\u011F\u015F",
    cyrillic: "\u0439\u044F\u0416",
    greek: "\u03B1\u03B2\u03A3",
    khmer: "\u1780\u1781\u1782",
    Hanuman: "\u1780\u1781\u1782"
  },
      Aa = {
    thin: "1",
    extralight: "2",
    "extra-light": "2",
    ultralight: "2",
    "ultra-light": "2",
    light: "3",
    regular: "4",
    book: "4",
    medium: "5",
    "semi-bold": "6",
    semibold: "6",
    "demi-bold": "6",
    demibold: "6",
    bold: "7",
    "extra-bold": "8",
    extrabold: "8",
    "ultra-bold": "8",
    ultrabold: "8",
    black: "9",
    heavy: "9",
    l: "3",
    r: "4",
    b: "7"
  },
      Ba = {
    i: "i",
    italic: "i",
    n: "n",
    normal: "n"
  },
      Ca = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;

  function Da(a) {
    for (var b = a.f.length, c = 0; c < b; c++) {
      var d = a.f[c].split(":"),
          e = d[0].replace(/\+/g, " "),
          f = ["n4"];

      if (2 <= d.length) {
        var g;
        var m = d[1];
        g = [];
        if (m) for (var m = m.split(","), h = m.length, l = 0; l < h; l++) {
          var k;
          k = m[l];

          if (k.match(/^[\w-]+$/)) {
            var n = Ca.exec(k.toLowerCase());
            if (null == n) k = "";else {
              k = n[2];
              k = null == k || "" == k ? "n" : Ba[k];
              n = n[1];
              if (null == n || "" == n) n = "4";else var r = Aa[n],
                  n = r ? r : isNaN(n) ? "4" : n.substr(0, 1);
              k = [k, n].join("");
            }
          } else k = "";

          k && g.push(k);
        }
        0 < g.length && (f = g);
        3 == d.length && (d = d[2], g = [], d = d ? d.split(",") : g, 0 < d.length && (d = za[d[0]]) && (a.c[e] = d));
      }

      a.c[e] || (d = za[e]) && (a.c[e] = d);

      for (d = 0; d < f.length; d += 1) {
        a.a.push(new G(e, f[d]));
      }
    }
  }

  ;

  function Ea(a, b) {
    this.c = a;
    this.a = b;
  }

  var Fa = {
    Arimo: !0,
    Cousine: !0,
    Tinos: !0
  };

  Ea.prototype.load = function (a) {
    var b = new B(),
        c = this.c,
        d = new ta(this.a.api, this.a.text),
        e = this.a.families;
    va(d, e);
    var f = new ya(e);
    Da(f);
    z(c, wa(d), C(b));
    E(b, function () {
      a(f.a, f.c, Fa);
    });
  };

  function Ga(a, b) {
    this.c = a;
    this.a = b;
  }

  Ga.prototype.load = function (a) {
    var b = this.a.id,
        c = this.c.o;
    b ? A(this.c, (this.a.api || "https://use.typekit.net") + "/" + b + ".js", function (b) {
      if (b) a([]);else if (c.Typekit && c.Typekit.config && c.Typekit.config.fn) {
        b = c.Typekit.config.fn;

        for (var e = [], f = 0; f < b.length; f += 2) {
          for (var g = b[f], m = b[f + 1], h = 0; h < m.length; h++) {
            e.push(new G(g, m[h]));
          }
        }

        try {
          c.Typekit.load({
            events: !1,
            classes: !1,
            async: !0
          });
        } catch (l) {}

        a(e);
      }
    }, 2E3) : a([]);
  };

  function Ha(a, b) {
    this.c = a;
    this.f = b;
    this.a = [];
  }

  Ha.prototype.load = function (a) {
    var b = this.f.id,
        c = this.c.o,
        d = this;
    b ? (c.__webfontfontdeckmodule__ || (c.__webfontfontdeckmodule__ = {}), c.__webfontfontdeckmodule__[b] = function (b, c) {
      for (var g = 0, m = c.fonts.length; g < m; ++g) {
        var h = c.fonts[g];
        d.a.push(new G(h.name, ga("font-weight:" + h.weight + ";font-style:" + h.style)));
      }

      a(d.a);
    }, A(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + ea(this.c) + "/" + b + ".js", function (b) {
      b && a([]);
    })) : a([]);
  };

  var Y = new oa(window);

  Y.a.c.custom = function (a, b) {
    return new sa(b, a);
  };

  Y.a.c.fontdeck = function (a, b) {
    return new Ha(b, a);
  };

  Y.a.c.monotype = function (a, b) {
    return new ra(b, a);
  };

  Y.a.c.typekit = function (a, b) {
    return new Ga(b, a);
  };

  Y.a.c.google = function (a, b) {
    return new Ea(b, a);
  };

  var Z = {
    load: p(Y.load, Y)
  };
   true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return Z;
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})();

/***/ }),

/***/ "./node_modules/@babel/polyfill/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@babel/polyfill/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./noConflict */ "./node_modules/@babel/polyfill/lib/noConflict.js");

var _global = _interopRequireDefault(__webpack_require__(/*! core-js/library/fn/global */ "./node_modules/core-js/library/fn/global.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (_global.default._babelPolyfill && typeof console !== "undefined" && console.warn) {
  console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
}

_global.default._babelPolyfill = true;

/***/ }),

/***/ "./node_modules/@babel/polyfill/lib/noConflict.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/polyfill/lib/noConflict.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/es6 */ "./node_modules/core-js/es6/index.js");

__webpack_require__(/*! core-js/fn/array/includes */ "./node_modules/core-js/fn/array/includes.js");

__webpack_require__(/*! core-js/fn/array/flat-map */ "./node_modules/core-js/fn/array/flat-map.js");

__webpack_require__(/*! core-js/fn/string/pad-start */ "./node_modules/core-js/fn/string/pad-start.js");

__webpack_require__(/*! core-js/fn/string/pad-end */ "./node_modules/core-js/fn/string/pad-end.js");

__webpack_require__(/*! core-js/fn/string/trim-start */ "./node_modules/core-js/fn/string/trim-start.js");

__webpack_require__(/*! core-js/fn/string/trim-end */ "./node_modules/core-js/fn/string/trim-end.js");

__webpack_require__(/*! core-js/fn/symbol/async-iterator */ "./node_modules/core-js/fn/symbol/async-iterator.js");

__webpack_require__(/*! core-js/fn/object/get-own-property-descriptors */ "./node_modules/core-js/fn/object/get-own-property-descriptors.js");

__webpack_require__(/*! core-js/fn/object/values */ "./node_modules/core-js/fn/object/values.js");

__webpack_require__(/*! core-js/fn/object/entries */ "./node_modules/core-js/fn/object/entries.js");

__webpack_require__(/*! core-js/fn/promise/finally */ "./node_modules/core-js/fn/promise/finally.js");

__webpack_require__(/*! core-js/web */ "./node_modules/core-js/web/index.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

/***/ }),

/***/ "./node_modules/core-js/es6/index.js":
/*!*******************************************!*\
  !*** ./node_modules/core-js/es6/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");
__webpack_require__(/*! ../modules/es6.object.create */ "./node_modules/core-js/modules/es6.object.create.js");
__webpack_require__(/*! ../modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");
__webpack_require__(/*! ../modules/es6.object.define-properties */ "./node_modules/core-js/modules/es6.object.define-properties.js");
__webpack_require__(/*! ../modules/es6.object.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");
__webpack_require__(/*! ../modules/es6.object.get-prototype-of */ "./node_modules/core-js/modules/es6.object.get-prototype-of.js");
__webpack_require__(/*! ../modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");
__webpack_require__(/*! ../modules/es6.object.get-own-property-names */ "./node_modules/core-js/modules/es6.object.get-own-property-names.js");
__webpack_require__(/*! ../modules/es6.object.freeze */ "./node_modules/core-js/modules/es6.object.freeze.js");
__webpack_require__(/*! ../modules/es6.object.seal */ "./node_modules/core-js/modules/es6.object.seal.js");
__webpack_require__(/*! ../modules/es6.object.prevent-extensions */ "./node_modules/core-js/modules/es6.object.prevent-extensions.js");
__webpack_require__(/*! ../modules/es6.object.is-frozen */ "./node_modules/core-js/modules/es6.object.is-frozen.js");
__webpack_require__(/*! ../modules/es6.object.is-sealed */ "./node_modules/core-js/modules/es6.object.is-sealed.js");
__webpack_require__(/*! ../modules/es6.object.is-extensible */ "./node_modules/core-js/modules/es6.object.is-extensible.js");
__webpack_require__(/*! ../modules/es6.object.assign */ "./node_modules/core-js/modules/es6.object.assign.js");
__webpack_require__(/*! ../modules/es6.object.is */ "./node_modules/core-js/modules/es6.object.is.js");
__webpack_require__(/*! ../modules/es6.object.set-prototype-of */ "./node_modules/core-js/modules/es6.object.set-prototype-of.js");
__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
__webpack_require__(/*! ../modules/es6.function.bind */ "./node_modules/core-js/modules/es6.function.bind.js");
__webpack_require__(/*! ../modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");
__webpack_require__(/*! ../modules/es6.function.has-instance */ "./node_modules/core-js/modules/es6.function.has-instance.js");
__webpack_require__(/*! ../modules/es6.parse-int */ "./node_modules/core-js/modules/es6.parse-int.js");
__webpack_require__(/*! ../modules/es6.parse-float */ "./node_modules/core-js/modules/es6.parse-float.js");
__webpack_require__(/*! ../modules/es6.number.constructor */ "./node_modules/core-js/modules/es6.number.constructor.js");
__webpack_require__(/*! ../modules/es6.number.to-fixed */ "./node_modules/core-js/modules/es6.number.to-fixed.js");
__webpack_require__(/*! ../modules/es6.number.to-precision */ "./node_modules/core-js/modules/es6.number.to-precision.js");
__webpack_require__(/*! ../modules/es6.number.epsilon */ "./node_modules/core-js/modules/es6.number.epsilon.js");
__webpack_require__(/*! ../modules/es6.number.is-finite */ "./node_modules/core-js/modules/es6.number.is-finite.js");
__webpack_require__(/*! ../modules/es6.number.is-integer */ "./node_modules/core-js/modules/es6.number.is-integer.js");
__webpack_require__(/*! ../modules/es6.number.is-nan */ "./node_modules/core-js/modules/es6.number.is-nan.js");
__webpack_require__(/*! ../modules/es6.number.is-safe-integer */ "./node_modules/core-js/modules/es6.number.is-safe-integer.js");
__webpack_require__(/*! ../modules/es6.number.max-safe-integer */ "./node_modules/core-js/modules/es6.number.max-safe-integer.js");
__webpack_require__(/*! ../modules/es6.number.min-safe-integer */ "./node_modules/core-js/modules/es6.number.min-safe-integer.js");
__webpack_require__(/*! ../modules/es6.number.parse-float */ "./node_modules/core-js/modules/es6.number.parse-float.js");
__webpack_require__(/*! ../modules/es6.number.parse-int */ "./node_modules/core-js/modules/es6.number.parse-int.js");
__webpack_require__(/*! ../modules/es6.math.acosh */ "./node_modules/core-js/modules/es6.math.acosh.js");
__webpack_require__(/*! ../modules/es6.math.asinh */ "./node_modules/core-js/modules/es6.math.asinh.js");
__webpack_require__(/*! ../modules/es6.math.atanh */ "./node_modules/core-js/modules/es6.math.atanh.js");
__webpack_require__(/*! ../modules/es6.math.cbrt */ "./node_modules/core-js/modules/es6.math.cbrt.js");
__webpack_require__(/*! ../modules/es6.math.clz32 */ "./node_modules/core-js/modules/es6.math.clz32.js");
__webpack_require__(/*! ../modules/es6.math.cosh */ "./node_modules/core-js/modules/es6.math.cosh.js");
__webpack_require__(/*! ../modules/es6.math.expm1 */ "./node_modules/core-js/modules/es6.math.expm1.js");
__webpack_require__(/*! ../modules/es6.math.fround */ "./node_modules/core-js/modules/es6.math.fround.js");
__webpack_require__(/*! ../modules/es6.math.hypot */ "./node_modules/core-js/modules/es6.math.hypot.js");
__webpack_require__(/*! ../modules/es6.math.imul */ "./node_modules/core-js/modules/es6.math.imul.js");
__webpack_require__(/*! ../modules/es6.math.log10 */ "./node_modules/core-js/modules/es6.math.log10.js");
__webpack_require__(/*! ../modules/es6.math.log1p */ "./node_modules/core-js/modules/es6.math.log1p.js");
__webpack_require__(/*! ../modules/es6.math.log2 */ "./node_modules/core-js/modules/es6.math.log2.js");
__webpack_require__(/*! ../modules/es6.math.sign */ "./node_modules/core-js/modules/es6.math.sign.js");
__webpack_require__(/*! ../modules/es6.math.sinh */ "./node_modules/core-js/modules/es6.math.sinh.js");
__webpack_require__(/*! ../modules/es6.math.tanh */ "./node_modules/core-js/modules/es6.math.tanh.js");
__webpack_require__(/*! ../modules/es6.math.trunc */ "./node_modules/core-js/modules/es6.math.trunc.js");
__webpack_require__(/*! ../modules/es6.string.from-code-point */ "./node_modules/core-js/modules/es6.string.from-code-point.js");
__webpack_require__(/*! ../modules/es6.string.raw */ "./node_modules/core-js/modules/es6.string.raw.js");
__webpack_require__(/*! ../modules/es6.string.trim */ "./node_modules/core-js/modules/es6.string.trim.js");
__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/modules/es6.string.iterator.js");
__webpack_require__(/*! ../modules/es6.string.code-point-at */ "./node_modules/core-js/modules/es6.string.code-point-at.js");
__webpack_require__(/*! ../modules/es6.string.ends-with */ "./node_modules/core-js/modules/es6.string.ends-with.js");
__webpack_require__(/*! ../modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
__webpack_require__(/*! ../modules/es6.string.repeat */ "./node_modules/core-js/modules/es6.string.repeat.js");
__webpack_require__(/*! ../modules/es6.string.starts-with */ "./node_modules/core-js/modules/es6.string.starts-with.js");
__webpack_require__(/*! ../modules/es6.string.anchor */ "./node_modules/core-js/modules/es6.string.anchor.js");
__webpack_require__(/*! ../modules/es6.string.big */ "./node_modules/core-js/modules/es6.string.big.js");
__webpack_require__(/*! ../modules/es6.string.blink */ "./node_modules/core-js/modules/es6.string.blink.js");
__webpack_require__(/*! ../modules/es6.string.bold */ "./node_modules/core-js/modules/es6.string.bold.js");
__webpack_require__(/*! ../modules/es6.string.fixed */ "./node_modules/core-js/modules/es6.string.fixed.js");
__webpack_require__(/*! ../modules/es6.string.fontcolor */ "./node_modules/core-js/modules/es6.string.fontcolor.js");
__webpack_require__(/*! ../modules/es6.string.fontsize */ "./node_modules/core-js/modules/es6.string.fontsize.js");
__webpack_require__(/*! ../modules/es6.string.italics */ "./node_modules/core-js/modules/es6.string.italics.js");
__webpack_require__(/*! ../modules/es6.string.link */ "./node_modules/core-js/modules/es6.string.link.js");
__webpack_require__(/*! ../modules/es6.string.small */ "./node_modules/core-js/modules/es6.string.small.js");
__webpack_require__(/*! ../modules/es6.string.strike */ "./node_modules/core-js/modules/es6.string.strike.js");
__webpack_require__(/*! ../modules/es6.string.sub */ "./node_modules/core-js/modules/es6.string.sub.js");
__webpack_require__(/*! ../modules/es6.string.sup */ "./node_modules/core-js/modules/es6.string.sup.js");
__webpack_require__(/*! ../modules/es6.date.now */ "./node_modules/core-js/modules/es6.date.now.js");
__webpack_require__(/*! ../modules/es6.date.to-json */ "./node_modules/core-js/modules/es6.date.to-json.js");
__webpack_require__(/*! ../modules/es6.date.to-iso-string */ "./node_modules/core-js/modules/es6.date.to-iso-string.js");
__webpack_require__(/*! ../modules/es6.date.to-string */ "./node_modules/core-js/modules/es6.date.to-string.js");
__webpack_require__(/*! ../modules/es6.date.to-primitive */ "./node_modules/core-js/modules/es6.date.to-primitive.js");
__webpack_require__(/*! ../modules/es6.array.is-array */ "./node_modules/core-js/modules/es6.array.is-array.js");
__webpack_require__(/*! ../modules/es6.array.from */ "./node_modules/core-js/modules/es6.array.from.js");
__webpack_require__(/*! ../modules/es6.array.of */ "./node_modules/core-js/modules/es6.array.of.js");
__webpack_require__(/*! ../modules/es6.array.join */ "./node_modules/core-js/modules/es6.array.join.js");
__webpack_require__(/*! ../modules/es6.array.slice */ "./node_modules/core-js/modules/es6.array.slice.js");
__webpack_require__(/*! ../modules/es6.array.sort */ "./node_modules/core-js/modules/es6.array.sort.js");
__webpack_require__(/*! ../modules/es6.array.for-each */ "./node_modules/core-js/modules/es6.array.for-each.js");
__webpack_require__(/*! ../modules/es6.array.map */ "./node_modules/core-js/modules/es6.array.map.js");
__webpack_require__(/*! ../modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");
__webpack_require__(/*! ../modules/es6.array.some */ "./node_modules/core-js/modules/es6.array.some.js");
__webpack_require__(/*! ../modules/es6.array.every */ "./node_modules/core-js/modules/es6.array.every.js");
__webpack_require__(/*! ../modules/es6.array.reduce */ "./node_modules/core-js/modules/es6.array.reduce.js");
__webpack_require__(/*! ../modules/es6.array.reduce-right */ "./node_modules/core-js/modules/es6.array.reduce-right.js");
__webpack_require__(/*! ../modules/es6.array.index-of */ "./node_modules/core-js/modules/es6.array.index-of.js");
__webpack_require__(/*! ../modules/es6.array.last-index-of */ "./node_modules/core-js/modules/es6.array.last-index-of.js");
__webpack_require__(/*! ../modules/es6.array.copy-within */ "./node_modules/core-js/modules/es6.array.copy-within.js");
__webpack_require__(/*! ../modules/es6.array.fill */ "./node_modules/core-js/modules/es6.array.fill.js");
__webpack_require__(/*! ../modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");
__webpack_require__(/*! ../modules/es6.array.find-index */ "./node_modules/core-js/modules/es6.array.find-index.js");
__webpack_require__(/*! ../modules/es6.array.species */ "./node_modules/core-js/modules/es6.array.species.js");
__webpack_require__(/*! ../modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
__webpack_require__(/*! ../modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
__webpack_require__(/*! ../modules/es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");
__webpack_require__(/*! ../modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
__webpack_require__(/*! ../modules/es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");
__webpack_require__(/*! ../modules/es6.regexp.match */ "./node_modules/core-js/modules/es6.regexp.match.js");
__webpack_require__(/*! ../modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
__webpack_require__(/*! ../modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");
__webpack_require__(/*! ../modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
__webpack_require__(/*! ../modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");
__webpack_require__(/*! ../modules/es6.map */ "./node_modules/core-js/modules/es6.map.js");
__webpack_require__(/*! ../modules/es6.set */ "./node_modules/core-js/modules/es6.set.js");
__webpack_require__(/*! ../modules/es6.weak-map */ "./node_modules/core-js/modules/es6.weak-map.js");
__webpack_require__(/*! ../modules/es6.weak-set */ "./node_modules/core-js/modules/es6.weak-set.js");
__webpack_require__(/*! ../modules/es6.typed.array-buffer */ "./node_modules/core-js/modules/es6.typed.array-buffer.js");
__webpack_require__(/*! ../modules/es6.typed.data-view */ "./node_modules/core-js/modules/es6.typed.data-view.js");
__webpack_require__(/*! ../modules/es6.typed.int8-array */ "./node_modules/core-js/modules/es6.typed.int8-array.js");
__webpack_require__(/*! ../modules/es6.typed.uint8-array */ "./node_modules/core-js/modules/es6.typed.uint8-array.js");
__webpack_require__(/*! ../modules/es6.typed.uint8-clamped-array */ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");
__webpack_require__(/*! ../modules/es6.typed.int16-array */ "./node_modules/core-js/modules/es6.typed.int16-array.js");
__webpack_require__(/*! ../modules/es6.typed.uint16-array */ "./node_modules/core-js/modules/es6.typed.uint16-array.js");
__webpack_require__(/*! ../modules/es6.typed.int32-array */ "./node_modules/core-js/modules/es6.typed.int32-array.js");
__webpack_require__(/*! ../modules/es6.typed.uint32-array */ "./node_modules/core-js/modules/es6.typed.uint32-array.js");
__webpack_require__(/*! ../modules/es6.typed.float32-array */ "./node_modules/core-js/modules/es6.typed.float32-array.js");
__webpack_require__(/*! ../modules/es6.typed.float64-array */ "./node_modules/core-js/modules/es6.typed.float64-array.js");
__webpack_require__(/*! ../modules/es6.reflect.apply */ "./node_modules/core-js/modules/es6.reflect.apply.js");
__webpack_require__(/*! ../modules/es6.reflect.construct */ "./node_modules/core-js/modules/es6.reflect.construct.js");
__webpack_require__(/*! ../modules/es6.reflect.define-property */ "./node_modules/core-js/modules/es6.reflect.define-property.js");
__webpack_require__(/*! ../modules/es6.reflect.delete-property */ "./node_modules/core-js/modules/es6.reflect.delete-property.js");
__webpack_require__(/*! ../modules/es6.reflect.enumerate */ "./node_modules/core-js/modules/es6.reflect.enumerate.js");
__webpack_require__(/*! ../modules/es6.reflect.get */ "./node_modules/core-js/modules/es6.reflect.get.js");
__webpack_require__(/*! ../modules/es6.reflect.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");
__webpack_require__(/*! ../modules/es6.reflect.get-prototype-of */ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js");
__webpack_require__(/*! ../modules/es6.reflect.has */ "./node_modules/core-js/modules/es6.reflect.has.js");
__webpack_require__(/*! ../modules/es6.reflect.is-extensible */ "./node_modules/core-js/modules/es6.reflect.is-extensible.js");
__webpack_require__(/*! ../modules/es6.reflect.own-keys */ "./node_modules/core-js/modules/es6.reflect.own-keys.js");
__webpack_require__(/*! ../modules/es6.reflect.prevent-extensions */ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js");
__webpack_require__(/*! ../modules/es6.reflect.set */ "./node_modules/core-js/modules/es6.reflect.set.js");
__webpack_require__(/*! ../modules/es6.reflect.set-prototype-of */ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/modules/_core.js");


/***/ }),

/***/ "./node_modules/core-js/fn/array/flat-map.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/fn/array/flat-map.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.array.flat-map */ "./node_modules/core-js/modules/es7.array.flat-map.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Array.flatMap;


/***/ }),

/***/ "./node_modules/core-js/fn/array/includes.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/fn/array/includes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Array.includes;


/***/ }),

/***/ "./node_modules/core-js/fn/object/entries.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/fn/object/entries.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.object.entries */ "./node_modules/core-js/modules/es7.object.entries.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Object.entries;


/***/ }),

/***/ "./node_modules/core-js/fn/object/get-own-property-descriptors.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/fn/object/get-own-property-descriptors.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.object.get-own-property-descriptors */ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Object.getOwnPropertyDescriptors;


/***/ }),

/***/ "./node_modules/core-js/fn/object/values.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/fn/object/values.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.object.values */ "./node_modules/core-js/modules/es7.object.values.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Object.values;


/***/ }),

/***/ "./node_modules/core-js/fn/promise/finally.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/fn/promise/finally.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ../../modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");
__webpack_require__(/*! ../../modules/es7.promise.finally */ "./node_modules/core-js/modules/es7.promise.finally.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Promise['finally'];


/***/ }),

/***/ "./node_modules/core-js/fn/string/pad-end.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/fn/string/pad-end.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.pad-end */ "./node_modules/core-js/modules/es7.string.pad-end.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").String.padEnd;


/***/ }),

/***/ "./node_modules/core-js/fn/string/pad-start.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/fn/string/pad-start.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.pad-start */ "./node_modules/core-js/modules/es7.string.pad-start.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").String.padStart;


/***/ }),

/***/ "./node_modules/core-js/fn/string/trim-end.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/fn/string/trim-end.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.trim-right */ "./node_modules/core-js/modules/es7.string.trim-right.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").String.trimRight;


/***/ }),

/***/ "./node_modules/core-js/fn/string/trim-start.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/fn/string/trim-start.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.trim-left */ "./node_modules/core-js/modules/es7.string.trim-left.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").String.trimLeft;


/***/ }),

/***/ "./node_modules/core-js/fn/symbol/async-iterator.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/fn/symbol/async-iterator.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");
module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js").f('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/library/fn/global.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/library/fn/global.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es7.global */ "./node_modules/core-js/library/modules/es7.global.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/library/modules/_core.js").global;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_a-function.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_a-function.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_core.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ctx.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ctx.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_descriptors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_descriptors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_dom-create.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_dom-create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_export.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_export.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_fails.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_global.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_global.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_has.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_has.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_hide.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_hide.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dp.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dp.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_property-desc.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_property-desc.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.global.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.global.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.G, { global: __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_a-number-value.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_a-number-value.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_advance-string-index.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_advance-string-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-instance.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_an-instance.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-copy-within.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-copy-within.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-fill.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_array-fill.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-methods.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-methods.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-reduce.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_array-reduce.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-constructor.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-create.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-create.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_bind.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_bind.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_classof.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_collection-strong.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-strong.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");
var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");
var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var fastKey = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").fastKey;
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_collection-weak.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-weak.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
var getWeak = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").getWeak;
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");
var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");
var $has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),

/***/ "./node_modules/core-js/modules/_collection.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_collection.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_create-property.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_create-property.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-iso-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-iso-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-primitive.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-primitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/modules/_fails-is-regexp.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_fails-is-regexp.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_fix-re-wks.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_fix-re-wks.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ./es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_flags.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_flags.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_flatten-into-array.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_flatten-into-array.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;


/***/ }),

/***/ "./node_modules/core-js/modules/_for-of.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_for-of.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/core-js/modules/_function-to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_function-to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);


/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_inherit-if-required.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_inherit-if-required.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_invoke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-regexp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-regexp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-call.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-detect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-step.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iterators.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/modules/_math-expm1.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-expm1.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),

/***/ "./node_modules/core-js/modules/_math-fround.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_math-fround.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_math-log1p.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-log1p.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_math-sign.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-sign.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_meta.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_meta.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/modules/_microtask.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_microtask.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_new-promise-capability.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/_new-promise-capability.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-assign.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-assign.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-create.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dps.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gops.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gpo.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-sap.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-sap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-to-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-to-array.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var isEnum = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_own-keys.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_own-keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var Reflect = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_parse-float.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-float.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseFloat;
var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),

/***/ "./node_modules/core-js/modules/_parse-int.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-int.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseInt;
var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;
var ws = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),

/***/ "./node_modules/core-js/modules/_perform.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_perform.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_promise-resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_promise-resolve.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');
var $toString = __webpack_require__(/*! ./_function-to-string */ "./node_modules/core-js/modules/_function-to-string.js");
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "./node_modules/core-js/modules/_same-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_same-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_set-proto.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_set-proto.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "./node_modules/core-js/modules/_set-species.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_set-species.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/modules/_species-constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_species-constructor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_strict-method.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_strict-method.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-at.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-context.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-context.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-html.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-html.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-pad.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-pad.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-repeat.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-repeat.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-trim.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-trim.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var spaces = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),

/***/ "./node_modules/core-js/modules/_string-ws.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-ws.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js/modules/_task.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_task.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");
var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-index.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_to-index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/modules/_typed-array.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-array.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
  var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");
  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");
  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
  var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");
  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");
  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js");
  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");
  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");
  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");
  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js");
  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/modules/_typed-buffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-buffer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "./node_modules/core-js/modules/_typed.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_typed.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_user-agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_user-agent.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "./node_modules/core-js/modules/_validate-collection.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_validate-collection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_wks-define.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-define.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");
var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_wks-ext.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-ext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");


/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.copy-within.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.copy-within.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', { copyWithin: __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js") });

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.every.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.every.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $every = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.fill.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.fill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', { fill: __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js") });

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('fill');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.filter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find-index.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find-index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.for-each.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.for-each.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);
var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.from.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.from.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.index-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.index-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.is-array.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.is-array.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', { isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.join.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.join.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.last-index-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.last-index-of.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.map.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.of.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.of.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce-right.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce-right.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.slice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.slice.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.some.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.some.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $some = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.sort.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.sort.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.species.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.species.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('Array');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.now.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.now.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-iso-string.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-iso-string.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toISOString = __webpack_require__(/*! ./_date-to-iso-string */ "./node_modules/core-js/modules/_date-to-iso-string.js");

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-json.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-json.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ "./node_modules/core-js/modules/_date-to-primitive.js"));


/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.bind.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.bind.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', { bind: __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.has-instance.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.has-instance.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.name.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.map.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.map.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.acosh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.acosh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var log1p = __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js");
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.asinh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.asinh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.atanh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.atanh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cbrt.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cbrt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.clz32.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.clz32.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cosh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cosh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.expm1.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.expm1.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.fround.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.fround.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { fround: __webpack_require__(/*! ./_math-fround */ "./node_modules/core-js/modules/_math-fround.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.hypot.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.hypot.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.imul.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.imul.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log10.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log10.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log1p.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log1p.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { log1p: __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log2.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log2.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sign.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sign.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { sign: __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sinh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sinh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.tanh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.tanh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.trunc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.trunc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.epsilon.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.epsilon.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-finite.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-finite.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var _isFinite = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-integer.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-integer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', { isInteger: __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-nan.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-nan.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-safe-integer.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-safe-integer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var isInteger = __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js");
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.max-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.max-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.min-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.min-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-float.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-float.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js");
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-int.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-int.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js");
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-fixed.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-fixed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");
var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-precision.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-precision.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.assign.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.assign.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.create.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.create.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-properties.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-properties.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', { defineProperties: __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-property.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.freeze.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.freeze.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-names.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-names.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js").f;
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-extensible.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-extensible.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-frozen.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-frozen.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-sealed.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-sealed.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
$export($export.S, 'Object', { is: __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.prevent-extensions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.prevent-extensions.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.seal.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.seal.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.set-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.set-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var test = {};
test[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-float.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-float.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js");
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-int.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-int.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js");
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.promise.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;
var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();
var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);
__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(PROMISE);
Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.apply.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.apply.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var rApply = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.construct.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.construct.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var bind = __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js");
var rConstruct = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.define-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.define-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.delete-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.delete-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.enumerate.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.enumerate.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var getProto = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.has.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.has.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.is-extensible.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.is-extensible.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.own-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.own-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var setProto = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");
var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('RegExp');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.exec.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.exec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");
__webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.flags.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.flags.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js")
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.match.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.match.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

// @@match logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.replace.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.replace.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.search.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.search.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var sameValue = __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js");
var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

// @@search logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.split.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.split.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");
var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ./es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.set.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.set.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.anchor.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.anchor.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.big.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.big.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.blink.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.blink.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.bold.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.bold.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.code-point-at.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.code-point-at.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.ends-with.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.ends-with.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fixed.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fixed.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontcolor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontcolor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontsize.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontsize.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.from-code-point.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.from-code-point.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.includes.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.includes.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.italics.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.italics.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.iterator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.link.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.link.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.raw.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.raw.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.repeat.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.repeat.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js")
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.small.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.small.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.starts-with.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.starts-with.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.strike.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.strike.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sub.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sub.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sup.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sup.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.trim.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.trim.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").KEY;
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");
var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js");
var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/modules/_enum-keys.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
var $GOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");
var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.array-buffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.array-buffer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");
var buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var ArrayBuffer = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").ArrayBuffer;
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.data-view.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.data-view.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js").DataView
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float32-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float32-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float64-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float64-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int16-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int16-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int32-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int32-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int8-array.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int8-array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-map.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");
var assign = __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js");
var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");
var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-set.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-set.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flat-map.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.flat-map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/core-js/modules/_flatten-into-array.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('flatMap');


/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.includes.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $includes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('includes');


/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.entries.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.entries.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $entries = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var ownKeys = __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.values.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.values.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $values = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.finally.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.promise.finally.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-end.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-end.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-start.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-start.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-left.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.trim-left.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');


/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-right.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.trim-right.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');


/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom.iterable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js");
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/web.timers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),

/***/ "./node_modules/core-js/web/index.js":
/*!*******************************************!*\
  !*** ./node_modules/core-js/web/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");
__webpack_require__(/*! ../modules/web.immediate */ "./node_modules/core-js/modules/web.immediate.js");
__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/modules/_core.js");


/***/ }),

/***/ "./node_modules/immutability-helper/index.js":
/*!***************************************************!*\
  !*** ./node_modules/immutability-helper/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var invariant = __webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js");
var hasOwnProperty = Object.prototype.hasOwnProperty;
var splice = Array.prototype.splice;
var toString = Object.prototype.toString;
function type(obj) {
    return toString.call(obj).slice(8, -1);
}
var assign = Object.assign || /* istanbul ignore next */ (function (target, source) {
    getAllKeys(source).forEach(function (key) {
        if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
        }
    });
    return target;
});
var getAllKeys = typeof Object.getOwnPropertySymbols === 'function'
    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }
    /* istanbul ignore next */
    : function (obj) { return Object.keys(obj); };
function copy(object) {
    return Array.isArray(object)
        ? assign(object.constructor(object.length), object)
        : (type(object) === 'Map')
            ? new Map(object)
            : (type(object) === 'Set')
                ? new Set(object)
                : (object && typeof object === 'object')
                    ? assign(Object.create(Object.getPrototypeOf(object)), object)
                    /* istanbul ignore next */
                    : object;
}
var Context = /** @class */ (function () {
    function Context() {
        this.commands = assign({}, defaultCommands);
        this.update = this.update.bind(this);
        // Deprecated: update.extend, update.isEquals and update.newContext
        this.update.extend = this.extend = this.extend.bind(this);
        this.update.isEquals = function (x, y) { return x === y; };
        this.update.newContext = function () { return new Context().update; };
    }
    Object.defineProperty(Context.prototype, "isEquals", {
        get: function () {
            return this.update.isEquals;
        },
        set: function (value) {
            this.update.isEquals = value;
        },
        enumerable: true,
        configurable: true
    });
    Context.prototype.extend = function (directive, fn) {
        this.commands[directive] = fn;
    };
    Context.prototype.update = function (object, $spec) {
        var _this = this;
        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;
        if (!(Array.isArray(object) && Array.isArray(spec))) {
            invariant(!Array.isArray(spec), 'update(): You provided an invalid spec to update(). The spec may ' +
                'not contain an array except as the value of $set, $push, $unshift, ' +
                '$splice or any custom command allowing an array value.');
        }
        invariant(typeof spec === 'object' && spec !== null, 'update(): You provided an invalid spec to update(). The spec and ' +
            'every included key path must be plain objects containing one of the ' +
            'following commands: %s.', Object.keys(this.commands).join(', '));
        var nextObject = object;
        getAllKeys(spec).forEach(function (key) {
            if (hasOwnProperty.call(_this.commands, key)) {
                var objectWasNextObject = object === nextObject;
                nextObject = _this.commands[key](spec[key], nextObject, spec, object);
                if (objectWasNextObject && _this.isEquals(nextObject, object)) {
                    nextObject = object;
                }
            }
            else {
                var nextValueForKey = type(object) === 'Map'
                    ? _this.update(object.get(key), spec[key])
                    : _this.update(object[key], spec[key]);
                var nextObjectValue = type(nextObject) === 'Map'
                    ? nextObject.get(key)
                    : nextObject[key];
                if (!_this.isEquals(nextValueForKey, nextObjectValue)
                    || typeof nextValueForKey === 'undefined'
                        && !hasOwnProperty.call(object, key)) {
                    if (nextObject === object) {
                        nextObject = copy(object);
                    }
                    if (type(nextObject) === 'Map') {
                        nextObject.set(key, nextValueForKey);
                    }
                    else {
                        nextObject[key] = nextValueForKey;
                    }
                }
            }
        });
        return nextObject;
    };
    return Context;
}());
exports.Context = Context;
var defaultCommands = {
    $push: function (value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, '$push');
        return value.length ? nextObject.concat(value) : nextObject;
    },
    $unshift: function (value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, '$unshift');
        return value.length ? value.concat(nextObject) : nextObject;
    },
    $splice: function (value, nextObject, spec, originalObject) {
        invariantSplices(nextObject, spec);
        value.forEach(function (args) {
            invariantSplice(args);
            if (nextObject === originalObject && args.length) {
                nextObject = copy(originalObject);
            }
            splice.apply(nextObject, args);
        });
        return nextObject;
    },
    $set: function (value, _nextObject, spec) {
        invariantSet(spec);
        return value;
    },
    $toggle: function (targets, nextObject) {
        invariantSpecArray(targets, '$toggle');
        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;
        targets.forEach(function (target) {
            nextObjectCopy[target] = !nextObject[target];
        });
        return nextObjectCopy;
    },
    $unset: function (value, nextObject, _spec, originalObject) {
        invariantSpecArray(value, '$unset');
        value.forEach(function (key) {
            if (Object.hasOwnProperty.call(nextObject, key)) {
                if (nextObject === originalObject) {
                    nextObject = copy(originalObject);
                }
                delete nextObject[key];
            }
        });
        return nextObject;
    },
    $add: function (values, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, '$add');
        invariantSpecArray(values, '$add');
        if (type(nextObject) === 'Map') {
            values.forEach(function (_a) {
                var key = _a[0], value = _a[1];
                if (nextObject === originalObject && nextObject.get(key) !== value) {
                    nextObject = copy(originalObject);
                }
                nextObject.set(key, value);
            });
        }
        else {
            values.forEach(function (value) {
                if (nextObject === originalObject && !nextObject.has(value)) {
                    nextObject = copy(originalObject);
                }
                nextObject.add(value);
            });
        }
        return nextObject;
    },
    $remove: function (value, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, '$remove');
        invariantSpecArray(value, '$remove');
        value.forEach(function (key) {
            if (nextObject === originalObject && nextObject.has(key)) {
                nextObject = copy(originalObject);
            }
            nextObject.delete(key);
        });
        return nextObject;
    },
    $merge: function (value, nextObject, _spec, originalObject) {
        invariantMerge(nextObject, value);
        getAllKeys(value).forEach(function (key) {
            if (value[key] !== nextObject[key]) {
                if (nextObject === originalObject) {
                    nextObject = copy(originalObject);
                }
                nextObject[key] = value[key];
            }
        });
        return nextObject;
    },
    $apply: function (value, original) {
        invariantApply(value);
        return value(original);
    },
};
var defaultContext = new Context();
exports.isEquals = defaultContext.update.isEquals;
exports.extend = defaultContext.extend;
exports.default = defaultContext.update;
// @ts-ignore
exports.default.default = module.exports = assign(exports.default, exports);
// invariants
function invariantPushAndUnshift(value, spec, command) {
    invariant(Array.isArray(value), 'update(): expected target of %s to be an array; got %s.', command, value);
    invariantSpecArray(spec[command], command);
}
function invariantSpecArray(spec, command) {
    invariant(Array.isArray(spec), 'update(): expected spec of %s to be an array; got %s. ' +
        'Did you forget to wrap your parameter in an array?', command, spec);
}
function invariantSplices(value, spec) {
    invariant(Array.isArray(value), 'Expected $splice target to be an array; got %s', value);
    invariantSplice(spec.$splice);
}
function invariantSplice(value) {
    invariant(Array.isArray(value), 'update(): expected spec of $splice to be an array of arrays; got %s. ' +
        'Did you forget to wrap your parameters in an array?', value);
}
function invariantApply(fn) {
    invariant(typeof fn === 'function', 'update(): expected spec of $apply to be a function; got %s.', fn);
}
function invariantSet(spec) {
    invariant(Object.keys(spec).length === 1, 'Cannot have more than one key in an object with $set');
}
function invariantMerge(target, specValue) {
    invariant(specValue && typeof specValue === 'object', 'update(): $merge expects a spec of type \'object\'; got %s', specValue);
    invariant(target && typeof target === 'object', 'update(): $merge expects a target of type \'object\'; got %s', target);
}
function invariantMapOrSet(target, command) {
    var typeOfTarget = type(target);
    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', 'update(): %s expects a target of type Set or Map; got %s', command, typeOfTarget);
}


/***/ }),

/***/ "./node_modules/invariant/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/invariant/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (true) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */

(function( global, factory ) {

	if (  true && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
var arr = [];

var document = window.document;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "2.2.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		var realStringObj = obj && obj.toString();
		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
	},

	isPlainObject: function( obj ) {
		var key;

		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Not own constructor property must be Object
		if ( obj.constructor &&
				!hasOwn.call( obj, "constructor" ) &&
				!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {

			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf( "use strict" ) === 1 ) {
				script = document.createElement( "script" );
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {

				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval

				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
/* jshint ignore: start */
if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
/* jshint ignore: end */

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, nidselect, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
					while ( i-- ) {
						groups[i] = nidselect + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[ 0 ] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

				// Always skip document fragments
				if ( cur.nodeType < 11 && ( pos ?
					pos.index( cur ) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector( cur, selectors ) ) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this === promise ? newDefer.promise() : this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add( function() {

					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 ||
				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.progress( updateFunc( i, progressContexts, progressValues ) )
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
} );


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {

	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
} );

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE9-10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	register: function( owner, initial ) {
		var value = initial || {};

		// If it is a node unlikely to be stringify-ed or looped over
		// use plain assignment
		if ( owner.nodeType ) {
			owner[ this.expando ] = value;

		// Otherwise secure it in a non-enumerable, non-writable property
		// configurability must be true to allow the property to be
		// deleted with the delete operator
		} else {
			Object.defineProperty( owner, this.expando, {
				value: value,
				writable: true,
				configurable: true
			} );
		}
		return owner[ this.expando ];
	},
	cache: function( owner ) {

		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return an empty object.
		if ( !acceptData( owner ) ) {
			return {};
		}

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ prop ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :
			owner[ this.expando ] && owner[ this.expando ][ key ];
	},
	access: function( owner, key, value ) {
		var stored;

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase( key ) );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key === undefined ) {
			this.register( owner );

		} else {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );

				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;

			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <= 35-45+
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://code.google.com/p/chromium/issues/detail?id=378607
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data, camelKey;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// with the key as-is
				data = dataUser.get( elem, key ) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

				if ( data !== undefined ) {
					return data;
				}

				camelKey = jQuery.camelCase( key );

				// Attempt to get data from the cache
				// with the key camelized
				data = dataUser.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			camelKey = jQuery.camelCase( key );
			this.each( function() {

				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = dataUser.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				dataUser.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
					dataUser.set( this, key, value );
				}
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" ||
			!jQuery.contains( elem.ownerDocument, elem );
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() { return tween.cur(); } :
			function() { return jQuery.css( elem, prop, "" ); },
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([\w:-]+)/ );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE9
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE9-11+
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0-4.3, Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE9
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support (at least): Chrome, IE9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox<=42+
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split( " " ),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
			"screenX screenY toElement" ).split( " " ),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX +
					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
					( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY +
					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
					( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {
	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName( "tbody" )[ 0 ] ||
			elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {

	// Keep domManip exposed until 3.0 (gh-2225)
	domManip: domManip,

	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );


var iframe,
	elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		display = jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
				.appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var documentElement = document.documentElement;



( function() {
	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {
		div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );
	}

	jQuery.extend( support, {
		pixelPosition: function() {

			// This test is executed only once but we still do memoizing
			// since we can use the boxSizingReliable pre-computing.
			// No need to check if the test was already performed, though.
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {

			// Support: Android 4.0-4.3
			// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
			// since that compresses better and they're computed together anyway.
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {

			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return reliableMarginLeftVal;
		},
		reliableMarginRight: function() {

			// Support: Android 2.3
			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// This support function is only executed once so no memoizing is needed.
			var ret,
				marginDiv = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" +
				"display:block;margin:0;border:0;padding:0";
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			documentElement.appendChild( container );

			ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

			documentElement.removeChild( container );
			div.removeChild( marginDiv );

			return ret;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );
	ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

	// Support: Opera 12.1x only
	// Fall back to style even without computed
	// computed is undefined for elems on document fragments
	if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
		ret = jQuery.style( elem, name );
	}

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = dataPriv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {

			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = dataPriv.access(
					elem,
					"olddisplay",
					defaultDisplay( elem.nodeName )
				);
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				dataPriv.set(
					elem,
					"olddisplay",
					hidden ? display : jQuery.css( elem, "display" )
				);
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
					elem.offsetWidth === 0 ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show
				// and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = dataPriv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done( function() {
				jQuery( elem ).hide();
			} );
		}
		anim.done( function() {
			var prop;

			dataPriv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		} );
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
		opt.duration : opt.duration in jQuery.fx.speeds ?
			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	window.clearInterval( timerId );

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {

					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g,
	rspaces = /[\x20\t\r\n\f]+/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ?
								!option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE8-11+
			// IE throws exception if url is malformed, e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE8-11+
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );

				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapAll( html.call( this, i ) );
			} );
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


jQuery.expr.filters.hidden = function( elem ) {
	return !jQuery.expr.filters.visible( elem );
};
jQuery.expr.filters.visible = function( elem ) {

	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	// Use OR instead of AND as the element is not visible if either is true
	// See tickets #10406 and #13132
	return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE9
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE9
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		box = elem.getBoundingClientRect();
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},
	size: function() {
		return this.length;
	}
} );

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}



var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}

return jQuery;
}));


/***/ }),

/***/ "./node_modules/jsondiffpatch/dist/empty.js":
/*!**************************************************!*\
  !*** ./node_modules/jsondiffpatch/dist/empty.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/jsondiffpatch/dist/jsondiffpatch.umd.js":
/*!**************************************************************!*\
  !*** ./node_modules/jsondiffpatch/dist/jsondiffpatch.umd.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports, __webpack_require__(/*! ./empty */ "./node_modules/jsondiffpatch/dist/empty.js")) :
	undefined;
}(this, (function (exports,chalk) { 'use strict';

chalk = chalk && chalk.hasOwnProperty('default') ? chalk['default'] : chalk;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Processor = function () {
  function Processor(options) {
    classCallCheck(this, Processor);

    this.selfOptions = options || {};
    this.pipes = {};
  }

  createClass(Processor, [{
    key: 'options',
    value: function options(_options) {
      if (_options) {
        this.selfOptions = _options;
      }
      return this.selfOptions;
    }
  }, {
    key: 'pipe',
    value: function pipe(name, pipeArg) {
      var pipe = pipeArg;
      if (typeof name === 'string') {
        if (typeof pipe === 'undefined') {
          return this.pipes[name];
        } else {
          this.pipes[name] = pipe;
        }
      }
      if (name && name.name) {
        pipe = name;
        if (pipe.processor === this) {
          return pipe;
        }
        this.pipes[pipe.name] = pipe;
      }
      pipe.processor = this;
      return pipe;
    }
  }, {
    key: 'process',
    value: function process(input, pipe) {
      var context = input;
      context.options = this.options();
      var nextPipe = pipe || input.pipe || 'default';
      var lastPipe = void 0;
      var lastContext = void 0;
      while (nextPipe) {
        if (typeof context.nextAfterChildren !== 'undefined') {
          // children processed and coming back to parent
          context.next = context.nextAfterChildren;
          context.nextAfterChildren = null;
        }

        if (typeof nextPipe === 'string') {
          nextPipe = this.pipe(nextPipe);
        }
        nextPipe.process(context);
        lastContext = context;
        lastPipe = nextPipe;
        nextPipe = null;
        if (context) {
          if (context.next) {
            context = context.next;
            nextPipe = lastContext.nextPipe || context.pipe || lastPipe;
          }
        }
      }
      return context.hasResult ? context.result : undefined;
    }
  }]);
  return Processor;
}();

var Pipe = function () {
  function Pipe(name) {
    classCallCheck(this, Pipe);

    this.name = name;
    this.filters = [];
  }

  createClass(Pipe, [{
    key: 'process',
    value: function process(input) {
      if (!this.processor) {
        throw new Error('add this pipe to a processor before using it');
      }
      var debug = this.debug;
      var length = this.filters.length;
      var context = input;
      for (var index = 0; index < length; index++) {
        var filter = this.filters[index];
        if (debug) {
          this.log('filter: ' + filter.filterName);
        }
        filter(context);
        if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object' && context.exiting) {
          context.exiting = false;
          break;
        }
      }
      if (!context.next && this.resultCheck) {
        this.resultCheck(context);
      }
    }
  }, {
    key: 'log',
    value: function log(msg) {
      console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);
    }
  }, {
    key: 'append',
    value: function append() {
      var _filters;

      (_filters = this.filters).push.apply(_filters, arguments);
      return this;
    }
  }, {
    key: 'prepend',
    value: function prepend() {
      var _filters2;

      (_filters2 = this.filters).unshift.apply(_filters2, arguments);
      return this;
    }
  }, {
    key: 'indexOf',
    value: function indexOf(filterName) {
      if (!filterName) {
        throw new Error('a filter name is required');
      }
      for (var index = 0; index < this.filters.length; index++) {
        var filter = this.filters[index];
        if (filter.filterName === filterName) {
          return index;
        }
      }
      throw new Error('filter not found: ' + filterName);
    }
  }, {
    key: 'list',
    value: function list() {
      return this.filters.map(function (f) {
        return f.filterName;
      });
    }
  }, {
    key: 'after',
    value: function after(filterName) {
      var index = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error('a filter is required');
      }
      params.unshift(index + 1, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: 'before',
    value: function before(filterName) {
      var index = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error('a filter is required');
      }
      params.unshift(index, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: 'replace',
    value: function replace(filterName) {
      var index = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error('a filter is required');
      }
      params.unshift(index, 1);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: 'remove',
    value: function remove(filterName) {
      var index = this.indexOf(filterName);
      this.filters.splice(index, 1);
      return this;
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.filters.length = 0;
      return this;
    }
  }, {
    key: 'shouldHaveResult',
    value: function shouldHaveResult(should) {
      if (should === false) {
        this.resultCheck = null;
        return;
      }
      if (this.resultCheck) {
        return;
      }
      var pipe = this;
      this.resultCheck = function (context) {
        if (!context.hasResult) {
          console.log(context);
          var error = new Error(pipe.name + ' failed');
          error.noResult = true;
          throw error;
        }
      };
      return this;
    }
  }]);
  return Pipe;
}();

var Context = function () {
  function Context() {
    classCallCheck(this, Context);
  }

  createClass(Context, [{
    key: 'setResult',
    value: function setResult(result) {
      this.result = result;
      this.hasResult = true;
      return this;
    }
  }, {
    key: 'exit',
    value: function exit() {
      this.exiting = true;
      return this;
    }
  }, {
    key: 'switchTo',
    value: function switchTo(next, pipe) {
      if (typeof next === 'string' || next instanceof Pipe) {
        this.nextPipe = next;
      } else {
        this.next = next;
        if (pipe) {
          this.nextPipe = pipe;
        }
      }
      return this;
    }
  }, {
    key: 'push',
    value: function push(child, name) {
      child.parent = this;
      if (typeof name !== 'undefined') {
        child.childName = name;
      }
      child.root = this.root || this;
      child.options = child.options || this.options;
      if (!this.children) {
        this.children = [child];
        this.nextAfterChildren = this.next || null;
        this.next = child;
      } else {
        this.children[this.children.length - 1].next = child;
        this.children.push(child);
      }
      child.next = this;
      return this;
    }
  }]);
  return Context;
}();

var isArray = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

function cloneRegExp(re) {
  var regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString());
  return new RegExp(regexMatch[1], regexMatch[2]);
}

function clone(arg) {
  if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !== 'object') {
    return arg;
  }
  if (arg === null) {
    return null;
  }
  if (isArray(arg)) {
    return arg.map(clone);
  }
  if (arg instanceof Date) {
    return new Date(arg.getTime());
  }
  if (arg instanceof RegExp) {
    return cloneRegExp(arg);
  }
  var cloned = {};
  for (var name in arg) {
    if (Object.prototype.hasOwnProperty.call(arg, name)) {
      cloned[name] = clone(arg[name]);
    }
  }
  return cloned;
}

var DiffContext = function (_Context) {
  inherits(DiffContext, _Context);

  function DiffContext(left, right) {
    classCallCheck(this, DiffContext);

    var _this = possibleConstructorReturn(this, (DiffContext.__proto__ || Object.getPrototypeOf(DiffContext)).call(this));

    _this.left = left;
    _this.right = right;
    _this.pipe = 'diff';
    return _this;
  }

  createClass(DiffContext, [{
    key: 'setResult',
    value: function setResult(result) {
      if (this.options.cloneDiffValues && (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
        var clone$$1 = typeof this.options.cloneDiffValues === 'function' ? this.options.cloneDiffValues : clone;
        if (_typeof(result[0]) === 'object') {
          result[0] = clone$$1(result[0]);
        }
        if (_typeof(result[1]) === 'object') {
          result[1] = clone$$1(result[1]);
        }
      }
      return Context.prototype.setResult.apply(this, arguments);
    }
  }]);
  return DiffContext;
}(Context);

var PatchContext = function (_Context) {
  inherits(PatchContext, _Context);

  function PatchContext(left, delta) {
    classCallCheck(this, PatchContext);

    var _this = possibleConstructorReturn(this, (PatchContext.__proto__ || Object.getPrototypeOf(PatchContext)).call(this));

    _this.left = left;
    _this.delta = delta;
    _this.pipe = 'patch';
    return _this;
  }

  return PatchContext;
}(Context);

var ReverseContext = function (_Context) {
  inherits(ReverseContext, _Context);

  function ReverseContext(delta) {
    classCallCheck(this, ReverseContext);

    var _this = possibleConstructorReturn(this, (ReverseContext.__proto__ || Object.getPrototypeOf(ReverseContext)).call(this));

    _this.delta = delta;
    _this.pipe = 'reverse';
    return _this;
  }

  return ReverseContext;
}(Context);

var isArray$1 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

var diffFilter = function trivialMatchesDiffFilter(context) {
  if (context.left === context.right) {
    context.setResult(undefined).exit();
    return;
  }
  if (typeof context.left === 'undefined') {
    if (typeof context.right === 'function') {
      throw new Error('functions are not supported');
    }
    context.setResult([context.right]).exit();
    return;
  }
  if (typeof context.right === 'undefined') {
    context.setResult([context.left, 0, 0]).exit();
    return;
  }
  if (typeof context.left === 'function' || typeof context.right === 'function') {
    throw new Error('functions are not supported');
  }
  context.leftType = context.left === null ? 'null' : _typeof(context.left);
  context.rightType = context.right === null ? 'null' : _typeof(context.right);
  if (context.leftType !== context.rightType) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'boolean' || context.leftType === 'number') {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'object') {
    context.leftIsArray = isArray$1(context.left);
  }
  if (context.rightType === 'object') {
    context.rightIsArray = isArray$1(context.right);
  }
  if (context.leftIsArray !== context.rightIsArray) {
    context.setResult([context.left, context.right]).exit();
    return;
  }

  if (context.left instanceof RegExp) {
    if (context.right instanceof RegExp) {
      context.setResult([context.left.toString(), context.right.toString()]).exit();
    } else {
      context.setResult([context.left, context.right]).exit();
    }
  }
};
diffFilter.filterName = 'trivial';

var patchFilter = function trivialMatchesPatchFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.left).exit();
    return;
  }
  context.nested = !isArray$1(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult(context.delta[0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    if (context.left instanceof RegExp) {
      var regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1]);
      if (regexArgs) {
        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
        return;
      }
    }
    context.setResult(context.delta[1]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult(undefined).exit();
  }
};
patchFilter.filterName = 'trivial';

var reverseFilter = function trivialReferseFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.delta).exit();
    return;
  }
  context.nested = !isArray$1(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult([context.delta[0], 0, 0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    context.setResult([context.delta[1], context.delta[0]]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult([context.delta[0]]).exit();
  }
};
reverseFilter.filterName = 'trivial';

function collectChildrenDiffFilter(context) {
  if (!context || !context.children) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var result = context.result;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (typeof child.result === 'undefined') {
      continue;
    }
    result = result || {};
    result[child.childName] = child.result;
  }
  if (result && context.leftIsArray) {
    result._t = 'a';
  }
  context.setResult(result).exit();
}
collectChildrenDiffFilter.filterName = 'collectChildren';

function objectsDiffFilter(context) {
  if (context.leftIsArray || context.leftType !== 'object') {
    return;
  }

  var name = void 0;
  var child = void 0;
  var propertyFilter = context.options.propertyFilter;
  for (name in context.left) {
    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    child = new DiffContext(context.left[name], context.right[name]);
    context.push(child, name);
  }
  for (name in context.right) {
    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    if (typeof context.left[name] === 'undefined') {
      child = new DiffContext(undefined, context.right[name]);
      context.push(child, name);
    }
  }

  if (!context.children || context.children.length === 0) {
    context.setResult(undefined).exit();
    return;
  }
  context.exit();
}
objectsDiffFilter.filterName = 'objects';

var patchFilter$1 = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    child = new PatchContext(context.left[name], context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
patchFilter$1.filterName = 'objects';

var collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {
      delete context.left[child.childName];
    } else if (context.left[child.childName] !== child.result) {
      context.left[child.childName] = child.result;
    }
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter.filterName = 'collectChildren';

var reverseFilter$1 = function nestedReverseFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter$1.filterName = 'objects';

function collectChildrenReverseFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var delta = {};
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (delta[child.childName] !== child.result) {
      delta[child.childName] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter.filterName = 'collectChildren';

/*

LCS implementation that supports arrays or strings

reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem

*/

var defaultMatch = function defaultMatch(array1, array2, index1, index2) {
  return array1[index1] === array2[index2];
};

var lengthMatrix = function lengthMatrix(array1, array2, match, context) {
  var len1 = array1.length;
  var len2 = array2.length;
  var x = void 0,
      y = void 0;

  // initialize empty matrix of len1+1 x len2+1
  var matrix = [len1 + 1];
  for (x = 0; x < len1 + 1; x++) {
    matrix[x] = [len2 + 1];
    for (y = 0; y < len2 + 1; y++) {
      matrix[x][y] = 0;
    }
  }
  matrix.match = match;
  // save sequence lengths for each coordinate
  for (x = 1; x < len1 + 1; x++) {
    for (y = 1; y < len2 + 1; y++) {
      if (match(array1, array2, x - 1, y - 1, context)) {
        matrix[x][y] = matrix[x - 1][y - 1] + 1;
      } else {
        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
      }
    }
  }
  return matrix;
};

var backtrack = function backtrack(matrix, array1, array2, index1, index2, context) {
  if (index1 === 0 || index2 === 0) {
    return {
      sequence: [],
      indices1: [],
      indices2: []
    };
  }

  if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {
    var subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context);
    subsequence.sequence.push(array1[index1 - 1]);
    subsequence.indices1.push(index1 - 1);
    subsequence.indices2.push(index2 - 1);
    return subsequence;
  }

  if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {
    return backtrack(matrix, array1, array2, index1, index2 - 1, context);
  } else {
    return backtrack(matrix, array1, array2, index1 - 1, index2, context);
  }
};

var get$1 = function get(array1, array2, match, context) {
  var innerContext = context || {};
  var matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);
  var result = backtrack(matrix, array1, array2, array1.length, array2.length, innerContext);
  if (typeof array1 === 'string' && typeof array2 === 'string') {
    result.sequence = result.sequence.join('');
  }
  return result;
};

var lcs = {
  get: get$1
};

var ARRAY_MOVE = 3;

var isArray$2 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

var arrayIndexOf = typeof Array.prototype.indexOf === 'function' ? function (array, item) {
  return array.indexOf(item);
} : function (array, item) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (array[i] === item) {
      return i;
    }
  }
  return -1;
};

function arraysHaveMatchByRef(array1, array2, len1, len2) {
  for (var index1 = 0; index1 < len1; index1++) {
    var val1 = array1[index1];
    for (var index2 = 0; index2 < len2; index2++) {
      var val2 = array2[index2];
      if (index1 !== index2 && val1 === val2) {
        return true;
      }
    }
  }
}

function matchItems(array1, array2, index1, index2, context) {
  var value1 = array1[index1];
  var value2 = array2[index2];
  if (value1 === value2) {
    return true;
  }
  if ((typeof value1 === 'undefined' ? 'undefined' : _typeof(value1)) !== 'object' || (typeof value2 === 'undefined' ? 'undefined' : _typeof(value2)) !== 'object') {
    return false;
  }
  var objectHash = context.objectHash;
  if (!objectHash) {
    // no way to match objects was provided, try match by position
    return context.matchByPosition && index1 === index2;
  }
  var hash1 = void 0;
  var hash2 = void 0;
  if (typeof index1 === 'number') {
    context.hashCache1 = context.hashCache1 || [];
    hash1 = context.hashCache1[index1];
    if (typeof hash1 === 'undefined') {
      context.hashCache1[index1] = hash1 = objectHash(value1, index1);
    }
  } else {
    hash1 = objectHash(value1);
  }
  if (typeof hash1 === 'undefined') {
    return false;
  }
  if (typeof index2 === 'number') {
    context.hashCache2 = context.hashCache2 || [];
    hash2 = context.hashCache2[index2];
    if (typeof hash2 === 'undefined') {
      context.hashCache2[index2] = hash2 = objectHash(value2, index2);
    }
  } else {
    hash2 = objectHash(value2);
  }
  if (typeof hash2 === 'undefined') {
    return false;
  }
  return hash1 === hash2;
}

var diffFilter$1 = function arraysDiffFilter(context) {
  if (!context.leftIsArray) {
    return;
  }

  var matchContext = {
    objectHash: context.options && context.options.objectHash,
    matchByPosition: context.options && context.options.matchByPosition
  };
  var commonHead = 0;
  var commonTail = 0;
  var index = void 0;
  var index1 = void 0;
  var index2 = void 0;
  var array1 = context.left;
  var array2 = context.right;
  var len1 = array1.length;
  var len2 = array2.length;

  var child = void 0;

  if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== 'boolean') {
    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);
  }

  // separate common head
  while (commonHead < len1 && commonHead < len2 && matchItems(array1, array2, commonHead, commonHead, matchContext)) {
    index = commonHead;
    child = new DiffContext(context.left[index], context.right[index]);
    context.push(child, index);
    commonHead++;
  }
  // separate common tail
  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {
    index1 = len1 - 1 - commonTail;
    index2 = len2 - 1 - commonTail;
    child = new DiffContext(context.left[index1], context.right[index2]);
    context.push(child, index2);
    commonTail++;
  }
  var result = void 0;
  if (commonHead + commonTail === len1) {
    if (len1 === len2) {
      // arrays are identical
      context.setResult(undefined).exit();
      return;
    }
    // trivial case, a block (1 or more consecutive items) was added
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len2 - commonTail; index++) {
      result[index] = [array2[index]];
    }
    context.setResult(result).exit();
    return;
  }
  if (commonHead + commonTail === len2) {
    // trivial case, a block (1 or more consecutive items) was removed
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len1 - commonTail; index++) {
      result['_' + index] = [array1[index], 0, 0];
    }
    context.setResult(result).exit();
    return;
  }
  // reset hash cache
  delete matchContext.hashCache1;
  delete matchContext.hashCache2;

  // diff is not trivial, find the LCS (Longest Common Subsequence)
  var trimmed1 = array1.slice(commonHead, len1 - commonTail);
  var trimmed2 = array2.slice(commonHead, len2 - commonTail);
  var seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);
  var removedItems = [];
  result = result || {
    _t: 'a'
  };
  for (index = commonHead; index < len1 - commonTail; index++) {
    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {
      // removed
      result['_' + index] = [array1[index], 0, 0];
      removedItems.push(index);
    }
  }

  var detectMove = true;
  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {
    detectMove = false;
  }
  var includeValueOnMove = false;
  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {
    includeValueOnMove = true;
  }

  var removedItemsLength = removedItems.length;
  for (index = commonHead; index < len2 - commonTail; index++) {
    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);
    if (indexOnArray2 < 0) {
      // added, try to match with a removed item and register as position move
      var isMove = false;
      if (detectMove && removedItemsLength > 0) {
        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
          index1 = removedItems[removeItemIndex1];
          if (matchItems(trimmed1, trimmed2, index1 - commonHead, index - commonHead, matchContext)) {
            // store position move as: [originalValue, newPosition, ARRAY_MOVE]
            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);
            if (!includeValueOnMove) {
              // don't include moved value on diff, to save bytes
              result['_' + index1][0] = '';
            }

            index2 = index;
            child = new DiffContext(context.left[index1], context.right[index2]);
            context.push(child, index2);
            removedItems.splice(removeItemIndex1, 1);
            isMove = true;
            break;
          }
        }
      }
      if (!isMove) {
        // added
        result[index] = [array2[index]];
      }
    } else {
      // match, do inner diff
      index1 = seq.indices1[indexOnArray2] + commonHead;
      index2 = seq.indices2[indexOnArray2] + commonHead;
      child = new DiffContext(context.left[index1], context.right[index2]);
      context.push(child, index2);
    }
  }

  context.setResult(result).exit();
};
diffFilter$1.filterName = 'arrays';

var compare = {
  numerically: function numerically(a, b) {
    return a - b;
  },
  numericallyBy: function numericallyBy(name) {
    return function (a, b) {
      return a[name] - b[name];
    };
  }
};

var patchFilter$2 = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var index = void 0;
  var index1 = void 0;

  var delta = context.delta;
  var array = context.left;

  // first, separate removals, insertions and modifications
  var toRemove = [];
  var toInsert = [];
  var toModify = [];
  for (index in delta) {
    if (index !== '_t') {
      if (index[0] === '_') {
        // removed item from original array
        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {
          toRemove.push(parseInt(index.slice(1), 10));
        } else {
          throw new Error('only removal or move can be applied at original array indices,' + (' invalid diff type: ' + delta[index][2]));
        }
      } else {
        if (delta[index].length === 1) {
          // added item at new array
          toInsert.push({
            index: parseInt(index, 10),
            value: delta[index][0]
          });
        } else {
          // modified item at new array
          toModify.push({
            index: parseInt(index, 10),
            delta: delta[index]
          });
        }
      }
    }
  }

  // remove items, in reverse order to avoid sawing our own floor
  toRemove = toRemove.sort(compare.numerically);
  for (index = toRemove.length - 1; index >= 0; index--) {
    index1 = toRemove[index];
    var indexDiff = delta['_' + index1];
    var removedValue = array.splice(index1, 1)[0];
    if (indexDiff[2] === ARRAY_MOVE) {
      // reinsert later
      toInsert.push({
        index: indexDiff[1],
        value: removedValue
      });
    }
  }

  // insert items, in reverse order to avoid moving our own floor
  toInsert = toInsert.sort(compare.numericallyBy('index'));
  var toInsertLength = toInsert.length;
  for (index = 0; index < toInsertLength; index++) {
    var insertion = toInsert[index];
    array.splice(insertion.index, 0, insertion.value);
  }

  // apply modifications
  var toModifyLength = toModify.length;
  var child = void 0;
  if (toModifyLength > 0) {
    for (index = 0; index < toModifyLength; index++) {
      var modification = toModify[index];
      child = new PatchContext(context.left[modification.index], modification.delta);
      context.push(child, modification.index);
    }
  }

  if (!context.children) {
    context.setResult(context.left).exit();
    return;
  }
  context.exit();
};
patchFilter$2.filterName = 'arrays';

var collectChildrenPatchFilter$1 = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    context.left[child.childName] = child.result;
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter$1.filterName = 'arraysCollectChildren';

var reverseFilter$2 = function arraysReverseFilter(context) {
  if (!context.nested) {
    if (context.delta[2] === ARRAY_MOVE) {
      context.newName = '_' + context.delta[1];
      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();
    }
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    if (name === '_t') {
      continue;
    }
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter$2.filterName = 'arrays';

var reverseArrayDeltaIndex = function reverseArrayDeltaIndex(delta, index, itemDelta) {
  if (typeof index === 'string' && index[0] === '_') {
    return parseInt(index.substr(1), 10);
  } else if (isArray$2(itemDelta) && itemDelta[2] === 0) {
    return '_' + index;
  }

  var reverseIndex = +index;
  for (var deltaIndex in delta) {
    var deltaItem = delta[deltaIndex];
    if (isArray$2(deltaItem)) {
      if (deltaItem[2] === ARRAY_MOVE) {
        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);
        var moveToIndex = deltaItem[1];
        if (moveToIndex === +index) {
          return moveFromIndex;
        }
        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
          reverseIndex++;
        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
          reverseIndex--;
        }
      } else if (deltaItem[2] === 0) {
        var deleteIndex = parseInt(deltaIndex.substr(1), 10);
        if (deleteIndex <= reverseIndex) {
          reverseIndex++;
        }
      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
        reverseIndex--;
      }
    }
  }

  return reverseIndex;
};

function collectChildrenReverseFilter$1(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var delta = {
    _t: 'a'
  };

  for (var index = 0; index < length; index++) {
    child = context.children[index];
    var name = child.newName;
    if (typeof name === 'undefined') {
      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);
    }
    if (delta[name] !== child.result) {
      delta[name] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter$1.filterName = 'arraysCollectChildren';

var diffFilter$2 = function datesDiffFilter(context) {
  if (context.left instanceof Date) {
    if (context.right instanceof Date) {
      if (context.left.getTime() !== context.right.getTime()) {
        context.setResult([context.left, context.right]);
      } else {
        context.setResult(undefined);
      }
    } else {
      context.setResult([context.left, context.right]);
    }
    context.exit();
  } else if (context.right instanceof Date) {
    context.setResult([context.left, context.right]).exit();
  }
};
diffFilter$2.filterName = 'dates';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var diffMatchPatch = createCommonjsModule(function (module) {
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push([DIFF_EQUAL, '']);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var a = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = a.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, a[j]);
          }
          pointer = pointer + a.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge_(text1);
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastequality && (lastequality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastequality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push([DIFF_EQUAL, precontext]);
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push([diff_type, diff_text]);
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diff_type, diff_text]);
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postcontext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// The following export code was added by @ForbesLindesay
module.exports = diff_match_patch;
module.exports['diff_match_patch'] = diff_match_patch;
module.exports['DIFF_DELETE'] = DIFF_DELETE;
module.exports['DIFF_INSERT'] = DIFF_INSERT;
module.exports['DIFF_EQUAL'] = DIFF_EQUAL;
});

/* global diff_match_patch */
var TEXT_DIFF = 2;
var DEFAULT_MIN_LENGTH = 60;
var cachedDiffPatch = null;

var getDiffMatchPatch = function getDiffMatchPatch(required) {
  /* jshint camelcase: false */

  if (!cachedDiffPatch) {
    var instance = void 0;
    /* eslint-disable camelcase, new-cap */
    if (typeof diff_match_patch !== 'undefined') {
      // already loaded, probably a browser
      instance = typeof diff_match_patch === 'function' ? new diff_match_patch() : new diff_match_patch.diff_match_patch();
    } else if (diffMatchPatch) {
      try {
        instance = diffMatchPatch && new diffMatchPatch();
      } catch (err) {
        instance = null;
      }
    }
    /* eslint-enable camelcase, new-cap */
    if (!instance) {
      if (!required) {
        return null;
      }
      var error = new Error('text diff_match_patch library not found');
      // eslint-disable-next-line camelcase
      error.diff_match_patch_not_found = true;
      throw error;
    }
    cachedDiffPatch = {
      diff: function diff(txt1, txt2) {
        return instance.patch_toText(instance.patch_make(txt1, txt2));
      },
      patch: function patch(txt1, _patch) {
        var results = instance.patch_apply(instance.patch_fromText(_patch), txt1);
        for (var i = 0; i < results[1].length; i++) {
          if (!results[1][i]) {
            var _error = new Error('text patch failed');
            _error.textPatchFailed = true;
          }
        }
        return results[0];
      }
    };
  }
  return cachedDiffPatch;
};

var diffFilter$3 = function textsDiffFilter(context) {
  if (context.leftType !== 'string') {
    return;
  }
  var minLength = context.options && context.options.textDiff && context.options.textDiff.minLength || DEFAULT_MIN_LENGTH;
  if (context.left.length < minLength || context.right.length < minLength) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  // large text, try to use a text-diff algorithm
  var diffMatchPatch$$1 = getDiffMatchPatch();
  if (!diffMatchPatch$$1) {
    // diff-match-patch library not available,
    // fallback to regular string replace
    context.setResult([context.left, context.right]).exit();
    return;
  }
  var diff = diffMatchPatch$$1.diff;
  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();
};
diffFilter$3.filterName = 'texts';

var patchFilter$3 = function textsPatchFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-patch algorithm
  var patch = getDiffMatchPatch(true).patch;
  context.setResult(patch(context.left, context.delta[0])).exit();
};
patchFilter$3.filterName = 'texts';

var textDeltaReverse = function textDeltaReverse(delta) {
  var i = void 0;
  var l = void 0;
  var lines = void 0;
  var line = void 0;
  var lineTmp = void 0;
  var header = null;
  var headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
  var lineHeader = void 0;
  lines = delta.split('\n');
  for (i = 0, l = lines.length; i < l; i++) {
    line = lines[i];
    var lineStart = line.slice(0, 1);
    if (lineStart === '@') {
      header = headerRegex.exec(line);
      lineHeader = i;

      // fix header
      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';
    } else if (lineStart === '+') {
      lines[i] = '-' + lines[i].slice(1);
      if (lines[i - 1].slice(0, 1) === '+') {
        // swap lines to keep default order (-+)
        lineTmp = lines[i];
        lines[i] = lines[i - 1];
        lines[i - 1] = lineTmp;
      }
    } else if (lineStart === '-') {
      lines[i] = '+' + lines[i].slice(1);
    }
  }
  return lines.join('\n');
};

var reverseFilter$3 = function textsReverseFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-diff algorithm
  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();
};
reverseFilter$3.filterName = 'texts';

var DiffPatcher = function () {
  function DiffPatcher(options) {
    classCallCheck(this, DiffPatcher);

    this.processor = new Processor(options);
    this.processor.pipe(new Pipe('diff').append(collectChildrenDiffFilter, diffFilter, diffFilter$2, diffFilter$3, objectsDiffFilter, diffFilter$1).shouldHaveResult());
    this.processor.pipe(new Pipe('patch').append(collectChildrenPatchFilter, collectChildrenPatchFilter$1, patchFilter, patchFilter$3, patchFilter$1, patchFilter$2).shouldHaveResult());
    this.processor.pipe(new Pipe('reverse').append(collectChildrenReverseFilter, collectChildrenReverseFilter$1, reverseFilter, reverseFilter$3, reverseFilter$1, reverseFilter$2).shouldHaveResult());
  }

  createClass(DiffPatcher, [{
    key: 'options',
    value: function options() {
      var _processor;

      return (_processor = this.processor).options.apply(_processor, arguments);
    }
  }, {
    key: 'diff',
    value: function diff(left, right) {
      return this.processor.process(new DiffContext(left, right));
    }
  }, {
    key: 'patch',
    value: function patch(left, delta) {
      return this.processor.process(new PatchContext(left, delta));
    }
  }, {
    key: 'reverse',
    value: function reverse(delta) {
      return this.processor.process(new ReverseContext(delta));
    }
  }, {
    key: 'unpatch',
    value: function unpatch(right, delta) {
      return this.patch(right, this.reverse(delta));
    }
  }, {
    key: 'clone',
    value: function clone$$1(value) {
      return clone(value);
    }
  }]);
  return DiffPatcher;
}();

var isArray$3 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {
  return a instanceof Array;
};

var getObjectKeys = typeof Object.keys === 'function' ? function (obj) {
  return Object.keys(obj);
} : function (obj) {
  var names = [];
  for (var property in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      names.push(property);
    }
  }
  return names;
};

var trimUnderscore = function trimUnderscore(str) {
  if (str.substr(0, 1) === '_') {
    return str.slice(1);
  }
  return str;
};

var arrayKeyToSortNumber = function arrayKeyToSortNumber(key) {
  if (key === '_t') {
    return -1;
  } else {
    if (key.substr(0, 1) === '_') {
      return parseInt(key.slice(1), 10);
    } else {
      return parseInt(key, 10) + 0.1;
    }
  }
};

var arrayKeyComparer = function arrayKeyComparer(key1, key2) {
  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);
};

var BaseFormatter = function () {
  function BaseFormatter() {
    classCallCheck(this, BaseFormatter);
  }

  createClass(BaseFormatter, [{
    key: 'format',
    value: function format(delta, left) {
      var context = {};
      this.prepareContext(context);
      this.recurse(context, delta, left);
      return this.finalize(context);
    }
  }, {
    key: 'prepareContext',
    value: function prepareContext(context) {
      context.buffer = [];
      context.out = function () {
        var _buffer;

        (_buffer = this.buffer).push.apply(_buffer, arguments);
      };
    }
  }, {
    key: 'typeFormattterNotFound',
    value: function typeFormattterNotFound(context, deltaType) {
      throw new Error('cannot format delta type: ' + deltaType);
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      return err.toString();
    }
  }, {
    key: 'finalize',
    value: function finalize(_ref) {
      var buffer = _ref.buffer;

      if (isArray$3(buffer)) {
        return buffer.join('');
      }
    }
  }, {
    key: 'recurse',
    value: function recurse(context, delta, left, key, leftKey, movedFrom, isLast) {
      var useMoveOriginHere = delta && movedFrom;
      var leftValue = useMoveOriginHere ? movedFrom.value : left;

      if (typeof delta === 'undefined' && typeof key === 'undefined') {
        return undefined;
      }

      var type = this.getDeltaType(delta, movedFrom);
      var nodeType = type === 'node' ? delta._t === 'a' ? 'array' : 'object' : '';

      if (typeof key !== 'undefined') {
        this.nodeBegin(context, key, leftKey, type, nodeType, isLast);
      } else {
        this.rootBegin(context, type, nodeType);
      }

      var typeFormattter = void 0;
      try {
        typeFormattter = this['format_' + type] || this.typeFormattterNotFound(context, type);
        typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);
      } catch (err) {
        this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);
        if (typeof console !== 'undefined' && console.error) {
          console.error(err.stack);
        }
      }

      if (typeof key !== 'undefined') {
        this.nodeEnd(context, key, leftKey, type, nodeType, isLast);
      } else {
        this.rootEnd(context, type, nodeType);
      }
    }
  }, {
    key: 'formatDeltaChildren',
    value: function formatDeltaChildren(context, delta, left) {
      var self = this;
      this.forEachDeltaKey(delta, left, function (key, leftKey, movedFrom, isLast) {
        self.recurse(context, delta[key], left ? left[leftKey] : undefined, key, leftKey, movedFrom, isLast);
      });
    }
  }, {
    key: 'forEachDeltaKey',
    value: function forEachDeltaKey(delta, left, fn) {
      var keys = getObjectKeys(delta);
      var arrayKeys = delta._t === 'a';
      var moveDestinations = {};
      var name = void 0;
      if (typeof left !== 'undefined') {
        for (name in left) {
          if (Object.prototype.hasOwnProperty.call(left, name)) {
            if (typeof delta[name] === 'undefined' && (!arrayKeys || typeof delta['_' + name] === 'undefined')) {
              keys.push(name);
            }
          }
        }
      }
      // look for move destinations
      for (name in delta) {
        if (Object.prototype.hasOwnProperty.call(delta, name)) {
          var value = delta[name];
          if (isArray$3(value) && value[2] === 3) {
            moveDestinations[value[1].toString()] = {
              key: name,
              value: left && left[parseInt(name.substr(1))]
            };
            if (this.includeMoveDestinations !== false) {
              if (typeof left === 'undefined' && typeof delta[value[1]] === 'undefined') {
                keys.push(value[1].toString());
              }
            }
          }
        }
      }
      if (arrayKeys) {
        keys.sort(arrayKeyComparer);
      } else {
        keys.sort();
      }
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        if (arrayKeys && key === '_t') {
          continue;
        }
        var leftKey = arrayKeys ? typeof key === 'number' ? key : parseInt(trimUnderscore(key), 10) : key;
        var isLast = index === length - 1;
        fn(key, leftKey, moveDestinations[leftKey], isLast);
      }
    }
  }, {
    key: 'getDeltaType',
    value: function getDeltaType(delta, movedFrom) {
      if (typeof delta === 'undefined') {
        if (typeof movedFrom !== 'undefined') {
          return 'movedestination';
        }
        return 'unchanged';
      }
      if (isArray$3(delta)) {
        if (delta.length === 1) {
          return 'added';
        }
        if (delta.length === 2) {
          return 'modified';
        }
        if (delta.length === 3 && delta[2] === 0) {
          return 'deleted';
        }
        if (delta.length === 3 && delta[2] === 2) {
          return 'textdiff';
        }
        if (delta.length === 3 && delta[2] === 3) {
          return 'moved';
        }
      } else if ((typeof delta === 'undefined' ? 'undefined' : _typeof(delta)) === 'object') {
        return 'node';
      }
      return 'unknown';
    }
  }, {
    key: 'parseTextDiff',
    value: function parseTextDiff(value) {
      var output = [];
      var lines = value.split('\n@@ ');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        var lineOutput = {
          pieces: []
        };
        var location = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1);
        lineOutput.location = {
          line: location[0],
          chr: location[1]
        };
        var pieces = line.split('\n').slice(1);
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          if (!piece.length) {
            continue;
          }
          var pieceOutput = {
            type: 'context'
          };
          if (piece.substr(0, 1) === '+') {
            pieceOutput.type = 'added';
          } else if (piece.substr(0, 1) === '-') {
            pieceOutput.type = 'deleted';
          }
          pieceOutput.text = piece.slice(1);
          lineOutput.pieces.push(pieceOutput);
        }
        output.push(lineOutput);
      }
      return output;
    }
  }]);
  return BaseFormatter;
}();



var base = Object.freeze({
	default: BaseFormatter
});

var HtmlFormatter = function (_BaseFormatter) {
  inherits(HtmlFormatter, _BaseFormatter);

  function HtmlFormatter() {
    classCallCheck(this, HtmlFormatter);
    return possibleConstructorReturn(this, (HtmlFormatter.__proto__ || Object.getPrototypeOf(HtmlFormatter)).apply(this, arguments));
  }

  createClass(HtmlFormatter, [{
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.out('<pre class="jsondiffpatch-error">' + err + '</pre>');
    }
  }, {
    key: 'formatValue',
    value: function formatValue(context, value) {
      context.out('<pre>' + htmlEscape(JSON.stringify(value, null, 2)) + '</pre>');
    }
  }, {
    key: 'formatTextDiffString',
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.out('<ul class="jsondiffpatch-textdiff">');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          /* global decodeURI */
          var piece = pieces[pieceIndex];
          context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + htmlEscape(decodeURI(piece.text)) + '</span>');
        }
        context.out('</div></li>');
      }
      context.out('</ul>');
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin(context, type, nodeType) {
      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');
      context.out('<div class="jsondiffpatch-delta ' + nodeClass + '">');
    }
  }, {
    key: 'rootEnd',
    value: function rootEnd(context) {
      context.out('</div>' + (context.hasArrows ? '<script type="text/javascript">setTimeout(' + (adjustArrows.toString() + ',10);</script>') : ''));
    }
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(context, key, leftKey, type, nodeType) {
      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');
      context.out('<li class="' + nodeClass + '" data-key="' + leftKey + '">' + ('<div class="jsondiffpatch-property-name">' + leftKey + '</div>'));
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(context) {
      context.out('</li>');
    }

    /* jshint camelcase: false */
    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, left);
      context.out('</div>');
    }
  }, {
    key: 'format_movedestination',
    value: function format_movedestination(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, left);
      context.out('</div>');
    }
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      // recurse
      var nodeType = delta._t === 'a' ? 'array' : 'object';
      context.out('<ul class="jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '">');
      this.formatDeltaChildren(context, delta, left);
      context.out('</ul>');
    }
  }, {
    key: 'format_added',
    value: function format_added(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div>');
    }
  }, {
    key: 'format_modified',
    value: function format_modified(context, delta) {
      context.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">');
      this.formatValue(context, delta[0]);
      context.out('</div>' + '<div class="jsondiffpatch-value jsondiffpatch-right-value">');
      this.formatValue(context, delta[1]);
      context.out('</div>');
    }
  }, {
    key: 'format_deleted',
    value: function format_deleted(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div>');
    }
  }, {
    key: 'format_moved',
    value: function format_moved(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div><div class="jsondiffpatch-moved-destination">' + delta[1] + '</div>');

      // draw an SVG arrow from here to move destination
      context.out(
      /* jshint multistr: true */
      '<div class="jsondiffpatch-arrow" ' + 'style="position: relative; left: -34px;">\n          <svg width="30" height="60" ' + 'style="position: absolute; display: none;">\n          <defs>\n              <marker id="markerArrow" markerWidth="8" markerHeight="8"\n                 refx="2" refy="4"\n                     orient="auto" markerUnits="userSpaceOnUse">\n                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\n              </marker>\n          </defs>\n          <path d="M30,0 Q-10,25 26,50"\n            style="stroke: #88f; stroke-width: 2px; fill: none; ' + 'stroke-opacity: 0.5; marker-end: url(#markerArrow);"\n          ></path>\n          </svg>\n      </div>');
      context.hasArrows = true;
    }
  }, {
    key: 'format_textdiff',
    value: function format_textdiff(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatTextDiffString(context, delta[0]);
      context.out('</div>');
    }
  }]);
  return HtmlFormatter;
}(BaseFormatter);

function htmlEscape(text) {
  var html = text;
  var replacements = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/'/g, '&apos;'], [/"/g, '&quot;']];
  for (var i = 0; i < replacements.length; i++) {
    html = html.replace(replacements[i][0], replacements[i][1]);
  }
  return html;
}

var adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {
  var node = nodeArg || document;
  var getElementText = function getElementText(_ref) {
    var textContent = _ref.textContent,
        innerText = _ref.innerText;
    return textContent || innerText;
  };
  var eachByQuery = function eachByQuery(el, query, fn) {
    var elems = el.querySelectorAll(query);
    for (var i = 0, l = elems.length; i < l; i++) {
      fn(elems[i]);
    }
  };
  var eachChildren = function eachChildren(_ref2, fn) {
    var children = _ref2.children;

    for (var i = 0, l = children.length; i < l; i++) {
      fn(children[i], i);
    }
  };
  eachByQuery(node, '.jsondiffpatch-arrow', function (_ref3) {
    var parentNode = _ref3.parentNode,
        children = _ref3.children,
        style = _ref3.style;

    var arrowParent = parentNode;
    var svg = children[0];
    var path = svg.children[1];
    svg.style.display = 'none';
    var destination = getElementText(arrowParent.querySelector('.jsondiffpatch-moved-destination'));
    var container = arrowParent.parentNode;
    var destinationElem = void 0;
    eachChildren(container, function (child) {
      if (child.getAttribute('data-key') === destination) {
        destinationElem = child;
      }
    });
    if (!destinationElem) {
      return;
    }
    try {
      var distance = destinationElem.offsetTop - arrowParent.offsetTop;
      svg.setAttribute('height', Math.abs(distance) + 6);
      style.top = -8 + (distance > 0 ? 0 : distance) + 'px';
      var curve = distance > 0 ? 'M30,0 Q-10,' + Math.round(distance / 2) + ' 26,' + (distance - 4) : 'M30,' + -distance + ' Q-10,' + Math.round(-distance / 2) + ' 26,4';
      path.setAttribute('d', curve);
      svg.style.display = '';
    } catch (err) {}
  });
};

/* jshint camelcase: true */
/* eslint-enable camelcase */

var showUnchanged = function showUnchanged(show, node, delay) {
  var el = node || document.body;
  var prefix = 'jsondiffpatch-unchanged-';
  var classes = {
    showing: prefix + 'showing',
    hiding: prefix + 'hiding',
    visible: prefix + 'visible',
    hidden: prefix + 'hidden'
  };
  var list = el.classList;
  if (!list) {
    return;
  }
  if (!delay) {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    list.remove(classes.visible);
    list.remove(classes.hidden);
    if (show === false) {
      list.add(classes.hidden);
    }
    return;
  }
  if (show === false) {
    list.remove(classes.showing);
    list.add(classes.visible);
    setTimeout(function () {
      list.add(classes.hiding);
    }, 10);
  } else {
    list.remove(classes.hiding);
    list.add(classes.showing);
    list.remove(classes.hidden);
  }
  var intervalId = setInterval(function () {
    adjustArrows(el);
  }, 100);
  setTimeout(function () {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    if (show === false) {
      list.add(classes.hidden);
      list.remove(classes.visible);
    } else {
      list.add(classes.visible);
      list.remove(classes.hidden);
    }
    setTimeout(function () {
      list.remove(classes.visible);
      clearInterval(intervalId);
    }, delay + 400);
  }, delay);
};

var hideUnchanged = function hideUnchanged(node, delay) {
  return showUnchanged(false, node, delay);
};

var defaultInstance = void 0;

function format(delta, left) {
  if (!defaultInstance) {
    defaultInstance = new HtmlFormatter();
  }
  return defaultInstance.format(delta, left);
}



var html = Object.freeze({
	showUnchanged: showUnchanged,
	hideUnchanged: hideUnchanged,
	default: HtmlFormatter,
	format: format
});

var AnnotatedFormatter = function (_BaseFormatter) {
  inherits(AnnotatedFormatter, _BaseFormatter);

  function AnnotatedFormatter() {
    classCallCheck(this, AnnotatedFormatter);

    var _this = possibleConstructorReturn(this, (AnnotatedFormatter.__proto__ || Object.getPrototypeOf(AnnotatedFormatter)).call(this));

    _this.includeMoveDestinations = false;
    return _this;
  }

  createClass(AnnotatedFormatter, [{
    key: 'prepareContext',
    value: function prepareContext(context) {
      get(AnnotatedFormatter.prototype.__proto__ || Object.getPrototypeOf(AnnotatedFormatter.prototype), 'prepareContext', this).call(this, context);
      context.indent = function (levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join('&nbsp;&nbsp;');
      };
      context.row = function (json, htmlNote) {
        context.out('<tr><td style="white-space: nowrap;">' + '<pre class="jsondiffpatch-annotated-indent"' + ' style="display: inline-block">');
        context.out(context.indentPad);
        context.out('</pre><pre style="display: inline-block">');
        context.out(json);
        context.out('</pre></td><td class="jsondiffpatch-delta-note"><div>');
        context.out(htmlNote);
        context.out('</div></td></tr>');
      };
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.row('', '<pre class="jsondiffpatch-error">' + err + '</pre>');
    }
  }, {
    key: 'formatTextDiffString',
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.out('<ul class="jsondiffpatch-textdiff">');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + piece.text + '</span>');
        }
        context.out('</div></li>');
      }
      context.out('</ul>');
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin(context, type, nodeType) {
      context.out('<table class="jsondiffpatch-annotated-delta">');
      if (type === 'node') {
        context.row('{');
        context.indent();
      }
      if (nodeType === 'array') {
        context.row('"_t": "a",', 'Array delta (member names indicate array indices)');
      }
    }
  }, {
    key: 'rootEnd',
    value: function rootEnd(context, type) {
      if (type === 'node') {
        context.indent(-1);
        context.row('}');
      }
      context.out('</table>');
    }
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(context, key, leftKey, type, nodeType) {
      context.row('&quot;' + key + '&quot;: {');
      if (type === 'node') {
        context.indent();
      }
      if (nodeType === 'array') {
        context.row('"_t": "a",', 'Array delta (member names indicate array indices)');
      }
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {
      if (type === 'node') {
        context.indent(-1);
      }
      context.row('}' + (isLast ? '' : ','));
    }

    /* jshint camelcase: false */

    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged() {}
  }, {
    key: 'format_movedestination',
    value: function format_movedestination() {}
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      // recurse
      this.formatDeltaChildren(context, delta, left);
    }
  }]);
  return AnnotatedFormatter;
}(BaseFormatter);

/* eslint-enable camelcase */

var wrapPropertyName = function wrapPropertyName(name) {
  return '<pre style="display:inline-block">&quot;' + name + '&quot;</pre>';
};

var deltaAnnotations = {
  added: function added(delta, left, key, leftKey) {
    var formatLegend = ' <pre>([newValue])</pre>';
    if (typeof leftKey === 'undefined') {
      return 'new value' + formatLegend;
    }
    if (typeof leftKey === 'number') {
      return 'insert at index ' + leftKey + formatLegend;
    }
    return 'add property ' + wrapPropertyName(leftKey) + formatLegend;
  },
  modified: function modified(delta, left, key, leftKey) {
    var formatLegend = ' <pre>([previousValue, newValue])</pre>';
    if (typeof leftKey === 'undefined') {
      return 'modify value' + formatLegend;
    }
    if (typeof leftKey === 'number') {
      return 'modify at index ' + leftKey + formatLegend;
    }
    return 'modify property ' + wrapPropertyName(leftKey) + formatLegend;
  },
  deleted: function deleted(delta, left, key, leftKey) {
    var formatLegend = ' <pre>([previousValue, 0, 0])</pre>';
    if (typeof leftKey === 'undefined') {
      return 'delete value' + formatLegend;
    }
    if (typeof leftKey === 'number') {
      return 'remove index ' + leftKey + formatLegend;
    }
    return 'delete property ' + wrapPropertyName(leftKey) + formatLegend;
  },
  moved: function moved(delta, left, key, leftKey) {
    return 'move from <span title="(position to remove at original state)">' + ('index ' + leftKey + '</span> to <span title="(position to insert at final') + (' state)">index ' + delta[1] + '</span>');
  },
  textdiff: function textdiff(delta, left, key, leftKey) {
    var location = typeof leftKey === 'undefined' ? '' : typeof leftKey === 'number' ? ' at index ' + leftKey : ' at property ' + wrapPropertyName(leftKey);
    return 'text diff' + location + ', format is <a href="https://code.google.com/' + 'p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>';
  }
};

var formatAnyChange = function formatAnyChange(context, delta) {
  var deltaType = this.getDeltaType(delta);
  var annotator = deltaAnnotations[deltaType];
  var htmlNote = annotator && annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));
  var json = JSON.stringify(delta, null, 2);
  if (deltaType === 'textdiff') {
    // split text diffs lines
    json = json.split('\\n').join('\\n"+\n   "');
  }
  context.indent();
  context.row(json, htmlNote);
  context.indent(-1);
};

/* eslint-disable camelcase */
AnnotatedFormatter.prototype.format_added = formatAnyChange;
AnnotatedFormatter.prototype.format_modified = formatAnyChange;
AnnotatedFormatter.prototype.format_deleted = formatAnyChange;
AnnotatedFormatter.prototype.format_moved = formatAnyChange;
AnnotatedFormatter.prototype.format_textdiff = formatAnyChange;
var defaultInstance$1 = void 0;

function format$1(delta, left) {
  if (!defaultInstance$1) {
    defaultInstance$1 = new AnnotatedFormatter();
  }
  return defaultInstance$1.format(delta, left);
}



var annotated = Object.freeze({
	default: AnnotatedFormatter,
	format: format$1
});

var OPERATIONS = {
  add: 'add',
  remove: 'remove',
  replace: 'replace',
  move: 'move'
};

var JSONFormatter = function (_BaseFormatter) {
  inherits(JSONFormatter, _BaseFormatter);

  function JSONFormatter() {
    classCallCheck(this, JSONFormatter);

    var _this = possibleConstructorReturn(this, (JSONFormatter.__proto__ || Object.getPrototypeOf(JSONFormatter)).call(this));

    _this.includeMoveDestinations = true;
    return _this;
  }

  createClass(JSONFormatter, [{
    key: 'prepareContext',
    value: function prepareContext(context) {
      get(JSONFormatter.prototype.__proto__ || Object.getPrototypeOf(JSONFormatter.prototype), 'prepareContext', this).call(this, context);
      context.result = [];
      context.path = [];
      context.pushCurrentOp = function (obj) {
        var op = obj.op,
            value = obj.value;

        var val = {
          op: op,
          path: this.currentPath()
        };
        if (typeof value !== 'undefined') {
          val.value = value;
        }
        this.result.push(val);
      };

      context.pushMoveOp = function (to) {
        var from = this.currentPath();
        this.result.push({
          op: OPERATIONS.move,
          from: from,
          path: this.toPath(to)
        });
      };

      context.currentPath = function () {
        return '/' + this.path.join('/');
      };

      context.toPath = function (toPath) {
        var to = this.path.slice();
        to[to.length - 1] = toPath;
        return '/' + to.join('/');
      };
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.out('[ERROR] ' + err);
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin() {}
  }, {
    key: 'rootEnd',
    value: function rootEnd() {}
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(_ref, key, leftKey) {
      var path = _ref.path;

      path.push(leftKey);
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(_ref2) {
      var path = _ref2.path;

      path.pop();
    }

    /* jshint camelcase: false */
    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged() {}
  }, {
    key: 'format_movedestination',
    value: function format_movedestination() {}
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      this.formatDeltaChildren(context, delta, left);
    }
  }, {
    key: 'format_added',
    value: function format_added(context, delta) {
      context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });
    }
  }, {
    key: 'format_modified',
    value: function format_modified(context, delta) {
      context.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });
    }
  }, {
    key: 'format_deleted',
    value: function format_deleted(context) {
      context.pushCurrentOp({ op: OPERATIONS.remove });
    }
  }, {
    key: 'format_moved',
    value: function format_moved(context, delta) {
      var to = delta[1];
      context.pushMoveOp(to);
    }
  }, {
    key: 'format_textdiff',
    value: function format_textdiff() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'format',
    value: function format(delta, left) {
      var context = {};
      this.prepareContext(context);
      this.recurse(context, delta, left);
      return context.result;
    }
  }]);
  return JSONFormatter;
}(BaseFormatter);

var last = function last(arr) {
  return arr[arr.length - 1];
};

var sortBy = function sortBy(arr, pred) {
  arr.sort(pred);
  return arr;
};

var compareByIndexDesc = function compareByIndexDesc(indexA, indexB) {
  var lastA = parseInt(indexA, 10);
  var lastB = parseInt(indexB, 10);
  if (!(isNaN(lastA) || isNaN(lastB))) {
    return lastB - lastA;
  } else {
    return 0;
  }
};

var opsByDescendingOrder = function opsByDescendingOrder(removeOps) {
  return sortBy(removeOps, function (a, b) {
    var splitA = a.path.split('/');
    var splitB = b.path.split('/');
    if (splitA.length !== splitB.length) {
      return splitA.length - splitB.length;
    } else {
      return compareByIndexDesc(last(splitA), last(splitB));
    }
  });
};

var partitionOps = function partitionOps(arr, fns) {
  var initArr = Array(fns.length + 1).fill().map(function () {
    return [];
  });
  return arr.map(function (item) {
    var position = fns.map(function (fn) {
      return fn(item);
    }).indexOf(true);
    if (position < 0) {
      position = fns.length;
    }
    return { item: item, position: position };
  }).reduce(function (acc, item) {
    acc[item.position].push(item.item);
    return acc;
  }, initArr);
};
var isMoveOp = function isMoveOp(_ref3) {
  var op = _ref3.op;
  return op === 'move';
};
var isRemoveOp = function isRemoveOp(_ref4) {
  var op = _ref4.op;
  return op === 'remove';
};

var reorderOps = function reorderOps(diff) {
  var _partitionOps = partitionOps(diff, [isMoveOp, isRemoveOp]),
      _partitionOps2 = slicedToArray(_partitionOps, 3),
      moveOps = _partitionOps2[0],
      removedOps = _partitionOps2[1],
      restOps = _partitionOps2[2];

  var removeOpsReverse = opsByDescendingOrder(removedOps);
  return [].concat(toConsumableArray(removeOpsReverse), toConsumableArray(moveOps), toConsumableArray(restOps));
};

var defaultInstance$2 = void 0;

var format$2 = function format(delta, left) {
  if (!defaultInstance$2) {
    defaultInstance$2 = new JSONFormatter();
  }
  return reorderOps(defaultInstance$2.format(delta, left));
};

var log = function log(delta, left) {
  console.log(format$2(delta, left));
};



var jsonpatch = Object.freeze({
	default: JSONFormatter,
	partitionOps: partitionOps,
	format: format$2,
	log: log
});

function chalkColor(name) {
  return chalk && chalk[name] || function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args;
  };
}

var colors = {
  added: chalkColor('green'),
  deleted: chalkColor('red'),
  movedestination: chalkColor('gray'),
  moved: chalkColor('yellow'),
  unchanged: chalkColor('gray'),
  error: chalkColor('white.bgRed'),
  textDiffLine: chalkColor('gray')
};

var ConsoleFormatter = function (_BaseFormatter) {
  inherits(ConsoleFormatter, _BaseFormatter);

  function ConsoleFormatter() {
    classCallCheck(this, ConsoleFormatter);

    var _this = possibleConstructorReturn(this, (ConsoleFormatter.__proto__ || Object.getPrototypeOf(ConsoleFormatter)).call(this));

    _this.includeMoveDestinations = false;
    return _this;
  }

  createClass(ConsoleFormatter, [{
    key: 'prepareContext',
    value: function prepareContext(context) {
      get(ConsoleFormatter.prototype.__proto__ || Object.getPrototypeOf(ConsoleFormatter.prototype), 'prepareContext', this).call(this, context);
      context.indent = function (levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join('  ');
        this.outLine();
      };
      context.outLine = function () {
        this.buffer.push('\n' + (this.indentPad || ''));
      };
      context.out = function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        for (var i = 0, l = args.length; i < l; i++) {
          var lines = args[i].split('\n');
          var text = lines.join('\n' + (this.indentPad || ''));
          if (this.color && this.color[0]) {
            text = this.color[0](text);
          }
          this.buffer.push(text);
        }
      };
      context.pushColor = function (color) {
        this.color = this.color || [];
        this.color.unshift(color);
      };
      context.popColor = function () {
        this.color = this.color || [];
        this.color.shift();
      };
    }
  }, {
    key: 'typeFormattterErrorFormatter',
    value: function typeFormattterErrorFormatter(context, err) {
      context.pushColor(colors.error);
      context.out('[ERROR]' + err);
      context.popColor();
    }
  }, {
    key: 'formatValue',
    value: function formatValue(context, value) {
      context.out(JSON.stringify(value, null, 2));
    }
  }, {
    key: 'formatTextDiffString',
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.indent();
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.pushColor(colors.textDiffLine);
        context.out(line.location.line + ',' + line.location.chr + ' ');
        context.popColor();
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context.pushColor(colors[piece.type]);
          context.out(piece.text);
          context.popColor();
        }
        if (i < l - 1) {
          context.outLine();
        }
      }
      context.indent(-1);
    }
  }, {
    key: 'rootBegin',
    value: function rootBegin(context, type, nodeType) {
      context.pushColor(colors[type]);
      if (type === 'node') {
        context.out(nodeType === 'array' ? '[' : '{');
        context.indent();
      }
    }
  }, {
    key: 'rootEnd',
    value: function rootEnd(context, type, nodeType) {
      if (type === 'node') {
        context.indent(-1);
        context.out(nodeType === 'array' ? ']' : '}');
      }
      context.popColor();
    }
  }, {
    key: 'nodeBegin',
    value: function nodeBegin(context, key, leftKey, type, nodeType) {
      context.pushColor(colors[type]);
      context.out(leftKey + ': ');
      if (type === 'node') {
        context.out(nodeType === 'array' ? '[' : '{');
        context.indent();
      }
    }
  }, {
    key: 'nodeEnd',
    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {
      if (type === 'node') {
        context.indent(-1);
        context.out(nodeType === 'array' ? ']' : '}' + (isLast ? '' : ','));
      }
      if (!isLast) {
        context.outLine();
      }
      context.popColor();
    }

    /* jshint camelcase: false */
    /* eslint-disable camelcase */

  }, {
    key: 'format_unchanged',
    value: function format_unchanged(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      this.formatValue(context, left);
    }
  }, {
    key: 'format_movedestination',
    value: function format_movedestination(context, delta, left) {
      if (typeof left === 'undefined') {
        return;
      }
      this.formatValue(context, left);
    }
  }, {
    key: 'format_node',
    value: function format_node(context, delta, left) {
      // recurse
      this.formatDeltaChildren(context, delta, left);
    }
  }, {
    key: 'format_added',
    value: function format_added(context, delta) {
      this.formatValue(context, delta[0]);
    }
  }, {
    key: 'format_modified',
    value: function format_modified(context, delta) {
      context.pushColor(colors.deleted);
      this.formatValue(context, delta[0]);
      context.popColor();
      context.out(' => ');
      context.pushColor(colors.added);
      this.formatValue(context, delta[1]);
      context.popColor();
    }
  }, {
    key: 'format_deleted',
    value: function format_deleted(context, delta) {
      this.formatValue(context, delta[0]);
    }
  }, {
    key: 'format_moved',
    value: function format_moved(context, delta) {
      context.out('==> ' + delta[1]);
    }
  }, {
    key: 'format_textdiff',
    value: function format_textdiff(context, delta) {
      this.formatTextDiffString(context, delta[0]);
    }
  }]);
  return ConsoleFormatter;
}(BaseFormatter);

var defaultInstance$3 = void 0;

var format$3 = function format(delta, left) {
  if (!defaultInstance$3) {
    defaultInstance$3 = new ConsoleFormatter();
  }
  return defaultInstance$3.format(delta, left);
};

function log$1(delta, left) {
  console.log(format$3(delta, left));
}



var console$1 = Object.freeze({
	default: ConsoleFormatter,
	format: format$3,
	log: log$1
});



var index = Object.freeze({
	base: base,
	html: html,
	annotated: annotated,
	jsonpatch: jsonpatch,
	console: console$1
});

// use as 2nd parameter for JSON.parse to revive Date instances
function dateReviver(key, value) {
  var parts = void 0;
  if (typeof value === 'string') {
    // eslint-disable-next-line max-len
    parts = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(value);
    if (parts) {
      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));
    }
  }
  return value;
}

function create(options) {
  return new DiffPatcher(options);
}

var defaultInstance$4 = void 0;

function diff() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.diff.apply(defaultInstance$4, arguments);
}

function patch() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.patch.apply(defaultInstance$4, arguments);
}

function unpatch() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.unpatch.apply(defaultInstance$4, arguments);
}

function reverse() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.reverse.apply(defaultInstance$4, arguments);
}

function clone$1() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.clone.apply(defaultInstance$4, arguments);
}

exports.DiffPatcher = DiffPatcher;
exports.formatters = index;
exports.console = console$1;
exports.create = create;
exports.dateReviver = dateReviver;
exports.diff = diff;
exports.patch = patch;
exports.unpatch = unpatch;
exports.reverse = reverse;
exports.clone = clone$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/observable-slim/observable-slim.js":
/*!*********************************************************!*\
  !*** ./node_modules/observable-slim/observable-slim.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * 	Observable Slim
 *	Version 0.1.5
 * 	https://github.com/elliotnb/observable-slim
 *
 * 	Licensed under the MIT license:
 * 	http://www.opensource.org/licenses/MIT
 *
 *	Observable Slim is a singleton that allows you to observe changes made to an object and any nested
 *	children of that object. It is intended to assist with one-way data binding, that is, in MVC parlance,
 *	reflecting changes in the model to the view. Observable Slim aspires to be as lightweight and easily
 *	understood as possible. Minifies down to roughly 3000 characters.
 */
var ObservableSlim = (function() {
	var paths = [];
	// An array that stores all of the observables created through the public create() method below.
	var observables = [];
	// An array of all the objects that we have assigned Proxies to
	var targets = [];

	// An array of arrays containing the Proxies created for each target object. targetsProxy is index-matched with
	// 'targets' -- together, the pair offer a Hash table where the key is not a string nor number, but the actual target object
	var targetsProxy = [];

	// this variable tracks duplicate proxies assigned to the same target.
	// the 'set' handler below will trigger the same change on all other Proxies tracking the same target.
	// however, in order to avoid an infinite loop of Proxies triggering and re-triggering one another, we use dupProxy
	// to track that a given Proxy was modified from the 'set' handler
	var dupProxy = null;

	var _getProperty = function(obj, path) {
		return path.split('.').reduce(function(prev, curr) {
			return prev ? prev[curr] : undefined
		}, obj || self)
	};

	/*	Function: _create
				Private internal function that is invoked to create a new ES6 Proxy whose changes we can observe through
				the Observerable.observe() method.

			Parameters:
				target 				- required, plain JavaScript object that we want to observe for changes.
				domDelay 			- batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.
				originalObservable 	- object, the original observable created by the user, exists for recursion purposes,
									  allows one observable to observe change on any nested/child objects.
				originalPath 		- array of objects, each object having the properties 'target' and 'property' -- target referring to the observed object itself
									  and property referring to the name of that object in the nested structure. the path of the property in relation to the target 
									  on the original observable, exists for recursion purposes, allows one observable to observe change on any nested/child objects. 

			Returns:
				An ES6 Proxy object.
	*/
	var _create = function(target, domDelay, originalObservable, originalPath) {

		var observable = originalObservable || null;
		
		// record the nested path taken to access this object -- if there was no path then we provide the first empty entry
		var path = originalPath || [{"target":target,"property":""}];
		paths.push(path);
		
		// in order to accurately report the "previous value" of the "length" property on an Array
		// we must use a helper property because intercepting a length change is not always possible as of 8/13/2018 in 
		// Chrome -- the new `length` value is already set by the time the `set` handler is invoked
		if (target instanceof Array) target.__length = target.length;
		
		var changes = [];

		/*	Function: _getPath
				Returns a string of the nested path (in relation to the top-level observed object)
				of the property being modified or deleted.
			Parameters:
				target - the object whose property is being modified or deleted.
				property - the string name of the property
				jsonPointer - optional, set to true if the string path should be formatted as a JSON pointer.

			Returns:
				String of the nested path (e.g., hello.testing.1.bar or, if JSON pointer, /hello/testing/1/bar
		*/
		var _getPath = function(target, property, jsonPointer) {
		
			var fullPath = "";
			var lastTarget = null;
			
			// loop over each item in the path and append it to full path
			for (var i = 0; i < path.length; i++) {
				
				// if the current object was a member of an array, it's possible that the array was at one point
				// mutated and would cause the position of the current object in that array to change. we perform an indexOf
				// lookup here to determine the current position of that object in the array before we add it to fullPath
				if (lastTarget instanceof Array && !isNaN(path[i].property)) {
					path[i].property = lastTarget.indexOf(path[i].target);
				}
				
				fullPath = fullPath + "." + path[i].property
				lastTarget = path[i].target;
			}
			
			// add the current property
			fullPath = fullPath + "." + property;
			
			// remove the beginning two dots -- ..foo.bar becomes foo.bar (the first item in the nested chain doesn't have a property name)
			fullPath = fullPath.substring(2);
			
			if (jsonPointer === true) fullPath = "/" + fullPath.replace(/\./g, "/");

			return fullPath;
		};

		var _notifyObservers = function(numChanges) {

			// if the observable is paused, then we don't want to execute any of the observer functions
			if (observable.paused === true) return;

			// execute observer functions on a 10ms settimeout, this prevents the observer functions from being executed
			// separately on every change -- this is necessary because the observer functions will often trigger UI updates
 			if (domDelay === true) {
				setTimeout(function() {
					if (numChanges === changes.length) {

						// we create a copy of changes before passing it to the observer functions because even if the observer function
						// throws an error, we still need to ensure that changes is reset to an empty array so that old changes don't persist
						var changesCopy = changes.slice(0);
						changes = [];

						// invoke any functions that are observing changes
						for (var i = 0; i < observable.observers.length; i++) observable.observers[i](changesCopy);

					}
				},10);
			} else {

				// we create a copy of changes before passing it to the observer functions because even if the observer function
				// throws an error, we still need to ensure that changes is reset to an empty array so that old changes don't persist
				var changesCopy = changes.slice(0);
				changes = [];

				// invoke any functions that are observing changes
				for (var i = 0; i < observable.observers.length; i++) observable.observers[i](changesCopy);

			}
		};

		var handler = {
			get: function(target, property) {

				// implement a simple check for whether or not the object is a proxy, this helps the .create() method avoid
				// creating Proxies of Proxies.
				if (property === "__getTarget") {
					return target;
				} else if (property === "__isProxy") {
					return true;
				// from the perspective of a given observable on a parent object, return the parent object of the given nested object
				} else if (property === "__getParent") {
					return function(i) {
						if (typeof i === "undefined") var i = 1;
						var parentPath = _getPath(target, "__getParent").split(".");
						parentPath.splice(-(i+1),(i+1));
						return _getProperty(observable.parentProxy, parentPath.join("."));
					}
				} else if (property === "__getPath") {
					var parentPath = _getPath(target, "__getParent");
					return parentPath.slice(0, -12);
				}

				// for performance improvements, we assign this to a variable so we do not have to lookup the property value again
				var targetProp = target[property];
				if (target instanceof Date && targetProp instanceof Function && targetProp !== null) {
					return targetProp.bind(target);
				}

				// if we are traversing into a new object, then we want to record path to that object and return a new observable.
				// recursively returning a new observable allows us a single Observable.observe() to monitor all changes on
				// the target object and any objects nested within.
				if (targetProp instanceof Object && targetProp !== null && target.hasOwnProperty(property)) {

					// if we've found a proxy nested on the object, then we want to retrieve the original object behind that proxy
					if (targetProp.__isProxy === true) targetProp = targetProp.__getTarget;
					
					// if the object accessed by the user (targetProp) already has a __targetPosition AND the object
					// stored at target[targetProp.__targetPosition] is not null, then that means we are already observing this object
					// we might be able to return a proxy that we've already created for the object
					if (targetProp.__targetPosition > -1 && targets[targetProp.__targetPosition] !== null) {
						
						// loop over the proxies that we've created for this object
						var ttp = targetsProxy[targetProp.__targetPosition];
						for (var i = 0, l = ttp.length; i < l; i++) {
							
							// if we find a proxy that was setup for this particular observable, then return that proxy
							if (observable === ttp[i].observable) {
								return ttp[i].proxy;
							}
						}
					}

					// if we're arrived here, then that means there is no proxy for the object the user just accessed, so we
					// have to create a new proxy for it

					// create a shallow copy of the path array -- if we didn't create a shallow copy then all nested objects would share the same path array and the path wouldn't be accurate
					var newPath = path.slice(0);
					newPath.push({"target":targetProp,"property":property});
					return _create(targetProp, domDelay, observable, newPath);
				} else {
					return targetProp;
				}
			},
 			deleteProperty: function(target, property) {

				// was this change an original change or was it a change that was re-triggered below
				var originalChange = true;
				if (dupProxy === proxy) {
					originalChange = false;
					dupProxy = null;
				}

				// in order to report what the previous value was, we must make a copy of it before it is deleted
				var previousValue = Object.assign({}, target);

				// record the deletion that just took place
				changes.push({
					"type":"delete"
					,"target":target
					,"property":property
					,"newValue":null
					,"previousValue":previousValue[property]
					,"currentPath":_getPath(target, property)
					,"jsonPointer":_getPath(target, property, true)
					,"proxy":proxy
				});

				if (originalChange === true) {

					// perform the delete that we've trapped if changes are not paused for this observable
					if (!observable.changesPaused) delete target[property];
				
					for (var a = 0, l = targets.length; a < l; a++) if (target === targets[a]) break;

					// loop over each proxy and see if the target for this change has any other proxies
					var currentTargetProxy = targetsProxy[a] || [];

					var b = currentTargetProxy.length;
					while (b--) {
						// if the same target has a different proxy
						if (currentTargetProxy[b].proxy !== proxy) {
							// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,
							// prevent a change on dupProxy from re-triggering the same change on other proxies)
							dupProxy = currentTargetProxy[b].proxy;

							// make the same delete on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change
							// on any other proxies so that the previousValue can show up correct for the other proxies
							delete currentTargetProxy[b].proxy[property];
						}
					}

				}

				_notifyObservers(changes.length);

				return true;

			},
			set: function(target, property, value, receiver) {
				
				// if the value we're assigning is an object, then we want to ensure
				// that we're assigning the original object, not the proxy, in order to avoid mixing
				// the actual targets and proxies -- creates issues with path logging if we don't do this
				if (value && value.__isProxy) value = value.__getTarget;
			
				// was this change an original change or was it a change that was re-triggered below
				var originalChange = true;
				if (dupProxy === proxy) {
					originalChange = false;
					dupProxy = null;
				}

				// improve performance by saving direct references to the property
				var targetProp = target[property];

				// Only record this change if:
				// 	1. the new value differs from the old one 
				//	2. OR if this proxy was not the original proxy to receive the change
				// 	3. OR the modified target is an array and the modified property is "length" and our helper property __length indicates that the array length has changed
				//
				// Regarding #3 above: mutations of arrays via .push or .splice actually modify the .length before the set handler is invoked
				// so in order to accurately report the correct previousValue for the .length, we have to use a helper property.
				if (targetProp !== value || originalChange === false || (property === "length" && target instanceof Array && target.__length !== value)) {

					var foundObservable = true;

					var typeOfTargetProp = (typeof targetProp);

					// determine if we're adding something new or modifying somethat that already existed
					var type = "update";
					if (typeOfTargetProp === "undefined") type = "add";

					// store the change that just occurred. it is important that we store the change before invoking the other proxies so that the previousValue is correct
					changes.push({
						"type":type
						,"target":target
						,"property":property
						,"newValue":value
						,"previousValue":receiver[property]
						,"currentPath":_getPath(target, property)
						,"jsonPointer":_getPath(target, property, true)
						,"proxy":proxy
					});
					
					// mutations of arrays via .push or .splice actually modify the .length before the set handler is invoked
					// so in order to accurately report the correct previousValue for the .length, we have to use a helper property.
					if (property === "length" && target instanceof Array && target.__length !== value) {
						changes[changes.length-1].previousValue = target.__length;
						target.__length = value;
					}

					// !!IMPORTANT!! if this proxy was the first proxy to receive the change, then we need to go check and see
					// if there are other proxies for the same project. if there are, then we will modify those proxies as well so the other
					// observers can be modified of the change that has occurred.
					if (originalChange === true) {

						// because the value actually differs than the previous value
						// we need to store the new value on the original target object,
						// but only as long as changes have not been paused
						if (!observable.changesPaused) target[property] = value;


						foundObservable = false;
						
						var targetPosition = target.__targetPosition;
						var z = targetsProxy[targetPosition].length;
						
						// find the parent target for this observable -- if the target for that observable has not been removed
						// from the targets array, then that means the observable is still active and we should notify the observers of this change
						while (z--) {
							if (observable === targetsProxy[targetPosition][z].observable) {
								if (targets[targetsProxy[targetPosition][z].observable.parentTarget.__targetPosition] !== null) {
									foundObservable = true;
									break;
								}
							}
						}

						// if we didn't find an observable for this proxy, then that means .remove(proxy) was likely invoked
						// so we no longer need to notify any observer function about the changes, but we still need to update the
						// value of the underlying original objectm see below: target[property] = value;
						if (foundObservable) {

							// loop over each proxy and see if the target for this change has any other proxies
							var currentTargetProxy = targetsProxy[targetPosition];
							for (var b = 0, l = currentTargetProxy.length; b < l; b++) {
								// if the same target has a different proxy
								if (currentTargetProxy[b].proxy !== proxy) {

									// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,
									// prevent a change on dupProxy from re-triggering the same change on other proxies)
									dupProxy = currentTargetProxy[b].proxy;

									// invoke the same change on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change
									// on any other proxies so that the previousValue can show up correct for the other proxies
									currentTargetProxy[b].proxy[property] = value;

								}
							}

							// if the property being overwritten is an object, then that means this observable
							// will need to stop monitoring this object and any nested objects underneath the overwritten object else they'll become
							// orphaned and grow memory usage. we excute this on a setTimeout so that the clean-up process does not block
							// the UI rendering -- there's no need to execute the clean up immediately
							setTimeout(function() {
								
								if (typeOfTargetProp === "object" && targetProp !== null) {

									// check if the to-be-overwritten target property still exists on the target object
									// if it does still exist on the object, then we don't want to stop observing it. this resolves
									// an issue where array .sort() triggers objects to be overwritten, but instead of being overwritten
									// and discarded, they are shuffled to a new position in the array
									var keys = Object.keys(target);
									for (var i = 0, l = keys.length; i < l; i++) {
										if (target[keys[i]] === targetProp) return;
									}
									
									var stillExists = false;
									
									// now we perform the more expensive search recursively through the target object.
									// if we find the targetProp (that was just overwritten) still exists somewhere else
									// further down in the object, then we still need to observe the targetProp on this observable.
									(function iterate(target) {
										var keys = Object.keys(target);
										for (var i = 0, l = keys.length; i < l; i++) {
											
											var property = keys[i];
											var nestedTarget = target[property];
											
											if (nestedTarget instanceof Object && nestedTarget !== null) iterate(nestedTarget);
											if (nestedTarget === targetProp) {
												stillExists = true;
												return;
											}
										};
									})(target);
									
									// even though targetProp was overwritten, if it still exists somewhere else on the object,
									// then we don't want to remove the observable for that object (targetProp)
									if (stillExists === true) return;

									// loop over each property and recursively invoke the `iterate` function for any
									// objects nested on targetProp
									(function iterate(obj) {

										var keys = Object.keys(obj);
										for (var i = 0, l = keys.length; i < l; i++) {
											var objProp = obj[keys[i]];
											if (objProp instanceof Object && objProp !== null) iterate(objProp);
										}

										// if there are any existing target objects (objects that we're already observing)...
										var c = -1;
										for (var i = 0, l = targets.length; i < l; i++) {
											if (obj === targets[i]) {
												c = i;
												break;
											}
										}
										if (c > -1) {

											// ...then we want to determine if the observables for that object match our current observable
											var currentTargetProxy = targetsProxy[c];
											var d = currentTargetProxy.length;

											while (d--) {
												// if we do have an observable monitoring the object thats about to be overwritten
												// then we can remove that observable from the target object
												if (observable === currentTargetProxy[d].observable) {
													currentTargetProxy.splice(d,1);
													break;
												}
											}

											// if there are no more observables assigned to the target object, then we can remove
											// the target object altogether. this is necessary to prevent growing memory consumption particularly with large data sets
											if (currentTargetProxy.length == 0) {
												// targetsProxy.splice(c,1);
												targets[c] = null;
											}
										}

									})(targetProp)
								}
							},10000);
						}

						// TO DO: the next block of code resolves test case #29, but it results in poor IE11 performance with very large objects.
						// UPDATE: need to re-evaluate IE11 performance due to major performance overhaul from 12/23/2018.
						// 
						// if the value we've just set is an object, then we'll need to iterate over it in order to initialize the
						// observers/proxies on all nested children of the object
						/* if (value instanceof Object && value !== null) {
							(function iterate(proxy) {
								var target = proxy.__getTarget;
								var keys = Object.keys(target);
								for (var i = 0, l = keys.length; i < l; i++) {
									var property = keys[i];
									if (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);
								};
							})(proxy[property]);
						}; */

					};

					if (foundObservable) {
						// notify the observer functions that the target has been modified
						_notifyObservers(changes.length);
					}

				}
				return true;
			}
		}

		var __targetPosition = target.__targetPosition;
		if (!(__targetPosition > -1)) {
			Object.defineProperty(target, "__targetPosition", {
				value: targets.length
				,writable: false
				,enumerable: false
				,configurable: false
			});
		}
		
		// create the proxy that we'll use to observe any changes
		var proxy = new Proxy(target, handler);

		// we don't want to create a new observable if this function was invoked recursively
		if (observable === null) {
			observable = {"parentTarget":target, "domDelay":domDelay, "parentProxy":proxy, "observers":[],"paused":false,"path":path,"changesPaused":false};
			observables.push(observable);
		}

		// store the proxy we've created so it isn't re-created unnecessairly via get handler
		var proxyItem = {"target":target,"proxy":proxy,"observable":observable};

		// if we have already created a Proxy for this target object then we add it to the corresponding array
		// on targetsProxy (targets and targetsProxy work together as a Hash table indexed by the actual target object).
		if (__targetPosition > -1) {
			
			// the targets array is set to null for the position of this particular object, then we know that
			// the observable was removed some point in time for this object -- so we need to set the reference again
			if (targets[__targetPosition] === null) {
				targets[__targetPosition] = target;
			}
			
			targetsProxy[__targetPosition].push(proxyItem);
			
		// else this is a target object that we had not yet created a Proxy for, so we must add it to targets,
		// and push a new array on to targetsProxy containing the new Proxy
		} else {
			targets.push(target);
			targetsProxy.push([proxyItem]);
		}

		return proxy;
	};

	return {
		/*	Method:
				Public method that is invoked to create a new ES6 Proxy whose changes we can observe
				through the Observerable.observe() method.

			Parameters
				target - Object, required, plain JavaScript object that we want to observe for changes.
				domDelay - Boolean, required, if true, then batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.
				observer - Function, optional, will be invoked when a change is made to the proxy.

			Returns:
				An ES6 Proxy object.
		*/
		create: function(target, domDelay, observer) {

			// test if the target is a Proxy, if it is then we need to retrieve the original object behind the Proxy.
			// we do not allow creating proxies of proxies because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage
			if (target.__isProxy === true) {
				var target = target.__getTarget;
				//if it is, then we should throw an error. we do not allow creating proxies of proxies
				// because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage
				//throw new Error("ObservableSlim.create() cannot create a Proxy for a target object that is also a Proxy.");
			}

			// fire off the _create() method -- it will create a new observable and proxy and return the proxy
			var proxy = _create(target, domDelay);

			// assign the observer function
			if (typeof observer === "function") this.observe(proxy, observer);

			// recursively loop over all nested objects on the proxy we've just created
			// this will allow the top observable to observe any changes that occur on a nested object
			(function iterate(proxy) {
				var target = proxy.__getTarget;
				var keys  = Object.keys(target);
				for (var i = 0, l = keys.length; i < l; i++) {
					var property = keys[i];
					if (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);
				}
			})(proxy);

			return proxy;

		},

		/*	Method: observe
				This method is used to add a new observer function to an existing proxy.

			Parameters:
				proxy 	- the ES6 Proxy returned by the create() method. We want to observe changes made to this object.
				observer 	- this function will be invoked when a change is made to the observable (not to be confused with the
							  observer defined in the create() method).

			Returns:
				Nothing.
		*/
		observe: function(proxy, observer) {
			// loop over all the observables created by the _create() function
			var i = observables.length;
			while (i--) {
				if (observables[i].parentProxy === proxy) {
					observables[i].observers.push(observer);
					break;
				}
			};
		},

		/*	Method: pause
				This method will prevent any observer functions from being invoked when a change occurs to a proxy.

			Parameters:
				proxy 	- the ES6 Proxy returned by the create() method.
		*/
		pause: function(proxy) {
			var i = observables.length;
			var foundMatch = false;
			while (i--) {
				if (observables[i].parentProxy === proxy) {
					observables[i].paused = true;
					foundMatch = true;
					break;
				}
			};

			if (foundMatch == false) throw new Error("ObseravableSlim could not pause observable -- matching proxy not found.");
		},

		/*	Method: resume
				This method will resume execution of any observer functions when a change is made to a proxy.

			Parameters:
				proxy 	- the ES6 Proxy returned by the create() method.
		*/
		resume: function(proxy) {
			var i = observables.length;
			var foundMatch = false;
			while (i--) {
				if (observables[i].parentProxy === proxy) {
					observables[i].paused = false;
					foundMatch = true;
					break;
				}
			};

			if (foundMatch == false) throw new Error("ObseravableSlim could not resume observable -- matching proxy not found.");
		},

		/*	Method: pauseChanges
				This method will prevent any changes (i.e., set, and deleteProperty) from being written to the target
				object.  However, the observer functions will still be invoked to let you know what changes WOULD have
				been made.  This can be useful if the changes need to be approved by an external source before the
				changes take effect.

			Parameters:
				proxy	- the ES6 Proxy returned by the create() method.
		 */
		pauseChanges: function(proxy){
			var i = observables.length;
			var foundMatch = false;
			while (i--) {
				if (observables[i].parentProxy === proxy) {
					observables[i].changesPaused = true;
					foundMatch = true;
					break;
				}
			};

			if (foundMatch == false) throw new Error("ObseravableSlim could not pause changes on observable -- matching proxy not found.");
		},

		/*	Method: resumeChanges
				This method will resume the changes that were taking place prior to the call to pauseChanges().

			Parameters:
				proxy	- the ES6 Proxy returned by the create() method.
		 */
		resumeChanges: function(proxy){
			var i = observables.length;
			var foundMatch = false;
			while (i--) {
				if (observables[i].parentProxy === proxy) {
					observables[i].changesPaused = false;
					foundMatch = true;
					break;
				}
			};

			if (foundMatch == false) throw new Error("ObseravableSlim could not resume changes on observable -- matching proxy not found.");
		},

		/*	Method: remove
				This method will remove the observable and proxy thereby preventing any further callback observers for
				changes occuring to the target object.

			Parameters:
				proxy 	- the ES6 Proxy returned by the create() method.
		*/
		remove: function(proxy) {

			var matchedObservable = null;
			var foundMatch = false;
			
			var c = observables.length;
			while (c--) {
				if (observables[c].parentProxy === proxy) {
					matchedObservable = observables[c];
					foundMatch = true;
					break;
				}
			};

			var a = targetsProxy.length;
			while (a--) {
				var b = targetsProxy[a].length;
				while (b--) {
					if (targetsProxy[a][b].observable === matchedObservable) {
						targetsProxy[a].splice(b,1);
						
						// if there are no more proxies for this target object
						// then we null out the position for this object on the targets array
						// since we are essentially no longer observing this object.
						// we do not splice it off the targets array, because if we re-observe the same 
						// object at a later time, the property __targetPosition cannot be redefined.
						if (targetsProxy[a].length === 0) {
							targets[a] = null;
						};
					}
				};
			};

			if (foundMatch === true) {
				observables.splice(c,1);
			}
		}
	};
})();

// Export in a try catch to prevent this from erroring out on older browsers
try { module.exports = ObservableSlim; } catch (err) {};


/***/ }),

/***/ "./node_modules/redux-devtools-extension/index.js":
/*!********************************************************!*\
  !*** ./node_modules/redux-devtools-extension/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compose = __webpack_require__(/*! redux */ "./node_modules/redux/es/redux.js").compose;

exports.__esModule = true;
exports.composeWithDevTools = (
  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?
    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ :
    function() {
      if (arguments.length === 0) return undefined;
      if (typeof arguments[0] === 'object') return compose;
      return compose.apply(null, arguments);
    }
);

exports.devToolsEnhancer = (
  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ ?
    window.__REDUX_DEVTOOLS_EXTENSION__ :
    function() { return function(noop) { return noop; } }
);


/***/ }),

/***/ "./node_modules/redux/es/redux.js":
/*!****************************************!*\
  !*** ./node_modules/redux/es/redux.js ***!
  \****************************************/
/*! exports provided: createStore, combineReducers, bindActionCreators, applyMiddleware, compose, __DO_NOT_USE__ActionTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return createStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return combineReducers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return bindActionCreators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return applyMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() { return ActionTypes; });
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/es/index.js");


/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
  return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (true) {
      if (typeof reducers[key] === 'undefined') {
        warning("No reducer provided for key \"" + key + "\"");
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers);
  var unexpectedKeyCache;

  if (true) {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (true) {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if ( true && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}




/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/symbol-observable/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "./node_modules/symbol-observable/es/ponyfill.js");
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["default"])(root);
/* harmony default export */ __webpack_exports__["default"] = (result);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/symbol-observable/es/ponyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return symbolObservablePonyfill; });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(n,t){ true?t(exports):undefined}(this,function(n){"use strict";function t(n,t){return void 0===t&&(t=1),null==n}function r(n){throw void 0===n&&(n=1),new Error("Argument "+n+" is empty.")}function e(n){return"function"==typeof n&&"getType"in n}function i(n){throw void 0===n&&(n=1),new Error("Argument "+n+' is invalid, it should be an action-creator instance from "typesafe-actions"')}function o(n,t){if(null==n)throw new Error("Argument contains array with empty element at index "+t);if(null==n.getType)throw new Error("Argument contains array with invalid element at index "+t+', it should be an action-creator instance from "typesafe-actions"')}function u(n){return"string"==typeof n||"symbol"==typeof n}function c(n){return!u(n)}function a(n){throw void 0===n&&(n=1),new Error("Argument "+n+" is invalid, it should be an action type of type: string | symbol")}function f(n,t){if(null==n)throw new Error("Argument contains array with empty element at index "+t);if("string"!=typeof n&&"symbol"!=typeof n)throw new Error("Argument contains array with invalid element at index "+t+", it should be of type: string | symbol")}function s(n,e,o,u){return t(n)&&r(1),c(n)&&i(1),{type:n,payload:e,meta:o,error:u}}function y(n,e){t(n)&&r(1),c(n)&&a(1);var i=null!=e?e(n):function(){return{type:n}};return Object.assign(i,{getType:function(){return n},toString:function(){return n}})}function p(n){return t(n)&&r(1),c(n)&&a(1),Object.assign(function(){return y(n,function(n){return function(t,r){return{type:n,payload:t,meta:r}}})},{map:function(t){return y(n,function(n){return function(r,e){return Object.assign(t(r,e),{type:n})}})}})}function l(n){return t(n)&&r(1),e(n)||i(1),n.getType()}n.action=s,n.createAction=function(n,t){var r=null==t?function(){return s(n)}:t(s.bind(null,n));return Object.assign(r,{getType:function(){return n},toString:function(){return n}})},n.createActionDeprecated=function(n,t){var r;if(null!=t){if("function"!=typeof t)throw new Error("second argument is not a function");r=t}else r=function(){return{type:n}};if(null==n)throw new Error("first argument is missing");if("string"!=typeof n&&"symbol"!=typeof n)throw new Error("first argument should be type of: string | symbol");return r},n.createAsyncAction=function(n,t,r,e){return[n,t,r].forEach(f),Object.assign(function(){return{request:p(n)(),success:p(t)(),failure:p(r)(),cancel:e&&p(e)()}},{})},n.createCustomAction=y,n.createReducer=function n(t,r){void 0===r&&(r={});var i=Object.assign({},r);return Object.assign(function(n,r){if(void 0===n&&(n=t),i.hasOwnProperty(r.type)){var e=i[r.type];if("function"!=typeof e)throw Error('Reducer under "'+r.type+'" key is not a valid reducer');return e(n,r)}return n},{handlers:Object.assign({},i),handleAction:function(r,o){var c=Array.isArray(r)?r:[r],a={};return c.map(function(n){return e(n)?l(n):u(n)?n:function(n){throw void 0===n&&(n=1),new Error("Argument "+n+' is invalid, it should be an action-creator instance from "typesafe-actions" or action type of type: string | symbol')}()}).forEach(function(n){return a[n]=o}),n(t,Object.assign({},i,a))}})},n.createStandardAction=p,n.getType=l,n.isActionOf=function(n,e){t(n)&&r(1);var i=Array.isArray(n)?n:[n];i.forEach(o);var u=function(n){return i.some(function(t){return n.type===t.getType()})};return void 0===e?u:u(e)},n.isOfType=function(n,e){t(n)&&r(1);var i=Array.isArray(n)?n:[n];i.forEach(f);var o=function(n){return i.includes(n.type)};return void 0===e?o:o(e)}});
//# sourceMappingURL=typesafe-actions.umd.production.js.map


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./sass/common/js/compatibility/_font-style.js":
/*!*****************************************************!*\
  !*** ./sass/common/js/compatibility/_font-style.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Created by Patryk on 30/03/18.
 * update "current" items
 * update pages interactions, pages' states interactions, pages' groups interactions, pages' items interactions
 * update  symbols' states interactions, symbols' groups interactions, symbols' items interactions
 * symbols' and pages' and "current" items update includes updating component and dynamic properties such as textfont (i.e Railway:400 to Railway and textFontStyle: 400) base on
 * the const hardcodedFonts variable, interactions both for items' dynamic and component properties
 **/
prx.compatibility.fontStyleCompatibility = {};

prx.compatibility.fontStyleCompatibility.ini = function () {
  prx.compatibility.fontStyleCompatibility.allItemsCompatibility();
  prx.fontStyleCompatibility = true;
};

prx.compatibility.fontStyleCompatibility.allItemsCompatibility = function () {
  var hardcodedFonts = {
    'sans-serif,Helvetica Neue,Arial': 'sans-serif',
    'Roboto Regular, sans-serif': 'Roboto, sans-serif',
    'Roboto Medium, sans-serif': 'Roboto, sans-serif',
    'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif': 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif',
    'HelveticaNeue-Medium, Helvetica, Verdana, Arial, sans-serif': 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif',
    'HelveticaNeue-Bold, Helvetica, Verdana, Arial, sans-serif': 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif',
    'HelveticaNeue-Light, Helvetica, Verdana, Arial, sans-serif': 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif',
    'San Francisco UI Display Light': 'San Francisco UI Display',
    'San Francisco UI Display Regular': 'San Francisco UI Display',
    'San Francisco UI Display Semibold': 'San Francisco UI Display',
    'San Francisco UI Display Bold': 'San Francisco UI Display',
    'San Francisco UI Text Light': 'San Francisco UI Text',
    'San Francisco UI Text Regular': 'San Francisco UI Text',
    'San Francisco UI Text Semibold': 'San Francisco UI Text',
    'San Francisco UI Text Bold': 'San Francisco UI Text',
    'San Francisco Compact Display Light': 'San Francisco Compact Display',
    'San Francisco Compact Display Regular': 'San Francisco Compact Display',
    'San Francisco Compact Display Semibold': 'San Francisco Compact Display',
    'San Francisco Compact Display Bold': 'San Francisco Compact Display',
    'San Francisco Compact Text Light': 'San Francisco Compact Text',
    'San Francisco Compact Text Regular': 'San Francisco Compact Text',
    'San Francisco Compact Text Semibold': 'San Francisco Compact Text',
    'San Francisco Compact Text Bold': 'San Francisco Compact Text'
  };
  var fontWeights = {
    light: '300',
    regular: '400',
    medium: '500',
    semibold: '600',
    bold: '700' // update "current" items

  };

  if (prx.editor) {
    prxy.items = prx.compatibility.fontStyleCompatibility.updateItems(prxy.items, hardcodedFonts, fontWeights);
    prx.canvas.refresh();
  } // update pages interactions, pages' states interactions, pages' groups interactions, pages' items interactions


  for (var i = 0; i < prxy.pages.length; i++) {
    if (prxy.pages[i].actions !== undefined && prxy.pages[i].actions.length > 0) {
      $.each(prxy.pages[i].actions, function (i, action) {
        prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(action, hardcodedFonts, fontWeights);
        prx.compatibility.fontStyleCompatibility.changeTextPropsActions(action);
      });
    }

    for (var j = 0; j < prxy.pages[i].states.length; j++) {
      if (prxy.pages[i].states[j].actions !== undefined && prxy.pages[i].states[j].actions.length > 0) {
        $.each(prxy.pages[i].states[j].actions, function (i, action) {
          prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(action, hardcodedFonts, fontWeights);
          prx.compatibility.fontStyleCompatibility.changeTextPropsActions(action);
        });
      }

      if (prxy.pages[i].states[j].groups !== undefined) {
        for (var gid in prxy.pages[i].states[j].groups) {
          if (prxy.pages[i].states[j].groups.hasOwnProperty(gid)) {
            if (prxy.pages[i].states[j].groups[gid].actions === undefined) continue;
            $.each(prxy.pages[i].states[j].groups[gid].actions, function (i, action) {
              prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(action, hardcodedFonts, fontWeights);
              prx.compatibility.fontStyleCompatibility.changeTextPropsActions(action);
            });
          }
        }
      }

      var data = JSON.parse(prxy.pages[i].states[j].data);
      data = prx.compatibility.fontStyleCompatibility.updateItems(data, hardcodedFonts, fontWeights);
      prxy.pages[i].states[j].data = JSON.stringify(data);
    }
  }

  for (var i = 0; i < prxy.symbols.length; i++) {
    if (prxy.symbols[i].actions !== undefined && prxy.symbols[i].actions.length > 0) {
      $.each(prxy.symbols[i].actions, function (i, action) {
        prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(action, hardcodedFonts, fontWeights);
        prx.compatibility.fontStyleCompatibility.changeTextPropsActions(action);
      });
    }

    for (var j = 0; j < prxy.symbols[i].states.length; j++) {
      if (prxy.symbols[i].states[j].actions !== undefined && prxy.symbols[i].states[j].actions.length > 0) {
        $.each(prxy.symbols[i].states[j].actions, function (i, action) {
          prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(action, hardcodedFonts, fontWeights);
          prx.compatibility.fontStyleCompatibility.changeTextPropsActions(action);
        });
      }

      if (prxy.symbols[i].states[j].groups !== undefined) {
        for (var gid in prxy.symbols[i].states[j].groups) {
          if (prxy.symbols[i].states[j].groups.hasOwnProperty(gid)) {
            if (prxy.symbols[i].states[j].groups[gid].actions === undefined) continue;
            $.each(prxy.symbols[i].states[j].groups[gid].actions, function (i, action) {
              prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(action, hardcodedFonts, fontWeights);
              prx.compatibility.fontStyleCompatibility.changeTextPropsActions(action);
            });
          }
        }
      }

      var data = JSON.parse(prxy.symbols[i].states[j].data);
      data = prx.compatibility.fontStyleCompatibility.updateItems(data, hardcodedFonts, fontWeights);
      prxy.symbols[i].states[j].data = JSON.stringify(data);
    }
  }
};

prx.compatibility.fontStyleCompatibility.updateItems = function (data, hardcodedFonts, fontWeights) {
  var actionTypes = prx.editor ? prx.mpactions._actionTypes : prx.actions._actionTypes;
  data.forEach(function (item) {
    var editedFont = [];
    var editedProperties = [];
    Object.getOwnPropertyNames(item).forEach(function (property) {
      if (actionTypes.indexOf(property) > -1) {
        if (typeof item[property] != 'undefined' && item[property].length > 0) {
          $.each(item[property], function (i, action) {
            prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(action, hardcodedFonts, fontWeights);
            prx.compatibility.fontStyleCompatibility.changeTextPropsActions(action);
          });
        }
      }

      if (property.slice(-4) === 'Font') {
        editedFont.push(property.substr(0, property.length - 4));
      }

      if (property.slice(-10) === 'Properties') {
        editedProperties.push(property.substr(0, property.length - 10));
      }
    });
    editedFont.forEach(function (property) {
      if (typeof item[property + 'FontStyle'] === 'undefined') {
        var fontFamily = item[property + 'Font'] || 'Arial,sans-serif';
        var fontStyle = '400';
        var isItalic = false;

        for (var type in fontWeights) {
          if (fontFamily.toLowerCase().includes(type)) {
            fontStyle = fontWeights[type];
            break; // this will not work if the loop doesnt loop the object in order - bold could be found in semibold :(
          }
        }

        for (var font in hardcodedFonts) {
          if (fontFamily == font) {
            fontFamily = hardcodedFonts[font];
          }
        }

        if (fontFamily.includes(':')) {
          fontStyle = fontFamily.split(':')[1];
          fontFamily = fontFamily.split(':')[0];
          isItalic = fontStyle.includes('italic') ? true : false;
        }

        for (var type in fontWeights) {
          if (fontStyle.toLowerCase() == type) {
            fontStyle = fontWeights[type];
          }
        } //Update font style with properties


        if (editedProperties.includes(property) && typeof item[property + 'Properties'] !== 'undefined' && _typeof(item[property + 'Properties']) === 'object' && item[property + 'Properties'] != null) {
          item[property + 'Properties'].forEach(function (property) {
            if (property === 'bold') {
              if (isItalic) {
                fontStyle = '700italic';
              } else {
                fontStyle = '700';
              }
            }

            if (property === 'italic' && !isItalic) {
              fontStyle += 'italic';
              isItalic = true;
            }
          });
          item[property + 'Properties'] = item[property + 'Properties'].includes("underline") ? ["underline"] : [];
        } //Save updated attributes


        if (fontFamily == 'Roboto, sans-serif') //fix issue with Roboto in components
          fontFamily = 'Roboto';
        item[property + 'Font'] = fontFamily;
        item[property + 'FontStyle'] = fontStyle;
      }
    });
    var dynamicPropertiesList;

    if (prx.editor) {
      dynamicPropertiesList = prx.properties.dynamic.props;
    } else {
      dynamicPropertiesList = prx.dynamicprops;
    }

    dynamicPropertiesList.forEach(function (dynProp) {
      if (typeof item[dynProp] !== 'undefined' && _typeof(item[dynProp]) === 'object') {
        item[dynProp].forEach(function (dynItem, index) {
          var editedDynItemProperties = [];
          Object.getOwnPropertyNames(dynItem).forEach(function (dynItemProperty, _index) {
            if (dynItemProperty == 'actions') {
              if (typeof item[dynProp][index][dynItemProperty] != 'undefined' && item[dynProp][index][dynItemProperty].length > 0) {
                $.each(item[dynProp][index][dynItemProperty], function (i, action) {
                  prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(action, hardcodedFonts, fontWeights);
                  prx.compatibility.fontStyleCompatibility.changeTextPropsActions(action);
                });
              }
            }

            if (dynItemProperty.slice(-10) === 'Properties') {
              editedDynItemProperties.push(dynItemProperty.substr(0, dynItemProperty.length - 10));
            }
          });
          editedDynItemProperties.forEach(function (elem) {
            if (_typeof(dynItem[elem + 'Properties']) !== 'object' || dynItem[elem + 'Properties'] === null) {
              return;
            }

            var fontStyle = '';

            if (dynItem[elem + 'Properties'].includes('bold')) {
              fontStyle += '700';
            } else {
              fontStyle += '400';
            }

            if (dynItem[elem + 'Properties'].includes('italic')) {
              fontStyle += 'italic';
            }

            dynItem[elem + 'FontStyle'] = fontStyle;
            dynItem[elem + 'Properties'] = dynItem[elem + 'Properties'].includes("underline") ? ["underline"] : [];
          });
        });
      }
    });

    if (typeof item.type != 'undefined' && item.type == 'io7_alert') {
      if (typeof item.title != 'undefined') {
        item.title = '<span style="font-weight: 700">' + item.title + '</span>';
      }
    }
  });
  return data;
};

prx.compatibility.fontStyleCompatibility.changeFontFamilyActions = function (jAction, hardcodedFonts, fontWeights) {
  var foundChangePropFontFamily = false;

  if (jAction.actionId == 'change-property' && jAction.propertyId && jAction.propertyId.slice(-4) == 'Font') {
    if (typeof jAction['newvalue'] != 'undefined') {
      var fontFamily = jAction['newvalue'];
      var fontStyle = '400'; // var isItalic = false;

      for (var type in fontWeights) {
        if (fontFamily.toLowerCase().includes(type)) {
          fontStyle = fontWeights[type];
          break; // this will not work if the loop doesnt loop the object in order - bold could be found in semibold :(
        }
      }

      for (var font in hardcodedFonts) {
        if (fontFamily == font) {
          fontFamily = hardcodedFonts[font];
        }
      }

      if (fontFamily.includes(':')) {
        fontStyle = fontFamily.split(':')[1];
        fontFamily = fontFamily.split(':')[0]; // isItalic = fontStyle.includes('italic') ? true : false;
        // if(isItalic) fontStyle += 'italic';
      }

      for (var type in fontWeights) {
        if (fontStyle.toLowerCase() == type) {
          fontStyle = fontWeights[type];
        }
      }

      jAction['newvalue'] = fontFamily;
      foundChangePropFontFamily = true; //yeaaa
    }
  }

  if (jAction.callbackAction !== undefined) {
    if (foundChangePropFontFamily) {
      //move callback further and add a new one to handle fontstyle change property
      var currentCallbackAction = prx.componentsHelper.cloneobject(jAction.callbackAction);
      var previousActionCopy = prx.componentsHelper.cloneobject(jAction);
      var relativeFontStylePropName = previousActionCopy.propertyId.replace('Font', 'FontStyle');
      jAction.callbackAction = {};
      jAction.callbackAction = previousActionCopy;
      jAction.callbackAction['callbackAction'] = currentCallbackAction;
      jAction.callbackAction['propertyId'] = relativeFontStylePropName;
      jAction.callbackAction['newvalue'] = fontStyle;
      jAction.callbackAction['delay'] = 0;
      jAction.callbackAction['clb_disabled'] = typeof previousActionCopy['clb_disabled'] != 'undefined' ? previousActionCopy['clb_disabled'] : false;
      jAction.callbackAction['guid'] = prx.utils.getGuid();
      prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(jAction.callbackAction, hardcodedFonts, fontWeights);
    } else {
      prx.compatibility.fontStyleCompatibility.changeFontFamilyActions(jAction.callbackAction, hardcodedFonts, fontWeights);
    }
  } else if (foundChangePropFontFamily) {
    // much easier case
    var previousActionCopy = prx.componentsHelper.cloneobject(jAction);
    var relativeFontStylePropName = previousActionCopy.propertyId.replace('Font', 'FontStyle');
    jAction['callback'] = true;
    jAction['callbackAction'] = {};
    jAction['callbackAction'] = previousActionCopy;
    jAction['callbackAction']['propertyId'] = relativeFontStylePropName;
    jAction['callbackAction']['delay'] = 0;
    jAction['callbackAction']['newvalue'] = fontStyle;
    jAction['callbackAction']['clb_disabled'] = typeof previousActionCopy['clb_disabled'] != 'undefined' ? previousActionCopy['clb_disabled'] : false;
    jAction['callbackAction']['guid'] = prx.utils.getGuid();
  }
};

prx.compatibility.fontStyleCompatibility.changeTextPropsActions = function (jAction) {
  var foundChangePropTextProps = false;

  if (jAction.actionId == 'change-property' && jAction.propertyId && jAction.propertyId.slice(-10) == 'Properties') {
    if (typeof jAction['newvalue'] != 'undefined') {
      var textProps = jAction['newvalue'];
      var singleLength = textProps.length == 1;
      var doubleLength = textProps.length == 2;
      var tripleLength = textProps.length == 3;
      var containsUnderLine = textProps.indexOf('underline') > -1;
      var containsItalic = textProps.indexOf('italic') > -1;
      var containsBold = textProps.indexOf('bold') > -1;
      var empty = textProps.length == 0; //.

      var underlineOnly = containsUnderLine && singleLength; //.

      var boldOnly = containsBold && singleLength;
      var boldAndUnderline = containsBold && containsUnderLine && doubleLength;
      var italicOnly = containsItalic && singleLength;
      var italicAndUnderline = containsItalic && containsUnderLine && doubleLength;
      var boldAndItalic = containsBold && containsItalic && doubleLength;
      var containsAll = tripleLength;

      if (underlineOnly) {
        //underline only
        foundChangePropTextProps = false; //yeaaa
      } else {
        if (empty) {
          // []
          // do nothing to current but add change font style to regular 400
          var fontStyle = '400';
        } else if (boldOnly) {
          jAction['newvalue'] = [];
          var fontStyle = '700';
        } else if (boldAndUnderline) {
          jAction['newvalue'] = ['underline'];
          var fontStyle = '700';
        } else if (italicOnly) {
          jAction['newvalue'] = [];
          var fontStyle = '400italic';
        } else if (italicAndUnderline) {
          jAction['newvalue'] = ['underline'];
          var fontStyle = '400italic';
        } else if (boldAndItalic) {
          jAction['newvalue'] = [];
          var fontStyle = '700italic';
        } else if (containsAll) {
          jAction['newvalue'] = ['underline'];
          var fontStyle = '700italic';
        }

        foundChangePropTextProps = true; //yeaaa
      }
    }
  }

  if (jAction.callbackAction !== undefined) {
    if (foundChangePropTextProps) {
      //move callback further and add a new one to handle fontstyle change property
      var currentCallbackAction = prx.componentsHelper.cloneobject(jAction.callbackAction);
      var previousActionCopy = prx.componentsHelper.cloneobject(jAction);
      var relativeFontStylePropName = previousActionCopy.propertyId.replace('Properties', 'FontStyle');
      jAction.callbackAction = {};
      jAction.callbackAction = previousActionCopy;
      jAction.callbackAction['callbackAction'] = currentCallbackAction;
      jAction.callbackAction['propertyId'] = relativeFontStylePropName;
      jAction.callbackAction['newvalue'] = fontStyle;
      jAction.callbackAction['delay'] = 0;
      jAction.callbackAction['clb_disabled'] = typeof previousActionCopy['clb_disabled'] != 'undefined' ? previousActionCopy['clb_disabled'] : false;
      jAction.callbackAction['guid'] = prx.utils.getGuid();
      prx.compatibility.fontStyleCompatibility.changeTextPropsActions(jAction.callbackAction);
    } else {
      prx.compatibility.fontStyleCompatibility.changeTextPropsActions(jAction.callbackAction);
    }
  } else if (foundChangePropTextProps) {
    // much easier case
    var previousActionCopy = prx.componentsHelper.cloneobject(jAction);
    var relativeFontStylePropName = previousActionCopy.propertyId.replace('Properties', 'FontStyle');
    jAction['callback'] = true;
    jAction['callbackAction'] = {};
    jAction['callbackAction'] = previousActionCopy;
    jAction['callbackAction']['propertyId'] = relativeFontStylePropName;
    jAction['callbackAction']['delay'] = 0;
    jAction['callbackAction']['newvalue'] = fontStyle;
    jAction['callbackAction']['clb_disabled'] = typeof previousActionCopy['clb_disabled'] != 'undefined' ? previousActionCopy['clb_disabled'] : false;
    jAction['callbackAction']['guid'] = prx.utils.getGuid();
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/common/js/compatibility/_state-transitions-to-ms.js":
/*!******************************************************************!*\
  !*** ./sass/common/js/compatibility/_state-transitions-to-ms.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.compatibility.stateTransitionsToMs = {}; // i am also rounding all ms values to the nearest 10. for example, 1735 ms will be rounded to 1730ms.
// this is needed due to complications in the timeline

prx.compatibility.stateTransitionsToMs.ini = function () {
  prx.compatibility.stateTransitionsToMs.upgrade();
};

prx.compatibility.stateTransitionsToMs.upgrade = function () {
  var canvastypes = ['pages', 'symbols'];
  canvastypes.forEach(function (canvastype) {
    prxy[canvastype].forEach(function (canvas, index) {
      for (var transition in canvas.state_transitions) {
        if (canvas.state_transitions.hasOwnProperty(transition)) {
          for (var item in canvas.state_transitions[transition]) {
            if (canvas.state_transitions[transition].hasOwnProperty(item)) {
              for (var prop in canvas.state_transitions[transition][item]) {
                if (canvas.state_transitions[transition][item].hasOwnProperty(prop)) {
                  if (typeof canvas.state_transitions[transition][item][prop]["duration"] !== "undefined") {
                    canvas.state_transitions[transition][item][prop]["duration"] = Math.floor(canvas.state_transitions[transition][item][prop]["duration"] * 1000 / 10) * 10;
                  }

                  if (typeof canvas.state_transitions[transition][item][prop]["delay"] !== "undefined") {
                    canvas.state_transitions[transition][item][prop]["delay"] = Math.floor(canvas.state_transitions[transition][item][prop]["delay"] * 1000 / 10) * 10;
                  }
                }
              }
            }
          }
        }
      }
    });
  });
  prx.transition.duration *= 1000;
  prx.stateTransitionToMSUpgraded = true;
};

/***/ }),

/***/ "./sass/common/js/prx/components/_components-helper.js":
/*!*************************************************************!*\
  !*** ./sass/common/js/prx/components/_components-helper.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($, jQuery) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

prx.componentsHelper = {};
prx.componentlibraries = ['common', 'iphone', 'android', 'ios7', 'material', 'metro', 'adrealestate', 'arrows_callouts', 'applewatch', 'generic2'];
prx.componentlibrariesicon = ['generic', 'material', 'swifticons-outlined', 'font-awesome-icons'];
prx.comps = {};
prx.comps.radioButtonsSupportingGrouping = ['material_radiobutton', 'material_onoffswitch', 'metro_radiobutton', 'metro_onoff', 'ios7_switch', 'ios10_switch', 'ios7_checkbox', 'basic_switch', 'basic_switch2', 'basic_radiobutton', 'basic_checkbox'];
prx.comps.onetoten = [{
  value: '1',
  displayValue: '1'
}, {
  value: '2',
  displayValue: '2'
}, {
  value: '3',
  displayValue: '3'
}, {
  value: '4',
  displayValue: '4'
}, {
  value: '5',
  displayValue: '5'
}, {
  value: '6',
  displayValue: '6'
}, {
  value: '7',
  displayValue: '7'
}, {
  value: '8',
  displayValue: '8'
}, {
  value: '9',
  displayValue: '9'
}, {
  value: '10',
  displayValue: '10'
}];
prx.comps.fallbackFont = 'Arial';
prx.comps.defaultcolor = "555555";
prx.comps.textPropertiesMappings = {
  underline: ['<u>', '</u>']
};
prx.comps.textFontStylePropertiesMappings = {
  'font-weight': '',
  'font-style': ''
};

prx.comps.fontForRichTextEditor = function (cleanGoogleFonts) {
  var fontsArray = {};
  var tempArray = [];

  var fontslist = prx.fonts._fonts.concat(prx.comps.fontsFullList);

  for (var i = 0; i < fontslist.length; i++) {
    var newFontName = prx.componentsHelper.getFontCssFromFontFamily(fontslist[i].value).replace('font-family: ', '').replace(/font-weight:(\s*\w+);/g, '');

    if (typeof cleanGoogleFonts !== 'undefined') {
      // newFontName = newFontName.replace(/(?:font-[^;]*;)/gi, '').replace(';','').trim()
      newFontName = newFontName.replace(/(?:font-style[^;]*;|font-weight[^;]*;)/gi, '').replace(';', '').trim();
    }

    if ($.inArray(newFontName.trim(), tempArray) < 0) {
      tempArray.push(newFontName);
      fontsArray[newFontName] = fontslist[i].displayValue;
    }
  } // for (var i = 0; i < prx.comps.fonts.length; i++) {
  // 	if (typeof(prx.comps.fonts[i].options) != 'undefined') {
  // 		for (var k = 0; k < prx.comps.fonts[i].options.length; k++) {
  // 			if(prx.comps.fonts[i].options[k].displayValue!=='Manage project webfonts...'){
  // 				var fontName = prx.componentsHelper.getFontCssFromFontFamily(prx.comps.fonts[i].options[k].value).replace('font-family: ', '').replace(/font-weight:(\s*\w+);/g,'');
  // 				if(typeof(cleanGoogleFonts)!=='undefined'){
  // 					fontName = fontName.replace(/(?:font-[^;]*;)/gi, '').replace(';','').trim()
  // 				}
  // 				if($.inArray(fontName.trim(), tempArray)<0) {
  // 					tempArray.push(fontName)
  // 					fontsArray[fontName] = prx.comps.fonts[i].options[k].displayValue;
  // 				}
  // 			}
  // 		}
  // 	}
  // }


  return fontsArray;
};

prx.comps.getFontFamilyValue = function (fontFamilyDisplay) {
  if (typeof fontFamilyDisplay == 'undefined') return '';

  if (prx.comps.fontsFullList.filter(function (fontFamily) {
    return fontFamily.value.replace(/\|\d+/gm, '') == fontFamilyDisplay;
  }).length > 0) {
    return fontFamilyDisplay;
  } //allready a value


  if (prx.comps.fontsFullList.filter(function (fontFamily) {
    return fontFamily.displayValue == fontFamilyDisplay;
  }).length > 0) {
    return prx.comps.fontsFullList.filter(function (fontFamily) {
      return fontFamily.displayValue == fontFamilyDisplay;
    })[0]['value'].replace(/\|\d+/gm, '');
  } //convert displayvalue to value


  return fontFamilyDisplay.replace(/\|\d+/gm, '');
};

prx.comps.fontsFullList = [// {value: 'sans-serif,Helvetica Neue,Arial', displayValue: 'Default'}, removed 8/3/18
{
  value: 'Arial,sans-serif',
  displayValue: 'Arial'
}, {
  value: 'Arial Black,sans-serif',
  displayValue: 'Arial Black'
}, {
  value: 'Comic Sans MS,cursive',
  displayValue: 'Comic Sans MS'
}, {
  value: 'Courier New,monospace',
  displayValue: 'Courier New'
}, {
  value: 'Helvetica,sans-serif',
  displayValue: 'Helvetica'
}, {
  value: 'Impact,sans-serif',
  displayValue: 'Impact'
}, {
  value: 'Georgia,serif',
  displayValue: 'Georgia'
}, {
  value: 'Tahoma,sans-serif',
  displayValue: 'Tahoma'
}, {
  value: 'Times New Roman,serif',
  displayValue: 'Times New Roman'
}, {
  value: 'Trebuchet MS,sans-serif',
  displayValue: 'Trebuchet MS'
}, {
  value: 'Verdana,sans-serif',
  displayValue: 'Verdana'
}, {
  value: 'Roboto, sans-serif',
  displayValue: 'Roboto'
}, {
  value: 'Segoe UI, sans-serif',
  displayValue: 'Segoe UI'
}, {
  value: 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif|300',
  displayValue: 'Helvetica Neue'
}, {
  value: 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif|500',
  displayValue: 'Helvetica Neue'
}, {
  value: 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif|700',
  displayValue: 'Helvetica Neue'
}, {
  value: 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif|400',
  displayValue: 'Helvetica Neue'
}, {
  value: 'San Francisco Pro Display|100',
  displayValue: 'San Francisco Pro Display'
}, {
  value: 'San Francisco Pro Display|200',
  displayValue: 'San Francisco Pro Display'
}, {
  value: 'San Francisco Pro Display|300',
  displayValue: 'San Francisco Pro Display'
}, {
  value: 'San Francisco Pro Display|400',
  displayValue: 'San Francisco Pro Display'
}, {
  value: 'San Francisco Pro Display|500',
  displayValue: 'San Francisco Pro Display'
}, {
  value: 'San Francisco Pro Display|600',
  displayValue: 'San Francisco Pro Display'
}, {
  value: 'San Francisco Pro Display|700',
  displayValue: 'San Francisco Pro Display'
}, {
  value: 'San Francisco Pro Display|800',
  displayValue: 'San Francisco Pro Display'
}, {
  value: 'San Francisco Pro Display|900',
  displayValue: 'San Francisco Pro Display'
}, {
  value: 'San Francisco Pro Text|100',
  displayValue: 'San Francisco Pro Text'
}, {
  value: 'San Francisco Pro Text|200',
  displayValue: 'San Francisco Pro Text'
}, {
  value: 'San Francisco Pro Text|300',
  displayValue: 'San Francisco Pro Text'
}, {
  value: 'San Francisco Pro Text|400',
  displayValue: 'San Francisco Pro Text'
}, {
  value: 'San Francisco Pro Text|500',
  displayValue: 'San Francisco Pro Text'
}, {
  value: 'San Francisco Pro Text|600',
  displayValue: 'San Francisco Pro Text'
}, {
  value: 'San Francisco Pro Text|700',
  displayValue: 'San Francisco Pro Text'
}, {
  value: 'San Francisco Pro Text|800',
  displayValue: 'San Francisco Pro Text'
}, {
  value: 'San Francisco Pro Text|900',
  displayValue: 'San Francisco Pro Text'
}, {
  value: 'San Francisco Compact Display|100',
  displayValue: 'San Francisco Compact Display'
}, {
  value: 'San Francisco Compact Display|200',
  displayValue: 'San Francisco Compact Display'
}, {
  value: 'San Francisco Compact Display|300',
  displayValue: 'San Francisco Compact Display'
}, {
  value: 'San Francisco Compact Display|400',
  displayValue: 'San Francisco Compact Display'
}, {
  value: 'San Francisco Compact Display|500',
  displayValue: 'San Francisco Compact Display'
}, {
  value: 'San Francisco Compact Display|600',
  displayValue: 'San Francisco Compact Display'
}, {
  value: 'San Francisco Compact Display|700',
  displayValue: 'San Francisco Compact Display'
}, {
  value: 'San Francisco Compact Display|800',
  displayValue: 'San Francisco Compact Display'
}, {
  value: 'San Francisco Compact Display|900',
  displayValue: 'San Francisco Compact Display'
}, {
  value: 'San Francisco Compact Text|100',
  displayValue: 'San Francisco Compact Text'
}, {
  value: 'San Francisco Compact Text|200',
  displayValue: 'San Francisco Compact Text'
}, {
  value: 'San Francisco Compact Text|300',
  displayValue: 'San Francisco Compact Text'
}, {
  value: 'San Francisco Compact Text|400',
  displayValue: 'San Francisco Compact Text'
}, {
  value: 'San Francisco Compact Text|500',
  displayValue: 'San Francisco Compact Text'
}, {
  value: 'San Francisco Compact Text|600',
  displayValue: 'San Francisco Compact Text'
}, {
  value: 'San Francisco Compact Text|700',
  displayValue: 'San Francisco Compact Text'
}, {
  value: 'San Francisco Compact Text|800',
  displayValue: 'San Francisco Compact Text'
}, {
  value: 'San Francisco Compact Text|900',
  displayValue: 'San Francisco Compact Text'
}, {
  value: 'cursive',
  displayValue: 'cursive'
}, {
  value: 'monospace',
  displayValue: 'monospace'
}, {
  value: 'sans-serif',
  displayValue: 'sans-serif'
}, {
  value: 'serif',
  displayValue: 'serif'
}];
prx.comps.fonts = [// {
//   optgroup: true,
//   displayValue: 'Manage',
//   options: [{value: '', displayValue: ''}
//   ,{
//     displayValue: 'Manage project fonts...',
//     value: 'manage-project-webfonts',
//     missing: false
//   }]
// },
{
  optgroup: true,
  displayValue: 'hide-group-header',
  options: prx.fonts._fonts.concat([{
    value: 'multiple-fonts',
    displayValue: 'Multiple'
  }, {
    value: '',
    displayValue: ''
  }, // {value: 'sans-serif,Helvetica Neue,Arial', displayValue: 'Default'}, removed 8/3/18
  {
    value: 'Arial,sans-serif',
    displayValue: 'Arial'
  }, {
    value: 'Arial Black,sans-serif',
    displayValue: 'Arial Black'
  }, {
    value: 'Comic Sans MS,cursive',
    displayValue: 'Comic Sans MS'
  }, {
    value: 'Courier New,monospace',
    displayValue: 'Courier New'
  }, {
    value: 'Helvetica,sans-serif',
    displayValue: 'Helvetica'
  }, {
    value: 'Impact,sans-serif',
    displayValue: 'Impact'
  }, {
    value: 'Georgia,serif',
    displayValue: 'Georgia'
  }, {
    value: 'Tahoma,sans-serif',
    displayValue: 'Tahoma'
  }, {
    value: 'Times New Roman,serif',
    displayValue: 'Times New Roman'
  }, {
    value: 'Trebuchet MS,sans-serif',
    displayValue: 'Trebuchet MS'
  }, {
    value: 'Verdana,sans-serif',
    displayValue: 'Verdana'
  }, {
    value: 'Roboto, sans-serif',
    displayValue: 'Roboto'
  }, {
    value: 'Segoe UI, sans-serif',
    displayValue: 'Segoe UI'
  }, {
    value: 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif',
    displayValue: 'Helvetica Neue'
  }, {
    value: 'San Francisco Pro Display',
    displayValue: 'San Francisco Pro Display'
  }, {
    value: 'San Francisco Pro Text',
    displayValue: 'San Francisco Pro Text'
  }, {
    value: 'San Francisco Compact Display',
    displayValue: 'San Francisco Compact Display'
  }, {
    value: 'San Francisco Compact Text',
    displayValue: 'San Francisco Compact Text'
  }])
}, {
  optgroup: true,
  displayValue: 'styled-separator',
  options: [{
    value: 'cursive',
    displayValue: 'cursive'
  }, {
    value: 'monospace',
    displayValue: 'monospace'
  }, {
    value: 'sans-serif',
    displayValue: 'sans-serif'
  }, {
    value: 'serif',
    displayValue: 'serif'
  }]
}];

prx.comps.fontSorting = function (a, b) {
  if (a.displayValue.toLowerCase() < b.displayValue.toLowerCase()) return -1;
  if (a.displayValue.toLowerCase() > b.displayValue.toLowerCase()) return 1;
  return 0;
};

prx.comps.fontStyles = prx.fontManager ? prx.fontManager.getAllVariantsOptions() : [];
prx.comps.textsize = [{
  value: '9',
  displayValue: '9'
}, {
  value: '10',
  displayValue: '10'
}, {
  value: '11',
  displayValue: '11'
}, {
  value: '12',
  displayValue: '12'
}, {
  value: '13',
  displayValue: '13'
}, {
  value: '14',
  displayValue: '14'
}, {
  value: '18',
  displayValue: '18'
}, {
  value: '20',
  displayValue: '20'
}, {
  value: '24',
  displayValue: '24'
}, {
  value: '36',
  displayValue: '36'
}, {
  value: '48',
  displayValue: '48'
}, {
  value: '64',
  displayValue: '64'
}, {
  value: '72',
  displayValue: '72'
}, {
  value: '144',
  displayValue: '144'
}, {
  value: '288',
  displayValue: '288'
}];
prx.comps.textspacing = [{
  value: 'auto',
  displayValue: 'auto'
}, {
  value: '1',
  displayValue: '1'
}, {
  value: '2',
  displayValue: '2'
}, {
  value: '3',
  displayValue: '3'
}, {
  value: '4',
  displayValue: '4'
}, {
  value: '5',
  displayValue: '5'
}, {
  value: '6',
  displayValue: '6'
}, {
  value: '7',
  displayValue: '7'
}, {
  value: '8',
  displayValue: '8'
}, {
  value: '9',
  displayValue: '9'
}, {
  value: '10',
  displayValue: '10'
}];
prx.comps.lineheight = [{
  value: 'auto',
  displayValue: 'auto'
}, {
  value: '1',
  displayValue: '1'
}, {
  value: '2',
  displayValue: '2'
}, {
  value: '3',
  displayValue: '3'
}, {
  value: '4',
  displayValue: '4'
}, {
  value: '5',
  displayValue: '5'
}, {
  value: '6',
  displayValue: '6'
}, {
  value: '7',
  displayValue: '7'
}, {
  value: '8',
  displayValue: '8'
}, {
  value: '9',
  displayValue: '9'
}, {
  value: '10',
  displayValue: '10'
}];
window.datetime = new Date();
window.weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
window.shortWeekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
window.shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
window.months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
prx.comps.dateGeneralFormat = [{
  value: 'date',
  displayValue: 'Date Only'
}, {
  value: 'time',
  displayValue: 'Time Only'
}, {
  value: 'datetime',
  displayValue: 'Date First'
}, {
  value: 'timedate',
  displayValue: 'Time First'
}];
prx.comps.dateFormat = [{
  value: 'daymonthyear',
  displayValue: 'Day Month Year'
}, {
  value: 'monthdayyear',
  displayValue: 'Month Day Year'
}, {
  value: 'yearmonthday',
  displayValue: 'Year Month Day'
}];
prx.comps.dayNameFormat = [{
  value: 'none',
  displayValue: 'None'
}, {
  value: 'short',
  displayValue: 'Day as abbreviation (' + shortWeekdays[datetime.getDay()] + ')'
}, {
  value: 'long',
  displayValue: 'Day as full name (' + weekdays[datetime.getDay()] + ')'
}];
prx.comps.dayFormat = [{
  value: 'none',
  displayValue: 'None'
}, {
  value: 'single',
  displayValue: 'Day without leading zero (' + datetime.getDate() + ')'
}, {
  value: 'double',
  displayValue: 'Day with leading zero (' + ('0' + datetime.getDate()).slice(-2) + ')'
}, {
  value: 'superscript',
  displayValue: 'Day with superscript (' + function () {
    var lastDigit = datetime.getDate().toString().slice(-2);
    var superscript = '';

    if (datetime.getDate() > 10 && datetime.getDate() < 20) {
      superscript = 'th';
    } else {
      switch (lastDigit) {
        case '1':
          superscript = 'st';
          break;

        case '2':
          superscript = 'nd';
          break;

        case '3':
          superscript = 'rd';
          break;

        default:
          superscript = 'th';
          break;
      }
    }

    return datetime.getDate() + superscript.sup();
  }() + ')'
}];
prx.comps.monthFormat = [{
  value: 'none',
  displayValue: 'None'
}, {
  value: 'single',
  displayValue: 'Month without leading zero (' + (datetime.getMonth() + 1) + ')'
}, {
  value: 'double',
  displayValue: 'Month with leading zero (' + ('0' + (datetime.getMonth() + 1)).slice(-2) + ')'
}, {
  value: 'short',
  displayValue: 'Month as abbreviation (' + shortMonths[datetime.getMonth()] + ')'
}, {
  value: 'long',
  displayValue: 'Month as full name (' + months[datetime.getMonth()] + ')'
}];
prx.comps.yearFormat = [{
  value: 'none',
  displayValue: 'None'
}, {
  value: 'short',
  displayValue: 'Two digit year (' + datetime.getFullYear().toString().slice(-2) + ')'
}, {
  value: 'long',
  displayValue: 'Four digit year (' + datetime.getFullYear() + ')'
}];
prx.comps.timeFormat = [{
  value: '24',
  displayValue: '24H format (' + datetime.getHours() + ':' + ('0' + datetime.getMinutes()).slice(-2) + ')'
}, {
  value: '12a',
  displayValue: '12H without AM/PM (' + function () {
    var hour = 0;

    if (datetime.getHours() > 12) {
      hour = datetime.getHours() - 12;
    } else {
      hour = datetime.getHours();
    }

    return hour + ':' + ('0' + datetime.getMinutes()).slice(-2);
  }() + ')'
}, {
  value: '12b',
  displayValue: '12H with AM/PM (' + function () {
    var hour = 0;

    if (datetime.getHours() > 12) {
      hour = datetime.getHours() - 12;
      var ampm = 'PM';
    } else {
      hour = datetime.getHours();
      var ampm = 'AM';
    }

    return hour + ':' + ('0' + datetime.getMinutes()).slice(-2) + ' ' + ampm;
  }() + ')'
}];
prx.comps.dateSeparator = [{
  value: '/',
  displayValue: 'Slash (/)'
}, {
  value: '.',
  displayValue: 'Dot (.)'
}, {
  value: '-',
  displayValue: 'Dash (-)'
}, {
  value: ' ',
  displayValue: 'Space ( )'
}];
prx.commonproperties = {};
prx.commonproperties.backgroundColor = {
  caption: 'Background',
  name: 'backgroundColor',
  proptype: 'background-color',
  type: 'gradients-colorpicker',
  value: function value(item, name) {
    return typeof item.backgroundColor == 'undefined' ? '' : item.backgroundColor;
  },
  liveUpdate: 'background-color',
  changeProperty: {
    caption: 'Background color',
    selector: '.changeProperty-backgroundColor',
    property: 'background-color',
    transitionable: true
  }
};
prx.commonproperties.backgroundColorSolid = {
  caption: 'Background',
  name: 'backgroundColor',
  proptype: 'background-color',
  type: 'solid-colorpicker',
  value: function value(item, name) {
    return typeof item.backgroundColor == 'undefined' ? '' : item.backgroundColor;
  },
  liveUpdate: 'background-color',
  changeProperty: {
    caption: 'Background color',
    selector: '.changeProperty-backgroundColor',
    property: 'background-color',
    transitionable: true
  }
};
prx.commonproperties.backgroundColorActive = {
  caption: 'Active',
  name: 'backgroundColorActive',
  proptype: 'background-color-2-active',
  type: 'colorpicker',
  value: function value(item, name) {
    return item.backgroundColorActive;
  },
  liveUpdate: 'background-color',
  changeProperty: {
    caption: 'Active Background color',
    selector: '.changeProperty-backgroundColorActive',
    property: 'background-color',
    transitionable: true
  }
};
prx.commonproperties.actions = {
  caption: 'Item',
  name: 'actions',
  type: 'action',
  value: function value(item, name) {
    if (typeof item.actions == 'undefined') {
      item.actions = [];
    }

    return item.actions.length;
  },
  changeProperty: {
    caption: 'Interactions',
    selector: '',
    property: 'action',
    transitionable: false,
    changeable: false
  }
};

prx.commonproperties.actions_hiddenByDefault = function (fun) {
  return {
    caption: 'Item',
    name: 'actions',
    type: 'action',
    value: function value(item, name) {
      if (typeof item.actions == 'undefined') {
        item.actions = [];
      }

      return item.actions.length;
    },
    changeProperty: {
      caption: 'Interactions',
      selector: '',
      property: 'action',
      transitionable: false,
      changeable: false
    },
    hiddenByDefault: fun
  };
};

prx.commonproperties.actions_listitems = {
  caption: 'List item',
  name: 'actions',
  type: 'action',
  value: function value(item, name, index) {
    if (typeof item.listitems[index].actions == 'undefined') {
      item.listitems[index].actions = [];
    }

    return item.listitems[index].actions.length;
  }
};

prx.commonproperties.actions_listitems_hiddenByDefault = function (fun) {
  return {
    caption: 'List item',
    name: 'actions',
    type: 'action',
    value: function value(item, name, index) {
      if (typeof item.listitems[index].actions == 'undefined') {
        item.listitems[index].actions = [];
      }

      return item.listitems[index].actions.length;
    },
    hiddenByDefault: fun
  };
};

prx.commonproperties.actions_buttons = {
  caption: 'Button',
  name: 'actions',
  type: 'action',
  value: function value(item, name, index) {
    if (typeof item.buttons[index].actions == 'undefined') {
      item.buttons[index].actions = [];
    }

    return item.buttons[index].actions.length;
  }
};

prx.commonproperties.actions_buttons_hiddenByDefault = function (fun) {
  return {
    caption: 'Button',
    name: 'actions',
    type: 'action',
    value: function value(item, name, index) {
      if (typeof item.buttons[index].actions == 'undefined') {
        item.buttons[index].actions = [];
      }

      return item.buttons[index].actions.length;
    },
    hiddenByDefault: fun
  };
};

prx.commonproperties.actions_tabs = {
  caption: 'Tab',
  name: 'actions',
  type: 'action',
  value: function value(item, name, index) {
    if (typeof item.tabs[index].actions == 'undefined') {
      item.tabs[index].actions = [];
    }

    return item.tabs[index].actions.length;
  }
};

prx.commonproperties.actions_tabs_hiddenByDefault = function (fun) {
  return {
    caption: 'Tab',
    name: 'actions',
    type: 'action',
    value: function value(item, name, index) {
      if (typeof item.tabs[index].actions == 'undefined') {
        item.tabs[index].actions = [];
      }

      return item.tabs[index].actions.length;
    },
    hiddenByDefault: fun
  };
};

prx.commonproperties.borderWidth = {
  caption: 'Border',
  name: 'borderWidth',
  proptype: 'border-width',
  type: 'combo-select',
  value: function value(item, name) {
    return item.borderWidth;
  },
  values: {
    min: 0,
    max: 20,
    step: 1
  },
  changeProperty: {
    caption: 'Border width',
    selector: '.changeProperty-borderWidth',
    property: 'border-width',
    transitionable: true
  }
};
prx.commonproperties.borderWidthExpandable = {
  caption: 'Border',
  name: 'borderWidth',
  proptype: 'border-width',
  type: 'combo-select',
  value: function value(item, name) {
    return item.borderWidth;
  },
  values: {
    min: 0,
    max: 20,
    step: 1
  },
  expandableType: 'borderWidth',
  expandedValues: ['t', 'r', 'l', 'b'],
  changeProperty: {
    caption: 'Border width',
    selector: '.changeProperty-borderWidth',
    property: 'border-width',
    transitionable: true
  }
};
prx.commonproperties.borderColor = {
  caption: false,
  name: 'borderColor',
  proptype: 'border-color',
  type: 'solid-colorpicker',
  value: function value(item, name) {
    return typeof item.borderColor == 'undefined' ? '' : item.borderColor;
  },
  liveUpdate: 'border-color',
  changeProperty: {
    caption: 'Border color',
    selector: '.changeProperty-borderColor',
    property: 'border-top-color,border-bottom-color,border-left-color,border-right-color',
    transitionable: true
  },
  hiddenByDefault: function hiddenByDefault(item) {
    if (item.type == 'image') if (prx.mask.isActive(item) || prx.mask.editModeIsMaskSelected(item)) return true;else return false;
    return false;
  }
}; // firefox issue http://greensock.com/forums/topic/8373-timeline-not-detecting-initial-bordercolor/

prx.commonproperties.borderColorActive = {
  caption: 'Active',
  name: 'borderColorActive',
  proptype: 'border-color-2-active',
  type: 'colorpicker',
  value: function value(item, name) {
    return item.borderColorActive;
  },
  liveUpdate: 'border-color',
  changeProperty: {
    caption: 'Active Border color',
    selector: '.changeProperty-borderColorActive',
    property: 'border-top-color,border-bottom-color,border-left-color,border-right-color',
    transitionable: true
  }
}; // firefox issue http://greensock.com/forums/topic/8373-timeline-not-detecting-initial-bordercolor/

prx.commonproperties.borderStyle = {
  caption: false,
  name: 'borderStyle',
  proptype: 'border-style',
  type: 'select',
  value: function value(item, name) {
    if (typeof item.borderStyle == "undefined") {
      item.borderStyle = "solid";
    }

    return item.borderStyle;
  },
  values: [{
    value: "solid",
    displayValue: "Solid"
  }, {
    value: "dotted",
    displayValue: "Dotted"
  }, {
    value: "dashed",
    displayValue: "Dashed"
  }, {
    value: "double",
    displayValue: "Double"
  }, {
    value: "none",
    displayValue: "None"
  }],
  changeProperty: {
    caption: 'Border Style',
    selector: '.changeProperty-borderStyle',
    property: 'border-style',
    transitionable: false
  }
};
prx.commonproperties.shadowColor = {
  caption: 'Shadow',
  name: 'shadowColor',
  proptype: 'shadow-color',
  type: 'colorpicker',
  value: function value(item, name) {
    return typeof item.shadowColor == 'undefined' ? '' : item.shadowColor;
  },
  changeProperty: {
    caption: 'Shadow',
    rerender: true,
    changeable: false
  }
};
prx.commonproperties.pffSettingsTextProperties = {
  labelBelow: true,
  groupClass: 'add-text-prop-left-margin icon-only-bordered-checkbox'
};
prx.commonproperties.pffSettingsLineHeight = {
  labelBelow: true,
  groupClass: 'add-text-prop-left-margin add-spacing-extra-label center-input'
};
prx.commonproperties.pffSettingsCharacterSpacing = {
  groupClass: 'align-label-center-to-left center-input',
  labelBelow: true
};
prx.commonproperties.pffSettingsColor = {
  labelBelow: true,
  groupClass: 'colorpicker-reverse-row text-properties'
};
prx.commonproperties.pffSettingsTextFontStyle = {
  groupClass: 'margin-fourteen'
};
prx.commonproperties.pffSettingsTextAlignment = {
  groupClass: 'alignment-div'
};
prx.commonproperties.borderRadius = {
  caption: '<span class="icon icon-border-radius" title="Border radius"></span>',
  name: 'borderRadius',
  proptype: 'border-radius',
  type: 'combo-select',
  value: function value(item, name) {
    return typeof item.borderRadius == 'undefined' ? '' : item.borderRadius;
  },
  values: {
    min: 0,
    max: 20,
    step: 1
  },
  changeProperty: {
    caption: 'Border radius',
    selector: '.changeProperty-borderRadius',
    property: 'border-radius',
    transitionable: true
  }
};
prx.commonproperties.borderRadiusExpandable = {
  caption: '<span class="icon icon-border-radius" title="Border radius"></span>',
  name: 'borderRadius',
  proptype: 'border-radius',
  type: 'combo-select',
  value: function value(item, name) {
    return typeof item.borderRadius == 'undefined' ? '' : item.borderRadius;
  },
  values: {
    min: 0,
    max: 20,
    step: 1
  },
  expandableType: 'borderRadius',
  expandedValues: ['tl', 'tr', 'bl', 'br'],
  changeProperty: {
    caption: 'Border radius',
    selector: '.changeProperty-borderRadius',
    property: 'border-radius',
    transitionable: true
  }
};
prx.commonproperties.text = {
  caption: 'Text',
  name: 'text',
  type: 'input',
  value: function value(item, name) {
    return typeof item.text == 'undefined' ? '' : item.text;
  },
  changeProperty: {
    caption: 'Text',
    selector: '.changeProperty-text',
    property: 'text',
    transitionable: false
  }
};
prx.commonproperties.text_textarea = {
  caption: 'Text',
  name: 'text',
  type: 'textarea',
  value: function value(item, name) {
    return typeof item.text == 'undefined' ? '' : item.text;
  },
  changeProperty: {
    caption: 'Text',
    selector: '.changeProperty-text',
    property: 'text',
    transitionable: false
  }
};
prx.commonproperties.body_textarea = {
  caption: 'Body',
  name: 'text',
  type: 'textarea',
  value: function value(item, name) {
    return typeof item.text == 'undefined' ? '' : item.text;
  },
  changeProperty: {
    caption: 'Body',
    selector: '.changeProperty-body',
    property: 'text',
    transitionable: false
  }
};
prx.commonproperties.textSubtitle = {
  caption: 'Subtitle',
  name: 'subtitle',
  proptype: 'text-2-subtitle',
  type: 'input',
  value: function value(item, name) {
    return typeof item.subtitle == 'undefined' ? '' : item.subtitle;
  },
  changeProperty: {
    caption: 'Subtitle',
    selector: '.changeProperty-subtitle',
    property: 'text',
    transitionable: false
  }
};
prx.commonproperties.textSubtitle_textarea = {
  caption: 'Subtitle',
  name: 'subtitle',
  proptype: 'text-2-subtitle',
  type: 'textarea',
  value: function value(item, name) {
    return typeof item.subtitle == 'undefined' ? '' : item.subtitle;
  },
  changeProperty: {
    caption: 'Subtitle',
    selector: '.changeProperty-subtitle',
    property: 'text',
    transitionable: false
  }
};
prx.commonproperties.footnote_textarea = {
  caption: 'Footnote',
  name: 'subtitle',
  proptype: 'text-2-subtitle',
  type: 'textarea',
  value: function value(item, name) {
    return typeof item.subtitle == 'undefined' ? '' : item.subtitle;
  },
  changeProperty: {
    caption: 'Footnote',
    selector: '.changeProperty-footnote',
    property: 'text',
    transitionable: false
  }
};
prx.commonproperties.textFont = {
  caption: {
    label: 'Font family',
    "class": 'text-properties-label text-fontfamily-label'
  },
  name: 'textFont',
  proptype: 'font-family',
  type: 'select',
  value: function value(item, name) {
    return typeof item.textFont == 'undefined' ? '' : item.textFont;
  },
  values: function values() {
    return prx.comps.fonts;
  },
  changeProperty: {
    caption: 'Text font',
    selector: '.changeProperty-textFont',
    property: 'font-family',
    transitionable: false
  }
};
prx.commonproperties.textFontStyle = {
  caption: {
    label: 'Font style',
    "class": 'text-properties-label text-fontstyle-label'
  },
  name: 'textFontStyle',
  proptype: 'font-style',
  type: 'select',
  pffSettings: prx.commonproperties.pffSettingsTextFontStyle,
  value: function value(item, name) {
    return typeof item.textFontStyle == 'undefined' ? '' : item.textFontStyle;
  },
  values: function values() {
    return prx.comps.fontStyles;
  },
  hiddenByDefault: function hiddenByDefault(item) {
    return false;
  },
  changeProperty: {
    caption: 'Text font style',
    rerender: true
  }
};
/**Rich Text**/

prx.commonproperties.textFontRichText = function (relatedCssProperty, relatedEditableProperty, hiddenByDefault) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.textFont);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  }

  return commonProperties;
};

prx.commonproperties.textFontButtonRichText = function (relatedCssProperty, relatedEditableProperty, hiddenByDefault, name) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.textFontButton);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty; // commonProperties['changeProperty'] =  {
  //    	caption: 'Text Font',
  //        rerender: true
  // };

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  }

  return commonProperties;
};

prx.commonproperties.textSizeRichText = function (relatedCssProperty, relatedEditableProperty, hiddenByDefault) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.textSize);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  }

  return commonProperties;
};

prx.commonproperties.textSizeButtonRichText = function (relatedCssProperty, relatedEditableProperty, hiddenByDefault) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.textSizeButton);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  }

  return commonProperties;
};

prx.commonproperties.ios7TextColorRichText = function (relatedCssProperty, relatedEditableProperty, hiddenByDefault, label) {
  var commonProperties = prx.commonproperties.ios7TextColor(label);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  }

  return commonProperties;
};

prx.commonproperties.ios7TextColorButtonRichText = function (relatedCssProperty, relatedEditableProperty, hiddenByDefault) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.ios7ButtonsTextColor);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  }

  return commonProperties;
};

prx.commonproperties.textPropertiesRichText = function (relatedCssProperty, relatedEditableProperty, hiddenByDefault, data) {
  if (typeof data == 'undefined') return false;
  var commonProperties = {
    caption: {
      label: 'Underline',
      "class": 'colorpicker-wrapper text-underline-label'
    },
    pffSettings: prx.commonproperties.pffSettingsTextProperties,
    name: data.propName,
    proptype: 'text-properties',
    type: 'checkbox',
    relatedEditableProperties: relatedEditableProperty,
    relatedCSSProperties: relatedCssProperty,
    value: function value(item, name, index) {
      var propName = data.propName;
      var useAsDynProp = data.useAsDynProp;
      relatedEditableProperty = $.isArray(relatedEditableProperty) ? relatedEditableProperty : [relatedEditableProperty];

      for (var i = 0; i < relatedEditableProperty.length; i++) {
        if (useAsDynProp) {
          var path = relatedEditableProperty[i].split(/[.]+/);
          var textPropertiesValue = typeof item[path[0]][index][propName] == 'undefined' ? prx.components[item.type][path[0]][0][propName] : item[path[0]][index][propName];
          return textPropertiesValue; // var fontStyleProps = prx.componentsHelper.getTextandFontStylePropsName(item.type, propName, useAsDynProp)['relatedTextFontStylePropsName'];
          // var fontStyleValue = typeof(item[path[0]][index][fontStyleProps]) == 'undefined' ? prx.components[item.type][path[0]][0][fontStyleProps] : item[path[0]][index][fontStyleProps];
          // return prx.commonproperties.getFontStyleValueCombined(textPropertiesValue, fontStyleValue);
        } else {
          var textPropertiesValue = typeof item[propName] == 'undefined' ? prx.components[item.type][propName] : item[propName];
          return textPropertiesValue; // var fontStyleProps = prx.componentsHelper.getTextandFontStylePropsName(item.type, propName, false)['relatedTextFontStylePropsName'];
          // var fontStyleValue = typeof(item[fontStyleProps]) == 'undefined' ? prx.components[item.type][propName] : item[fontStyleProps];
          //
          // return prx.commonproperties.getFontStyleValueCombined(textPropertiesValue, fontStyleValue);
        }
      }
    },
    values: [{
      value: 'underline',
      displayValue: '',
      icon: 'text-underline'
    }],
    changeProperty: {
      caption: data.caption,
      transitionable: false
    }
  };

  commonProperties['changeProperty']['changeFunction'] = function (item, containerid, duration, easing, dynPropI) {
    prx.componentsHelper.changeFunctionForTextProperties(item, containerid, dynPropI, data.propName);
  };

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  } else if (typeof hiddenByDefault == 'function') {
    commonProperties['hiddenByDefault'] = hiddenByDefault;
  }

  if (data.onChange !== undefined) {
    commonProperties['data'] = data.onChange;
  }

  return commonProperties;
};

prx.commonproperties.textFontStyleRichText = function (relatedCssProperty, relatedEditableProperty, hiddenByDefault, data) {
  if (typeof data == 'undefined') return false;
  var commonProperties = {
    caption: {
      label: 'Font style',
      "class": 'text-properties-label text-fontstyle-label'
    },
    name: data.propName,
    proptype: 'font-style',
    type: 'select',
    relatedEditableProperties: relatedEditableProperty,
    relatedCSSProperties: relatedCssProperty,
    pffSettings: prx.commonproperties.pffSettingsTextFontStyle,
    value: function value(item, name, index) {
      var propName = data.propName;
      var useAsDynProp = data.useAsDynProp;
      relatedEditableProperty = $.isArray(relatedEditableProperty) ? relatedEditableProperty : [relatedEditableProperty];

      for (var i = 0; i < relatedEditableProperty.length; i++) {
        if (useAsDynProp) {
          if (typeof index != 'undefined') {
            var path = relatedEditableProperty[i].split(/[.]+/);
            return typeof item[path[0]][index][propName] == 'undefined' ? prx.components[item.type][path[0]][0][propName] : item[path[0]][index][propName];
          }
        } else {
          return typeof item[propName] == 'undefined' ? prx.components[item.type][propName] : item[propName];
        }
      }
    },
    values: function values() {
      return prx.comps.fontStyles;
    },
    hiddenByDefault: function hiddenByDefault(item, name, index) {
      return false;
    },
    changeProperty: {
      caption: data.caption,
      selector: '.changeProperty-' + data.caption,
      property: 'font-style',
      transitionable: false,
      changeFunction: function changeFunction(item, containerid, duration, easing, dynPropI) {
        prx.componentsHelper.changeFunctionForTextFontStyleProperties(item, containerid, dynPropI, data.propName);
      }
    }
  };

  if (typeof data.onChange != 'undefined') {
    commonProperties['onChange'] = data.onChange;
  }

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  } else if (typeof hiddenByDefault == 'function') {
    commonProperties['hiddenByDefault'] = hiddenByDefault;
  }

  return commonProperties;
};

prx.commonproperties.textAlignRichText = function (relatedCssProperty, relatedEditableProperty, hiddenByDefault) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.textAlign);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  }

  return commonProperties;
};

prx.commonproperties.textColorRichText = function (relatedCssProperty, relatedEditableProperty, label) {
  var commonProperties = prx.commonproperties.textColor(label);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;
  return commonProperties;
};

prx.commonproperties.materialTextColorRichText = function (relatedCssProperty, relatedEditableProperty, label, hiddenByDefault) {
  var commonProperties = prx.commonproperties.materialTextColor(label);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;

  if (hiddenByDefault !== undefined && hiddenByDefault.eq !== undefined && hiddenByDefault.condition !== undefined) {
    commonProperties['hiddenByDefault'] = function (_item) {
      return hiddenByDefault.eq == 'eq' ? _item.name == hiddenByDefault.condition : _item.name !== hiddenByDefault.condition;
    };
  }

  return commonProperties;
};

prx.commonproperties.textSizeSubtitleRichText = function (relatedCssProperty, relatedEditableProperty) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.textSizeSubtitle);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;
  return commonProperties;
};

prx.commonproperties.textFontSubtitleRichText = function (relatedCssProperty, relatedEditableProperty) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.textFontSubtitle);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;
  return commonProperties;
};

prx.commonproperties.textColorSubtitleRichText = function (relatedCssProperty, relatedEditableProperty) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.textColorSubtitle);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;
  return commonProperties;
};

prx.commonproperties.textAlignSubtitleRichText = function (relatedCssProperty, relatedEditableProperty) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.textAlignSubtitle);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;
  return commonProperties;
};

prx.commonproperties.metroTextColorRichText = function (relatedCssProperty, relatedEditableProperty) {
  var commonProperties = prx.componentsHelper.cloneobject(prx.commonproperties.metroTextColor);
  commonProperties['relatedEditableProperties'] = relatedEditableProperty;
  commonProperties['relatedCSSProperties'] = relatedCssProperty;
  return commonProperties;
};
/**Rich Text END**/

/** Font family related BEGIN **/


prx.commonproperties.textFontSubtitle = {
  caption: {
    label: 'Font family',
    "class": 'text-properties-label text-fontfamily-label'
  },
  name: 'subtitleFont',
  proptype: 'font-family-2-subtitle',
  type: 'select',
  value: function value(item, name) {
    return typeof item.subtitleFont == 'undefined' ? '' : item.subtitleFont;
  },
  values: function values() {
    return prx.comps.fonts;
  },
  changeProperty: {
    caption: 'Subtitle font',
    selector: '.changeProperty-subtitleFont',
    property: 'font-family',
    transitionable: false
  }
};
prx.commonproperties.textFontStyleSubtitle = {
  caption: {
    label: 'Font style',
    "class": 'text-properties-label text-fontstyle-label'
  },
  name: 'subtitleFontStyle',
  proptype: 'font-style-subtitle',
  type: 'select',
  pffSettings: prx.commonproperties.pffSettingsTextFontStyle,
  value: function value(item, name) {
    return typeof item.textFontStyle == 'undefined' ? '' : item.subtitleFontStyle;
  },
  values: function values() {
    return prx.comps.fontStyles;
  },
  hiddenByDefault: function hiddenByDefault(item) {
    return false;
  },
  // TODO: CHANGE
  changeProperty: {
    caption: 'Subtitle Style',
    selector: '.changeProperty-subtitleFontStyle',
    property: 'font-weight',
    transitionable: false
  }
};
prx.commonproperties.textFontButton = {
  caption: {
    label: 'Font family',
    "class": 'text-properties-label text-fontfamily-label'
  },
  name: 'textFont',
  proptype: 'font-family-button',
  type: 'select',
  value: function value(item, name, index) {
    return typeof item.buttons[index].textFont == 'undefined' ? '' : item.buttons[index].textFont;
  },
  values: function values() {
    return prx.comps.fonts;
  },
  changeProperty: {
    caption: 'Text font',
    selector: '.changeProperty-textFontButton',
    property: 'font-family',
    transitionable: false
  }
};
prx.commonproperties.textFontLabel = {
  caption: {
    label: 'Font family',
    "class": 'text-properties-label text-fontfamily-label'
  },
  name: 'labelFont',
  proptype: 'font-family-3-label',
  type: 'select',
  value: function value(item, name) {
    return typeof item.labelFont == 'undefined' ? '' : item.labelFont;
  },
  values: function values() {
    return prx.comps.fonts;
  },
  changeProperty: {
    caption: 'Label font',
    selector: '.changeProperty-labelFont',
    property: 'font-family',
    transitionable: false
  }
};
prx.commonproperties.textFontStyleLabel = {
  caption: {
    label: 'Font style',
    "class": 'text-properties-label text-fontstyle-label'
  },
  name: 'labelFontStyle',
  proptype: 'font-style-3-label',
  type: 'select',
  value: function value(item, name) {
    return typeof item.labelFontStyle == 'undefined' ? '' : item.labelFontStyle;
  },
  values: function values() {
    return prx.comps.fontStyles;
  },
  changeProperty: {
    caption: 'Label font style',
    selector: '.changeProperty-labelFontStyle',
    property: 'font-style',
    transitionable: false
  }
};
prx.commonproperties.textPropertiesLabel = {
  caption: {
    label: 'Underline',
    "class": 'colorpicker-wrapper text-underline-label'
  },
  name: 'labelProperties',
  proptype: 'properties-3-label',
  type: 'checkbox',
  pffSettings: prx.commonproperties.pffSettingsTextProperties,
  value: function value(item, name) {
    if (typeof item.labelProperties == "undefined") {
      item.labelProperties = [];
    }

    return item.labelProperties;
  },
  values: [{
    value: 'underline',
    displayValue: '',
    icon: 'text-underline'
  }],
  changeProperty: {
    caption: 'Label underline',
    selector: '.changeProperty-labelProperties',
    property: 'label-properties',
    transitionable: false
  }
};
/** Font family related END **/

/** Text Size related BEGIN **/

prx.commonproperties.textSize = {
  caption: false,
  name: 'textSize',
  proptype: 'font-size',
  type: 'combo-select',
  value: function value(item, name) {
    return typeof item.textSize == 'undefined' ? '' : item.textSize;
  },
  values: prx.comps.textsize,
  changeProperty: {
    caption: 'Text size',
    selector: '.changeProperty-textSize',
    property: 'font-size',
    transitionable: true
  }
};
prx.commonproperties.textSizeButton = {
  caption: false,
  name: 'textSize',
  proptype: 'font-size',
  type: 'combo-select',
  value: function value(item, name, index) {
    return typeof item.buttons[index].textSize == 'undefined' ? '' : item.buttons[index].textSize;
  },
  values: prx.comps.textsize,
  changeProperty: {
    caption: 'Text size',
    selector: '.changeProperty-textSize',
    property: 'font-size',
    transitionable: true
  }
};
prx.commonproperties.textSizeActive = {
  caption: false,
  name: 'textSizeActive',
  proptype: 'font-size-2-active',
  type: 'combo-select',
  value: function value(item, name) {
    return typeof item.textSizeActive == 'undefined' ? '' : item.textSizeActive;
  },
  values: prx.comps.textsize,
  changeProperty: {
    caption: 'Active Text size',
    selector: '.changeProperty-textSizeActive',
    property: 'font-size',
    transitionable: true
  }
};
prx.commonproperties.textSizeSubtitle = {
  caption: false,
  name: 'subtitleSize',
  proptype: 'font-size-3-subtitle',
  type: 'combo-select',
  value: function value(item, name) {
    return typeof item.subtitleSize == 'undefined' ? '' : item.subtitleSize;
  },
  values: prx.comps.textsize,
  changeProperty: {
    caption: 'Subtitle size',
    selector: '.changeProperty-subtitleSize',
    property: 'font-size',
    transitionable: true
  }
};
prx.commonproperties.textSizeLabel = {
  caption: false,
  name: 'labelSize',
  proptype: 'font-size-4-label',
  type: 'combo-select',
  value: function value(item, name) {
    return typeof item.labelSize == 'undefined' ? '' : item.labelSize;
  },
  values: prx.comps.textsize,
  changeProperty: {
    caption: 'Label size',
    selector: '.changeProperty-labelSize',
    property: 'font-size',
    transitionable: true
  }
};
/** Text Size related END **/

/** Color related BEGIN **/

prx.commonproperties.textColor = function (_label) {
  if (typeof _label == 'undefined') {
    _label = 'Color';
  }

  return {
    caption: {
      label: _label,
      "class": 'text-properties-label text-color-label'
    },
    name: 'textColor',
    proptype: 'font-color',
    type: 'solid-colorpicker',
    pffSettings: prx.commonproperties.pffSettingsColor,
    value: function value(item, name) {
      return typeof item.textColor == 'undefined' ? '' : item.textColor;
    },
    liveUpdate: 'color',
    changeProperty: {
      caption: 'Text color',
      selector: '.changeProperty-textColor',
      property: 'color',
      transitionable: true
    }
  };
};

prx.commonproperties.textColorActive = {
  caption: 'Active',
  name: 'textColorActive',
  proptype: 'font-color-2-active',
  type: 'solid-colorpicker',
  pffSettings: prx.commonproperties.pffSettingsColor,
  value: function value(item, name) {
    return typeof item.textColorActive == 'undefined' ? '' : item.textColorActive;
  },
  liveUpdate: 'color',
  changeProperty: {
    caption: 'Active Text color',
    selector: '.changeProperty-textColorActive',
    property: 'color',
    transitionable: true
  }
};
prx.commonproperties.textColorSubtitle = {
  caption: {
    label: 'Color',
    "class": 'text-properties-label text-color-label'
  },
  name: 'subtitleColor',
  proptype: 'font-color-3-subtitle',
  type: 'solid-colorpicker',
  pffSettings: prx.commonproperties.pffSettingsColor,
  value: function value(item, name) {
    return typeof item.subtitleColor == 'undefined' ? '' : item.subtitleColor;
  },
  liveUpdate: 'color',
  changeProperty: {
    caption: 'Subtitle color',
    selector: '.changeProperty-subtitleColor',
    property: 'color',
    transitionable: true
  }
};
prx.commonproperties.textColorLabel = {
  caption: {
    label: 'Color',
    "class": 'text-properties-label text-color-label'
  },
  name: 'labelColor',
  proptype: 'font-color-4-label',
  type: 'solid-colorpicker',
  pffSettings: prx.commonproperties.pffSettingsColor,
  value: function value(item, name) {
    return typeof item.labelColor == 'undefined' ? '' : item.labelColor;
  },
  liveUpdate: 'color',
  changeProperty: {
    caption: 'Label color',
    selector: '.changeProperty-labelColor',
    property: 'color',
    transitionable: true
  }
};
prx.commonproperties.placeholderColor = {
  caption: 'Placeholder Color',
  name: 'placeholderColor',
  proptype: 'placeholder-color',
  type: 'solid-colorpicker',
  value: function value(item, name) {
    if (typeof item.placeholderColor == 'undefined') {
      return '999999';
    }

    return item.placeholderColor;
  },
  liveUpdate: 'color',
  changeProperty: {
    caption: 'Placeholder color',
    selector: '.changeProperty-placeholderColor',
    property: 'color',
    transitionable: true
  }
};
/** Color related END **/

prx.commonproperties.textProperties = {
  caption: {
    label: 'Underline',
    "class": 'colorpicker-wrapper text-underline-label'
  },
  name: 'textProperties',
  proptype: 'text-properties',
  type: 'checkbox',
  pffSettings: prx.commonproperties.pffSettingsTextProperties,
  value: function value(item, name) {
    if (typeof item.textProperties == "undefined") {
      item.textProperties = [];
    }

    return item.textProperties;
  },
  values: [{
    value: 'underline',
    displayValue: '',
    icon: 'text-underline'
  }],
  changeProperty: {
    caption: 'Underline',
    rerender: true
  }
};

prx.commonproperties.getFontStyleValueCombined = function (textPropertiesValue, fontStylePropertiesValue) {
  var currentFontWeighValue;
  var currentFontStyleValue;
  var newValue = [];
  fontStylePropertiesValue = $.isArray(fontStylePropertiesValue) ? fontStylePropertiesValue : [fontStylePropertiesValue];

  for (var i = 0; i < fontStylePropertiesValue.length; i++) {
    if (fontStylePropertiesValue[i] !== '') {
      fontStylePropertiesValue[i] = fontStylePropertiesValue[i].toString();

      if (fontStylePropertiesValue[i].match(/[a-zA-Z]+/g) !== null) {
        currentFontStyleValue = fontStylePropertiesValue[i].match(/[a-zA-Z]+/g)[0];
      }

      if (fontStylePropertiesValue[i].match(/\d+/g) !== null) {
        currentFontWeighValue = fontStylePropertiesValue[i].match(/\d+/g)[0];
      }
    } else {
      currentFontStyleValue = '';
      currentFontWeighValue = '';
    }
  }

  if (typeof currentFontWeighValue != 'undefined' && currentFontWeighValue >= 700) {
    newValue.push('bold');
  }

  if (typeof currentFontStyleValue != 'undefined' && currentFontStyleValue.indexOf('italic') > -1) {
    newValue.push('italic');
  }

  return newValue.concat(textPropertiesValue);
};

prx.commonproperties.textAlign = {
  caption: {
    label: 'Alignment',
    "class": 'text-properties-label text-alignment-label'
  },
  proptype: 'text-align',
  name: 'textAlign',
  type: 'radio',
  pffSettings: prx.commonproperties.pffSettingsTextAlignment,
  value: function value(item, name) {
    return typeof item.textAlign == 'undefined' ? '' : item.textAlign;
  },
  values: [{
    value: 'left',
    displayValue: '',
    icon: 'align-left'
  }, {
    value: 'center',
    displayValue: '',
    icon: 'align-center'
  }, {
    value: 'right',
    displayValue: '',
    icon: 'align-right'
  }, {
    value: 'justify',
    displayValue: '',
    icon: 'align-justify'
  }],
  changeProperty: {
    caption: 'Text align',
    selector: '.changeProperty-textAlign',
    property: 'text-align',
    transitionable: false
  }
};
prx.commonproperties.textAlignSubtitle = {
  caption: {
    label: 'Alignment',
    "class": 'text-properties-label text-alignment-label'
  },
  name: 'subtitleAlign',
  proptype: 'text-align-2-subtitle',
  type: 'radio',
  pffSettings: prx.commonproperties.pffSettingsTextAlignment,
  value: function value(item, name) {
    return typeof item.subtitleAlign == 'undefined' ? '' : item.subtitleAlign;
  },
  values: [{
    value: 'left',
    displayValue: '',
    icon: 'align-left'
  }, {
    value: 'center',
    displayValue: '',
    icon: 'align-center'
  }, {
    value: 'right',
    displayValue: '',
    icon: 'align-right'
  }],
  changeProperty: {
    caption: 'Subtitle Text align',
    selector: '.changeProperty-subtitleAlign',
    property: 'text-align',
    transitionable: false
  }
};
prx.commonproperties.textAlignLabel = {
  caption: {
    label: 'Alignment',
    "class": 'text-properties-label text-alignment-label'
  },
  name: 'labelAlign',
  proptype: 'text-align-3-label',
  type: 'radio',
  pffSettings: prx.commonproperties.pffSettingsTextAlignment,
  value: function value(item, name) {
    return typeof item.labelAlign == 'undefined' ? '' : item.labelAlign;
  },
  values: [{
    value: 'left',
    displayValue: '',
    icon: 'align-left'
  }, {
    value: 'center',
    displayValue: '',
    icon: 'align-center'
  }, {
    value: 'right',
    displayValue: '',
    icon: 'align-right'
  }],
  changeProperty: {
    caption: 'Label Text align',
    selector: '.changeProperty-labelAlign',
    property: 'text-align',
    transitionable: false
  }
};
prx.commonproperties.labelInput = {
  caption: false,
  name: 'label',
  type: 'input',
  value: function value(item, name) {
    return item.label;
  },
  changeProperty: {
    caption: 'Label text',
    rerender: true
  }
};
prx.commonproperties.placeholderInput = {
  caption: 'Placeholder text',
  name: 'placeholder',
  proptype: 'placeholder-input',
  type: 'input',
  value: function value(item, name) {
    return typeof item.placeholder == 'undefined' ? '' : item.placeholder;
  },
  changeProperty: {
    caption: 'Placeholder text',
    rerender: true
  }
};
prx.commonproperties.radioButtonsGroupNameInput = {
  caption: 'Belongs to group',
  help: 'Add radio buttons or On/off switches to the same group within the same screen/container, to have only one of them active at a time.',
  name: 'radioButtonsGroupName',
  proptype: 'radio-group-name',
  type: 'custom-select',
  pffSettings: {
    groupClass: 'combo-select-input',
    inputAttr: 'getproptype="radio-group-name"'
  },
  customDefault: function customDefault() {
    return prx.stc.helper.getNextAvailableNameForRadioButtonGroups();
  },
  //get next available group name based on what exists on container's or page items
  onChange: function onChange(item) {
    if (typeof item['radioButtonsGroupName'] == 'undefined') {
      item['radioButtonsGroupName'] = '';
    }

    if (prx.editor) {
      var newValue = $('input#p-' + item.id + '-radioButtonsGroupName').length > 0 ? $('input#p-' + item.id + '-radioButtonsGroupName').val() : $('input#p-all-selected-radioButtonsGroupName').val();
      newValue = prx.componentsHelper.getProp(newValue, 'radio-group-name');

      if (newValue == 'custom-select-custom') {
        return;
      } else if (newValue == '') {
        item['radioButtonsGroupName'] = '';
        rerenderItem(newValue, item);
      } else {
        item['radioButtonsGroupName'] = newValue;
        rerenderItem(newValue, item);
      }
    }

    return item;

    function rerenderItem(_newValue, item) {
      if (item.active) {
        prxy.items.filter(function (_item) {
          return _item.id != item.id && prx.comps.radioButtonsSupportingGrouping.indexOf(_item.type) > -1 && typeof _item.radioButtonsGroupName != 'undefined' && typeof newValue != 'undefined' && newValue == _item.radioButtonsGroupName;
        }).map(function (__item) {
          __item.active = false;
          prx.items.rerender(__item);
          prx.items.bindItemEvents(__item);
          prx.items.helper.refreshHtmlComponent(__item);
          return __item;
        });
      }
    }
  },
  value: function value(item, name) {
    return typeof item.radioButtonsGroupName == 'undefined' ? '' : item.radioButtonsGroupName;
  },
  values: function values() {
    return [{
      value: '',
      displayValue: 'No group'
    }].concat(prx.stc.helper.getAvailableRadioButtonGroupsOnCanvasList()).concat([{
      value: 'custom-select-custom',
      displayValue: 'New group...'
    }]);
  },
  changeProperty: {
    caption: 'Belongs to group',
    rerender: true
  }
};

prx.commonproperties.radioButtonsActiveStatusOnChange = function (item, name) {
  console.log('change');

  if (typeof item['radioButtonsGroupName'] == 'undefined' || typeof item['radioButtonsGroupName'] != 'undefined' && item['radioButtonsGroupName'].length == 0) {
    return;
  }

  var radioButtonGroupName = item['radioButtonsGroupName'];
  if (radioButtonGroupName.trim().length == 0) return item;

  if (prx.editor) {
    if (item.active) {
      prxy.items.filter(function (_item) {
        return _item.id != item.id && prx.comps.radioButtonsSupportingGrouping.indexOf(_item.type) > -1 && typeof _item.radioButtonsGroupName != 'undefined' && typeof radioButtonGroupName != 'undefined' && radioButtonGroupName == _item.radioButtonsGroupName;
      }).map(function (__item) {
        __item.active = false;
        prx.items.rerender(__item);
        prx.items.bindItemEvents(__item);
        prx.items.helper.refreshHtmlComponent(__item);
        return __item;
      });
    }
  }
};

prx.commonproperties.iconSize = {
  caption: 'Size',
  name: 'iconSize',
  proptype: 'icon-size',
  type: 'select',
  value: function value(item, name) {
    return typeof item.iconSize == 'undefined' ? '' : item.iconSize;
  },
  values: [{
    value: '1',
    displayValue: 'Very small'
  }, {
    value: '2',
    displayValue: 'Small'
  }, {
    value: '3',
    displayValue: 'Normal'
  }, {
    value: '4',
    displayValue: 'Large'
  }, {
    value: '5',
    displayValue: 'Full'
  }],
  changeProperty: {
    caption: 'Icon size',
    rerender: true,
    changeable: false
  }
};
prx.commonproperties.thumbSize = {
  caption: 'Size',
  name: 'thumbSize',
  proptype: 'thumb-size',
  type: 'select',
  value: function value(item, name) {
    return typeof item.thumbSize == 'undefined' ? '' : item.thumbSize;
  },
  values: [{
    value: '1',
    displayValue: 'Very small'
  }, {
    value: '2',
    displayValue: 'Small'
  }, {
    value: '3',
    displayValue: 'Normal'
  }, {
    value: '4',
    displayValue: 'Large'
  }, {
    value: '5',
    displayValue: 'Full'
  }],
  changeProperty: {
    caption: 'Thumbnail size',
    rerender: true,
    changeable: false
  }
};
prx.commonproperties.iconActiveMask = {
  caption: 'Active',
  name: 'iconColorActive',
  proptype: 'icon-color-active',
  type: 'solid-colorpicker',
  value: function value(item, name) {
    return typeof item.iconColorActive == 'undefined' ? '' : item.iconColorActive;
  },
  liveUpdate: 'background-color',
  changeProperty: {
    caption: 'Active icon color',
    rerender: true
  }
};
prx.commonproperties.iconSource = {
  caption: false,
  name: 'imgSrc',
  proptype: 'icon-source',
  type: 'combo-asset',
  displayValue: function displayValue(item, name) {
    if (item.imgSrc.fileId == '') {
      return 'No asset selected.';
    }

    return item.imgSrc.name;
  },
  value: function value(item, name) {
    return JSON.stringify({
      allow: 'image',
      asset: item.imgSrc
    });
  },
  changeProperty: {
    caption: 'Icon',
    rerender: true
  }
};
prx.commonproperties.iconSourceSecondary = {
  caption: false,
  name: 'imgSrc2',
  proptype: 'icon-source-2-secondary',
  type: 'combo-asset',
  displayValue: function displayValue(item, name) {
    if (item.imgSrc2.fileId == '') {
      return 'No asset selected.';
    }

    return item.imgSrc2.name;
  },
  value: function value(item, name) {
    return JSON.stringify({
      allow: 'image',
      asset: item.imgSrc2
    });
  },
  changeProperty: {
    caption: 'Secondary Icon',
    rerender: true
  }
};
prx.commonproperties.iconSourceTabs = {
  caption: false,
  name: 'imgSrc',
  proptype: 'icon-source',
  type: 'combo-asset',
  displayValue: function displayValue(item, name, index) {
    if (item.tabs[index].imgSrc.fileId == '') {
      return 'No icon selected';
    }

    return item.tabs[index].imgSrc.name;
  },
  value: function value(item, name, index) {
    return JSON.stringify({
      allow: 'image',
      asset: item.tabs[index].imgSrc
    });
  },
  changeProperty: {
    caption: 'Icon',
    rerender: true
  }
};
prx.commonproperties.iconSourceSecondaryTabs = {
  caption: false,
  name: 'imgSrc2',
  proptype: 'icon-source-2-secondary',
  type: 'combo-asset',
  displayValue: function displayValue(item, name) {
    if (item.tabs[index].imgSrc2.fileId == '') {
      return 'No asset selected.';
    }

    return item.tabs[index].imgSrc2.name;
  },
  value: function value(item, name) {
    return JSON.stringify({
      allow: 'image',
      asset: item.tabs[index].imgSrc2
    });
  },
  changeProperty: {
    caption: 'Secondary Icon',
    rerender: true
  }
};
prx.commonproperties.iconSourceList = {
  caption: false,
  name: 'imgSrc',
  proptype: 'icon-source',
  type: 'combo-asset',
  displayValue: function displayValue(item, name, index) {
    if (item.listitems[index].imgSrc.fileId == '') {
      return 'No icon selected';
    }

    return item.listitems[index].imgSrc.name;
  },
  value: function value(item, name, index) {
    return JSON.stringify({
      allow: 'image',
      asset: item.listitems[index].imgSrc
    });
  },
  changeProperty: {
    caption: 'Icon',
    rerender: true
  }
};
prx.commonproperties.iconSourceSecondaryList = {
  caption: false,
  name: 'imgSrc2',
  proptype: 'icon-source-2-secondary',
  type: 'combo-asset',
  displayValue: function displayValue(item, name) {
    if (item.listitems[index].imgSrc2.fileId == '') {
      return 'No asset selected.';
    }

    return item.listitems[index].imgSrc2.name;
  },
  value: function value(item, name) {
    return JSON.stringify({
      allow: 'image',
      asset: item.listitems[index].imgSrc2
    });
  },
  changeProperty: {
    caption: 'Secondary Icon',
    rerender: true
  }
};
prx.commonproperties.thumbnailSource = {
  caption: false,
  name: 'thumbnail',
  proptype: 'thumbnail-source',
  type: 'combo-asset',
  displayValue: function displayValue(item, name, index) {
    if (typeof item.thumbnail == 'undefined' || item.thumbnail.fileId == '') {
      return 'No thumbnail selected';
    }

    return item.thumbnail.name;
  },
  value: function value(item, name, index) {
    return JSON.stringify({
      allow: 'image',
      asset: item.thumbnail
    });
  },
  changeProperty: {
    caption: 'Thumbnail',
    rerender: true
  }
};
prx.commonproperties.thumbnailSourceList = {
  caption: false,
  name: 'thumbnail',
  proptype: 'thumbnail-source-list',
  type: 'combo-asset',
  displayValue: function displayValue(item, name, index) {
    if (typeof item.listitems[index].thumbnail == 'undefined' || item.listitems[index].thumbnail.fileId == '') {
      return 'No thumbnail selected';
    }

    return item.listitems[index].thumbnail.name;
  },
  value: function value(item, name, index) {
    return JSON.stringify({
      allow: 'image',
      asset: item.listitems[index].thumbnail
    });
  },
  changeProperty: {
    caption: 'Thumbnail',
    rerender: true
  }
};
prx.tabbargradient = '-webkit-gradient(linear, 38% 0%, 60% 70%, from(#dde9f0), to(#3fc5f8), color-stop(.6,#79b2ec),color-stop(.7,#2e91e5))';

prx.componentsHelper.removeObjMembers = function (obj, toRemove) {
  var _len = toRemove.length;

  for (var i = 0; i < _len; i++) {
    delete obj[toRemove[i]];
  }

  return obj;
};

prx.componentsHelper.editProperty = function (props, prop, memberName, newValue) {
  if (typeof props[0].properties == 'undefined') {
    // properties
    var _len = props.length;

    for (var i = 0; i < _len; i++) {
      if (props[i].name == prop) {
        props[i][memberName] = newValue;
        return props;
      }
    }
  } else {
    // propertyGroups
    var _plen = props.length; // property groups len

    for (var i = 0; i < _plen; i++) {
      // loop property groups
      var _llen = props[i].properties.length; // property line len

      for (var j = 0; j < _llen; j++) {
        var _len = props[i].properties[j].length; // property len

        for (var k = 0; k < _len; k++) {
          if (props[i].properties[j][k].name == prop) {
            props[i].properties[j][k][memberName] = newValue;
            return props;
          }
        }
      }
    }
  }

  return props;
};

prx.componentsHelper.removeProperties = function (props, toRemove) {
  if (typeof props[0].properties == 'undefined') {
    // properties
    var _len = props.length;

    for (var i = 0; i < _len; i++) {
      if (toRemove.indexOf(props[i].name) != -1) {
        props.splice(i, 1);
        i--;
        _len--;
      }
    }
  } else {
    // propertyGroups
    var _plen = props.length; // property groups len

    for (var i = 0; i < _plen; i++) {
      // loop property groups
      var _llen = props[i].properties.length; // property line len

      for (var j = 0; j < _llen; j++) {
        var _len = props[i].properties[j].length; // property len

        for (var k = 0; k < _len; k++) {
          if (toRemove.indexOf(props[i].properties[j][k].name) != -1) {
            props[i].properties[j].splice(k, 1);
            k--;
            _len--;
          }
        }
      }
    }
  }

  return props;
};

prx.componentsHelper.removePropertySetting = function (props, property, settingToRemove) {
  var _plen = props.length; // property groups len

  for (var i = 0; i < _plen; i++) {
    // loop property groups
    var _llen = props[i].properties.length; // property line len

    for (var j = 0; j < _llen; j++) {
      var _len = props[i].properties[j].length; // property len

      for (var k = 0; k < _len; k++) {
        if (props[i].properties[j][k].name === property) {
          delete props[i].properties[j][k][settingToRemove];
        }
      }
    }
  }

  return props;
}; // ADAPTED FROM http://my.opera.com/GreyWyvern/blog/show.dml/1725165


prx.componentsHelper.cloneobject = function (obj) {
  var newObj = obj instanceof Array ? [] : {};

  for (i in obj) {
    if (i == 'clone') continue;

    if (obj[i] && _typeof(obj[i]) == 'object') {
      newObj[i] = prx.componentsHelper.cloneobject(obj[i]);
    } else newObj[i] = obj[i];
  }

  return newObj;
};

prx.componentsHelper.getRealDims = function (item, symbol) {
  var dims = {};
  dims.width = item.width;
  dims.height = item.height;

  if (prx.mask.isActive(item)) {
    dims = prx.mask.getInnerDimsObj(item);
  }

  if (typeof symbol == 'undefined') {
    if (dims.width == 'full') {
      dims.width = $('#dragarea').width();
    }

    if (item.wtype == 'variable') {
      dims.width = $('#dragarea').width() - dims.width;
    }

    if (dims.height == 'full') {
      dims.height = $('#dragarea').height();
    }

    if (item.htype == 'variable') {
      dims.height = $('#dragarea').height() - dims.height;
    }
  } else {
    var _symbolDims = symbol.dimensions;

    if (dims.width == 'full') {
      dims.width = _symbolDims[0];
    }

    if (item.wtype == 'variable') {
      dims.width = _symbolDims[0] - dims.width;
    }

    if (dims.height == 'full') {
      dims.height = _symbolDims[1];
    }

    if (item.htype == 'variable') {
      dims.height = _symbolDims[1] - dims.height;
    }
  }

  return dims;
};

prx.componentsHelper.getRealPos = function (item, symbol) {
  var pos = {};
  pos.left = item.left;
  pos.top = item.top;

  if (prx.mask.isActive(item)) {
    pos = prx.mask.getInnerAbsolutePositionObj(item);
  }

  if (typeof symbol == 'undefined') {
    if (item.hpos == 'right') {
      pos.left = $('#dragarea').width() - item.width - item.left;
    } else if (item.hpos == 'center') {
      pos.left = ($('#dragarea').width() - item.width) / 2;
    }

    if (item.vpos == 'bottom') {
      pos.top = $('#dragarea').height() - item.height - item.top;
    } else if (item.vpos == 'middle') {
      pos.top = ($('#dragarea').height() - item.height) / 2;
    }
  } else {// ?
  }

  return pos;
};

prx.componentsHelper.getAssetUrl = function (asset, thumbnail, embedPrgss) {
  if (!thumbnail) thumbnail = false;
  if (thumbnail !== true) thumbnail = false;

  if (typeof asset == 'undefined') {
    return '';
  } // for player no longer has prx.projectid and prx.account


  prx.projectid = prx.projectid || (prx.spaces ? prx.projectsettings.s3b : prx.projectsettings.id);
  prx.account = prx.account || prx.projectsettings.account;
  if (prx.urlCache !== undefined && prx.urlCache.urls !== undefined && prx.urlCache.urls[asset.fileId]) return prx.urlCache.urls[asset.fileId];
  var assetType = asset.assetType;
  var assetColor = asset.color;
  var url; // = asset.url;
  // assets to hit

  if (typeof prx.dropboxfs != 'undefined' && prx.dropboxfs) {
    var assetsurl = 'assetsd';
    url = asset.fileId;
  } else {
    var assetsurl = 'assets';
    url = asset.url;
  } // not used.


  if (assetType == 'local') {
    return url;
  } //static and gallery


  if (asset.bucketsource == 'static') {
    if (typeof asset.targetSrc != 'undefined') {
      return prx.url.staticassets + '/' + asset.targetSrc;
    }

    return prx.url.staticassets + '/assets/' + asset.url;
  }

  if (typeof prx.spaces === 'undefined') prx.spaces = false; //spaces editor assets

  if (prx.spaces == true) assetType = 'spaces/' + assetType;

  if (assetType == 'project' || assetType == 'spaces/project') {
    url = prx.utils.getAssetsServer(asset.fileId) + '/' + assetType + '/' + prx.projectid + '/' + url;
  } else {
    url = prx.utils.getAssetsServer(asset.fileId) + '/' + assetType + '/' + url;
  }

  if (typeof assetColor !== 'undefined') {
    url += '/' + assetColor.toLowerCase();
  }

  if (typeof prx.s3Links != 'undefined') {
    if (typeof prx.dropboxfs != 'undefined' && prx.dropboxfs) {
      if (typeof prx.s3Links[asset.fileId] != 'undefined') {
        if (prx.s3Links[asset.fileId].indexOf('?') > -1) {
          return prx.s3Links[asset.fileId] + '&v=' + prx.mpasset._imgs_version;
        }

        return prx.s3Links[asset.fileId] + '?v=' + prx.mpasset._imgs_version;
      }
    } else {
      if (typeof prx.s3Links[asset.assetType + '_' + asset.url] != 'undefined') {
        if (prx.s3Links[asset.assetType + '_' + asset.url].indexOf('?') > -1) {
          return prx.s3Links[asset.assetType + '_' + asset.url] + '&v=' + prx.mpasset._imgs_version;
        }

        return prx.s3Links[asset.assetType + '_' + asset.url] + '?v=' + prx.mpasset._imgs_version;
      }
    }
  } //db url var for database use


  if (typeof prx.dropboxfs != 'undefined' && prx.dropboxfs) {
    url += '?db=' + 1;
  } else {
    url += '?db=' + 0;
  } //account subdomain url variable


  url += '&ac=' + prx.account;

  if (asset.isFont === true) {
    url += "&isfont=true&family=".concat(asset.familyId);
    var access_token = document.cookie.split('; ').reduce(function (r, v) {
      var parts = v.split('=');
      return parts[0] === 'access_token' ? decodeURIComponent(parts[1]) : r;
    }, '');

    if (prx.prgss && prx.prgss.length > 0) {
      url += "&prgss=".concat(prx.prgss);
    } else if (access_token && access_token.length > 0) {
      url += "&access_token=".concat(access_token);
    }
  }

  var timestamp = prx.urlCache !== undefined && prx.urlCache.timestamp !== undefined && prx.urlCache.timestamp[asset.fileId] ? prx.urlCache.timestamp[asset.fileId] : false;

  if (asset.isFont === true) {
    url += '&v=' + prx.fonts.custom_fonts_version;
  } else if (timestamp) {
    url += '&ts=' + timestamp;
  } else {
    url += '&v=' + prx.mpasset._imgs_version;
  }

  if (thumbnail) {
    url += '&p=2';
  }

  if (embedPrgss) {
    url += '&prgss=' + prx.prgss;
  }

  return url;
};

prx.componentsHelper.getFontFamilyFromCSS = function (fontfamilyCSS) {
  if (typeof fontfamilyCSS == "undefined") {
    return '';
  } else {
    fontfamilyCSS = fontfamilyCSS.replace(/"/gi, '').replace(/'/gi, '');
    ;
  }

  if (fontfamilyCSS.indexOf('HelveticaNeue') == 0 || fontfamilyCSS.indexOf('Helvetica Neue') == 0) {
    return 'Helvetica Neue';
  } else if (fontfamilyCSS.indexOf('Comic Sans') == 0 || fontfamilyCSS.indexOf("'Comic Sans'") == 0) {
    return 'Comic Sans MS';
  } else if (fontfamilyCSS.indexOf('SFProDisplay-') == 0 || fontfamilyCSS.indexOf('SFUIDisplay-') == 0) {
    return 'San Francisco Pro Display';
  } else if (fontfamilyCSS.indexOf('SFProText') == 0 || fontfamilyCSS.indexOf('SFUIText') == 0) {
    return 'San Francisco Pro Text';
  } else if (fontfamilyCSS.indexOf('SFCompactDisplay-') == 0 || fontfamilyCSS.indexOf('SFCompactDisplay') == 0) {
    return 'San Francisco Compact Display';
  } else if (fontfamilyCSS.indexOf('SFCompactText-') == 0 || fontfamilyCSS.indexOf('SFCompactText-') == 0) {
    return 'San Francisco Compact Text';
  } else if (fontfamilyCSS.indexOf('Arial,') == 0) {
    return 'Arial';
  } else if (fontfamilyCSS.indexOf('Courier New') == 0) {
    return 'Courier New';
  } else if (fontfamilyCSS.indexOf('Helvetica,') == 0) {
    return 'Helvetica';
  } else if (fontfamilyCSS.indexOf('Impact') == 0) {
    return 'Impact';
  } else if (fontfamilyCSS.indexOf('Courier New') == 0) {
    return 'Courier New';
  } else if (fontfamilyCSS.indexOf('Roboto') == 0) {
    return 'Roboto';
  } else if (fontfamilyCSS.indexOf('Georgia') == 0) {
    return 'Georgia';
  } else if (fontfamilyCSS.indexOf('Tahoma') == 0) {
    return 'Tahoma';
  } else if (fontfamilyCSS.indexOf('Times New Roman') == 0) {
    return 'Times New Roman';
  } else if (fontfamilyCSS.indexOf('Trebuchet MS') == 0) {
    return 'Trebuchet MS';
  } else if (fontfamilyCSS.indexOf('Verdana') == 0) {
    return 'Verdana';
  } else if (fontfamilyCSS.indexOf('Segoe UI') == 0) {
    return 'Segoe UI';
  } else if (fontfamilyCSS.indexOf('Arial Black') == 0) {
    return 'Arial Black';
  } else {
    // fallback font looking for ,Arial at the end of font fam. a bit dangerous but fallback is an issue
    var lastFontFamilyString = fontfamilyCSS.match(/(\s*,)\s*(\w+)$/gi);

    if (lastFontFamilyString != null && $.isArray(lastFontFamilyString) && lastFontFamilyString.length > 0 && lastFontFamilyString[0].replace(/\s+/g, '').replace(',', '') == prx.comps.fallbackFont) {
      return fontfamilyCSS.replace(/(\s*,)\s*(\w+)$/gi, '');
    } else {
      return fontfamilyCSS;
    }
  }
};

prx.componentsHelper.getFontCssFromFontFamily = function (fontfamily) {
  if (typeof fontfamily == "undefined") {
    return "";
  }

  var containsFontStyle = fontfamily.split(/[|]+/).length > 1 ? true : false;

  if (containsFontStyle) {
    var fontStyleFullValue = fontfamily.split(/[|]+/)[1];

    if (fontStyleFullValue.match(/^([0-9]+)(.*)$/i) != null && fontStyleFullValue.match(/^([0-9]+)(.*)$/i).length > 0) {
      var fontWeight = fontStyleFullValue.match(/^([0-9]+)(.*)$/i)[1];
    } else {
      var fontWeight = '400';
    }

    fontfamily = fontfamily.split(/[|]+/)[0];
  } else {
    fontWeight = '400';
  } // firefox needs font-weight and also "Helvetica Neue" which wasn't included in the original font definition
  //switch (fontfamily) {


  if (fontfamily == 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif') {
    switch (fontWeight) {
      case '300':
        return 'font-family: HelveticaNeue-Light, HelveticaNeue, Helvetica Neue, Helvetica Neue LT Std, Helvetica, Verdana, Arial, sans-serif;';
        break;

      case '400':
        return 'font-family: Helvetica Neue, Helvetica Neue LT Std, Helvetica, Verdana, Arial, sans-serif;';
        break;

      case '500':
        return 'font-family: HelveticaNeue-Medium, HelveticaNeue, Helvetica Neue, Helvetica Neue LT Std, Helvetica, Verdana, Arial, sans-serif;';
        break;

      case '700':
        return 'font-family: HelveticaNeue-Bold, HelveticaNeue, Helvetica Neue, Helvetica Neue LT Std, Helvetica, Verdana, Arial, sans-serif;';
        break;

      default:
        return 'font-family: Helvetica Neue, Helvetica Neue LT Std, Helvetica, Verdana, Arial, sans-serif;';
        break;
    }

    return 'font-family: Helvetica Neue, Helvetica Neue LT Std, Helvetica, Verdana, Arial, sans-serif;';
  } else if (fontfamily == 'Comic Sans MS,cursive') {
    return "font-family: 'Comic Sans', 'Comic Sans MS', 'Chalkboard', 'ChalkboardSE-Regular', 'Marker Felt', 'Purisa', 'URW Chancery L', cursive;";
  } else if (fontfamily == 'San Francisco Pro Display' || fontfamily == 'San Francisco UI Display') {
    switch (fontWeight) {
      case '100':
        return "font-family: SFProDisplay-Thin, SFUIDisplay-Thin, SanFranciscoDisplay-Thin, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '200':
        return "font-family: SFProDisplay-Ultralight, SFUIDisplay-Ultralight, SanFranciscoDisplay-Ultralight, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '300':
        return "font-family: SFProDisplay-Light, SFUIDisplay-Light, SanFranciscoDisplay-Light, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '400':
        return "font-family: SFProDisplay-Regular, SFUIDisplay-Regular, SanFranciscoDisplay-Regular, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '500':
        return "font-family: SFProDisplay-Medium, SFUIDisplay-Medium, SanFranciscoDisplay-Medium, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '600':
        return "font-family: SFProDisplay-SemiBold, SFUIDisplay-SemiBold, SanFranciscoDisplay-SemiBold, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '700':
        return "font-family: SFProDisplay-Bold, SFUIDisplay-Bold, SanFranciscoDisplay-Bold, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '800':
        return "font-family: SFProDisplay-Heavy, SFUIDisplay-Heavy, SanFranciscoDisplay-Heavy, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '900':
        return "font-family: SFProDisplay-Black, SFUIDisplay-Black, SanFranciscoDisplay-Black, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      default:
        return "font-family: SFProDisplay-Regular, SFUIDisplay-Regular, SanFranciscoDisplay-Regular, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;
    }
  } else if (fontfamily == 'San Francisco Pro Text' || fontfamily == 'San Francisco UI Text') {
    switch (fontWeight) {
      case '100':
        return "font-family: SFProText-Thin, SFUIText-Thin, SanFranciscoText-Thin, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '200':
        return "font-family: SFProText-Ultralight, SFUIText-Ultralight, SanFranciscoText-Ultralight, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '300':
        return "font-family: SFProText-Light, SFUIText-Light, SanFranciscoText-Light, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '400':
        return "font-family: SFProText-Regular, SFUIText-Regular, SanFranciscoText-Regular, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '500':
        return "font-family: SFProText-Medium, SFUIText-Medium, SanFranciscoText-Medium, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '600':
        return "font-family: SFProText-SemiBold, SFUIText-SemiBold, SanFranciscoText-SemiBold, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '700':
        return "font-family: SFProText-Bold, SFUIText-Bold, SanFranciscoText-Bold, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '800':
        return "font-family: SFProText-Heavy, SFUIText-Heavy, SanFranciscoText-Heavy, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '900':
        return "font-family: SFProText-Black, SFUIText-Black, SanFranciscoText-Black, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      default:
        return "font-family: SFProText-Regular, SFUIText-Regular, SanFranciscoText-Regular, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;
    }
  } else if (fontfamily == 'San Francisco Compact Display') {
    switch (fontWeight) {
      case '100':
        return "font-family: SFCompactDisplay-Thin, SFProDisplay-Thin, SFUIDisplay-Thin, SanFranciscoDisplay-Thin, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '200':
        return "font-family: SFCompactDisplay-Ultralight, SFProDisplay-Ultralight, SFUIDisplay-Ultralight, SanFranciscoDisplay-Ultralight, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '300':
        return "font-family: SFCompactDisplay-Light, SFProDisplay-Light, SFUIDisplay-Light, SanFranciscoDisplay-Light, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '400':
        return "font-family: SFCompactDisplay-Regular, SFProDisplay-Regular, SFUIDisplay-Regular, SanFranciscoDisplay-Regular, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '500':
        return "font-family: SFCompactDisplay-Medium, SFProDisplay-Medium, SFUIDisplay-Medium, SanFranciscoDisplay-Medium, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '600':
        return "font-family: SFCompactDisplay-SemiBold, SFProDisplay-SemiBold, SFUIDisplay-SemiBold, SanFranciscoDisplay-SemiBold, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '700':
        return "font-family: SFCompactDisplay-Bold, SFProDisplay-Bold, SFUIDisplay-Bold, SanFranciscoDisplay-Bold, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '800':
        return "font-family: SFCompactDisplay-Heavy, SFProDisplay-Heavy, SFUIDisplay-Heavy, SanFranciscoDisplay-Heavy, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '900':
        return "font-family: SFCompactDisplay-Black, SFProDisplay-Black, SFUIDisplay-Black, SanFranciscoDisplay-Black, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      default:
        return "font-family:SFCompactDisplay-Regular, SFProDisplay-Regular, SFUIDisplay-Regular, SanFranciscoDisplay-Regular, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;
    }
  } else if (fontfamily == 'San Francisco Compact Text') {
    switch (fontWeight) {
      case '100':
        return "font-family: SFCompactText-Thin, SFProText-Thin, SFUIText-Thin, SanFranciscoText-Thin, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '200':
        return "font-family: SFCompactText-Ultralight, SFProText-Ultralight, SFUIText-Ultralight, SanFranciscoText-Ultralight, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '300':
        return "font-family: SFCompactText-Light, SFProText-Light, SFUIText-Light, SanFranciscoText-Light, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '400':
        return "font-family: SFCompactText-Regular, SFProText-Regular, SFUIText-Regular, SanFranciscoText-Regular, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '500':
        return "font-family: SFCompactText-Medium, SFProText-Medium, SFUIText-Medium, SanFranciscoText-Medium, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '600':
        return "font-family: SFCompactText-SemiBold, SFProText-SemiBold, SFUIText-SemiBold, SanFranciscoText-SemiBold, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '700':
        return "font-family: SFCompactText-Bold, SFProText-Bold, SFUIText-Bold, SanFranciscoText-Bold, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '800':
        return "font-family: SFCompactText-Heavy, SFProText-Heavy, SFUIText-Heavy, SanFranciscoText-Heavy, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      case '900':
        return "font-family: SFCompactText-Black, SFProText-Black, SFUIText-Black, SanFranciscoText-Black, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;

      default:
        return "font-family: SFCompactText-Regular, SFProText-Regular, SFUIText-Regular, SanFranciscoText-Regular, -apple-system, system-ui, HelveticaNeue-Light, Helvetica Neue, Helvetica, Verdana, Arial, sans-serif;";
        break;
    }
  } //}


  var fontfamilyEscaped = fontfamily;
  if (fontfamilyEscaped.indexOf(',') == -1 && ['serif', 'sans-serif', 'cursive', 'monospace'].indexOf(fontfamily) == -1) // single font, can wrap in '' (Exo 2 issue). monospace etc cannot be wrapped
    fontfamilyEscaped = '\'' + fontfamily + '\''; // if(prx.componentsHelper.getFontFamilyType(fontfamily)['type'] == 'custom'){
  // fallback font looking for ,Arial at the end of font fam. a bit dangerous but fallback is an issue

  var lastFontFamilyString = fontfamilyEscaped.match(/(\s*,)\s*(\w+)$/gi);

  if (lastFontFamilyString != null && $.isArray(lastFontFamilyString) && lastFontFamilyString.length > 0 && lastFontFamilyString[0].replace(/\s+/g, '').replace(',', '') == prx.comps.fallbackFont) {
    var str = 'font-family: ' + fontfamilyEscaped + ';';
  } else {
    var str = 'font-family: ' + fontfamilyEscaped + ',' + prx.comps.fallbackFont + ';';
  }

  return str;
}; // taken from http://thomas.bindzus.me/2007/12/24/adding-dynamic-contents-to-iframes/


prx.componentsHelper.IFrame = function (parentElement) {
  var iframe = document.createElement('iframe');
  if (parentElement == null) parentElement = document.body;
  parentElement.appendChild(iframe);
  iframe.doc = null;
  if (iframe.contentDocument) // Firefox, Opera
    iframe.doc = iframe.contentDocument;else if (iframe.contentWindow) // Internet Explorer
    iframe.doc = iframe.contentWindow.document;else if (iframe.document) // Others?
    iframe.doc = iframe.document;
  if (iframe.doc == null) //throw "Document not found, append the parent element to the DOM before creating the IFrame";
    throw 'We apologize, an error occured.';
  iframe.doc.open();
  iframe.doc.close();
  return iframe;
};

prx.componentsHelper.getScale = function (library) {
  if (prx.v5x11) {
    return prx.devices[prx.device].dpr;
  }

  if (typeof library != 'string') {
    if (typeof library.rscale != 'undefined') {
      return library.rscale;
    } else {
      library = library.lib;
    }
  }

  if (library == 'iphone' && prx.compatibility.responsiveComponents.iphone_retina) {
    return 2;
  }

  var libraries = {
    iphone_retina: 2,
    ios7: 2
  };
  return typeof libraries[library] != 'undefined' ? libraries[library] : 1;
};

prx.componentsHelper.missingComponent = function (item, containerid) {
  var _id = !containerid ? item.id : containerid + '-' + item.id;

  var cErr = 'Component "' + item.type + '" is missing.';

  if (item.type == 'symbol') {
    cErr = prx.lang.get('editor.hint.brokenContainerRefComponent', {
      itemCaption: item.caption
    }); //'Container "'+item.caption+'" reference missing.';
  } else if (item.type == 'vrsymbol') {
    cErr = prx.lang.get('editor.hint.brokenVRContainerRefComponent', {
      itemCaption: item.caption
    });
    item.lib = void 0;
  }

  var loading = typeof prx.libraries[item.lib] != 'undefined' && prx.libraries[item.lib];

  if (loading) {
    cErr = 'Loading component...';
  }

  var cR = '<div id="' + _id + '" class="box pos type-missingComponent ' + (loading ? 'type-missingComponent-loading' : '') + '">';
  cR += '<style>';
  cR += prx.items.getComponentBaseStyle(item, containerid);
  cR += '</style>';
  cR += '<div class="xborder"></div>';
  cR += '<div class="error-msg">' + cErr + '</div>';
  cR += '</div>';
  return cR;
};

prx.commonproperties.metroBackgroundColor = {
  caption: {
    label: 'Background'
  },
  name: 'backgroundColor',
  type: 'solid-colorpicker',
  proptype: 'background-color',
  value: function value(item, name) {
    return item.backgroundColor;
  },
  values: prx.comps.metroColorsLight,
  liveUpdate: 'background-color',
  changeProperty: {
    caption: 'Background color',
    selector: '.changeProperty-backgroundColor',
    property: 'background-color',
    transitionable: true
  }
};
prx.commonproperties.metroBackgroundColorSolid = {
  caption: 'Background',
  name: 'backgroundColor',
  type: 'solid-colorpicker',
  proptype: 'background-color',
  value: function value(item, name) {
    return item.backgroundColor;
  },
  values: prx.comps.metroColorsLight,
  liveUpdate: 'background-color',
  changeProperty: {
    caption: 'Background color',
    selector: '.changeProperty-backgroundColor',
    property: 'background-color',
    transitionable: true
  }
};
prx.commonproperties.metroBackgroundColorGradients = {
  caption: 'Background',
  name: 'backgroundColor',
  type: 'gradients-colorpicker',
  proptype: 'background-color',
  value: function value(item, name) {
    return item.backgroundColor;
  },
  values: prx.comps.metroColorsLight,
  liveUpdate: 'background-color',
  changeProperty: {
    caption: 'Background color',
    selector: '.changeProperty-backgroundColor',
    property: 'background-color',
    transitionable: true
  }
};
prx.commonproperties.metroTextColor = {
  caption: {
    label: 'Color',
    "class": 'text-properties-label text-color-label'
  },
  name: 'textColor',
  type: 'solid-colorpicker',
  proptype: 'font-color',
  pffSettings: prx.commonproperties.pffSettingsColor,
  value: function value(item, name) {
    return item.textColor;
  },
  values: prx.comps.metroColorsLight,
  liveUpdate: 'color',
  changeProperty: {
    caption: 'Text color',
    selector: '.changeProperty-textColor',
    property: 'color',
    transitionable: true
  }
};
prx.commonproperties.metroBorderColor = {
  caption: false,
  name: 'borderColor',
  type: 'solid-colorpicker',
  proptype: 'border-color',
  value: function value(item, name) {
    return item.borderColor;
  },
  values: prx.comps.metroColorsLight,
  liveUpdate: 'border-color',
  changeProperty: {
    caption: 'Border color',
    selector: '.changeProperty-borderColor',
    property: 'border-color',
    transitionable: true
  }
  /******** SHAPES COMPONENT FUNCTIONS ********/

  /* for simpler, static shapes with and origin point (triangles, rhombi, rectangles, etc.) */

};

prx.componentsHelper.drawShape = function (item, shapeType, width, height, lineWidth) {
  var skew = item.skew / 100;
  var baseWidth = item.baseWidth / 2 / 100; // 0 to 50 %

  if (shapeType == 'rhombus' || shapeType == 'triangle') {
    var path = 'M ' + width / 2 + ' ' + lineWidth / 2;
  }

  if (shapeType == 'rhombus') {
    path += ' L ' + (width - lineWidth / 2) + ' ' + height / 2;
    path += ' L ' + width / 2 + ' ' + (height - lineWidth / 2);
    path += ' L ' + lineWidth / 2 + ' ' + height / 2;
  } else if (shapeType == 'triangle') {
    path += ' L ' + (width - lineWidth / 2) + ' ' + (height - lineWidth / 2);
    path += ' L ' + lineWidth / 2 + ' ' + (height - lineWidth / 2);
  } else if (shapeType == 'trapezoid') {
    var baseStart = width * (0.5 - baseWidth) + parseInt(lineWidth / 2);
    var baseEnd = width * (1 - (0.5 - baseWidth)) - parseInt(lineWidth / 2);

    if (baseStart >= baseEnd) {
      var path = 'M ' + (width / 2 - 0.1) + ' ' + lineWidth / 2;
      path += ' L ' + (width / 2 + 0.1) + ' ' + lineWidth / 2;
    } else {
      var path = 'M ' + (width * (0.5 - baseWidth) + parseInt(lineWidth / 2)) + ' ' + lineWidth / 2;
      path += ' L ' + (width * (1 - (0.5 - baseWidth)) - lineWidth / 2) + ' ' + lineWidth / 2;
    }

    path += ' L ' + (width - lineWidth / 2) + ' ' + (height - lineWidth / 2);
    path += ' L ' + lineWidth / 2 + ' ' + (height - lineWidth / 2);
  } else if (shapeType == 'parallelogram') {
    var path = 'M ' + (width * skew + parseInt(lineWidth / 2)) + ' ' + lineWidth / 2;
    path += ' L ' + (width - lineWidth / 2) + ' ' + lineWidth / 2;
    path += ' L ' + (width * (1 - skew) - lineWidth / 2) + ' ' + (height - lineWidth / 2);
    path += ' L ' + lineWidth / 2 + ' ' + (height - lineWidth / 2);
  }

  path += ' Z';
  return path;
};
/* for complex, dynamic shapes built around a mid-point (polygons, stars, etc.) */


prx.componentsHelper.drawComplexShape = function (item, shapeType, width, height, lineWidth) {
  var centerX = width / 2;
  var centerY = height / 2;
  var scale = width / height;
  var scaleX = 1;
  var scaleY = 1;

  if (scale < 1) {
    scaleY = 1 / scale;
  } else if (scale > 1) {
    scaleX = scale;
  } // distance between center and the container edge, passing from point i


  var radius = (Math.min(width, height) - lineWidth) / 2;
  var points = []; // store points

  var tx, ty; // temporarily store points

  var counter; // keep track of number of points

  var spikeDepth = isNaN(parseInt(item.spikeDepth)) === true ? '2' : parseInt(item.spikeDepth);
  var numOfNodes = isNaN(parseInt(item.numOfNodes)) === true ? '5' : parseInt(item.numOfNodes);
  var nextAngle = Math.PI / 2 * 3; // set first angle to the starting angle

  var step = Math.PI / numOfNodes; // angle difference between points

  var counter = 0;

  for (i = 0; i < numOfNodes; i++) {
    radians = nextAngle;
    tx = centerX + Math.cos(radians) * radius * scaleX;
    ty = centerY + Math.sin(radians) * radius * scaleY;
    points.push({
      x: tx,
      y: ty
    });
    nextAngle = radians + step;
    radians = nextAngle; // if star, add one extra point in between

    if (shapeType == 'star') {
      tx = centerX + Math.cos(radians) * radius * scaleX / spikeDepth;
      ty = centerY + Math.sin(radians) * radius * scaleY / spikeDepth;
      points.push({
        x: tx,
        y: ty
      });
      counter += 1;
    }

    if (i < numOfNodes - 1) {
      nextAngle = radians + step;
    }

    counter += 1;
  }

  var path = 'M ' + parseInt(points[0].x) + ' ' + parseInt(points[0].y);

  for (var i = 1; i < counter; i++) {
    path += ' L ' + parseInt(points[i].x) + ' ' + parseInt(points[i].y);
  }

  path += ' Z';
  return path;
};
/******** BUBBLES COMPONENT FUNCTIONS ********/

/* bubbles */


prx.componentsHelper.drawBubble = function (item, bubbleType, width, height, lineWidth) {
  var centerX = width / 2;
  var centerY = height / 2;
  var tipSize = Math.min(width, height) * 0.1;
  var direction = item.tipDirection; // define tip positioning: left / top / right / bottom

  var x1, y1, x2, y2; // start and end points

  var tx, ty; // temporarily store points
  // for ROUNDED CORNERS or ROUNDED TYPE

  if (item.bubbleType == 'rounded-corners' || item.bubbleType == 'rounded') {
    // get initial values depending ot tip direction
    var x, y, cwidth, cheight;

    if (direction == 'left') {
      x = parseInt(tipSize) + parseInt(lineWidth);
      y = parseInt(lineWidth);
      cwidth = width - parseInt(tipSize) - parseInt(lineWidth * 2);
      cheight = height - parseInt(lineWidth * 2);
    } else if (direction == 'right') {
      x = parseInt(lineWidth);
      y = parseInt(lineWidth);
      cwidth = width - parseInt(tipSize) - parseInt(lineWidth * 2);
      cheight = height - parseInt(lineWidth * 2);
    } else if (direction == 'top') {
      x = parseInt(lineWidth);
      y = parseInt(tipSize) + parseInt(lineWidth);
      cwidth = width - parseInt(lineWidth * 2);
      cheight = height - parseInt(tipSize) - parseInt(lineWidth * 2);
    } else if (direction == 'bottom') {
      x = parseInt(lineWidth);
      y = parseInt(lineWidth);
      cwidth = width - parseInt(lineWidth * 2);
      cheight = height - parseInt(tipSize) - parseInt(lineWidth * 2);
    } // define the tip edges


    var radius = item.borderRadius;

    if (direction == 'left') {
      x1 = x;
      x2 = x;
      y1 = (y + cheight - radius + (y + radius)) / 2 - tipSize / 2;
      y2 = (y + cheight - radius + (y + radius)) / 2 + tipSize / 2;
    } else if (direction == 'right') {
      x1 = x + cwidth;
      x2 = x + cwidth;
      y1 = (y + radius + (y + cheight - radius)) / 2 - tipSize / 2;
      y2 = (y + radius + (y + cheight - radius)) / 2 + tipSize / 2;
    } else if (direction == 'top') {
      x1 = (x + radius + (x + cwidth - radius)) / 2 - tipSize / 2;
      x2 = (x + radius + (x + cwidth - radius)) / 2 + tipSize / 2;
      y1 = y;
      y2 = y;
    } else if (direction == 'bottom') {
      x1 = (x + cwidth - radius + (x + radius)) / 2 - tipSize / 2;
      x2 = (x + cwidth - radius + (x + radius)) / 2 + tipSize / 2;
      y1 = y + cheight;
      y2 = y + cheight;
    } // for ROUNDED CORNERS TYPE


    if (item.bubbleType == 'rounded-corners') {
      var path = 'M ' + (x + radius) + ' ' + y; // if tip direction is top, inject tip here

      if (direction == 'top') {
        path += ' L ' + x1 + ' ' + y1;
        path += ' L ' + x2 + ' ' + lineWidth;
        path += ' L ' + x2 + ' ' + y2;
      }

      path += ' L ' + (x + cwidth - radius) + ' ' + y;
      path += ' Q ' + (x + cwidth) + ' ' + y + ' ' + (x + cwidth) + ' ' + (y + radius); // if tip direction is right, inject tip here

      if (direction == 'right') {
        path += ' L ' + x1 + ' ' + y1;
        path += ' L ' + (width - lineWidth) + ' ' + y1;
        path += ' L ' + x2 + ' ' + y2;
      }

      path += ' L ' + (x + cwidth) + ' ' + (y + cheight - radius);
      path += ' Q ' + (x + cwidth) + ' ' + (y + cheight) + ' ' + (x + cwidth - radius) + ' ' + (y + cheight); // if tip direction is bottom, inject tip here

      if (direction == 'bottom') {
        path += ' L ' + x2 + ' ' + y2;
        path += ' L ' + x2 + ' ' + (height - lineWidth);
        path += ' L ' + x1 + ' ' + y1;
      }

      path += ' L ' + (x + radius) + ' ' + (y + cheight);
      path += ' Q ' + x + ' ' + (y + cheight) + ' ' + x + ' ' + (y + cheight - radius); // if tip direction is left, inject tip here

      if (direction == 'left') {
        path += ' L ' + x2 + ' ' + y2;
        path += ' L ' + lineWidth + ' ' + y1;
        path += ' L ' + x1 + ' ' + y1;
      }

      path += ' L ' + x + ' ' + (y + radius);
      path += ' Q ' + x + ' ' + y + ' ' + (x + radius) + ' ' + y;
    } // for ROUNDED TYPE
    else if (item.bubbleType == 'rounded') {
        /*
        * DRAW POINTS AND INSERT BUBBLE TIP DEPENDING ON POSITION
        */
        // if tip direction is top
        if (direction == 'top') {
          var path = 'M ' + x2 + ' ' + lineWidth;
          path += ' L ' + x2 + ' ' + y2;
          path += ' A ' + (width / 2 - lineWidth) + ' ' + ((height - tipSize) / 2 - lineWidth) + ' 0 1 1 ' + x1 + ' ' + y1;
          path += ' L ' + x2 + ' ' + lineWidth;
        } // if tip direction is right


        if (direction == 'right') {
          var path = 'M ' + (width - lineWidth) + ' ' + height / 2;
          path += ' L ' + x2 + ' ' + y2;
          path += ' A ' + ((width - tipSize) / 2 - lineWidth) + ' ' + (height / 2 - lineWidth) + ' 0 1 1 ' + x1 + ' ' + y1;
          path += ' L ' + (width - lineWidth) + ' ' + height / 2;
        } // if tip direction is bottom


        if (direction == 'bottom') {
          var path = 'M ' + width / 2 + ' ' + (height - lineWidth);
          path += ' L ' + x2 + ' ' + y2;
          path += ' A ' + (width / 2 - lineWidth) + ' ' + ((height - tipSize) / 2 - lineWidth) + ' 0 1 0 ' + x1 + ' ' + y1;
          path += ' L ' + width / 2 + ' ' + (height - lineWidth);
        } // if tip direction is left


        if (direction == 'left') {
          var path = 'M ' + lineWidth + ' ' + height / 2;
          path += ' L ' + x2 + ' ' + y2;
          path += ' A ' + ((width - tipSize) / 2 - lineWidth) + ' ' + (height / 2 - lineWidth) + ' 0 1 0 ' + x1 + ' ' + y1;
          path += ' L ' + lineWidth + ' ' + height / 2;
        }
      }
  } // for CLOUD TYPE
  else if (item.bubbleType == 'cloud') {
      var path = 'M ' + width * 0.2 + ' ' + height * 0.77; //path += ' Q -'+(width*0.015)+' '+(height*0.725)+' '+(width*0.105+parseInt(lineWidth))+' '+(height*0.565);

      path += ' C ' + width * 0.05 + ' ' + height * 0.85 + ' ' + width * 0.04 + ' ' + height * 0.62 + ' ' + (width * 0.08 + parseInt(lineWidth)) + ' ' + height * 0.57; //path += ' Q -'+(width*0.088)+' '+(height*0.433)+' '+(width*0.155)+' '+(height*0.365);

      path += ' C 0 ' + height * 0.55 + ' 0 ' + height * 0.32 + ' ' + width * 0.1 + ' ' + height * 0.35;

      if (direction == 'left') {
        path += ' L ' + lineWidth + ' ' + height * 0.2;
        path += ' L ' + (width * 0.21 + parseInt(lineWidth)) + ' ' + (height * 0.13 + parseInt(lineWidth));
      } else {
        //path += ' Q '+(width*0.023)+' '+(height*0.156)+' '+(width*0.236+parseInt(lineWidth))+' '+(height*0.173+parseInt(lineWidth));
        path += ' C ' + width * 0.05 + ' ' + height * 0.25 + ' ' + width * 0.1 + ' ' + height * 0.05 + ' ' + (width * 0.21 + parseInt(lineWidth)) + ' ' + (height * 0.13 + parseInt(lineWidth));
      } //path += ' Q '+(width*0.266)+' -'+(height*0.021)+' '+(width*0.435)+' '+(height*0.111+parseInt(lineWidth));


      path += ' C ' + width * 0.22 + ' ' + height * 0.01 + ' ' + width * 0.4 + ' 0 ' + width * 0.435 + ' ' + (height * 0.08 + parseInt(lineWidth)); //path += ' Q '+(width*0.562)+' -'+(height*0.098)+' '+(width*0.623)+' '+(height*0.161+parseInt(lineWidth));

      path += ' C ' + width * 0.48 + ' 0 ' + width * 0.62 + ' ' + height * 0.01 + ' ' + width * 0.625 + ' ' + (height * 0.1 + parseInt(lineWidth));

      if (direction == 'top') {
        path += ' L ' + width * 0.8 + ' ' + lineWidth;
        path += ' L ' + (width * 0.83 - parseInt(lineWidth)) + ' ' + (height * 0.18 + parseInt(lineWidth));
      } else {
        //path += ' Q '+(width*0.84)+' '+(height*0.02)+' '+(width*0.81-parseInt(lineWidth))+' '+(height*0.246+parseInt(lineWidth));
        path += ' C ' + width * 0.68 + ' ' + height * 0.03 + ' ' + width * 0.84 + ' ' + height * 0.035 + ' ' + (width * 0.83 - parseInt(lineWidth)) + ' ' + (height * 0.18 + parseInt(lineWidth));
      } //path += ' Q '+(width*1.03)+' '+(height*0.26)+' '+(width*0.88-parseInt(lineWidth))+' '+(height*0.433);


      path += ' C ' + width * 0.95 + ' ' + height * 0.12 + ' ' + width + ' ' + height * 0.36 + ' ' + (width * 0.935 - parseInt(lineWidth)) + ' ' + height * 0.433; //path += ' Q '+(width*1.075)+' '+(height*0.55)+' '+(width*0.883-parseInt(lineWidth))+' '+(height*0.643);

      path += ' C ' + width + ' ' + height * 0.45 + ' ' + width + ' ' + height * 0.65 + ' ' + (width * 0.925 - parseInt(lineWidth)) + ' ' + height * 0.655;

      if (direction == 'right') {
        path += ' L ' + (width - lineWidth) + ' ' + height * 0.8;
        path += ' L ' + width * 0.79 + ' ' + height * 0.85;
      } else {
        //path += ' Q '+(width*0.976)+' '+(height*0.845)+' '+(width*0.735)+' '+(height*0.785);
        path += ' C ' + width * 0.98 + ' ' + height * 0.78 + ' ' + width * 0.89 + ' ' + height * 0.95 + ' ' + width * 0.79 + ' ' + height * 0.85;
      } //path += ' Q '+(width*0.744)+' '+(height*1.037)+' '+(width*0.556)+' '+(height*0.895-parseInt(lineWidth));


      path += ' C ' + width * 0.75 + ' ' + height + ' ' + width * 0.6 + ' ' + height + ' ' + width * 0.58 + ' ' + (height * 0.91 - parseInt(lineWidth)); //path += ' Q '+(width*0.441)+' '+(height*1.062)+' '+(width*0.345+parseInt(lineWidth))+' '+(height*0.895-parseInt(lineWidth));

      path += ' C ' + width * 0.53 + ' ' + height + ' ' + width * 0.39 + ' ' + height + ' ' + (width * 0.342 + parseInt(lineWidth)) + ' ' + (height * 0.9 - parseInt(lineWidth));

      if (direction == 'bottom') {
        path += ' L ' + width * 0.2 + ' ' + (height - lineWidth);
        path += ' L ' + width * 0.2 + ' ' + height * 0.77;
      } else {
        //path += ' Q '+(width*0.15)+' '+(height*0.983)+' '+(width*0.217)+' '+(height*0.77);
        path += ' C ' + width * 0.3 + ' ' + height * 0.98 + ' ' + width * 0.15 + ' ' + height * 0.96 + ' ' + width * 0.2 + ' ' + height * 0.77;
      }
    } // for THINK CLOUD TYPE
    else if (item.bubbleType == 'think-cloud') {
        var path = 'M ' + (width * 0.145 + parseInt(lineWidth)) + ' ' + height * 0.423;
        path += ' C 0 ' + height * 0.42 + ' 0 ' + height * 0.24 + ' ' + (width * 0.145 + parseInt(lineWidth)) + ' ' + height * 0.24;
        path += ' C ' + width * 0.08 + ' ' + height * 0.15 + ' ' + width * 0.19 + ' ' + height * 0.04 + ' ' + width * 0.375 + ' ' + (height * 0.08 + parseInt(lineWidth));
        path += ' C ' + width * 0.4 + ' 0 ' + width * 0.6 + ' 0 ' + width * 0.625 + ' ' + (height * 0.08 + parseInt(lineWidth));
        path += ' C ' + width * 0.81 + ' ' + height * 0.04 + ' ' + width * 0.92 + ' ' + height * 0.15 + ' ' + (width * 0.855 - parseInt(lineWidth)) + ' ' + height * 0.24;
        path += ' C ' + width + ' ' + height * 0.24 + ' ' + width + ' ' + height * 0.42 + ' ' + (width * 0.855 - parseInt(lineWidth)) + ' ' + height * 0.423;
        path += ' C ' + width * 0.92 + ' ' + height * 0.5 + ' ' + width * 0.81 + ' ' + height * 0.61 + ' ' + width * 0.625 + ' ' + (height * 0.556 - parseInt(lineWidth));
        path += ' C ' + width * 0.6 + ' ' + height * 0.65 + ' ' + width * 0.4 + ' ' + height * 0.65 + ' ' + width * 0.375 + ' ' + (height * 0.556 - parseInt(lineWidth));
        path += ' C ' + width * 0.19 + ' ' + height * 0.61 + ' ' + width * 0.08 + ' ' + height * 0.5 + ' ' + (width * 0.145 + parseInt(lineWidth)) + ' ' + height * 0.423;
      }

  path += ' Z';
  return path;
};
/******** ARROWS COMPONENT FUNCTIONS ********/

/* straight arrows */


prx.componentsHelper.drawArrow = function (item, width, height, lineWidth) {
  var arrowSize = 10 * prx.componentsHelper.getScale(item.lib) * (item.borderWidth / (2 * prx.componentsHelper.getScale(item.lib))); // distance between base of arrowhead to end of line

  var x1, x2, y; // set the points

  var cpx, cpy; // set control point for arrow heads
  // define arrow points

  x1 = lineWidth;
  x2 = width - lineWidth;
  y = height / 2; // define control point for arrow heads

  cpx = width / 2;
  cpy = height / 2; // define arrow heads angle

  var arrowAngleFront = Math.atan2(cpx - x2, cpy - y) + Math.PI;
  var arrowAngleEnd = Math.atan2(cpx - x1, cpy - y) + Math.PI; // get arrow direction: front / end / both

  var direction = item.arrowDirection; // define path

  if (item.arrowName == 'arrow3' && direction == 'front') {
    var path = 'M ' + (x1 * 1 + parseInt(arrowSize / 2)) + ' ' + y;
  } else if (item.arrowName == 'arrow4') {
    var path = 'M ' + x1 * 1 + ' ' + y;

    if (direction == 'end' || direction == 'both') {
      path += ' L ' + (x1 * 1 + parseInt(arrowSize) - parseInt(item.borderWidth)) + ' ' + y;
    }
  } else {
    var path = 'M ' + x1 + ' ' + y;
  } // make wiggly line for arrow 4 only


  if (item.arrowName == 'arrow4') {
    if (direction == 'front') {
      var length = parseInt(item.borderWidth * 2) + (x2 * 1 - parseInt(arrowSize)) - x1;
      var offset = x1 * 1 - parseInt(item.borderWidth);
    } else if (direction == 'end') {
      var length = parseInt(item.borderWidth * 2) + parseInt(x2) - (x1 * 1 + parseInt(arrowSize));
      var offset = x1 * 1 + parseInt(arrowSize) - parseInt(item.borderWidth);
    } else if (direction == 'both') {
      var length = parseInt(item.borderWidth * 2) + (x2 * 1 - parseInt(arrowSize)) - (x1 * 1 + parseInt(arrowSize));
      var offset = x1 * 1 + parseInt(arrowSize) - parseInt(item.borderWidth);
    }

    var interval = length / 5;
    var points = []; // wiggly line points

    for (var i = 0; i < 6; i++) {
      points.push({
        x: offset + interval * i
      });
    } // first control point, the rest are mirrored


    var cpx = offset + interval / 2;
    var cpy = y + arrowSize / 4;
    path += ' Q ' + cpx + ' ' + cpy + ' ' + points[1].x + ' ' + y;
    path += ' T ' + points[2].x + ' ' + y;
    path += ' T ' + points[3].x + ' ' + y;
    path += ' T ' + points[4].x + ' ' + y;
    path += ' T ' + points[5].x + ' ' + y;
  }

  if (item.arrowName == 'arrow3' && direction == 'end') {
    path += ' L ' + (x2 - parseInt(arrowSize / 2)) + ' ' + y;
  } else if (item.arrowName == 'arrow4') {
    if (direction == 'front' || direction == 'both') {
      path += ' M ' + (x2 - parseInt(arrowSize) + parseInt(item.borderWidth)) + ' ' + y;
      path += ' L ' + x2 + ' ' + y;
    }
  } else {
    path += ' L ' + x2 + ' ' + y;
  } // define arrow heads


  path += ';' + prx.componentsHelper.arrowHeads(direction, arrowSize, x1, x2, y, y, arrowAngleFront, arrowAngleEnd, item); // define details

  if (item.arrowName == 'arrow2' || item.arrowName == 'arrow3') {
    path += ';' + prx.componentsHelper.arrowDetails(direction, arrowSize, x1, x2, y, y, arrowAngleFront, arrowAngleEnd, item);
  }

  return path;
};
/* curved arrows */


prx.componentsHelper.drawArrowCurved = function (item, arrowType, width, height, lineWidth) {
  var arrowSize = 10 * prx.componentsHelper.getScale(item.lib) * (item.borderWidth / (2 * prx.componentsHelper.getScale(item.lib))); // distance between base of arrowhead to end of line

  var x1, x2, y1, y2; // set the points

  var cpx, cpy; // set the control point for quad curve, if needed

  var cpx1, cpx2, cpy1, cpy2; // set control points for bezier curve
  // define arrow points

  if (arrowType == 'curved') {
    x1 = parseInt(lineWidth) + arrowSize / 2 / (item.borderWidth / (2 * prx.componentsHelper.getScale(item.lib)));
    y1 = height - parseInt(lineWidth) - arrowSize / 2 / (item.borderWidth / (2 * prx.componentsHelper.getScale(item.lib)));
    x2 = width - parseInt(lineWidth) - arrowSize / 2 / (item.borderWidth / (2 * prx.componentsHelper.getScale(item.lib)));
    y2 = arrowSize / 2 + parseInt(lineWidth); // actual control points we would like the curve to go through

    cpx = (x1 + x2) / 2 - Math.min(width, height) * 0.2;
    cpy = (y1 + y2) / 2 - Math.min(width, height) * 0.2; // formula to manipulate control points so that the curve actually passes through

    cpx = cpx * 2 - (x1 + x2) / 2;
    cpy = cpy * 2 - (y1 + y2) / 2;
  } else if (arrowType == 'arced') {
    x1 = width - parseInt(lineWidth);
    y1 = height - parseInt(lineWidth) - arrowSize / 2;
    x2 = width - parseInt(lineWidth);
    y2 = parseInt(lineWidth) + arrowSize / 2; // actual control points we would like the curve to go through

    cpx1 = lineWidth - width * 0.3;
    cpy1 = height * 0.8;
    cpx2 = lineWidth - width * 0.3;
    cpy2 = height * 0.2;
  } else if (arrowType == 'right-angle') {
    x1 = parseInt(lineWidth) + arrowSize / 2;
    y1 = height - parseInt(lineWidth);
    x2 = width - parseInt(lineWidth);
    y2 = parseInt(lineWidth) + arrowSize / 2; // actual control points we would like the curve to go through

    cpx = parseInt(lineWidth) + arrowSize / 2;
    cpy = parseInt(lineWidth) + arrowSize / 2;
  } // define arrow heads angle


  if (arrowType == 'arced') {
    var arrowAngleFront = Math.atan2(cpx2 - x2, cpy2 - y2) + Math.PI;
    var arrowAngleEnd = Math.atan2(cpx1 - x1, cpy1 - y1) + Math.PI;
  } else {
    var arrowAngleFront = Math.atan2(cpx - x2, cpy - y2) + Math.PI;
    var arrowAngleEnd = Math.atan2(cpx - x1, cpy - y1) + Math.PI;
  } // get arrow direction: front / end / both


  var direction = item.arrowDirection; // define path

  if (item.arrowName == 'arrow3' && direction == 'front' && arrowType == 'right-angle') {
    var path = 'M ' + x1 + ' ' + (y1 - parseInt(arrowSize / 2));
  } else {
    var path = 'M ' + x1 + ' ' + y1;
  }

  if (arrowType == 'curved') {
    path += ' Q ' + cpx + ' ' + cpy + ' ' + x2 + ' ' + y2;
  } else if (arrowType == 'arced') {
    path += ' C ' + cpx1 + ' ' + cpy1 + ' ' + cpx2 + ' ' + cpy2 + ' ' + x2 + ' ' + y2;
  } else if (arrowType == 'right-angle') {
    path += ' L ' + (parseInt(lineWidth) + arrowSize / 2) + ' ' + (parseInt(lineWidth) + arrowSize / 2);

    if (item.arrowName == 'arrow3' && direction == 'end') {
      path += ' L ' + (x2 - parseInt(arrowSize / 2)) + ' ' + y2;
    } else {
      path += ' L ' + x2 + ' ' + y2;
    }
  } // define arrow heads


  path += ';' + prx.componentsHelper.arrowHeads(direction, arrowSize, x1, x2, y1, y2, arrowAngleFront, arrowAngleEnd, item); // define details

  if (arrowType == 'right-angle' && (item.arrowName == 'arrow2' || item.arrowName == 'arrow3')) {
    path += ';' + prx.componentsHelper.arrowDetails(direction, arrowSize, x1, x2, y1, y2, arrowAngleFront, arrowAngleEnd, item);
  }

  return path;
};
/* custom arrows */


prx.componentsHelper.drawArrowCustom = function (item, width, height, lineWidth) {
  var direction = item.arrowDirection;
  var path = ''; // arrow 5

  if (item.arrowName == 'arrow5') {
    if (direction == 'front') {
      path += 'M ' + lineWidth + ' ' + height * 0.2;
      path += ' L ' + lineWidth + ' ' + height * 0.8;
      path += ' L ' + width * 0.6 + ' ' + height * 0.8;
      path += ' L ' + width * 0.6 + ' ' + (height - lineWidth);
      path += ' L ' + (width - lineWidth) + ' ' + height / 2;
      path += ' L ' + width * 0.6 + ' ' + lineWidth;
      path += ' L ' + width * 0.6 + ' ' + height * 0.2;
      path += ' L ' + lineWidth + ' ' + height * 0.2;
    } else if (direction == 'end') {
      path += 'M ' + (width - lineWidth) + ' ' + height * 0.2;
      path += ' L ' + (width - lineWidth) + ' ' + height * 0.8;
      path += ' L ' + width * 0.4 + ' ' + height * 0.8;
      path += ' L ' + width * 0.4 + ' ' + (height - lineWidth);
      path += ' L ' + lineWidth + ' ' + height / 2;
      path += ' L ' + width * 0.4 + ' ' + lineWidth;
      path += ' L ' + width * 0.4 + ' ' + height * 0.2;
      path += ' L ' + (width - lineWidth) + ' ' + height * 0.2;
    }
  } // arrow 6
  else if (item.arrowName == 'arrow6') {
      if (direction == 'front') {
        path += 'M ' + lineWidth + ' ' + lineWidth;
        path += ' L ' + width * 0.6 + ' ' + height / 2;
        path += ' L ' + lineWidth + ' ' + (height - lineWidth);
        path += ' L ' + width * 0.4 + ' ' + (height - lineWidth);
        path += ' L ' + (width - lineWidth) + ' ' + height / 2;
        path += ' L ' + width * 0.4 + ' ' + lineWidth;
        path += ' L ' + lineWidth + ' ' + lineWidth;
      } else if (direction == 'end') {
        path += 'M ' + (width - lineWidth) + ' ' + lineWidth;
        path += ' L ' + width * 0.4 + ' ' + height / 2;
        path += ' L ' + (width - lineWidth) + ' ' + (height - lineWidth);
        path += ' L ' + width * 0.6 + ' ' + (height - lineWidth);
        path += ' L ' + lineWidth + ' ' + height / 2;
        path += ' L ' + width * 0.6 + ' ' + lineWidth;
        path += ' L ' + (width - lineWidth) + ' ' + lineWidth;
      }
    } // arrow 7
    else if (item.arrowName == 'arrow7') {
        if (direction == 'front') {
          path += 'M ' + lineWidth + ' ' + lineWidth;
          path += ' L ' + width * 0.3 + ' ' + height / 2;
          path += ' L ' + lineWidth + ' ' + (height - lineWidth);
          path += ' L ' + (width - lineWidth) + ' ' + height / 2;
          path += ' L ' + lineWidth + ' ' + lineWidth;
        } else if (direction == 'end') {
          path += 'M ' + (width - lineWidth) + ' ' + lineWidth;
          path += ' L ' + width * 0.7 + ' ' + height / 2;
          path += ' L ' + (width - lineWidth) + ' ' + (height - lineWidth);
          path += ' L ' + lineWidth + ' ' + height / 2;
          path += ' L ' + (width - lineWidth) + ' ' + lineWidth;
        }
      } // arrow 8
      else if (item.arrowName == 'arrow8') {
          if (direction == 'front') {
            path += 'M ' + width * 0.6 + ' ' + height * 0.15; // arrow head

            path += ' L ' + width * 0.55 + ' ' + lineWidth;
            path += ' Q ' + (width * 0.6 + (width - lineWidth)) / 2 + ' ' + (height * 0.15 + (height * 0.25 - lineWidth)) / 2 + ' ' + (width - lineWidth) + ' ' + (height * 0.25 - lineWidth);
            path += ' Q ' + (width * 0.6 + (width - lineWidth)) / 2 + ' ' + (height * 0.25 - lineWidth + height * 0.35) / 2 + ' ' + width * 0.55 + ' ' + (height * 0.5 - lineWidth);
            path += ' L ' + width * 0.6 + ' ' + height * 0.35; // arrow line

            path += ' Q ' + lineWidth + ' ' + height * 0.4 + ' ' + width * 0.75 + ' ' + (height - lineWidth);
            path += ' Q -' + width / 2 + ' ' + height * 0.3 + ' ' + width * 0.6 + ' ' + height * 0.15;
          } else if (direction == 'end') {
            path += 'M ' + width * 0.4 + ' ' + height * 0.15; // arrow head

            path += ' L ' + width * 0.45 + ' ' + lineWidth;
            path += ' Q ' + (width * 0.4 + lineWidth) / 2 + ' ' + (height * 0.15 + (height * 0.25 - lineWidth)) / 2 + ' ' + lineWidth + ' ' + (height * 0.25 - lineWidth);
            path += ' Q ' + (width * 0.4 + lineWidth) / 2 + ' ' + (height * 0.25 - lineWidth + height * 0.35) / 2 + ' ' + width * 0.45 + ' ' + (height * 0.5 - lineWidth);
            path += ' L ' + width * 0.4 + ' ' + height * 0.35; // arrow line

            path += ' Q ' + (width - lineWidth) + ' ' + height * 0.4 + ' ' + width * 0.25 + ' ' + (height - lineWidth);
            path += ' Q ' + (width + width / 2) + ' ' + height * 0.3 + ' ' + width * 0.4 + ' ' + height * 0.15;
          }
        }

  return path;
};
/* define arrow heads */


prx.componentsHelper.arrowHeads = function (direction, arrowSize, x1, x2, y1, y2, arrowAngleFront, arrowAngleEnd, item) {
  var path = '';

  if (direction == 'front' || direction == 'both') {
    path += ' M ' + (x2 - arrowSize * Math.sin(arrowAngleFront - Math.PI / 6)) + ' ' + (y2 - arrowSize * Math.cos(arrowAngleFront - Math.PI / 6));
    path += ' L ' + x2 + ' ' + y2;
    path += ' L ' + (x2 - arrowSize * Math.sin(arrowAngleFront + Math.PI / 6)) + ' ' + (y2 - arrowSize * Math.cos(arrowAngleFront + Math.PI / 6));
    if (item.filledArrow) path += ' Z';
  }

  if (direction == 'end' || direction == 'both') {
    path += ' M ' + (x1 - arrowSize * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - arrowSize * Math.cos(arrowAngleEnd - Math.PI / 6));
    path += ' L ' + x1 + ' ' + y1;
    path += ' L ' + (x1 - arrowSize * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y1 - arrowSize * Math.cos(arrowAngleEnd + Math.PI / 6));
    if (item.filledArrow) path += ' Z';
  }

  return path;
};
/* define arrow details */


prx.componentsHelper.arrowDetails = function (direction, arrowSize, x1, x2, y1, y2, arrowAngleFront, arrowAngleEnd, item) {
  var path = '';

  if (direction == 'front' || direction == 'both') {
    if (item.arrowName == 'arrow2' && item.arrowType == 'straight') {
      path += ' M ' + (x1 * 1 + parseInt(arrowSize / 2) + arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x1 * 1 + parseInt(arrowSize / 2)) + ' ' + y1;
      path += ' L ' + (x1 * 1 + parseInt(arrowSize / 2) + arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y1 - arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
      path += ' M ' + (x1 * 1 + parseInt(arrowSize) + arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x1 * 1 + parseInt(arrowSize)) + ' ' + y1;
      path += ' L ' + (x1 * 1 + parseInt(arrowSize) + arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y1 - arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
    } else if (item.arrowName == 'arrow2' && item.arrowType == 'right-angle') {
      path += ' M ' + (x1 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + x1 + ' ' + (y1 - parseInt(arrowSize / 2));
      path += ' L ' + (x1 - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y1 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
      path += ' M ' + (x1 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - parseInt(arrowSize) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + x1 + ' ' + (y1 - parseInt(arrowSize));
      path += ' L ' + (x1 - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y1 - parseInt(arrowSize) + arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
    } else if (item.arrowName == 'arrow3' && item.arrowType == 'straight') {
      path += ' M ' + (x1 * 1 + parseInt(arrowSize / 2) + arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x1 * 1 + parseInt(arrowSize / 2)) + ' ' + y1;
      path += ' L ' + (x1 * 1 + parseInt(arrowSize / 2) + arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y1 - arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
      path += ' L ' + (x1 * 1 + parseInt(arrowSize * 1.2) + arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y1 - arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
      path += ' L ' + (x1 * 1 + parseInt(arrowSize * 1.2)) + ' ' + y1;
      path += ' L ' + (x1 * 1 + parseInt(arrowSize * 1.2) + arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x1 * 1 + parseInt(arrowSize / 2) + arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
    } else if (item.arrowName == 'arrow3' && item.arrowType == 'right-angle') {
      path += ' M ' + (x1 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + x1 + ' ' + (y1 - parseInt(arrowSize / 2));
      path += ' L ' + (x1 - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y1 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
      path += ' L ' + (x1 - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y1 - parseInt(arrowSize * 1.2) + arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
      path += ' L ' + x1 + ' ' + (y1 - parseInt(arrowSize * 1.2));
      path += ' L ' + (x1 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - parseInt(arrowSize * 1.2) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x1 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y1 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
    }
  }

  if (direction == 'end' || direction == 'both') {
    if (item.arrowName == 'arrow2' && item.arrowType == 'straight') {
      path += ' M ' + (x2 - parseInt(arrowSize / 2) - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize / 2)) + ' ' + y2;
      path += ' L ' + (x2 - parseInt(arrowSize / 2) - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
      path += ' M ' + (x2 - parseInt(arrowSize) - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize)) + ' ' + y2;
      path += ' L ' + (x2 - parseInt(arrowSize) - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
    } else if (item.arrowName == 'arrow2' && item.arrowType == 'right-angle') {
      path += ' M ' + (x2 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize / 2)) + ' ' + y2;
      path += ' L ' + (x2 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6));
      path += ' M ' + (x2 - parseInt(arrowSize) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize)) + ' ' + y2;
      path += ' L ' + (x2 - parseInt(arrowSize) + arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6));
    } else if (item.arrowName == 'arrow3' && item.arrowType == 'straight') {
      path += ' M ' + (x2 - parseInt(arrowSize / 2) - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize / 2)) + ' ' + y2;
      path += ' L ' + (x2 - parseInt(arrowSize / 2) - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize * 1.2) - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize * 1.2)) + ' ' + y2;
      path += ' L ' + (x2 - parseInt(arrowSize * 1.2) - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize / 2) - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6));
    } else if (item.arrowName == 'arrow3' && item.arrowType == 'right-angle') {
      path += ' M ' + (x2 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize / 2)) + ' ' + y2;
      path += ' L ' + (x2 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize * 1.2) + arrowSize / 2 * Math.cos(arrowAngleEnd + Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.sin(arrowAngleEnd + Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize * 1.2)) + ' ' + y2;
      path += ' L ' + (x2 - parseInt(arrowSize * 1.2) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6));
      path += ' L ' + (x2 - parseInt(arrowSize / 2) + arrowSize / 2 * Math.cos(arrowAngleEnd - Math.PI / 6)) + ' ' + (y2 - arrowSize / 2 * Math.sin(arrowAngleEnd - Math.PI / 6));
    }
  }

  return path;
}; // returns an ordered array (based on css properties) of the expanded properties in the value for use in getProp function,
// if it is not an object or the result is undefined, return false
// if key is provided, return value for that expanded property only
// if they key value is undefined, return false


prx.componentsHelper.getExpandedProp = function (value, key, type) {
  if (_typeof(value) === 'object') {
    if (key == undefined) {
      // get sub properties labels
      var values = prx.expandableProperties.getOrderedProps(value, 'display');
      var ellipticalRadius = prx.componentsHelper.checkIfExpandedRadiusElliptical(value, values, type); // if valid

      if (values !== undefined) {
        var tempVal = '';

        if (ellipticalRadius) {
          var values1 = [],
              values2 = [];

          for (var i = 0; i < values.length; i++) {
            values1.push(value[values[i]].split(' ').first());
            values2.push(value[values[i]].split(' ').last());
          }

          tempVal += values1[0] + ' ' + values1[1] + ' ' + values1[2] + ' ' + values1[3];
          tempVal += ' / ';
          tempVal += values2[0] + ' ' + values2[1] + ' ' + values2[2] + ' ' + values2[3];
        } else {
          // generate a string for the multiple values (e.g. "value"px "value"px "value"px "value"px)
          for (var i = 0; i < values.length; i++) {
            tempVal += value[values[i]];
            if (parseFloat(value[values[i]]) == value[values[i]]) tempVal += 'px';
            tempVal += ' ';
          }
        }

        return tempVal;
      }

      return false;
    } else {
      if (value[key] !== undefined) return value[key] + (ellipticalRadius ? '' : 'px');
      return false;
    }
  } else return false;
};
/**
 * Checks if a border radius object contains values for elliptical border radius or not
 * It is considered to be an elliptical border radius if all object values are made up of two values separated by a space
 *
 * @returns {boolean}		True if elliptical, false otherwise
 */


prx.componentsHelper.checkIfExpandedRadiusElliptical = function (value, values, type) {
  if (type.includes('border-radius')) {
    var elliptical = 0;

    for (var i = 0; i < values.length; i++) {
      if (value[values[i]].toString().includes(' ')) {
        elliptical++;
      }
    }

    if (elliptical == values.length) return true;else return false;
  } else {
    return false;
  }
};

prx.componentsHelper.getProp = function (value, type) {
  //added "undefined|undefined" for fontfamily | fontstyle undefined case
  if (typeof value == 'undefined' || typeof type == 'undefined' || typeof value != 'undefined' && value == 'undefined|undefined') {
    return '';
  }

  switch (type) {
    case 'url':
      //check for value beginning with http or https
      var regex = /^(http|https)/i;

      if (regex.test(value)) {
        return value;
      } else {
        return 'about:blank';
      }

      break;

    case 'text':
    case 'spikeDepth':
    case 'numOfNodes':
    case 'skew':
    case 'baseWidth':
    case 'border-type':
    case 'num-other':
    case 'align':
    case 'button-type':
    case 'icon-position':
    case 'icon-size':
    case 'boolean':
    case 'other':
      return prx.utils.escapeHTML(value);
      break;

    case 'border-radius':
    case 'num-border-radius':
    case 'border-radius-tl':
    case 'border-radius-tr':
    case 'border-radius-bl':
    case 'border-radius-br':
      // if the type ends with an expanded property label
      if (type.match(/-(tl|tr|bl|br)$/)) var key = type.substr(-2, 2);
      var expandedValue = prx.componentsHelper.getExpandedProp(value, key !== undefined ? key : undefined, type);
      if (expandedValue) value = expandedValue;else if (parseFloat(value) == value) value += 'px';
      return prx.utils.escapeHTML(value);
      break;

    case 'border-width':
    case 'border-width-t':
    case 'border-width-r':
    case 'border-width-b':
    case 'border-width-l':
      // if the type ends with an expanded property label
      if (type.match(/-(t|r|b|l)$/)) var key = type.substr(-2, 2);
      var expandedValue = prx.componentsHelper.getExpandedProp(value, key !== undefined ? key : undefined, type);
      if (expandedValue) value = expandedValue;else if (parseFloat(value) == value) value += 'px';
      return prx.utils.escapeHTML(value);
      break;

    case 'text-list':
    case 'text-textarea':
    case 'text-wysiwyg':
    case 'text-html':
      return prx.utils.escapeRichText(value);
      break;

    case 'color-background':
      if (_typeof(value) === "object") {
        return prx.utils.escapeHTML(prx.gradients.prxToCss(prx.utils.getColor(value)));
        break;
      }

      return prx.utils.escapeHTML(prx.utils.getColor(value));
      break;

    case 'color-border':
    case 'color-fill':
    case 'color-ripple':
    case 'color-shadow':
    case 'color-switch':
    case 'color-text':
    case 'color-other':
      return prx.utils.escapeHTML(prx.gradients.prxToCss(prx.utils.getColor(value)));
      break;

    case 'num-border-width':
    case 'num-percentage':
    case 'num-text-size':
      value = prx.utils.escapeHTML(value);

      if (isNaN(value) === true) {
        return 0;
      } else {
        return value;
      }

      break;

    case 'slide-input':
      value = parseInt(value);

      if (isNaN(value) === true) {
        return 0;
      } else {
        return value;
      }

      break;

    case 'asset':
      return prx.componentsHelper.getAssetUrl(value);
      break;

    case 'font-family':
      return prx.componentsHelper.getFontCssFromFontFamily(value);
      break;

    case 'font-style':
      // return '';
      var weight = parseInt(value, 10);
      if (isNaN(weight) || weight == null) weight = 400;
      var styleCss = value.toString().indexOf('italic') > -1 ? 'italic' : 'normal';
      return "font-weight:".concat(weight, "; font-style:").concat(styleCss, ";");
      break;

    case 'font-weight-value':
      if (value == 'bold') {
        return '700';
      } else {
        var weightVal = parseInt(value, 10);
        if (isNaN(weightVal) || weightVal == null) weightVal = 400;
        return weightVal;
      }

      break;

    case 'font-style-value':
      var styleVal = value.toString().indexOf('italic') > -1 ? 'italic' : 'normal';
      return styleVal;
      break;

    case 'props-text':
      // var _str = (jQuery.inArray("bold", value) > -1) ? " font-weight: bold;" : "";
      // _str += (jQuery.inArray("italic", value) > -1) ? " font-style: italic;" : "";
      _str = jQuery.inArray("underline", value) > -1 ? " text-decoration: underline;" : "";
      return _str;
      break;

    case 'props-text-style':
      var _str = " font-weight: " + prx.componentsHelper.getProp(value, 'font-weight-value') + " ;";

      _str += " font-style: " + prx.componentsHelper.getProp(value, 'font-style-value') + " ;";
      return _str;
      break;

    case 'select-property-interactions':
      /**GY escape but dont mess with spaces &nbsp;**/
      return prx.utils.escapeHTML(value.replace(/&nbsp;/g, '\\space')).replace(/\\space/g, '&nbsp;');
      break;

    case 'video-url':
      return value //.replace(/&/g, "&amp;")
      .replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      break;

    case 'color-colorpicker':
    case 'opacity-colorpicker':
      return prx.utils.escapeHTML(value);
      break;

    case 'esc-dbl-quotes':
      return value.replace(/"/g, '&quot;');
      break;

    case 'caption':
      //strip out all HTML
      //[] means filter out all tags
      // return prx.utils.escapeRichText(value,[])
      return prx.utils.escapeHTML(value);
      break;

    case 'zoom-level-txtBox':
      value = parseInt(prx.utils.escapeHTML(value));

      if (isNaN(value) === false) {
        if (value < prx.zoom._minZoom) {
          return prx.zoom._minZoom;
        } else if (value > prx.zoom._maxZoom) {
          return prx.zoom._maxZoom;
        } else {
          return value;
        }
      } else {
        return false;
      }

      break;

    case 'radio-group-name':
      return value.replace(/[^a-zA-Z0-9 :-]/g, '').replace(/\s/g, '-');
      break;

    default:
      return prx.utils.escapeHTML(value);
  }
};

prx.componentsHelper.changeFunctionForTextProperties = function (item, containerid, dynPropI, props) {
  if (typeof item == 'undefined' || typeof props == 'undefined') return;
  var itemType = item.type;
  var data = prx.componentsHelper.getSelectorForTextProperties(itemType, props, dynPropI);
  var selectors = typeof data.selectors !== 'undefined' ? data.selectors : false;
  var dynPropData = typeof data.textPropsKey !== 'undefined' && typeof data.textPropsKey[0] !== 'undefined' ? data.textPropsKey[0] : false;
  if (selectors == false || selectors.length == 0) return;
  selectors.forEach(function (value) {
    // var element =  $('#' + containerid + '-' + item.id + ' ' + value + ' span[data-editableproperty="'+props+'"], ' + containerid + '-' + item.id + value + ' span[data-editableproperty="'+props+'"]');
    var element = $('#' + containerid + '-' + item.id + ' ' + value + ' span[data-editableproperty], #' + containerid + '-' + item.id + value + ' span[data-editableproperty]'); //data attr to just exist. we may have text, subtitle, e.t.c

    element = $('#' + containerid + '-' + item.id + ' ' + value + ', #' + containerid + '-' + item.id + value).length > element.length ? $('#' + containerid + '-' + item.id + ' ' + value + ', #' + containerid + '-' + item.id + value) : element;
    if (element.length == 0) return;

    for (var i = 0; i < element.length; i++) {
      if (typeof dynPropI !== 'undefined' && typeof $(element[i]).data('dynamicPropertyIndex') !== 'undefined' && $(element[i]).data('dynamicPropertyIndex').toString() !== dynPropI.toString()) continue;
      var html = $(element[i]).html();
      if (typeof html == 'undefined' || html.length == 0) return;

      for (var k in prx.comps.textPropertiesMappings) {
        //strip text from all [b,i,u]
        html = prx.componentsHelper.stripStyle(html, k, false);
      }

      var textProperties = typeof dynPropI !== 'undefined' && dynPropData !== false ? item[dynPropData][dynPropI][props] : item[props];
      if (typeof textProperties == 'undefined') return;
      textProperties.forEach(function (val) {
        //add new text properties
        html = prx.comps.textPropertiesMappings[val][0] + html + prx.comps.textPropertiesMappings[val][1];
      });
      $(element[i]).html(html);
    }
  });
};

prx.componentsHelper.changeFunctionForTextFontStyleProperties = function (item, containerid, dynPropI, props) {
  if (typeof item == 'undefined' || typeof props == 'undefined') return;
  var itemType = item.type;
  var data = prx.componentsHelper.getSelectorForTextProperties(itemType, props, dynPropI);
  var selectors = typeof data.selectors !== 'undefined' ? data.selectors : false;
  var dynPropData = typeof data.textPropsKey !== 'undefined' && typeof data.textPropsKey[0] !== 'undefined' ? data.textPropsKey[0] : false;
  var relatedData = prx.componentsHelper.getTextandFontStylePropsName(item.type, props, dynPropData);
  var relatedFontFamilyPropGroup = relatedData['fontFamilyGroup'];
  var relatedFontFamilyPropName = relatedData['relatedFontFamilyPropsName'];

  if (typeof relatedFontFamilyPropGroup['value'] == 'function') {
    var currentFontFamily = relatedFontFamilyPropGroup['value'](item, relatedFontFamilyPropName, dynPropI);
  }

  if (selectors == false || selectors.length == 0) return;
  selectors.forEach(function (value) {
    // var element =  $('#' + containerid + '-' + item.id + ' ' + value + ' span[data-editableproperty="'+props+'"], ' + containerid + '-' + item.id + value + ' span[data-editableproperty="'+props+'"]');
    var element = $('#' + containerid + '-' + item.id + ' ' + value + ' span[data-editableproperty], ' + containerid + '-' + item.id + value + ' span[data-editableproperty]'); //data attr to just exist. we may have text, subtitle, e.t.c

    element = $('#' + containerid + '-' + item.id + ' ' + value + ', ' + containerid + '-' + item.id + value).length > element.length ? $('#' + containerid + '-' + item.id + ' ' + value + ', ' + containerid + '-' + item.id + value) : element;
    if (element.length == 0) return;

    for (var i = 0; i < element.length; i++) {
      if (typeof dynPropI !== 'undefined' && typeof $(element[i]).data('dynamicPropertyIndex') !== 'undefined' && $(element[i]).data('dynamicPropertyIndex').toString() !== dynPropI.toString()) continue;
      var html = $(element[i]).html();
      if (typeof html == 'undefined' || html.length == 0) return;

      for (var k in prx.comps.textFontStylePropertiesMappings) {
        //strip text from all font weight and font font style
        html = prx.componentsHelper.stripStyle(html, k, true);
      }

      if (typeof currentFontFamily != 'undefined') {
        var includeList = [currentFontFamily];
        html = prx.componentsHelper.stripStyle(html, 'font-family', false, includeList);
      }

      var textFontStyleProperties = typeof dynPropI !== 'undefined' && dynPropData !== false ? item[dynPropData][dynPropI][props] : item[props];
      if (typeof textFontStyleProperties == 'undefined') return;
      var style = prx.componentsHelper.getProp(textFontStyleProperties, 'font-style-value');
      var weight = prx.componentsHelper.getProp(textFontStyleProperties, 'font-weight-value'); // textProperties.forEach(function (val) {//add new text font style propsproperties

      html = '<span style="font-weight:' + weight + ';font-style:' + style + ';">' + html + '</span>'; // });

      $(element[i]).html(html);
    }
  });
};

prx.componentsHelper.getSelectorForTextProperties = function (itemType, name, dynPropI) {
  var data = {
    selectors: [],
    textPropsKey: [],
    property: []
  };
  if (typeof itemType == 'undefined' || typeof name == 'undefined') return data;

  if (typeof dynPropI == 'undefined') {
    if (typeof prx.types[itemType] !== 'undefined' && typeof prx.types[itemType].propertyGroups !== 'undefined') {
      for (var j = 0; j < prx.types[itemType].propertyGroups.length; j++) {
        for (var k = 0; k < prx.types[itemType].propertyGroups[j].properties.length; k++) {
          var _props = prx.types[itemType].propertyGroups[j].properties[k];

          for (var n = 0; n < _props.length; n++) {
            if (typeof _props[n]['relatedEditableProperties'] != 'undefined' && typeof _props[n]['name'] != 'undefined' && _props[n]['name'] == name) {
              var _relatedEditableProperties = $.isArray(_props[n]['relatedEditableProperties']) ? _props[n]['relatedEditableProperties'] : [_props[n]['relatedEditableProperties']];

              for (var t = 0; t < _relatedEditableProperties.length; t++) {
                var isCustomProperty = _relatedEditableProperties[t].split(/[.]+/).length > 1 ? true : false;

                if (isCustomProperty) {
                  var path = _relatedEditableProperties[t].split(/[.]+/); // if(typeof(path[0])!=='undefined') data.textPropsKey.push(path[0]);


                  if (typeof path[1] !== 'undefined' && typeof prx.types[itemType].dynamicProperties !== 'undefined' && typeof prx.types[itemType].dynamicProperties.editableProperties !== 'undefined') {
                    for (var l = 0; l < prx.types[itemType].dynamicProperties.editableProperties.length; l++) {
                      if (typeof prx.types[itemType].dynamicProperties.editableProperties[l].name !== 'undefined' && prx.types[itemType].dynamicProperties.editableProperties[l].name == path[1]) {
                        if (_typeof(prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty'] !== 'undefined' && prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['selector'] !== 'undefined')) {
                          data.selectors.push(prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['selector']);

                          if (typeof prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['property'] !== 'undefined') {
                            data.property.push(prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['property']);
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (typeof prx.types[itemType].editableProperties !== 'undefined') {
                    for (var l = 0; l < prx.types[itemType].editableProperties.length; l++) {
                      if (typeof prx.types[itemType].editableProperties[l].name !== 'undefined' && prx.types[itemType].editableProperties[l].name == _relatedEditableProperties[t]) {
                        if (_typeof(prx.types[itemType].editableProperties[l]['changeProperty'] !== 'undefined' && prx.types[itemType].editableProperties[l]['changeProperty']['selector'] !== 'undefined')) {
                          data.selectors.push(prx.types[itemType].editableProperties[l]['changeProperty']['selector']);

                          if (typeof prx.types[itemType].editableProperties[l]['changeProperty']['property'] !== 'undefined') {
                            data.property.push(prx.types[itemType].editableProperties[l]['changeProperty']['property']);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } else {
    //dynProperty
    if (typeof prx.types[itemType].dynamicProperties.propertyGroups !== 'undefined') {
      data.textPropsKey.push(prx.types[itemType].dynamicProperties.data);

      for (var j = 0; j < prx.types[itemType].dynamicProperties.propertyGroups.length; j++) {
        for (var k = 0; k < prx.types[itemType].dynamicProperties.propertyGroups[j].properties.length; k++) {
          var _props = prx.types[itemType].dynamicProperties.propertyGroups[j].properties[k];

          for (var n = 0; n < _props.length; n++) {
            if (typeof _props[n]['relatedEditableProperties'] != 'undefined' && typeof _props[n]['name'] != 'undefined' && _props[n]['name'] == name) {
              var _relatedEditableProperties = $.isArray(_props[n]['relatedEditableProperties']) ? _props[n]['relatedEditableProperties'] : [_props[n]['relatedEditableProperties']];

              for (var t = 0; t < _relatedEditableProperties.length; t++) {
                var isCustomProperty = _relatedEditableProperties[t].split(/[.]+/).length > 1 ? true : false;

                if (isCustomProperty) {
                  var path = _relatedEditableProperties[t].split(/[.]+/);

                  if (typeof path[1] !== 'undefined' && typeof prx.types[itemType].dynamicProperties !== 'undefined' && typeof prx.types[itemType].dynamicProperties.editableProperties !== 'undefined') {
                    for (var l = 0; l < prx.types[itemType].dynamicProperties.editableProperties.length; l++) {
                      if (typeof prx.types[itemType].dynamicProperties.editableProperties[l].name !== 'undefined' && prx.types[itemType].dynamicProperties.editableProperties[l].name == path[1]) {
                        if (_typeof(prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty'] !== 'undefined' && prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['selector'] !== 'undefined')) {
                          data.selectors.push(prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['selector']);

                          if (typeof prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['property'] !== 'undefined') {
                            data.property.push(prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['property']);
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (typeof prx.types[itemType].dynamicProperties !== 'undefined' && typeof prx.types[itemType].dynamicProperties.editableProperties !== 'undefined') {
                    for (var l = 0; l < prx.types[itemType].dynamicProperties.editableProperties.length; l++) {
                      if (typeof prx.types[itemType].dynamicProperties.editableProperties[l].name !== 'undefined' && prx.types[itemType].dynamicProperties.editableProperties[l].name == _relatedEditableProperties[t]) {
                        if (_typeof(prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty'] !== 'undefined' && prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['selector'] !== 'undefined')) {
                          data.selectors.push(prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['selector']);

                          if (typeof prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['property'] !== 'undefined') {
                            data.property.push(prx.types[itemType].dynamicProperties.editableProperties[l]['changeProperty']['property']);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return data;
};

prx.componentsHelper.isComponentSupportedProperty = function (itemType, property) {
  if (typeof property == 'undefined' || typeof itemType == 'undefined') {
    return false;
  }

  if (typeof prx.components[itemType] == 'undefined' || typeof prx.components[itemType].properties == 'undefined') {
    return true; // no specific props - all props supported by default
  }

  if (typeof prx.components[itemType].properties == 'all') return true;

  switch (property) {
    //add more here
    case 'visibility':
      property = 'v';
      break;

    case 'height':
      property = 'h';
      break;

    case 'width':
      property = 'w';
      break;

    case 'xPosition':
      property = 'hpos';
      break;

    case 'yPosition':
      property = 'ypos';
      break;

    case 'opacity':
      property = 'o';
      break;

    case 'lock':
      property = 'l';
      break;

    case 'rotation':
      property = 'r';
      break;

    default:
      break;
  }

  if (typeof prx.components[itemType] != 'undefined' && typeof prx.components[itemType].properties != 'undefined') {
    //ok we ve got a game
    if (prx.components[itemType].properties.length > 0) {
      if (prx.components[itemType].properties.split(',').indexOf(property) === -1) {
        return false; //not supported
      } else {
        return true; // supported component property
      }
    } else {
      return false;
    }
  }
};

prx.componentsHelper.resetDimensions = function (item, toDpr, doNotAppendHistory, callback) {
  if (doNotAppendHistory !== true) {
    doNotAppendHistory = false;
  }

  if (toDpr !== true) {
    toDpr = false;
  }

  switch (item.type) {
    case 'image':
    case 'vrimage':
      if (toDpr) {
        var multiplier = prx.imageFunctions.checkImageMultiplier(item);
        if (multiplier !== false) return prx.imageFunctions.resetdimensions(item, multiplier, doNotAppendHistory, callback);
      }

      return prx.imageFunctions.resetdimensions(item, 1, doNotAppendHistory, callback);
      break;

    case 'vectoranimation':
      if (toDpr) {
        var multiplier = prx.imageFunctions.checkImageMultiplier(item);
        if (multiplier !== false) return prx.bodymovinAnimation.resetDimensions(item, multiplier, doNotAppendHistory, callback);
      }

      return prx.bodymovinAnimation.resetDimensions(item, multiplier, doNotAppendHistory, callback);
      break;

    default:
      try {
        if (callback) {
          callback();
        }
      } catch (ex) {// set this try to catch cases that parameter that is not a function is passed
      }

  }
};

prx.componentsHelper.getTextandFontStylePropsName = function (itemType, propname, isDynProp) {
  var groupPropsSimplified;
  var groupProps = [];
  var relatedStyleProps = {
    relatedTextPropsName: false,
    relatedTextFontStylePropsName: false,
    relatedFontFamilyPropsName: false,
    textPropGroup: {},
    textFontStyleGroup: {},
    fontFamilyGroup: {}
  };

  if (typeof prx.types[itemType].propertyGroups != 'undefined') {
    if (isDynProp) {
      if (typeof prx.types[[itemType]].dynamicProperties !== 'undefined') {
        prx.types[itemType].dynamicProperties.propertyGroups.forEach(function (propertyGroup) {
          groupPropsSimplified = propertyGroup.properties.reduce(function (a, b) {
            return a.concat(b);
          });
          groupProps = groupProps.concat(groupPropsSimplified);
        });
      }
    } else {
      prx.types[itemType].propertyGroups.forEach(function (propertyGroup) {
        groupPropsSimplified = propertyGroup.properties.reduce(function (a, b) {
          return a.concat(b);
        });
        groupProps = groupProps.concat(groupPropsSimplified);
      });
    }

    if ((itemType == 'ios7_navbar_buttons' || itemType == 'ios7_navbar') && propname == 'title') {
      propname = 'text';
    }

    groupProps.forEach(function (prop) {
      // if (JSON.stringify(prop.relatedCSSProperties) == JSON.stringify(["font-weight", "font-style", "text-decoration"])
      //     && prop.type == "checkbox" && prop.name.indexOf('Style') > -1) {
      if (typeof prop.name != 'undefined') {
        if (prx.componentsHelper.fontStylePropExists(prop, propname)) {
          relatedStyleProps['textFontStyleGroup'] = prop;
          relatedStyleProps['relatedTextFontStylePropsName'] = prop.name; // } else if (JSON.stringify(prop.relatedCSSProperties) == JSON.stringify(["font-weight", "font-style"])
          //     && prop.type == "select" && prop.name.indexOf('FontStyle') > -1){
        } else if (prx.componentsHelper.textPropertiesPropExists(prop, propname)) {
          relatedStyleProps['textPropGroup'] = prop;
          relatedStyleProps['relatedTextPropsName'] = prop.name;
        } else if (prx.componentsHelper.fontFamilyPropExists(prop, propname)) {
          relatedStyleProps['fontFamilyGroup'] = prop;
          relatedStyleProps['relatedFontFamilyPropsName'] = prop.name;
        }
      }
    });
    return relatedStyleProps;
  } else {
    return relatedStyleProps;
  }
}; // propname sent should be the text prop. could be textProperties, durationProperties, subProperties, valueProperties e.t.c. We are looking for textFontStyle, durationFontStyle, subFontStyle, valueFontStyle
// you can also send textFont (font family property and will search based on that as well)


prx.componentsHelper.fontStylePropExists = function (prop, propname) {
  var propnameFromFontFamily = propname.toLowerCase();
  var propname = propname.replace('Properties', '').replace('FontStyle', '').toLowerCase(); //first case for textfields , textareas e.t.c which do not have relatededitableprops and relatedcssprops

  if (typeof prop.relatedCSSProperties == 'undefined' || typeof prop.relatedEditableProperties == 'undefined') {
    return prop.name.toLowerCase() == propname + 'fontstyle';
  } else {
    return JSON.stringify(prop.relatedCSSProperties) == JSON.stringify(["font-weight", "font-style"]) && prop.type == "select" && (prop.name.toLowerCase() == propname + 'fontstyle' || prop.name.toLowerCase() == propnameFromFontFamily + 'style');
  }
}; // propname sent should be the fontStyle prop. could be textFontStyle, durationFontStyle, subFontStyle, valueFontstyle e.t.c We are looking for textProperties, durationProperties, subProperties, valueProperties


prx.componentsHelper.textPropertiesPropExists = function (prop, propname) {
  var propname = propname.replace('FontStyle', '').replace('Properties', '').toLowerCase(); //first case for textfields , textareas e.t.c which do not have relatededitableprops and relatedcssprops

  if (typeof prop.relatedCSSProperties == 'undefined' || typeof prop.relatedEditableProperties == 'undefined') {
    return prop.name.toLowerCase() == propname + 'properties';
  } else {
    return (JSON.stringify(prop.relatedCSSProperties) == JSON.stringify(["font-weight", "font-style", "text-decoration"]) || JSON.stringify(prop.relatedCSSProperties) == JSON.stringify(["text-decoration"])) && prop.type == "checkbox" && prop.name.toLowerCase() == propname + 'properties';
  }
}; // propname sent should be the fontStyle prop. could be textFontStyle, durationFontStyle, subFontStyle, valueFontstyle e.t.c We are looking for textFont, durationFont, subFont, valueFont


prx.componentsHelper.fontFamilyPropExists = function (prop, propname) {
  var propname = propname.replace('Properties', '').replace('FontStyle', '').toLowerCase(); //first case for textfields , textareas e.t.c which do not have relatededitableprops and relatedcssprops

  if (typeof prop.relatedCSSProperties == 'undefined' || typeof prop.relatedEditableProperties == 'undefined') {
    return prop.name.toLowerCase() == propname + 'font';
  } else {
    return JSON.stringify(prop.relatedCSSProperties) == JSON.stringify("font-family") && prop.type == "select" && prop.name.toLowerCase() == propname + 'font';
  }
}; // is this a fontstyle property object


prx.componentsHelper.isFontStyleProp = function (prop) {
  if (prop.name.substr(-9) == 'FontStyle') {
    return true;
  } else {
    return JSON.stringify(prop.relatedCSSProperties) == JSON.stringify(["font-weight", "font-style"]) && prop.type == "select";
  }
}; // is this a text properties property object


prx.componentsHelper.isTextPropertiesProp = function (prop) {
  if (prop.name.substr(-10) == 'Properties') {
    return true;
  } else {
    return JSON.stringify(prop.relatedCSSProperties) == JSON.stringify(["font-weight", "font-style", "text-decoration"]) && prop.type == "checkbox";
  }
}; // is this a font family property object


prx.componentsHelper.isFontFamilyProp = function (prop) {
  if (prop.name.toLowerCase().indexOf('font-family') > -1) {
    return true;
  } else {
    return JSON.stringify(prop.relatedCSSProperties) == JSON.stringify("font-family") && prop.type == "select";
  }
};

prx.componentsHelper.hasThumbnails = function (list) {
  var hasThumbnails = false;

  if (list.listitems) {
    list.listitems.forEach(function (item) {
      if (item.thumbnail && item.thumbnail.fileId != '') hasThumbnails = true;
    });
  }

  return hasThumbnails;
};

prx.componentsHelper.hasIcons = function (list) {
  var hasIcons = false;

  if (list.listitems) {
    list.listitems.forEach(function (item) {
      if (item.imgSrc && item.imgSrc.fileId != '') hasIcons = true;
    });
  }

  return hasIcons;
};

prx.componentsHelper.getFontStyleValueFromTextProperties = function (textPropertiesValue) {
  var fontStyleValue = '';
  if (textPropertiesValue === undefined || !$.isArray(textPropertiesValue)) return '';

  if (textPropertiesValue.indexOf('bold') > -1) {
    fontStyleValue += '700';
  } else {
    fontStyleValue += '400';
  }

  if (textPropertiesValue.indexOf('italic') > -1) {
    fontStyleValue += 'italic';
  }

  return fontStyleValue;
};

prx.componentsHelper.getFontFamilyType = function (fontFamilyValue) {
  var defaultFontsWithFontStyle = ['Roboto, sans-serif', 'HelveticaNeue, Helvetica, Verdana, Arial, sans-serif', 'Impact,sans-serif', 'Arial Black,sans-serif'];
  var appleFonts = ['San Francisco Pro Display', 'San Francisco Pro Text', 'San Francisco Compact Display', 'San Francisco Compact Text'];
  var customFonts = [];

  prx.fonts._fonts.forEach(function (font) {
    customFonts.push(font['displayValue']);
  });

  if (defaultFontsWithFontStyle.indexOf(fontFamilyValue) > -1) {
    return {
      type: 'default',
      fontstylesupport: true
    };
  } else if (appleFonts.indexOf(fontFamilyValue) > -1) {
    return {
      type: 'apple',
      fontstylesupport: true
    };
  } else if (customFonts.indexOf(fontFamilyValue) > -1) {
    return {
      type: 'custom',
      fontstylesupport: true
    };
  } else {
    return {
      type: 'default',
      fontstylesupport: false
    };
  }
};

prx.componentsHelper.isValidFontWeightValue = function (fontWeight) {
  if (fontWeight == 'bold') {
    return true;
  } else {
    fontWeight = parseInt(fontWeight, 10);
    if (isNaN(fontWeight) || fontWeight == null) return false;
  }

  return true;
}; //value: false | true


prx.componentsHelper.setAutoresizeValue = function (item, containerid, symbol, value) {
  if (prx.editor) {
    if (value) {
      item.autoResize = Boolean(value);
      $('#' + item.id).find('[data-editableproperty=text]').addClass('autoresize').addClass('autoResize-true');
      $('#radioSwitcher_p-' + item.id + '-autoResize_false').val(false).prop('checked', false);
      $('#radioSwitcher_p-' + item.id + '-autoResize_true').val(true).prop('checked', true);
    } else {
      item.autoResize = Boolean(value);
      $('#' + item.id).find('[data-editableproperty=text]').removeClass('autoresize').removeClass('autoResize-true');
      $('#radioSwitcher_p-' + item.id + '-autoResize_true').val(false).prop('checked', false);
      $('#radioSwitcher_p-' + item.id + '-autoResize_false').val(true).prop('checked', true);
    }
  }
};

prx.componentsHelper.maskImageFixForSafari11 = function (asset) {
  if (prx.export2html && typeof asset.fileId != 'undefined' && typeof prx.mask.images != 'undefined' && typeof prx.mask.images[asset.fileId] != 'undefined') {
    return prx.mask.images[asset.fileId];
  } else {
    var url = prx.componentsHelper.getProp(asset, 'asset');

    if (typeof prx.export2html != 'undefined' && prx.export2html == 0 && prx.utils.isSafariV1111orGreater() || typeof prx.export2html == 'undefined' && prx.utils.isSafariV1111orGreater()) {
      if (url.indexOf('?') === -1) {
        url += '?v=' + Math.floor(Math.random() * 1000000000 + 1);
      } else {
        url += '&v=' + Math.floor(Math.random() * 1000000000 + 1);
      }
    }

    return url;
  }
};

prx.componentsHelper.stripStyle = function (text, style, isTextFontStyleProperties, includeList) {
  var stylesData = {
    "bold": {
      regex: /(<strong>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(font-weight(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/strong>)|(<strong)/gi,
      startingTag: "<strong"
    },
    "italic": {
      regex: /(<em>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(font-style(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/em>)|(<em)/gi,
      startingTag: "<em"
    },
    "underline": {
      regex: /(<u>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(text-decoration(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/u>)|(<u)/gi,
      startingTag: "<u"
    },
    "color": {
      regex: /(<span\s+[^>]*?\s*style\s*=\s*(?:\'|")(?:\S+\s+)?color(?:\s+\S+)?\1[^>]*>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(color(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/span>)|(<span)/gi,
      startingTag: "<span"
    },
    "letter-spacing": {
      regex: /(<span\s+[^>]*?\s*style\s*=\s*(?:\'|")(?:\S+\s+)?letter-spacing(?:\s+\S+)?\1[^>]*>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(letter-spacing(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/span>)|(<span)/gi,
      startingTag: "<span"
    },
    "line-height": {
      regex: /(<span\s+[^>]*?\s*style\s*=\s*(?:\'|")(?:\S+\s+)?line-height(?:\s+\S+)?\1[^>]*>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(line-height(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/span>)|(<span)/gi,
      startingTag: "<span"
    },
    "font-size": {
      regex: /(<span\s+[^>]*?\s*style\s*=\s*(?:\'|")(?:\S+\s+)?font-size(?:\s+\S+)?\1[^>]*>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(font-size(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/span>)|(<span)/gi,
      startingTag: "<span"
    },
    "font-family": {
      regex: /(<span\s+[^>]*?\s*style\s*=\s*(?:\'|")(?:\S+\s+)?font-family(?:\s+\S+)?\1[^>]*>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(font-family(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/span>)|(<span)/gi,
      startingTag: "<span"
    },
    "font-weight": {
      regex: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?((font-weight)(?:\s+\S+)?\1[^;"]*;?)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?((font-weight)(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/span>)|(<span)/gi,
      startingTag: "<span"
    },
    "font-style": {
      regex: /(<span\s+[^>]*?\s*style\s*=\s*(?:\'|")(?:\S+\s+)?font-style(?:\s+\S+)?\1[^>]*>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(font-style(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/span>)|(<span)/gi,
      startingTag: "<span"
    },
    "text-align": {
      regex: /(<div\s+[^>]*?\s*style\s*=\s*(?:\'|")(?:\S+\s+)?text-align(?:\s+\S+)?\1[^>]*>)/gi,
      regexB: /[<span|<u|<em|<div|<p]\s+[^>]*?\s*style="[\s\S+]*?(text-align(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/div>)|(<div)/gi,
      startingTag: "<div"
    },
    "custom-selection": {
      regex: /(<em\s+[^>]*?\s*class\s*=\s*(?:\'|")(?:\S+\s+)?custom-selection(?:\s+\S+)?\1[^>]*>)/gi,
      regexB: /[<span|<u|<em|<div|<p|<em]\s+[^>]*?\s*class="[\s\S+]*?(custom-selection(?:\s+\S+)?\1[^;"]*;?)/gi,
      tags: /(<\/em>)|(<em)/gi,
      startingTag: "<em"
    }
  };
  var emptyTagStylesData = {
    span: {
      regex: /((?:<span)(?:\s+[^>]*?\s*style\s*=[\s*;"]*>)|(<span>))/gi,
      tags: /(<\/span>)|(<span)/gi,
      startingTag: "<span"
    },
    div: {
      regex: /((?:<div)(?:\s+[^>]*?\s*style\s*=[\s*;"]*>)|(<div>))/gi,
      tags: /(<\/div>)|(<div)/gi,
      startingTag: "<div"
    },
    p: {
      regex: /((?:<p)(?:\s+[^>]*?\s*style\s*=[\s*;"]*>)|(<p>))/gi,
      tags: /(<\/p>)|(<p)/gi,
      startingTag: "<p"
    },
    em: {
      regex: /((?:<em)(?:\s+[^>]*?\s*style\s*=[\s*;"]*>)|(<em>))/gi,
      tags: /(<\/em>)|(<em)/gi,
      startingTag: "<em"
    }
  };

  if (typeof isTextFontStyleProperties !== "undefined" && isTextFontStyleProperties) {
    style = ["font-weight", "font-style"];

    for (var i = 0; i < style.length; i++) {
      text = stripTheStyles(text, style[i], includeList);
    }
  } else {
    text = stripTheStyles(text, style, includeList);
  }

  return text;

  function stripTheStyles(text, style, includeList) {
    var m;
    var strippedText = text;

    while ((m = stylesData[style]["regexB"].exec(text)) !== null) {
      if (m.index === stylesData[style]["regexB"].lastIndex) {
        stylesData[style]["regexB"].lastIndex++;
      }

      if (typeof includeList != 'undefined') {
        for (var c = 0; c < includeList.length; c++) {
          if (prx.componentsHelper.getFontFamilyFromCSS(m[1].replace('font-family:', '')) == includeList[c]) {
            strippedText = strippedText.replace(m[1], "");
          } // else {
          // 	console.log('not included')
          // }

        }
      } else {
        strippedText = strippedText.replace(m[1], "");
      }
    } //STEP 1.1 in case of bold or italic or underline replace them with span so that we dont delete cases of <em style="font-weight:600">...</em>
    //Instead they will be converted to <span style="font-weight:600">...</span>


    if (style == "bold") {
      var strongOpening = /(<strong)/gi;
      var strongClosing = /<\/strong>/gi;
      strippedText = strippedText.replace(strongOpening, "<span");
      strippedText = strippedText.replace(strongClosing, "</span>");
    }

    if (style == "italic") {
      var italicOpening = /(<em)/gi;
      var italicClosing = /<\/em>/gi;
      strippedText = strippedText.replace(italicOpening, "<span");
      strippedText = strippedText.replace(italicClosing, "</span>");
    }

    if (style === "font-weight") {
      var strongOpening = /(<strong)/gi;
      var strongClosing = /<\/strong>/gi;
      strippedText = strippedText.replace(strongOpening, "<span");
      strippedText = strippedText.replace(strongClosing, "</span>");
    }

    if (style === "font-style") {
      var strongOpening = /(<em)/gi;
      var strongClosing = /<\/em>/gi;
      strippedText = strippedText.replace(strongOpening, "<span");
      strippedText = strippedText.replace(strongClosing, "</span>");
    }

    if (style == "underline") {
      var strongOpening = /(<u)/gi;
      var strongClosing = /<\/u>/gi;
      strippedText = strippedText.replace(strongOpening, "<span");
      strippedText = strippedText.replace(strongClosing, "</span>");
    } //STEP 2: Fix cases of <em|strong|u style="">Hello World</em> by replacing it with <em|strong|u>Hello World</em|strong|u>
    //var emptyEMUSTRONGRegex = /((<em|<u|<strong|<span|<div|<p)(?:\s+[^>]*?\s*style\s*=[\s*;"]*)>)/gi;


    var emptyEMUSTRONGRegex = /((<em|<u|<strong|<span|<div|<p)(?:\s+[^>]*?\s*[style|class]\s*=[\s*;"]*)>)/gi;
    var lm;
    var strippedTextB = strippedText;

    while ((lm = emptyEMUSTRONGRegex.exec(strippedText)) !== null) {
      if (lm.index === emptyEMUSTRONGRegex.lastIndex) {
        emptyEMUSTRONGRegex.lastIndex++;
      }

      var replaceWith = lm[2] + ">";
      strippedTextB = strippedTextB.replace(lm[1], replaceWith);
    } //STEP 3: Fix cases of <span|div|p style="">Hello World</em> by replacing it with 'Hello World'


    var emptyTagsArray = ["span", "div", "p"];

    for (var i = 0; i < emptyTagsArray.length; i++) {
      strippedTextB = _stripTheTags(strippedTextB, emptyTagsArray[i], true);
    }

    return strippedTextB;
  } //Inner function


  function _stripTheTags(_text, _style, _checkForEmptyTags) {
    if (_checkForEmptyTags) {
      var myRegex = emptyTagStylesData[_style]["regex"];
      var spansRegex = emptyTagStylesData[_style]["tags"];
      var startingTag = emptyTagStylesData[_style]["startingTag"];
    } else {
      var myRegex = stylesData[_style]["regex"];
      var spansRegex = stylesData[_style]["tags"];
      var startingTag = stylesData[_style]["startingTag"];
    }

    var matches = [];
    var toRemove = [];
    var res, count, styleMatch;

    while (res = spansRegex.exec(_text)) {
      //Find all spans beginning and ending and pushing to array (in the right order)
      matches.push({
        text: res[0],
        index: res.index
      });
    }

    while (styleMatch = myRegex.exec(_text)) {
      //looking for style match with regex
      toRemove.push({
        index: styleMatch.index,
        length: styleMatch[0].length
      }); //placing strings that we want to remove in the 'toRemove'

      count = 0;

      for (var i = 0; i < matches.length; i++) {
        //looping all found opening and closing tags
        if (matches[i].index <= styleMatch.index) //before the fontsize span or in case it is equal it is the actual font size span
          continue; //skip it

        if (matches[i].text === startingTag) //
          count++;else count--;
        if (count < 0) break;
      }

      if (matches[i] === undefined) {
        //not euqal number of opening and closing tags
        // bad html
        toRemove.pop();
        continue;
      }

      if (matches[i].text === startingTag) {
        //if found and it is an opening tag we have a problem
        // MAJOR problem
        toRemove.pop();
        continue;
      }

      toRemove.push({
        index: matches[i].index,
        length: matches[i].text.length
      }); //Match! Closing tag, where it starts and length
      //while continous since you may find more font size spans
    }

    toRemove.sort(function (a, b) {
      //sorting because we want to start removing from the end, since in other case we are goind to break the indexes
      if (a.index < b.index) //first is the one with the highest index
        return 1;
      return -1;
    });

    for (var i = 0; i < toRemove.length; i++) {
      //remove = getting text before the index of the span, getting text after span
      _text = _text.substring(0, toRemove[i].index) + _text.substring(toRemove[i].index + toRemove[i].length);
    }

    return _text;
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/common/js/prx/components/_cross-msg.js":
/*!*****************************************************!*\
  !*** ./sass/common/js/prx/components/_cross-msg.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.crossmsg = {};

prx.crossmsg.ini = function () {
  window.addEventListener('message', function (event) {
    if (!prx.crossmsg.checkrequestdomain(event)) return;
    prx.crossmsg.onmsg(event.data);
  }, false);
};

prx.crossmsg.getdomain = function () {
  if (prx.export2html) return '*';
  return prx.url.crossmsg;
};

prx.crossmsg.checkrequestdomain = function (event) {
  var origin = event.origin || event.originalEvent.origin;
  if (!prx.export2html && origin == prx.url.crossmsg) return true;
  if (prx.export2html) return true;
  return false;
};

prx.crossmsg.send = function (msg) {
  prx.crossmsg.gettargetframe().postMessage(msg, prx.crossmsg.getdomain());
};

/***/ }),

/***/ "./sass/common/js/prx/components/_css.js":
/*!***********************************************!*\
  !*** ./sass/common/js/prx/components/_css.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.css = {};

prx.css.RGBA = function (color, offset, alpha) {
  if (typeof alpha == "undefined") {
    alpha = 1;
  }

  var _r = parseInt(color.substr(0, 2), 16);

  var _g = parseInt(color.substr(2, 2), 16);

  var _b = parseInt(color.substr(4, 2), 16);

  return "rgba(" + Math.round(_r + offset) + "," + Math.round(_g + offset) + "," + Math.round(_b + offset) + ", " + alpha + ")";
}; // -moz type direction needed.


prx.css.gradient = function (colorStops, direction) {
  if (typeof direction == "undefined") {
    direction = 'to center bottom';
  }

  var cR = '';
  var _moz = '-moz-linear-gradient(';
  var _webkit = '-webkit-gradient(';
  var _standard = 'linear-gradient(';

  switch (direction) {
    case 'to center bottom':
      _moz += 'center top';
      _webkit += 'linear, left top, left bottom';
      _standard += 'to center bottom';
      break;

    case 'to center top':
      _moz += 'center bottom';
      _webkit += 'linear, left bottom, left top';
      _standard += 'to center top';
      break;

    case 'to right center':
      _moz += 'left center';
      _webkit += 'linear, left top, right top';
      _standard += 'to right center';
      break;

    case 'to left center':
      _moz += 'right center';
      _webkit += 'linear, right top, left top';
      _standard += 'to left center';
      break;

    /*case '45deg':
     _webkit += 'linear, left bottom, right top';
     break;
     case '-45deg':
     _webkit += 'linear, left top, right bottom';
     break;
     case '135deg':
     _webkit += 'linear, right bottom, left top';
     break;
     case '-135deg':
     _webkit += 'linear, right top, left bottom';
     break;
     */

    case '45deg':
      _moz += '45deg';
      _webkit += 'linear, left bottom, right top';
      _standard += direction;
      break;

    case '135deg':
      _moz += '-45deg';
      _webkit += 'linear, left top, right bottom';
      _standard += direction;
      break;

    case '-45deg':
      _moz += '135deg';
      _webkit += 'linear, right bottom, left top';
      _standard += direction;
      break;

    case '225deg':
      _moz += '-135deg';
      _webkit += 'linear, right top, left bottom';
      _standard += direction;
      break;
  }

  for (var i = 0; i < colorStops.length; i++) {
    _moz += ", " + colorStops[i].c + " " + colorStops[i].p + "%";
    _webkit += ", color-stop(" + colorStops[i].p / 100 + ", " + colorStops[i].c + ")";
    _standard += ", " + colorStops[i].c + " " + colorStops[i].p + "%";
  } // for browsers not supporting gradients, background will be the first colorStop.


  cR += 'background: ' + colorStops[0].c + '; ';
  cR += 'background-image: ' + _moz + '); ';
  cR += 'background-image: ' + _webkit + '); ';
  cR += 'background-image: ' + _standard + '); ';
  return cR;
};

prx.css.borderRadius = function (value) {
  if ($.isArray(value) && value.length == 4) {
    cR = "";

    if (value[0] != null) {
      cR += 'border-top-left-radius: ' + value[0] + 'px; ';
    }

    if (value[1] != null) {
      cR += 'border-top-right-radius: ' + value[1] + 'px; ';
    }

    if (value[2] != null) {
      cR += 'border-bottom-right-radius: ' + value[2] + 'px; ';
    }

    if (value[3] != null) {
      cR += 'border-bottom-left-radius: ' + value[3] + 'px; ';
    }

    return cR;
  }

  return 'border-radius: ' + value + ';';
};

prx.css.boxShadow = function (shadows) {
  if (!$.isArray(shadows)) {
    shadows = [shadows];
  }

  var _moz = '-moz-box-shadow: ';
  var _webkit = '-webkit-box-shadow: ';
  var _normal = 'box-shadow: ';
  cR = '';

  for (var i = 0; i < shadows.length; i++) {
    if (i > 0) {
      _moz += ", ";
      _webkit += ", ";
      _normal += ", ";
    }

    _moz += shadows[i];
    _webkit += shadows[i];
    _normal += shadows[i];
    cR += _moz + "; " + _webkit + "; " + _normal + "; ";
  }

  return cR;
};

prx.css.flexJustifyContent = function (dir) {
  var olddir = '';

  switch (dir) {
    case "left":
      dir = "flex-start";
      olddir = 'start';
      break;

    case "right":
      dir = "flex-end";
      olddir = 'end';
      break;

    default:
      olddir = 'center';
  }

  var cR = '';
  cR += '-ms-justify-content: ' + dir + ';';
  cR += '-webkit-justify-content: ' + dir + ';';
  cR += 'justify-content: ' + dir + ';';
  cR += '-ms-box-pack: ' + olddir + ';';
  cR += '-webkit-box-pack: ' + olddir + ';';
  cR += 'box-pack: ' + olddir + ';';
  cR += '-ms-flex-pack: ' + olddir + ';';
  cR += '-webkit-flex-pack: ' + olddir + ';';
  cR += 'flex-pack: ' + olddir + ';';
  /*
  cR += '-webkit-box-pack: '+olddir+';';
  cR += '-ms-justify-content: ' + dir + ';';
  cR += '-webkit-justify-content: ' + dir + ';';
  cR += 'justify-content: ' + dir + ';';
  */

  return cR;
};

prx.css.flexAlignContent = function (dir) {
  var olddir = '';

  switch (dir) {
    case "left":
      dir = "flex-start";
      olddir = 'start';
      break;

    case "right":
      dir = "flex-end";
      olddir = 'end';
      break;

    default:
      olddir = 'center';
  }

  var cR = '';
  cR += '-ms-align-items: ' + dir + ';';
  cR += '-webkit-align-items: ' + dir + ';';
  cR += 'align-items: ' + dir + ';';
  cR += ' -ms-box-align: ' + olddir + ';';
  cR += '-webkit-box-align: ' + olddir + ';';
  cR += 'box-align: ' + olddir + ';';
  cR += '-ms-flex-align: ' + olddir + ';';
  cR += '-webkit-flex-align: ' + olddir + ';';
  cR += 'flex-align: ' + olddir + ';';
  /*
  cR += '-webkit-flex-align: '+olddir+';';
  cR += '-ms-flex-align: ' + dir + ';';
  cR += '-webkit-align-items: ' + dir + ';';
  cR += 'align-items: ' + dir + ';';
  */

  return cR;
};

prx.css.flexJustifyGrow = function (grow) {
  var cR = '';
  cR += '-webkit-box-flex: ' + grow + ';';
  cR += '-ms-flex-grow: ' + grow + ';';
  cR += '-webkit-flex-grow: ' + grow + ';';
  cR += 'flex-grow: ' + grow + ';';
  return cR;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/common/js/prx/components/_easing.js":
/*!**************************************************!*\
  !*** ./sass/common/js/prx/components/_easing.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var _prx$easing$_easingMa, _prx$easing$_easingMa2, _prx$easing$_easingDe;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

prx.easing = {};
prx.easing._customEasings = {}; // in case you update you also need to update copy between projects app.js****

prx.easing._customEasingsColors = ["#FF90D4", "#FFD02A", "#A98BE0", "#00E2FF", "#A2E555", "#A9948C", "#5CB4FA", "#FE7775", "#BD59E4", "#46CFB5"];
prx.easing._easingMappings = (_prx$easing$_easingMa = {
  'linear': 'Linear.easeNone',
  'Linear.easeNone': 'Linear.easeNone',
  'ease': 'Quad.easeInOut',
  'Linear.ease': 'Quad.easeInOut',
  'Quad.ease': 'Quad.easeInOut',
  'in': 'Quad.easeIn',
  'Linear.easeIn': 'Quad.easeIn',
  'Quad.easeIn': 'Quad.easeIn',
  'out': 'Quad.easeOut',
  'Linear.easeOut': 'Quad.easeOut',
  'Quad.easeOut': 'Quad.easeOut',
  'in-out': 'Quad.easeInOut',
  'Linear.easeInOut': 'Quad.easeInOut',
  'Quad.easeInOut': 'Quad.easeInOut',
  'swing': 'Quad.easeInOut'
}, _defineProperty(_prx$easing$_easingMa, "Linear.easeInOut", 'Quad.easeInOut'), _defineProperty(_prx$easing$_easingMa, "Quad.easeInOut", 'Quad.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'snap', 'Strong.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Strong.easeOut', 'Strong.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Cubic.easeIn', 'Cubic.easeIn'), _defineProperty(_prx$easing$_easingMa, 'Cubic.easeOut', 'Cubic.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Cubic.easeInOut', 'Cubic.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'Quart.easeIn', 'Quart.easeIn'), _defineProperty(_prx$easing$_easingMa, 'Quart.easeOut', 'Quart.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Quart.easeInOut', 'Quart.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'Quint.easeIn', 'Quint.easeIn'), _defineProperty(_prx$easing$_easingMa, 'Quint.easeOut', 'Quint.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Quint.easeInOut', 'Quint.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'Circ.easeIn', 'Circ.easeIn'), _defineProperty(_prx$easing$_easingMa, 'Circ.easeOut', 'Circ.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Circ.easeInOut', 'Circ.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'Back.easeIn', 'Back.easeIn'), _defineProperty(_prx$easing$_easingMa, 'Back.easeOut', 'Back.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Back.easeInOut', 'Back.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'Bounce.easeIn', 'Bounce.easeIn'), _defineProperty(_prx$easing$_easingMa, 'Bounce.easeOut', 'Bounce.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Bounce.easeInOut', 'Bounce.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'Elastic.easeIn', 'Elastic.easeIn'), _defineProperty(_prx$easing$_easingMa, 'Elastic.easeOut', 'Elastic.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Elastic.easeInOut', 'Elastic.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'Expo.easeIn', 'Expo.easeIn'), _defineProperty(_prx$easing$_easingMa, 'Expo.easeOut', 'Expo.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Expo.easeInOut', 'Expo.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'Sine.easeIn', 'Sine.easeIn'), _defineProperty(_prx$easing$_easingMa, 'Sine.easeOut', 'Sine.easeOut'), _defineProperty(_prx$easing$_easingMa, 'Sine.easeInOut', 'Sine.easeInOut'), _defineProperty(_prx$easing$_easingMa, 'springrk4', 'springrk4'), _prx$easing$_easingMa);
prx.easing._easingMappingsReverse = (_prx$easing$_easingMa2 = {
  'linear': 'Linear.easeNone',
  'Linear.easeNone': 'Linear.easeNone',
  'ease': 'Quad.easeInOut',
  'Linear.ease': 'Quad.easeInOut',
  'in': 'Quad.easeOut',
  'Quad.easeIn': 'Linear.easeOut',
  'out': 'Quad.easeIn',
  'Quad.easeOut': 'Linear.easeIn',
  'in-out': 'Quad.easeInOut',
  'Linear.easeInOut': 'Quad.easeInOut',
  'swing': 'Quad.easeInOut'
}, _defineProperty(_prx$easing$_easingMa2, "Linear.easeInOut", 'Quad.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'snap', 'Strong.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Strong.easeOut', 'Strong.easeIn'), _defineProperty(_prx$easing$_easingMa2, "Quad.easeIn", 'Quad.easeOut'), _defineProperty(_prx$easing$_easingMa2, "Quad.easeOut", 'Quad.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Quad.easeInOut', 'Quad.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Quad.ease', 'Quad.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Cubic.easeIn', 'Cubic.easeOut'), _defineProperty(_prx$easing$_easingMa2, 'Cubic.easeOut', 'Cubic.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Cubic.easeInOut', 'Cubic.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Quart.easeIn', 'Quart.easeOut'), _defineProperty(_prx$easing$_easingMa2, 'Quart.easeOut', 'Quart.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Quart.easeInOut', 'Quart.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Quint.easeIn', 'Quint.easeOut'), _defineProperty(_prx$easing$_easingMa2, 'Quint.easeOut', 'Quint.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Quint.easeInOut', 'Quint.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Circ.easeIn', 'Circ.easeOut'), _defineProperty(_prx$easing$_easingMa2, 'Circ.easeOut', 'Circ.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Circ.easeInOut', 'Circ.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Back.easeIn', 'Back.easeOut'), _defineProperty(_prx$easing$_easingMa2, 'Back.easeOut', 'Back.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Back.easeInOut', 'Back.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Bounce.easeIn', 'Bounce.easeOut'), _defineProperty(_prx$easing$_easingMa2, 'Bounce.easeOut', 'Bounce.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Bounce.easeInOut', 'Bounce.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Elastic.easeIn', 'Elastic.easeOut'), _defineProperty(_prx$easing$_easingMa2, 'Elastic.easeOut', 'Elastic.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Elastic.easeInOut', 'Elastic.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Expo.easeIn', 'Expo.easeOut'), _defineProperty(_prx$easing$_easingMa2, 'Expo.easeOut', 'Expo.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Expo.easeInOut', 'Expo.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'Sine.easeIn', 'Sine.easeOut'), _defineProperty(_prx$easing$_easingMa2, 'Sine.easeOut', 'Sine.easeIn'), _defineProperty(_prx$easing$_easingMa2, 'Sine.easeInOut', 'Sine.easeInOut'), _defineProperty(_prx$easing$_easingMa2, 'springrk4', 'springrk4'), _prx$easing$_easingMa2);
prx.easing._easingDescriptionMappings = (_prx$easing$_easingDe = {
  'linear': 'Linear',
  'Linear.easeNone': 'Linear',
  'ease': 'Ease in-out - Quad',
  'Linear.ease': 'Ease in-out - Quad',
  'Quad.ease': 'Ease in-out - Quad',
  'in': 'Ease in - Quad',
  'Linear.easeIn': 'Ease in - Quad',
  'Quad.easeIn': 'Ease in - Quad',
  'out': 'Ease out - Quad',
  'Linear.easeOut': 'Ease out - Quad',
  'Quad.easeOut': 'Ease out - Quad',
  'in-out': 'Ease in-out - Quad',
  'Linear.easeInOut': 'Ease in-out - Quad',
  'Quad.easeInOut': 'Ease in-out - Quad',
  'swing': 'Ease in-out - Quad'
}, _defineProperty(_prx$easing$_easingDe, "Linear.easeInOut", 'Ease in-out - Quad'), _defineProperty(_prx$easing$_easingDe, "Quad.easeInOut", 'Ease in-out - Quad'), _defineProperty(_prx$easing$_easingDe, 'snap', 'Ease out - Strong'), _defineProperty(_prx$easing$_easingDe, 'Strong.easeOut', 'Ease out - Strong'), _defineProperty(_prx$easing$_easingDe, 'Cubic.easeIn', 'Ease in - Cubic'), _defineProperty(_prx$easing$_easingDe, 'Cubic.easeOut', 'Ease out - Cubic'), _defineProperty(_prx$easing$_easingDe, 'Cubic.easeInOut', 'Ease in-out - Cubic'), _defineProperty(_prx$easing$_easingDe, 'Quart.easeIn', 'Ease in - Quart'), _defineProperty(_prx$easing$_easingDe, 'Quart.easeOut', 'Ease out - Quart'), _defineProperty(_prx$easing$_easingDe, 'Quart.easeInOut', 'Ease in-out - Quart'), _defineProperty(_prx$easing$_easingDe, 'Quint.easeIn', 'Ease in - Quint'), _defineProperty(_prx$easing$_easingDe, 'Quint.easeOut', 'Ease out - Quint'), _defineProperty(_prx$easing$_easingDe, 'Quint.easeInOut', 'Ease in-out - Quint'), _defineProperty(_prx$easing$_easingDe, 'Circ.easeIn', 'Ease in - Circ'), _defineProperty(_prx$easing$_easingDe, 'Circ.easeOut', 'Ease out - Circ'), _defineProperty(_prx$easing$_easingDe, 'Circ.easeInOut', 'Ease in-out - Circ'), _defineProperty(_prx$easing$_easingDe, 'Back.easeIn', 'Ease in - Back'), _defineProperty(_prx$easing$_easingDe, 'Back.easeOut', 'Ease out - Back'), _defineProperty(_prx$easing$_easingDe, 'Back.easeInOut', 'Ease in-out - Back'), _defineProperty(_prx$easing$_easingDe, 'Bounce.easeIn', 'Ease in - Bounce'), _defineProperty(_prx$easing$_easingDe, 'Bounce.easeOut', 'Ease out - Bounce'), _defineProperty(_prx$easing$_easingDe, 'Bounce.easeInOut', 'Ease in-out - Bounce'), _defineProperty(_prx$easing$_easingDe, 'Elastic.easeIn', 'Ease in - Elastic'), _defineProperty(_prx$easing$_easingDe, 'Elastic.easeOut', 'Ease out - Elastic'), _defineProperty(_prx$easing$_easingDe, 'Elastic.easeInOut', 'Ease in-out - Elastic'), _defineProperty(_prx$easing$_easingDe, 'Expo.easeIn', 'Ease in - Expo'), _defineProperty(_prx$easing$_easingDe, 'Expo.easeOut', 'Ease out - Expo'), _defineProperty(_prx$easing$_easingDe, 'Expo.easeInOut', 'Ease in-out - Expo'), _defineProperty(_prx$easing$_easingDe, 'Sine.easeIn', 'Ease in - Sine'), _defineProperty(_prx$easing$_easingDe, 'Sine.easeOut', 'Ease out - Sine'), _defineProperty(_prx$easing$_easingDe, 'Sine.easeInOut', 'Ease in-out - Sine'), _defineProperty(_prx$easing$_easingDe, 'springrk4', 'Spring rk4'), _defineProperty(_prx$easing$_easingDe, 'cubicbezier', 'Cubic-Bezier'), _prx$easing$_easingDe);

prx.easing.getEasingDescriptionForTimeline = function (value) {
  if (typeof value == "undefined") return "";

  if (typeof prx.easing._easingDescriptionMappings[value] !== "undefined") {
    return prx.easing._easingDescriptionMappings[value];
  } else {
    if (value.indexOf("springrk4(") > -1) {
      return value.replace("springrk4", "Spring RK4");
    } else if (value.indexOf("cubic-bezier(") > -1) {
      return value.replace("cubic-bezier", "Cubic Bezier");
    } else if (value === "broken") {
      return "No common easing";
    }
  }

  return value;
}; //
// prx.easing._easingDescriptionMappings = {
//     'linear':'Linear','Linear.easeNone':'Linear'
//     ,'ease':'Ease in-out - Quad','Linear.ease':'Ease in-out - Quad','Quad.ease':'Ease in-out - Quad'
//     ,'in':'Ease in - Quad','Linear.easeIn':'Ease in - Quad','Quad.easeIn':'Ease in - Quad'
//     ,'out':'Ease out - Quad','Linear.easeOut':'Ease out - Quad','Quad.easeOut':'Ease out - Quad'
//     ,'in-out':'Ease in-out - Quad','Linear.easeInOut':'Ease in-out - Quad','Quad.easeInOut':'Ease in-out - Quad'
//     ,'swing':'Ease in-out - Quad','Linear.easeInOut':'Ease in-out - Quad','Quad.easeInOut':'Ease in-out - Quad'
//     ,'snap':'Ease out - Strong','Strong.easeOut':'Ease out - Strong'
//     ,'Cubic.easeIn':'Ease in - Cubic','Cubic.easeOut':'Ease out - Cubic','Cubic.easeInOut':'Ease in-out - Cubic'
//     ,'Quart.easeIn':'Ease in - Quart','Quart.easeOut':'Ease out - Quart','Quart.easeInOut':'Ease in-out - Quart'
//     ,'Quint.easeIn':'Ease in - Quint','Quint.easeOut':'Ease out - Quint','Quint.easeInOut':'Ease in-out - Quint'
//     ,'Circ.easeIn':'Ease in - Circ','Circ.easeOut':'Ease out - Circ','Circ.easeInOut':'Ease in-out - Quart'
//     ,'Back.easeIn':'Ease in - Back','Back.easeOut':'Ease out - Back','Back.easeInOut':'Ease in-out - Back'
//     ,'Bounce.easeIn':'Ease in - Bounce','Bounce.easeOut':'Ease out - Bounce','Bounce.easeInOut':'Ease in-out - Bounce'
//     ,'Elastic.easeIn':'Ease in - Elastic','Elastic.easeOut':'Ease out - Elastic','Elastic.easeInOut':'Ease in-out - Elastic'
//     ,'Expo.easeIn':'Ease in - Expo','Expo.easeOut':'Ease out - Expo','Expo.easeInOut':'Ease in-out - Expo'
//     ,'Sine.easeIn':'Ease in - Sine','Sine.easeOut':'Ease out - Sine','Sine.easeInOut':'Ease in-out - Sine'
//     ,'springrk4': 'Spring rk4', 'cubicbezier': 'Cubic-Bezier'
// }


prx.easing.get = function (easing, opt) {
  if (_typeof(easing) == "object") {
    return easing; // already an ease()
  }

  if (typeof easing != "undefined") {
    var isMyEasing = prx.utils.isGuid(easing);

    if (isMyEasing && typeof prx.easing._customEasings[easing] !== 'undefined') {
      easing = prx.easing._customEasings[easing].easing;
    }

    if (typeof easing == "string") {
      if (easing.substring(0, 12) == "cubic-bezier") {
        easing = prx.easing.getFromCubicBezier(easing);
      } else if (easing.substring(0, 9) == "springrk4") {
        easing = prx.easing.getFromSpringrk4(easing);
      } else {
        if (typeof prx.easing._easingMappings[easing] !== 'undefined') {
          //maybe a myeasing that got deleted
          easing = prx.easing._easingMappings[easing];
        } else {
          easing = prx.easing._easingMappings[prx.utils.getDefaultDefaultTransition().easing];
        }
      }
    }
  } else {
    easing = prx.easing._easingMappings[prx.utils.getDefaultDefaultTransition().easing];
  }

  return easing;
};

prx.easing.getReverse = function (easing) {
  if (_typeof(easing) == "object") {
    return easing; // already an ease()
  }

  if (typeof easing != "undefined") {
    if (typeof prx.easing._easingMappingsReverse[easing] != "undefined") {
      easing = prx.easing._easingMappingsReverse[easing];
    } else if (easing.indexOf('cubic-bezier') > -1) {
      easing = prx.easing.getFromCubicBezierReverse(easing);
    }
  } else {
    easing = prx.easing._easingMappingsReverse[prx.utils.getDefaultDefaultTransition().easing];
  }

  return easing;
};

prx.easing.getFromCubicBezier = function (cb) {
  var split = cb.replace("cubic-bezier(", "").replace(")", "").split(",");

  if (split.length == 4) {
    var cubic = parseFloat(split[0]) + '-' + parseFloat(split[1]) + '-' + parseFloat(split[2]) + '-' + parseFloat(split[3]);

    if (typeof prx.easing._easingMappings[cubic] == "undefined") {
      prx.easing._easingMappings[cubic] = new Ease(BezierEasing(parseFloat(split[0]), parseFloat(split[1]), parseFloat(split[2]), parseFloat(split[3])));
    }

    return prx.easing._easingMappings[cubic];
  }

  return prx.easing._easingMappings[prx.utils.getDefaultDefaultTransition().easing];
};

prx.easing.getFromCubicBezierReverse = function (cb) {
  // https://gist.github.com/IanLunn/4666512
  var split = cb.replace("cubic-bezier(", "").replace(")", "").split(",");

  if (split.length == 4) {
    var cubic = 1 - parseFloat(split[2]) + '-' + (1 - parseFloat(split[3])) + '-' + (1 - parseFloat(split[0])) + '-' + (1 - parseFloat(split[1]));

    if (typeof prx.easing._easingMappings[cubic] == "undefined") {
      prx.easing._easingMappings[cubic] = new Ease(BezierEasing(1 - parseFloat(split[2]), 1 - parseFloat(split[3]), 1 - parseFloat(split[0]), 1 - parseFloat(split[1])));
    }

    return prx.easing._easingMappings[cubic];
  }

  return prx.easing._easingMappingsReverse[prx.utils.getDefaultDefaultTransition().easing];
};

prx.easing.getFromSpringrk4 = function (springrk4) {
  if (springrk4.indexOf("springrk4(") > -1) {
    prx.easing._easingMappings[springrk4] = prx.springrk4.init(springrk4);
    return prx.easing._easingMappings[springrk4];
  } else {
    return prx.easing._easingMappings[prx.utils.getDefaultDefaultTransition().easing];
  } // var split = springrk4.replace("springrk4(", "").replace(")", "").split(",");
  //
  // // if(split.length == 3) {
  // //     var springrk4 = parseFloat(split[0]) + '-' + parseFloat(split[1]) + '-' +  parseFloat(split[2]);
  //     // if(typeof(prx.easing._easingMappings[springrk4]) == "undefined") {
  //     prx.easing._easingMappings[springrk4] = prx.springrk4.init(springrk4);
  //     // }
  //     return prx.easing._easingMappings[springrk4];
  // // }
  // // return prx.easing._easingMappings[prx.utils.getDefaultDefaultTransition().easing];

};

prx.easing.checkForFixedDuration = function (easing, duration) {
  if (_typeof(easing) == 'object' && typeof easing.isSpringrk4 !== 'undefined' && easing.isSpringrk4) {
    //spring has fixed duration
    return easing.duration;
  } else {
    return duration;
  }
};

prx.easing.getIScrollEasing = function (easing) {
  switch (easing) {
    case 'Quad.easeInOut':
    case 'Quad.ease':
    case 'Quad.easeIn':
    case 'Quad.easeOut':
      return IScroll.utils.ease.quadratic;
      break;

    case 'Back.easeInOut':
    case 'Back.easeIn':
    case 'Back.easeOut':
      return IScroll.utils.ease.back;
      break;

    case 'Bounce.easeInOut':
    case 'Bounce.easeIn':
    case 'Bounce.easeOut':
      return IScroll.utils.ease.bounce;
      break;

    case 'Elastic.easeInOut':
    case 'Elastic.easeIn':
    case 'Elastic.easeOut':
      return IScroll.utils.ease.elastic;
      break;

    default:
      return IScroll.utils.ease.circular;
      break;
  }
};

/***/ }),

/***/ "./sass/common/js/prx/components/_expandable-properties.js":
/*!*****************************************************************!*\
  !*** ./sass/common/js/prx/components/_expandable-properties.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.expandableProperties = {};
/**
 * Defines the corresponding PFF type based on the property field type.
 * The PFF type is returned (equals to 'not-allowed' when the type is non-expandable).
 *
 * @param _propType     string      the property type to be checked
 * @returns {*}                     check description above
 */

prx.expandableProperties.getPffType = function (_propType) {
  var pffType;

  switch (_propType) {
    case "input":
    case "select":
      pffType = _propType;
      break;

    case "multiple-select":
      pffType = "selectMultiple";
      break;

    case "input-numeric":
      pffType = 'inputNumeric';
      break;

    case "colorpicker":
    case "combo-colorpicker":
    case "solid-colorpicker":
    case "gradients-colorpicker":
      pffType = 'colorpicker';
      break;

    case 'combo-select':
      pffType = 'selectInput';
      break;

    case "asset":
    case "combo-asset":
    case 'link':
    case "wysiwyg":
    case "textarea":
    case "html-textarea":
    case "radio":
    case "checkbox":
    case "switcher":
    case "onoff":
    case "slider-input":
      // these types are not allowed to be expandable (for now)
      pffType = 'not-allowed';
      break;

    default:
      pffType = 'not-allowed';
      break;
  }

  return pffType;
};
/**
 * Checks if a property is allowed to be made expandable.
 * True is returned when the property is expandable and false when it is not.
 *
 * @param _propType     string      the property type to be checked
 * @returns {*}                     check description above
 */


prx.expandableProperties.checkIfExpandableAllowed = function (_propType) {
  return prx.expandableProperties.getPffType(_propType) !== 'not-allowed'; // true if it IS allowed, false if it IS NOT allowed
};
/**
 * Checks the given data for expanded properties.
 * If _propValue is a string or number (single value), _propValue is returned.
 * If _propValue is an object, we loop all object values to check if all are equal:
 *  - If they are all the same, their common value is returned.
 *  - If they are not equal:
 *    - An empty string is returned when no _expandedPropKey is provided
 *    - The value for that _expandedPropKey is returned.
 *
 * @param _propValue            string, number or object        the property value to be checked for expanded properties
 * @param _expandedPropKey      string                          optional, the key of the expanded property we want the value of
 * @returns {*}                                                 check description above
 */


prx.expandableProperties.checkForExpandedProp = function (_propValue, _expandedPropKey) {
  if (typeof _propValue != 'undefined') {
    // if _propValue is an object, check the values
    if (typeof _propValue != 'string' && typeof _propValue != 'number') {
      var allthesame = true; // keep track if all values are the same, assume to be true at start

      var tempval; // used to check if all values are the same

      $.each(_propValue, function (key, value) {
        if (tempval == undefined) {
          tempval = value;
        } else if (tempval != value) {
          allthesame = false;
        }
      }); // if all values are the same, return the single value (common to all)

      if (allthesame) {
        return tempval;
      } // if not all values are the same, return empty value for parent and _expandedPropKey value for expanded prop
      else {
          if (_expandedPropKey !== undefined) return _propValue[_expandedPropKey];else return '';
        }
    } // if _propValue is a string or number, and does not contain a space, return as is
    else if (("" + _propValue).trim().indexOf(' ') == -1) {
        return _propValue;
      } // this is for backwards compatibility for rectangle. it contained a complex value eg 50px 20px, or perhaps 10px 20px 30px 40px;
      else {
          var split = _propValue.split(' ');

          var _propValue = {
            tl: split[0],
            tr: split[1]
          };

          switch (split.length) {
            case 2:
              _propValue.br = split[0];
              _propValue.bl = split[1];
              break;

            case 3:
              _propValue.br = split[2];
              _propValue.bl = split[1];
              break;

            case 4:
              _propValue.br = split[2];
              _propValue.bl = split[3];
              break;
          }

          if (_expandedPropKey !== undefined) return _propValue[_expandedPropKey];else return '';
        }
  }
};
/**
 * Returns the interaction property expanded value
 * If the core field is empty, return the expanded value from the stored attribute object
 * Else, return the core field value for all keys
 *
 * @param _parentId         string      the id of the parent field
 * @param _expandedPropKey  string      the key of the expanded property we want the value of
 */


prx.expandableProperties.getInteractionPropExpandedValue = function (_parentId, _expandedPropKey) {
  // if field value is empty, assume there are expanded properties defined
  if ($('#' + _parentId).val() == '') {
    return JSON.parse($('#' + _parentId).attr('data-expanded-obj'))[_expandedPropKey];
  } else {
    return $('#' + _parentId).val();
  }
};
/**
 * Returns an array of the expandable properties based on the layout type of the expandable modal.
 * If _order is not given or not equals to 'display', the array is ordered in the way the expanded properties html is built in the expanded modal.
 * If _order is given and equals to 'display', the array is ordered in the same way as css shorthand properties.
 * If the layout is invalid, undefined is returned.
 *
 * @param _values           object      the expanded values to be checked
 * @param _order            string      the order which the returned array should have
 * @returns {*}                         check description above
 */


prx.expandableProperties.getOrderedProps = function (_values, _order) {
  var layout = prx.expandableProperties.getLayoutType(_values);

  if (layout == 'diagonal') {
    if (_order == 'display') return ["tl", "tr", "br", "bl"];else return ["tl", "tr", "bl", "br"];
  } else if (layout == 'tabular') {
    if (_order == 'display') return ["t", "r", "b", "l"];else return ["t", "b", "l", "r"];
  } else return undefined;
};
/**
 * Returns an array of the expandable values, given a specific component type and its property
 *
 * @param _componentType     string      the component type for which we want the expandable values (e.g. rectangle)
 * @param _componentId       string      the component property for which we want the expandable values (e.g. borderRadius)
 * @returns {*}                          check description above
 */


prx.expandableProperties.getExpandedValuesFromComponent = function (_componentType, _componentId) {
  for (var j = 0; j < prx.types[_componentType].propertyGroups.length; j++) {
    for (var k = 0; k < prx.types[_componentType].propertyGroups[j].properties.length; k++) {
      var _props = prx.types[_componentType].propertyGroups[j].properties[k].slice(0);

      for (var n = 0; n < _props.length; n++) {
        if (_props[n].name == _componentId) {
          if (typeof _props[n].expandedValues == 'function') {
            return _props[n].expandedValues(_props[n]);
          } else {
            return _props[n].expandedValues;
          }
        }
      }
    }
  }
};
/**
 * Returns an the item's values, given a specific component type and its property
 * Returns undefined if the property does not have dropdown values
 *
 * @param _componentType     string      the component type for which we want the values (e.g. rectangle)
 * @param _componentId       string      the component property for which we want the values (e.g. borderRadius)
 * @returns {*}                          check description above
 */


prx.expandableProperties.getDropdownValuesFromComponent = function (_componentType, _componentId) {
  for (var j = 0; j < prx.types[_componentType].propertyGroups.length; j++) {
    for (var k = 0; k < prx.types[_componentType].propertyGroups[j].properties.length; k++) {
      var _props = prx.types[_componentType].propertyGroups[j].properties[k].slice(0);

      for (var n = 0; n < _props.length; n++) {
        if (_props[n].name == _componentId) {
          return _props[n].values;
        }
      }
    }
  }
};
/**
 * Returns an array of objects containing the list data, or false if _values is a function
 *
 * @param _values       object/function     object to get the list from
 * @returns {*}                             check description above
 */


prx.expandableProperties.getDropdownList = function (_values) {
  var _list = [];

  if (typeof _values == 'function') {
    return false;
  }

  if ($.isArray(_values)) {
    _list = _values.map(function (el) {
      return Object.assign({}, {
        value: el.value,
        label: el.displayValue
      });
    });
  } else {
    for (var i = _values.min; i <= _values.max; i += _values.step) {
      _list.push({
        label: i,
        value: i
      });
    }
  }

  return _list;
};
/**
 * Defines the type of layout for the expandable modal based on the expanded values.
 * If the _expandedValues object contains known combinations, the layout type is returned.
 * If the _expandedValues are not recognised, undefined is returned.
 *
 * @param _expandedValues       object      the expanded values to be checked
 * @returns {*}                             check description above
 */


prx.expandableProperties.getLayoutType = function (_expandedValues) {
  // define layout only for the known cases of expanded property groups
  if (_expandedValues.hasOwnProperty('tl') || Array.isArray(_expandedValues) && _expandedValues.indexOf('tl') !== -1 && (_expandedValues.hasOwnProperty('tr') || Array.isArray(_expandedValues) && _expandedValues.indexOf('tr') !== -1) && (_expandedValues.hasOwnProperty('bl') || Array.isArray(_expandedValues) && _expandedValues.indexOf('bl') !== -1) && (_expandedValues.hasOwnProperty('br') || Array.isArray(_expandedValues) && _expandedValues.indexOf('br') !== -1)) {
    return 'diagonal';
  } else if ((_expandedValues.hasOwnProperty('t') || Array.isArray(_expandedValues) && _expandedValues.indexOf('t') !== -1) && (_expandedValues.hasOwnProperty('l') || Array.isArray(_expandedValues) && _expandedValues.indexOf('l') !== -1) && (_expandedValues.hasOwnProperty('r') || Array.isArray(_expandedValues) && _expandedValues.indexOf('r') !== -1) && (_expandedValues.hasOwnProperty('b') || Array.isArray(_expandedValues) && _expandedValues.indexOf('b') !== -1)) {
    return 'tabular';
  } else {
    return undefined;
  }
};
/**
 * Populates the expanded properties modal html and initialises the modal.
 * Delta drag is also binded to the fields on modal load.
 *
 * @param _expandedValues   object              the array containing all the expanded properties labels
 * @param _item             object              the item whose property is being changed
 * @param _type             string              the type of the property field
 * @param _name             string              the key of the property being changed
 * @param _value            string or number    the core property value
 * @param _values           object              contains the min, max and step values if it is a select field
 * @param _parentId         string              the id of the parent (core) field, used for identifying expandable property fields
 * @param _popupType        string              whether the modal is created for properties or interactions
 */


prx.expandableProperties.createExpandableModal = function (_expandedValues, _item, _type, _name, _value, _values, _parentId, _popupType) {
  var pffType = prx.expandableProperties.getPffType(_type); // if the type is allowed to be expandable and if the expanded values are provided

  if (pffType !== 'not-allowed' && _expandedValues !== undefined && _expandedValues !== '') {
    if (_popupType == undefined && _parentId == undefined) _parentId = 'p-' + _item.id + '-' + _name; // objects to store special properties for inputs and selects

    var selectOpts = {},
        inputOpts = {}; // check what kind of layout is needed based on the expanded properties labels and store those labels for later use

    var layout = prx.expandableProperties.getLayoutType(_expandedValues),
        layoutValues = prx.expandableProperties.getOrderedProps(_expandedValues); // if a select type, add select list

    if (pffType.includes('select')) {
      selectOpts.list = prx.expandableProperties.getDropdownList(_values);
    } // string to append any input classes needed


    var inputClass = ''; // if an input type, add specific type options

    if (pffType.includes('input')) {
      inputOpts.maxLength = 6;
      inputClass += ' small-input';
    } // popup html strings and extra properties object


    var expandedHtml = '',
        expandedInner = '',
        extraProps = Object.assign({}, selectOpts, inputOpts); // object to store the selected value for each expanded field, if the type is select

    if (pffType.includes('select')) {
      var selected = {};
    }
    /**
     * Build modal html (expanded fields)
     */


    if (layout == 'diagonal') {
      $.each(layoutValues, function (index, val) {
        var _tempValue = _popupType == 'interactions' ? prx.expandableProperties.getInteractionPropExpandedValue(_parentId, val) : prx.expandableProperties.checkForExpandedProp(_item[_name], val); // if a select type, add selected value - else make empty object


        if (pffType.includes('select')) {
          selected.selected = prx.utils.escapeHTML(_tempValue);
        } else {
          selected = {};
        }

        var props = {
          id: _parentId + '-' + val,
          value: prx.utils.escapeHTML(_tempValue),
          icon: _name + '-' + val,
          inputClass: inputClass + (val.indexOf('r') !== -1 ? ' force-icon-right' : ''),
          inputAttr: 'data-expanded="true" data-expanded-values="' + _expandedValues + '"',
          innerGroup: true
        }; // if the selected object is not empty, add to extra props

        if (selected.selected !== undefined) extraProps = Object.assign({}, extraProps, selected); // add field to the row's html

        expandedInner += pff[pffType](Object.assign({}, extraProps, props)); // if the first row (two fields) is finished, wrap and continue to next row (2 fields)

        if (index == 1 || index == 3) {
          expandedHtml += pff.wrapGroups({
            innerHtml: expandedInner
          });
          expandedInner = '';
        }
      });
    } else if (layout == 'tabular') {
      $.each(layoutValues, function (index, val) {
        var _tempValue = _popupType == 'interactions' ? prx.expandableProperties.getInteractionPropExpandedValue(_parentId, val) : prx.expandableProperties.checkForExpandedProp(_item[_name], val); // if a select type, add selected value - else make empty object


        if (pffType.includes('select')) {
          selected.selected = prx.utils.escapeHTML(_tempValue);
        } else {
          selected = {};
        }

        var props = {
          id: _parentId + '-' + val,
          value: prx.utils.escapeHTML(_tempValue),
          icon: _name + '-' + val,
          inputClass: inputClass + (val.indexOf('t') !== -1 ? ' force-icon-top' : val.indexOf('b') !== -1 ? ' force-icon-bottom' : ''),
          inputAttr: 'data-expanded="true" data-expanded-values="' + _expandedValues + '"',
          innerGroup: true
        }; // if the selected object is not empty, add to extra props

        if (selected.selected !== undefined) extraProps = Object.assign({}, extraProps, selected); // add field to the row's html

        expandedInner += pff[pffType](Object.assign({}, extraProps, props)); // if the first row (one field) is finished, wrap and continue to next row (2 fields)
        // if the second row (two fields) is finished, wrap and continue to next row (1 field)

        if (index == 1 || index == 3) {
          expandedHtml += pff.wrapGroups({
            innerHtml: expandedInner
          });
          expandedInner = '';
        }
      });
    }

    var _modalAttrs = _popupType == 'interactions' ? '' : 'relative-to="#property-' + _name + '-dropdown"';
    /**
     * Create modal with the generated html
     */


    var modalParameters = {
      "class": 'modal-' + _name + '-dropdown modal-expanded-properties property-popup',
      contentId: _name + '-dropdown-wrapper',
      content: expandedHtml,
      closeX: false,
      size: 'auto',
      arrow: false,
      modalAttrs: _modalAttrs // save the id of target property field for use later when showing it, only for properties

    };
    $('body').append(prx.mpmodal.helper.modalTemplateHtml(modalParameters));

    if (_popupType == 'interactions') {
      var basicprops = {
        position: 'relativeTo',
        relativeToDom: '#' + _parentId + '-dropdown',
        hidden: false,
        manualDestroyOnly: false
      };
    } else {
      var basicprops = {
        position: {
          x: 0,
          y: 0
        },
        hidden: true,
        manualDestroyOnly: true
      };
    }

    $('.modal-' + _name + '-dropdown.modal-expanded-properties').mpmodal(Object.assign({}, basicprops, {
      invisibleModal: true,
      animationOut: '',
      onLoad: function onLoad() {
        // add class to focused expanded properties to activate the icon
        $('[id^="' + _parentId + '-"]').focus(function () {
          $(this).parent().addClass('focused');
        }).blur(function () {
          $(this).parent().removeClass('focused');
        }); // make sure all select fields from select-inputs have the correct value on initialisation
        // this is because the select's value cannot be set inline through PFF like the input field, so need to do it after applying html

        var _selectInputFields = $(this).find('.form-group-select-input > .form-field-select-wrapper > select');

        $.each(_selectInputFields, function (i, field) {
          $(field).val($(field).siblings('input').val());
        }); // bind delta drag on all the property fields (core and expanded)

        prx.deltaDrag($('label[for^="' + _parentId + '"]:not(label[for="' + _parentId + '"])'), {
          initialized: function initialized(delta, activeTarget) {
            $target = $('#' + $('.deltadrag-active').attr('for'));
            initialValue = parseFloat($target.focusin().val() || 0);
          },
          delta: function delta(_delta, activeTarget) {
            var newValue = initialValue + _delta.deltaX;
            newValue = newValue < 0 ? 0 : newValue;
            if ($target.prop('disabled') == false) $target.val(parseInt(newValue)).trigger("changeWithOutSave");
          },
          done: function done(delta, activeTarget) {
            $target = $('#' + $('.deltadrag-active').attr('for'));
            if ($target.prop('disabled') == false) $target.change();
          }
        });

        if (_popupType == 'interactions') {
          prx.expandableProperties.bindExpandableFields(_expandedValues, _parentId, _item, _name, _type);
        }
      }
    }));
  }
};
/**
 * Bind events for the expandable fields in the modal, according to field type
 *
 * @param _expandedValues   object              the array containing all the expanded properties labels
 * @param _parentId         string              the id of the parent (core) field, used for identifying expandable property fields
 * @param _item             object              the item whose property is being changed
 * @param _name             string              the key of the property being changed
 * @param _type             string              the type of the property field
 */


prx.expandableProperties.bindExpandableFields = function (_expandedValues, _parentId, _item, _name, _type) {
  var targets = '',
      pffType = prx.expandableProperties.getPffType(_type); // get all property field ids to bind change event

  $.each(_expandedValues, function (i, value) {
    if (i !== 0) targets += ', ';
    targets += '#' + _parentId + '-' + value;

    if (pffType.includes('select')) {
      targets += ', #' + _parentId + '-' + value + '-select';
    }
  });
  $(targets).on('changeWithOutSave', function (event) {
    prx.expandableProperties.onExpandedPropChange($(this), $(this).val(), _item, _name, _type, _parentId, 'interactions');
  }).on('change', function (event) {
    prx.expandableProperties.onExpandedPropChange($(this), $(this).val(), _item, _name, _type, _parentId, 'interactions');
  });
};
/**
 * Called on .change() of an expanded property field, in order to run the appropriate code needed for expanded properties.
 * If the _type is non-expandable, returns false.
 *
 * For properties popup:
 * If the existing core property value is a number or string, it builds an object for the expanded properties and initialises the values to the existing core property value.
 * It updates the property value in the object, changes the core property field value accordingly and rerenders the item.
 *
 * For interactions form:
 * If the existing core field doesn't have an attribute containing the expanded values, it builds an object for the expanded properties and initialises the values to the existing core property value.
 * It updates the core field's attribute with the stringifyied object and changes the core property field value accordingly.
 *
 *
 * @param $this         object                      the jQuery element that is being changed
 * @param _value        string, number or object    the new value of the changed property
 * @param _item         object                      the item whose property is being changed
 * @param _name         string                      the key of the property being changed
 * @param _type         string                      the type of the property field
 * @param _parentId     string                      the id of the parent (core) field, used for identifying expandable property fields
 * @param _popupType    string                      whether the modal is created for properties or interactions
 * @returns {boolean}                               check description above
 */


prx.expandableProperties.onExpandedPropChange = function ($this, _value, _item, _name, _type, _parentId, _popupType) {
  // only continue with change if expanded properties are allowed for this type
  if (prx.expandableProperties.checkIfExpandableAllowed(_type)) {
    if (_popupType == undefined && _parentId == undefined) _parentId = 'p-' + _item.id + '-' + _name; // get expanded value labels for data

    var _expandedValues = $this.data('expanded-values').split(','); // append expanded label to end of name, so we don't break the flow that already exists for properties popup


    if (_popupType == 'interactions') _name = _name + '-' + $this.attr('id').replace('-select', '').split('-').last(); // the key value for the expanded property we are trying to change (get part after dash in the property name,
    // which is added for the expanded properties)

    var _targetKey = _name.split('-').last(); // the core property we are targeting (remove the expanded key from the property name)


    var _targetProp = _name.replace('-' + _targetKey, '');

    if (_popupType == undefined || _popupType == 'properties') {
      // if property is a single value, generate object with the same value for all keys
      if (typeof _item[_targetProp] == 'string' || typeof _item[_targetProp] == 'number') {
        var currVal = _item[_targetProp];
        _item[_targetProp] = {};

        for (var i = 0; i < _expandedValues.length; i++) {
          _item[_targetProp][_expandedValues[i]] = currVal;
        }
      }

      _item[_targetProp][_targetKey] = _value; // display empty input (core property) if all values are NOT the same, or the common single value if they are all the same
      // also target ids that end in "-select" for cases that this is a select or input-select field

      $('#' + _parentId.replace('-' + _targetKey, '') + ', #' + _parentId.replace('-' + _targetKey, '') + '-select').val(prx.expandableProperties.checkForExpandedProp(_item[_targetProp]));
    } else if (_popupType == 'interactions') {
      var _currObj = {}; // if core field doesn't have data-expanded-obj attribute, generate object with the same values for all keys

      if ($('#' + _parentId).attr('data-expanded-obj') == undefined) {
        var _currVal = $('#' + _parentId).val();

        for (var i = 0; i < _expandedValues.length; i++) {
          _currObj[_expandedValues[i]] = _currVal;
        }
      } else {
        // get object from attribute
        _currObj = JSON.parse($('#' + _parentId).attr('data-expanded-obj'));
      }

      _currObj[_targetKey] = _value;
      $('#' + _parentId).attr('data-expanded-obj', JSON.stringify(_currObj)); // display empty input (core property) if all values are NOT the same, or the common single value if they are all the same
      // also target ids that end in "-select" for cases that this is a select or input-select field

      $('#' + _parentId + ', #' + _parentId + '-select').val(prx.expandableProperties.checkForExpandedProp(_currObj));
    }

    var _formId = _popupType == 'interactions' ? 'form-interactions' : 'form-item-properties';

    $("#" + _formId).change();
  } else {
    return false;
  }
};
/**
 * Updates all the values of the property (core value and expanded values) when the core property field is changed.
 * If the _type is non-expandable, returns false.
 *
 * @param _type         string              the type of the property field
 * @param _value        string or number    the core property value
 * @param _parentId     string              the id of the parent (core) field, used for identifying expandable property fields
 * @param _popupType    string              whether the modal is created for properties or interactions
 * @returns {boolean}                       check description above
 */


prx.expandableProperties.updateExpandedValues = function (_type, _value, _parentId, _popupType) {
  if (prx.expandableProperties.checkIfExpandableAllowed(_type)) {
    if (_popupType == undefined || _popupType == 'properties') {
      var normalisedValues; // only normalise if it is a border radius field

      if (/borderRadius/gi.test(_parentId)) normalisedValues = prx.expandableProperties.normalizeBorderRadiusString(_value);else normalisedValues = false;

      if (normalisedValues == false) {
        $('[id^="' + _parentId + '"]').val(_value);
      } else {
        // get sub properties labels
        var values = prx.expandableProperties.getOrderedProps(normalisedValues, 'display');

        for (var i = 0; i < values.length; i++) {
          $('#' + _parentId + '-' + values[i]).val(prx.expandableProperties.checkForExpandedProp(normalisedValues, values[i])).change();
        }
      }
    } else if (_popupType == 'interactions') {
      var _currObj = {},
          _expandedValues = $('#' + _parentId).attr('data-expanded-values').split(',');

      if ($('#' + _parentId).attr('data-expanded-obj') !== undefined) // get object from attribute
        _currObj = JSON.parse($('#' + _parentId).attr('data-expanded-obj'));

      for (var i = 0; i < _expandedValues.length; i++) {
        _currObj[_expandedValues[i]] = _value;
      }

      $('#' + _parentId).attr('data-expanded-obj', JSON.stringify(_currObj));
    }
  } else return false;
};
/**
 * Check the border radius value for space separated values and converts it to a normalised
 * expanded object
 *
 * @param data          The target item
 *
 * @returns {boolean}   False if it is not a rectangle or a string value containing spaces
 */


prx.expandableProperties.normalizeBorderRadiusString = function (value) {
  if (value !== undefined) {
    if (typeof value == 'string' && (value.includes(' ') || value.includes('/'))) {
      if (value.includes('/')) {
        var part1 = value.split('/').first(),
            part2 = value.split('/').last();
        var values1 = part1.split(' '),
            values2 = part2.split(' ');
        values1 = prx.expandableProperties.normalizeEllipticalRadiusValues(values1);
        values2 = prx.expandableProperties.normalizeEllipticalRadiusValues(values2);
        return {
          tl: values1[0] + ' ' + values2[0],
          tr: values1[1] + ' ' + values2[1],
          br: values1[2] + ' ' + values2[2],
          bl: values1[3] + ' ' + values2[3]
        };
      } else {
        var values = value.split(' ');
        values = prx.expandableProperties.normalizeEllipticalRadiusValues(values);
        return {
          tl: values[0],
          tr: values[1],
          br: values[2],
          bl: values[3]
        };
      }
    } else {
      return false;
    }
  } else {
    return false;
  }
};
/**
 * Checks the values generated for elliptical border radius and returned a normalised object with the necessary data
 *
 * @param values        The border radius values
 *
 * @returns {Array}     The normalised border radius values
 */


prx.expandableProperties.normalizeEllipticalRadiusValues = function (values) {
  values = values.filter(function (value) {
    return value !== '';
  });

  switch (values.length) {
    case 1:
      values.push(values[0]);
      values.push(values[0]);
      values.push(values[0]);
      break;

    case 2:
      values.push(values[0]);
      values.push(values[1]);
      break;

    case 3:
      values.push(values[1]);
      break;

    default:
      break;
  }

  return values;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/common/js/prx/components/_jquery-2-migrate.js":
/*!************************************************************!*\
  !*** ./sass/common/js/prx/components/_jquery-2-migrate.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($, __webpack_provided_window_dot_jQuery) {$.uaMatch = function (ua) {
  ua = ua.toLowerCase();
  var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
  return {
    browser: match[1] || "",
    version: match[2] || "0"
  };
};

if (!$.browser) {
  matched = $.uaMatch(navigator.userAgent);
  browser = {};

  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
  } // Chrome is Webkit, but Webkit is also Safari.


  if (browser.chrome) {
    browser.webkit = true;
  } else if (browser.webkit) {
    browser.safari = true;
  }

  window.$.browser = __webpack_provided_window_dot_jQuery.browser = browser;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/common/js/prx/components/_kvs.js":
/*!***********************************************!*\
  !*** ./sass/common/js/prx/components/_kvs.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

window.Kvs = function () {
  function Kvs(settings) {
    settings = settings || {};
    this.namespace = settings.namespace || 'kvs';
    if (settings.seconds) this.seconds = settings.seconds || 30 * 24 * 60 * 60;
  }

  Kvs.prototype.get = function (key) {
    // setting the key
    key = this.namespace + '-' + key; // geting the data

    if (!this.isLocalStorageSupported() || typeof localStorage[key] === 'undefined') return null;
    var val = JSON.parse(localStorage[key]); // checking if expired

    var now = new Date().getTime();

    if (val.meta.exp !== undefined && val.meta.exp < now) {
      delete localStorage[key];
      return null;
    } // returning the data


    switch (val.meta.type) {
      case 'string':
        return val.data;
        break;

      case 'undefined':
      case 'null':
        return val.data;
        break;

      case 'object':
      default:
        return JSON.parse(val.data);
    }
  };

  Kvs.prototype.set = function (key, value, seconds) {
    if (!this.isLocalStorageSupported()) return;
    var val = {
      meta: {
        type: _typeof(value)
      }
    };

    if (seconds !== undefined || this.seconds !== undefined) {
      //in every kvs initialization we do not set this.seconds
      //As a result, if you don't send param: seconds in this function, no expiration will be set and the cookie will never expire
      val.meta.exp = new Date().getTime() + parseInt(seconds || this.seconds) * 1000;
    }

    switch (val.meta.type) {
      case 'string':
        val.data = value;
        break;

      case 'object':
      default:
        val.data = JSON.stringify(value);
    }

    localStorage[this.namespace + '-' + key] = JSON.stringify(val);
  };

  Kvs.prototype["delete"] = function (key) {
    if (!this.isLocalStorageSupported()) return;
    delete localStorage[this.namespace + '-' + key];
  };

  Kvs.prototype.remove = function (key) {
    if (!this.isLocalStorageSupported()) return;
    var t = this.get(key);
    this["delete"](key);
    return t;
  };

  Kvs.prototype.isLocalStorageSupported = function () {
    var testKey = 'test',
        storage = window.localStorage;

    try {
      storage.setItem(testKey, '1');
      storage.removeItem(testKey);
      return true;
    } catch (error) {
      return false;
    }
  };

  return Kvs;
}();

/***/ }),

/***/ "./sass/common/js/prx/components/_mask.js":
/*!************************************************!*\
  !*** ./sass/common/js/prx/components/_mask.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Created by kyriakos on 25/08/16.
 */
prx.mask = {}; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////MASK HELPER FUNCTIONS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

prx.mask.isEnabled = function (item) {
  if (item) {
    if (item.hasOwnProperty('mask')) {
      if (item.mask.hasOwnProperty("borderRadiusBL")) {
        //update border radius
        item.mask.borderRadius = {};
        item.mask.borderRadius.br = item.mask.borderRadiusBR;
        item.mask.borderRadius.bl = item.mask.borderRadiusBL;
        item.mask.borderRadius.tl = item.mask.borderRadiusTL;
        item.mask.borderRadius.tr = item.mask.borderRadiusTR;
        delete item.mask.borderRadiusBR;
        delete item.mask.borderRadiusBL;
        delete item.mask.borderRadiusTL;
        delete item.mask.borderRadiusTR;
      }

      if (!item.mask.hasOwnProperty("borderColor")) {
        item.mask.borderColor = "#000000";
        item.mask.borderPos = "inside";
        item.mask.borderStyle = "solid";
        item.mask.borderWidth = 0;
      }

      return item.mask.isMasked;
    }
  }

  return false;
};

prx.mask.isEditing = function (item) {
  if (item) {
    if (item.hasOwnProperty('mask') && item.mask.isMasked) {
      if (item.mask.hasOwnProperty('editing') && item.mask.editing) return true;else return false;
    }
  }

  return false;
};

prx.mask.isActive = function (item) {
  if (item) {
    if (item.hasOwnProperty('mask') && item.mask.isMasked) {
      if (item.mask.hasOwnProperty('editing') && item.mask.editing) return false;else return true;
    }
  }

  return false;
}; //get the dimensions of the inner object


prx.mask.getInnerDimsObj = function (item) {
  var dims = {};

  if (prx.mask.isActive(item)) {
    dims.width = item.mask.inner_width;
    dims.height = item.mask.inner_height;
  } else {
    dims.width = item.width;
    dims.height = item.height;
  }

  return dims;
};

prx.mask.getInnerDims = function (item) {
  var dims = prx.mask.getInnerDimsObj(item);
  return [dims.width, dims.height];
}; //get the Absolute position of the inner object


prx.mask.getInnerAbsolutePositionObj = function (item) {
  var pos = {};

  if (prx.mask.isActive(item)) {
    pos.left = item.left + item.mask.x;
    pos.top = item.top + item.mask.y;
  } else {
    pos.left = item.left;
    pos.top = item.top;
  }

  return pos;
};

prx.mask.getInnerAbsolutePosition = function (item) {
  var pos = prx.mask.getInnerAbsolutePositionObj(item);
  return [pos.left, pos.top];
};

prx.mask.getInnerDimsAndAbsolutePositionObj = function (item) {
  var dims = prx.mask.getInnerDimsObj(item);
  var pos = prx.mask.getInnerAbsolutePositionObj(item);
  dims.top = pos.top;
  dims.left = pos.left;
  return dims;
};

prx.mask.getInnerDimsAndAbsolutePosition = function (item) {
  var dims = prx.mask.getInnerDimsAndAbsolutePositionObj(item);
  return [dims.width, dims.height, dims.left, dims.top];
};

prx.mask.getMaskDimsObj = function (item) {
  var dims = {};

  if (prx.mask.isActive(item) || !prx.mask.isEnabled(item)) {
    dims.width = item.width;
    dims.height = item.height;
  } else {
    dims.width = item.mask.width;
    dims.height = item.mask.height;
  }

  return dims;
};

prx.mask.getMaskDims = function (item) {
  var dims = prx.mask.getMaskDimsObj(item);
  return [dims.width, dims.height];
};

prx.mask.getMaskAbsolutePositionObj = function (item) {
  var pos = {};

  if (prx.mask.isActive(item) || !prx.mask.isEnabled(item)) {
    pos.left = item.left;
    pos.top = item.top;
  } else {
    if (prx.mask.isEditing(item)) {
      pos.top = item.mask.y;
      pos.left = item.mask.x;
    }
  }

  return pos;
};

prx.mask.getMaskAbsolutePosition = function (item) {
  var pos = prx.mask.getMaskAbsolutePositionObj(item);
  return [pos.left, pos.top];
};

prx.mask.getMaskDimsAndAbsolutPositionObj = function (item) {
  var dims = prx.mask.getMaskDimsObj(item);
  var pos = prx.mask.getMaskAbsolutePositionObj(item);
  dims.top = pos.top;
  dims.left = pos.left;
  return dims;
};

prx.mask.getMaskDimsAndAbsolutPosition = function (item) {
  var dims = prx.mask.getMaskDimsAndAbsolutPositionObj(item);
  return [dims.width, dims.height, dims.left, dims.top];
};

prx.mask.getMaskRealDimsAndPosWithRotationObj = function (item) {
  var _dims = prx.mask.getMaskDimsAndAbsolutPositionObj(item);

  var rotation = prx.mask.getMaskRotation(item);

  if (typeof rotation == "undefined" || rotation == 0 || isNaN(parseFloat(rotation))) {
    // not is numeric
    return _dims;
  }

  var rw = _dims.width;
  var rh = _dims.height;
  var r = rotation * (Math.PI / 180); // radians

  var w = prx.items.helper.getRotatedWidth(rw, rh, r);
  var h = prx.items.helper.getRotatedHeight(rw, rh, r);
  var l = _dims.left - Math.round((w - rw) / 2);
  var t = _dims.top - Math.round((h - rh) / 2);
  return {
    width: parseInt(w),
    height: parseInt(h),
    left: parseInt(l),
    top: parseInt(t)
  };
};

prx.mask.getMaskRealDimsAndPosWithRotation = function (item) {
  var _dims = prx.mask.getMaskRealDimsAndPosWithRotationObj(item);

  return [_dims.width, _dims.height, _dims.left, _dims.top]; // [width,height,left,top]
};

prx.mask.itemDimensions = function (item, parenttype, parentindex, stateindex) {
  if (!prx.mask.isEditing(item)) return prx.toolbox.itemDimensions(item, parenttype, parentindex, stateindex);
  var id = {},
      od = prx.orientation.getDims(parenttype, parentindex, stateindex),
      iw = parseFloat(item.mask.width),
      ih = parseFloat(item.mask.height),
      il = parseFloat(item.mask.x),
      it = parseFloat(item.mask.y);
  if (i.wtype == 'variable') iw = od[0] - iw;
  if (i.htype == 'variable') ih = od[1] - ih;
  if (i.hpos == 'right') il = od[0] - il - iw;
  if (i.hpos == 'center') il = (od[0] - iw) / 2;
  if (i.vpos == 'bottom') it = od[1] - it - ih;
  if (i.vpos == 'middle') it = (od[1] - ih) / 2;
  id.width = iw;
  id.height = ih;
  id.left = il;
  id.top = it;
  id.rotation = i.rotation || 0;
  id.x = id.left + id.width / 2;
  id.y = id.top + id.height / 2;
  id.x1 = id.left;
  id.x2 = id.left + id.width;
  id.y1 = id.top;
  id.y2 = id.top + id.height;
  return prx.toolbox.rotatedDims(id);
};

prx.mask.getMaskBorderRadiousObj = function (item) {
  if (prx.mask.isEnabled(item)) {
    if (_typeof(item.mask.borderRadius) === 'object') {
      return item.mask.borderRadius;
    } else {
      return {
        tl: item.mask.borderRadius,
        tr: item.mask.borderRadius,
        bl: item.mask.borderRadius,
        br: item.mask.borderRadius
      };
    }
  }
};

prx.mask.getBorderRadiusCss = function (item) {
  if (!prx.mask.isEnabled(item)) return "";
  var borderRadius = prx.mask.getMaskBorderRadiousObj(item);
  return "border-radius: " + parseInt(borderRadius.tl) + "px " + parseInt(borderRadius.tr) + "px " + parseInt(borderRadius.br) + "px " + parseInt(borderRadius.bl) + "px; ";
};

prx.mask.getBorderCss = function (item) {
  if (!prx.mask.isEnabled(item)) return "";
  var style = '';
  style += "border-width:" + prx.componentsHelper.getProp(item.mask.borderWidth, 'border-width') + "; ";
  style += "border-style: " + item.mask.borderStyle + "; border-color: " + prx.gradients.prxToCss(item.mask.borderColor) + ";";
  return style;
};

prx.mask.marginOnBorderOutside = function (item, isInside) {
  var style = '',
      cond = false;

  if (isInside) {
    cond = item.mask.borderPos == "inside";
  } else {
    cond = item.mask.borderPos != "inside";
  }

  if (cond) {
    if (_typeof(item.mask.borderWidth) == 'object') {
      style += "margin-top:" + -item.mask.borderWidth.t + "px; ";
      style += "margin-bottom:" + -item.mask.borderWidth.b + "px; ";
      style += "margin-left:" + -item.mask.borderWidth.l + "px; ";
      style += "margin-right:" + -item.mask.borderWidth.r + "px; ";
    } else {
      style += "margin-top:" + -item.mask.borderWidth + "px; ";
      style += "margin-bottom:" + -item.mask.borderWidth + "px; ";
      style += "margin-left:" + -item.mask.borderWidth + "px; ";
      style += "margin-right:" + -item.mask.borderWidth + "px; ";
    }
  }

  return style;
};

/***/ }),

/***/ "./sass/common/js/prx/components/_polyfills.js":
/*!*****************************************************!*\
  !*** ./sass/common/js/prx/components/_polyfills.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (!Array.indexOf) {
  // missing from IE
  Array.prototype.indexOf = function indexOf(obj) {
    var l = this.length;

    while (--l > -1) {
      if (this[l] == obj) return l;
    }

    return l;
  };
}

Array.prototype.unique = function unique() {
  var a = [];
  var i = 0;

  while (i < this.length) {
    if (a.indexOf(this[i++]) === -1) a.push(this[i - 1]);
  }

  return a;
};

Array.prototype.insertArrayAt = function insertArrayAt(i, a) {
  return this.splice(0, i).concat(a).concat(this);
};

Array.prototype.first = function first() {
  return this[0];
};

Array.prototype.last = function last() {
  return this[this.length - 1];
}; // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign


if (!Object.assign) {
  Object.defineProperty(Object, 'assign', {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function value(target) {
      'use strict';

      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert first argument to object');
      }

      var to = Object(target);

      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];

        if (nextSource === undefined || nextSource === null) {
          continue;
        }

        nextSource = Object(nextSource);
        var keysArray = Object.keys(nextSource);

        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }

      return to;
    }
  });
}

if (!Array.prototype.every) {
  Array.prototype.every = function (callbackfn, thisArg) {
    'use strict';

    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    } // 1. Let O be the result of calling ToObject passing the this
    //    value as the argument.


    var O = Object(this); // 2. Let lenValue be the result of calling the Get internal method
    //    of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).

    var len = O.length >>> 0; // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.

    if (typeof callbackfn !== 'function') {
      throw new TypeError();
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    if (arguments.length > 1) {
      T = thisArg;
    } // 6. Let k be 0.


    k = 0; // 7. Repeat, while k < len

    while (k < len) {
      var kValue; // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then

      if (k in O) {
        // i. Let kValue be the result of calling the Get internal method
        //    of O with argument Pk.
        kValue = O[k]; // ii. Let testResult be the result of calling the Call internal method
        //     of callbackfn with T as the this value and argument list
        //     containing kValue, k, and O.

        var testResult = callbackfn.call(T, kValue, k, O); // iii. If ToBoolean(testResult) is false, return false.

        if (!testResult) {
          return false;
        }
      }

      k++;
    }

    return true;
  };
}

if (!Array.prototype.includes) {
  Array.prototype.includes = function (searchElement
  /*, fromIndex*/
  ) {
    'use strict';

    if (this == null) {
      throw new TypeError('Array.prototype.includes called on null or undefined');
    }

    var O = Object(this);
    var len = parseInt(O.length, 10) || 0;

    if (len === 0) {
      return false;
    }

    var n = parseInt(arguments[1], 10) || 0;
    var k;

    if (n >= 0) {
      k = n;
    } else {
      k = len + n;

      if (k < 0) {
        k = 0;
      }
    }

    var currentElement;

    while (k < len) {
      currentElement = O[k];

      if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
        // NaN !== NaN
        return true;
      }

      k++;
    }

    return false;
  };
} // https://tc39.github.io/ecma262/#sec-array.prototype.find


if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function value(predicate) {
      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this); // 2. Let len be ? ToLength(? Get(O, "length")).

      var len = o.length >>> 0; // 3. If IsCallable(predicate) is false, throw a TypeError exception.

      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


      var thisArg = arguments[1]; // 5. Let k be 0.

      var k = 0; // 6. Repeat, while k < len

      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
        // d. If testResult is true, return kValue.
        var kValue = o[k];

        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        } // e. Increase k by 1.


        k++;
      } // 7. Return undefined.


      return undefined;
    },
    configurable: true,
    writable: true
  });
}

if (!String.prototype.includes) {
  String.prototype.includes = function (search, start) {
    'use strict';

    if (typeof start !== 'number') {
      start = 0;
    }

    if (start + search.length > this.length) {
      return false;
    } else {
      return this.indexOf(search, start) !== -1;
    }
  };
}

/***/ }),

/***/ "./sass/common/js/prx/components/_toolbox.js":
/*!***************************************************!*\
  !*** ./sass/common/js/prx/components/_toolbox.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.toolbox = function () {
  function clone(i) {
    return lodash.cloneDeep(i);
  }

  function toArray(o, s) {
    var a = [],
        v,
        k,
        r;

    if (typeof s === 'undefined') {
      for (k in o) {
        if (o.hasOwnProperty(k)) a.push(clone(o[k]));
      }
    } else {
      s = s.split('.').filter(function (x) {
        return x.length !== 0;
      });

      for (k in o) {
        if (o.hasOwnProperty(k)) {
          v = clone(o[k]);
          r = clone(s);

          while (r.length) {
            if (typeof v[r[0]] === 'undefined') v = void 0;else v = v[r.shift()];
          }

          if (typeof v !== 'undefined') a.push(v);
        }
      }
    }

    return a;
  } //i: item


  function itemDimensions(i, parenttype, parentindex, stateindex) {
    if (typeof i.wtype === 'undefined') i.wtype = 'fixed';
    if (typeof i.htype === 'undefined') i.htype = 'fixed';
    if (typeof i.hpos === 'undefined') i.hpos = 'left';
    if (typeof i.vpos === 'undefined') i.vpos = 'top';
    var id = {},
        od = prx.orientation.getDims(parenttype, parentindex, stateindex),
        iw = parseFloat(i.width),
        ih = parseFloat(i.height),
        il = parseFloat(i.left),
        it = parseFloat(i.top);
    if (i.wtype == 'variable') iw = od[0] - iw;
    if (i.htype == 'variable') ih = od[1] - ih;
    if (i.hpos == 'right') il = od[0] - il - iw;
    if (i.hpos == 'center') il = (od[0] - iw) / 2;
    if (i.vpos == 'bottom') it = od[1] - it - ih;
    if (i.vpos == 'middle') it = (od[1] - ih) / 2;
    id.width = iw;
    id.height = ih;
    id.left = il;
    id.top = it;
    id.rotation = i.rotation || 0;
    id.x = id.left + id.width / 2;
    id.y = id.top + id.height / 2;
    id.x1 = id.left;
    id.x2 = id.left + id.width;
    id.y1 = id.top;
    id.y2 = id.top + id.height;
    return rotatedDims(id);
  }

  function rotatedDims(x) {
    var c = clone(x);
    c.rad = parseFloat((c.rotation * (Math.PI / 180)).toFixed(8)); // radians

    c.rWidth = Math.abs(c.width * Math.cos(c.rad)) + Math.abs(c.height * Math.sin(c.rad));
    c.rHeight = Math.abs(c.width * Math.sin(c.rad)) + Math.abs(c.height * Math.cos(c.rad));
    c.rLeft = c.left - Math.round((c.rWidth - c.width) / 2);
    c.rTop = c.top - Math.round((c.rHeight - c.height) / 2);
    return c;
  } //ds: dimensions


  function center(ds, degrees) {
    if (typeof ds === 'undefined' || ds.length === 0) return {
      x: 0,
      y: 0
    };
    if (typeof degrees === 'undefined') degrees = 0;
    degrees %= 360;
    var vertices = [],
        imax,
        imin,
        imax90,
        imin90,
        radians = parseFloat((degrees / 180 * Math.PI).toFixed(8)),
        radians90 = parseFloat(((degrees - 90) / 180 * Math.PI).toFixed(8)),
        m = Math.tan(radians),
        m90 = Math.tan(radians90);
    ds.forEach(function (d) {
      var x, y, nx, ny;
      x = d.left;
      y = d.top;
      nx = Math.cos(d.rad) * (x - d.x) - Math.sin(d.rad) * (y - d.y) + d.x;
      ny = Math.sin(d.rad) * (x - d.x) + Math.cos(d.rad) * (y - d.y) + d.y;
      vertices.push({
        x: nx,
        y: ny
      });
      x = d.left + d.width;
      y = d.top;
      nx = Math.cos(d.rad) * (x - d.x) - Math.sin(d.rad) * (y - d.y) + d.x;
      ny = Math.sin(d.rad) * (x - d.x) + Math.cos(d.rad) * (y - d.y) + d.y;
      vertices.push({
        x: nx,
        y: ny
      });
      x = d.left;
      y = d.top + d.height;
      nx = Math.cos(d.rad) * (x - d.x) - Math.sin(d.rad) * (y - d.y) + d.x;
      ny = Math.sin(d.rad) * (x - d.x) + Math.cos(d.rad) * (y - d.y) + d.y;
      vertices.push({
        x: nx,
        y: ny
      });
      x = d.left + d.width;
      y = d.top + d.height;
      nx = Math.cos(d.rad) * (x - d.x) - Math.sin(d.rad) * (y - d.y) + d.x;
      ny = Math.sin(d.rad) * (x - d.x) + Math.cos(d.rad) * (y - d.y) + d.y;
      vertices.push({
        x: nx,
        y: ny
      });
    }); //$('.redline').remove();
    //vertices.forEach(function (v) {
    //    var d = $('<div class="redline"></div>');
    //    d.css({
    //        position: 'absolute'
    //        , top: v.y - 3 + 'px'
    //        , left: v.x - 3 + 'px'
    //        , width: 6 + 'px'
    //        , height: 6 + 'px'
    //        , 'background-color': '#ff0000'
    //    });
    //    prx.dragarea.append(d);
    //});

    var tv = vertices.first();
    imax = imin = tv.y - m * tv.x;
    imax90 = imin90 = tv.y - m90 * tv.x;
    vertices.forEach(function (v) {
      var i = v.y - m * v.x,
          i90 = v.y - m90 * v.x; //var d = $('<div class="redline"></div>');
      //d.css({
      //    position: 'absolute'
      //    , top: i + 'px'
      //    , left: 0 + 'px'
      //    , width: 1500 + 'px'
      //    , height: 1 + 'px'
      //    , 'background-color': '#00ff00'
      //    , transform: 'rotate(' + (degrees ) + 'deg)'
      //    , 'transform-origin': '0% 50%'
      //});
      //prx.dragarea.append(d);
      //d = $('<div class="redline"></div>');
      //d.css({
      //    position: 'absolute'
      //    , top: i90 + 'px'
      //    , left: 0 + 'px'
      //    , width: 1500 + 'px'
      //    , height: 1 + 'px'
      //    , 'background-color': '#0000ff'
      //    , transform: 'rotate(' + (degrees - 90) + 'deg)'
      //    , 'transform-origin': '0% 50%'
      //});
      //prx.dragarea.append(d);

      if (i < imin) imin = i;
      if (i > imax) imax = i;
      if (i90 < imin90) imin90 = i90;
      if (i90 > imax90) imax90 = i90;
    });
    var x1 = (imax90 - imax) / (m - m90),
        x2 = (imin90 - imin) / (m - m90),
        y1 = m * x1 + imax,
        y2 = m * x2 + imin,
        cx = (x1 + x2) / 2,
        cy = (y1 + y2) / 2; //var d = $('<div class="redline"></div>');
    //d.css({
    //    position: 'absolute'
    //    , top: cy - 3 + 'px'
    //    , left: cx - 3 + 'px'
    //    , width: 6 + 'px'
    //    , height: 6 + 'px'
    //    , 'background-color': '#00ff00'
    //});
    //prx.dragarea.append(d);
    //d = $('<div class="redline"></div>');
    //d.css({
    //    position: 'absolute'
    //    , top: y1 - 3 + 'px'
    //    , left: x1 - 3 + 'px'
    //    , width: 6 + 'px'
    //    , height: 6 + 'px'
    //    , 'background-color': '#00ffff'
    //});
    //prx.dragarea.append(d);
    //d = $('<div class="redline"></div>');
    //d.css({
    //    position: 'absolute'
    //    , top: y2 - 3 + 'px'
    //    , left: x2 - 3 + 'px'
    //    , width: 6 + 'px'
    //    , height: 6 + 'px'
    //    , 'background-color': '#00ffff'
    //});
    //
    //prx.dragarea.append(d);

    return {
      x: Math.round(cx * 100) / 100,
      y: Math.round(cy * 100) / 100
    };
  } //d: dimensions c: center r: rotation


  function rotate(d, c, r) {
    var nd = {};

    if (r < 0) {
      r %= 360;
      r += 360;
    }

    nd.rotation = d.rotation + r;
    nd.rotation %= 360;
    var xd = d.x - c.x,
        yd = d.y - c.y,
        h = Math.sqrt(Math.pow(xd, 2) + Math.pow(yd, 2)),
        ir = parseFloat(Math.atan2(yd, xd) / (Math.PI / 180).toFixed(8));
    if (ir < 0) ir += 360;
    var fr = (ir + r) % 360;
    var nyd = parseFloat(Math.abs(Math.sin(fr * Math.PI / 180) * h).toFixed(8));
    var nxd = parseFloat(Math.abs(Math.cos(fr * Math.PI / 180) * h).toFixed(8));

    if (fr > 90 && fr <= 180) {
      nxd = -nxd;
    } else if (fr > 180 && fr <= 270) {
      nxd = -nxd;
      nyd = -nyd;
    } else if (fr > 270 && fr <= 360) {
      nyd = -nyd;
    }

    nd.top = Math.round(c.y + nyd - d.height / 2);
    nd.left = Math.round(c.x + nxd - d.width / 2);
    nd.width = Math.round(d.width);
    nd.height = Math.round(d.height);
    nd.x = nd.left + nd.width / 2;
    nd.y = nd.top + nd.height / 2;
    return nd;
  }

  function calculateBox(ds, r, parenttype, parentindex, stateindex) {
    if (ds.length === 0) return {};
    if (ds.length === 1) return itemDimensions(ds[0], parenttype, parentindex, stateindex);
    var c = center(ds, r);
    var rds = ds.map(function (d) {
      var nd = rotate(d, c, 360 - r);
      return itemDimensions(nd, parenttype, parentindex, stateindex);
    });
    var bc = {
      x1: 999999,
      y1: 999999,
      x2: -999999,
      y2: -999999
    };
    rds.forEach(function (rd) {
      bc.x1 = rd.rLeft < bc.x1 ? rd.rLeft : bc.x1;
      bc.y1 = rd.rTop < bc.y1 ? rd.rTop : bc.y1;
      bc.x2 = rd.rLeft + rd.rWidth > bc.x2 ? rd.rLeft + rd.rWidth : bc.x2;
      bc.y2 = rd.rTop + rd.rHeight > bc.y2 ? rd.rTop + rd.rHeight : bc.y2;
    });
    bc.x1 = Math.round(bc.x1);
    bc.x2 = Math.round(bc.x2);
    bc.y1 = Math.round(bc.y1);
    bc.y2 = Math.round(bc.y2);
    bc.rotation = Math.round(r);
    bc.width = bc.x2 - bc.x1;
    bc.height = bc.y2 - bc.y1;
    bc.left = bc.x1;
    bc.top = bc.y1;
    return itemDimensions(bc, parenttype, parentindex, stateindex);
  }

  function indexOf(a, o, t) {
    for (var i = 0; i < a.length; i++) {
      if (t(a[i], o) == true) return i;
    }

    return -1;
  }

  function getGroupDimensions(groupId) {
    var group = prxy[prx.stc.helper.getType()][prx.stc.helper.getIndex()].states[prxy.iSelectedState].groups[groupId];
    var filteredItems = prx.editingtools.group.getGroup(groupId).kids;
    var ds = filteredItems.map(function (item) {
      return prx.toolbox.itemDimensions(item.item);
    });
    var cordinates = prx.toolbox.calculateBox(ds, group.rotation);
    return cordinates;
  }

  return {
    clone: clone,
    indexOf: indexOf,
    itemDimensions: itemDimensions,
    rotatedDims: rotatedDims,
    center: center,
    rotate: rotate,
    calculateBox: calculateBox,
    toArray: toArray,
    getGroupDimensions: getGroupDimensions
  };
}();

/***/ }),

/***/ "./sass/common/js/prx/components/_utils.js":
/*!*************************************************!*\
  !*** ./sass/common/js/prx/components/_utils.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//@koala-prepend "_kvs.js"
window.prx = window.prx || {};
window.sd = window.sd || {};
window.evt = window.evt || {};
window.pee = window.pee || {};

if (window.proto) {
  window.prxy = window.prxy || window.proto.proxy;
}

prx.kvs = new Kvs({
  namespace: 'proto'
});
prx.utils = window.prx.utils || {};
prx.utils.dynamic_properties = ['listitems', 'buttons', 'options', 'tabs'];
prx.utils.XSSJSWhitelistForFroala = {
  //a: ['target', 'href', 'title', 'style'],
  b: ['style'],
  br: [],
  div: ['style'],
  em: ['style'],
  i: ['style'],
  //p: ['style'],
  span: ['style', 'class'],
  strong: ['style'],
  strike: ['style'],
  s: ['style'],
  u: ['style'],
  font: []
};

prx.utils.setCookie = function (c_name, value, exdays) {
  var exdate = new Date();
  exdate.setDate(exdate.getDate() + exdays);
  var c_value = escape(value) + (exdays == null ? '' : '; expires=' + exdate.toUTCString());
  document.cookie = c_name + '=' + c_value;
};

prx.utils.getCookie = function (c_name) {
  var i,
      x,
      y,
      ARRcookies = document.cookie.split(';');

  for (i = 0; i < ARRcookies.length; i++) {
    x = ARRcookies[i].substr(0, ARRcookies[i].indexOf('='));
    y = ARRcookies[i].substr(ARRcookies[i].indexOf('=') + 1);
    x = x.replace(/^\s+|\s+$/g, '');

    if (x == c_name) {
      return unescape(y);
    }
  }
};

prx.utils.deleteCookie = function (c_name) {
  document.cookie = c_name + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
};

prx.utils.getGuid = function () {
  var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
  return guid;
};

prx.utils.isGuid = function (str) {
  // to match the getGiud above AND the coldfusion alternative which is 8-4-4-16
  return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}$/.test(str);
};

prx.utils.getColor = function (color) {
  if (typeof color === "string") {
    if (!/^[0-9a-f]{3,6}$/i.test(color)) {
      try {
        color = JSON.parse(color);
      } catch (e) {}
    }

    if (typeof color === "number") {
      color = "" + color;
    }
  }

  if (_typeof(color) == "object") {
    // todo check if isPrxData only?
    return color;
  } else {
    if (typeof color == "undefined" || color == null) {
      return '';
    }

    color = color.trim();
    /*
    //var keywords_color_regex = /^[a-z]*$/;
    //var rgb_color_regex = /^rgb\(\s*(0|[1-9]\d?|1\d\d?|2[0-4]\d|25[0-5])\s*,\s*(0|[1-9]\d?|1\d\d?|2[0-4]\d|25[0-5])\s*,\s*(0|[1-9]\d?|1\d\d?|2[0-4]\d|25[0-5])\s*\)$/;
    //var rgba_color_regex = /^rgba\(\s*(0|[1-9]\d?|1\d\d?|2[0-4]\d|25[0-5])\s*,\s*(0|[1-9]\d?|1\d\d?|2[0-4]\d|25[0-5])\s*,\s*(0|[1-9]\d?|1\d\d?|2[0-4]\d|25[0-5])\s*,\s*((0.[1-9])|[01])\s*\)$/;
    var hex_color_regex = /[#a-f0-9]/i;
    var hsl_color_regex = /^hsl\(\s*(0|[1-9]\d?|[12]\d\d|3[0-5]\d)\s*,\s*((0|[1-9]\d?|100)%)\s*,\s*((0|[1-9]\d?|100)%)\s*\)$/;
    var rgba_color_regex = /rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)/ig;
    var rgb_color_regex = /^rgb\((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\s?,\s?){2}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\)/;
    */

    if (color == "none") {
      return "rgba(0,0,0,0)";
    }

    if (color == 0) {
      //return '';
      return "rgba(0,0,0,1)";
    } //rgba with more than 3 commas? Most probably we have opacity with comma instead of doT!


    if (color.substring(0, 4) == 'rgba') {
      if ((color.match(/,/g) || []).length > 3) {
        color = color.replace(/,([^,]*)$/, '.' + '$1');
      }
    }

    if (color == color.replace(/[^A-F0-9]/ig, '')) {
      return '#' + color;
    }
    /*  if(!hex_color_regex.test(color) && !rgb_color_regex.test(color) && !rgba_color_regex.test(color) && !hsl_color_regex.test(color)) {
       return "#000000";
    }
    */


    return color;
  }
};

prx.utils.getBgCss = function (prop) {
  return prx.gradients.getBgCss(prop);
};

prx.utils.getBgCssByProperty = function (prop, property) {
  return prx.gradients.getBgCssByProperty(prop, property);
};

prx.utils.getBgCssByValue = function (val) {
  return prx.gradients.getBgCssByValue(val);
}; //TODO REVISION need this as well to return false when not color on update so that it keeps the previous value


prx.utils.checkColorPickerInputOnUpdate = function (color) {
  //  var hex_color_regex = /^#[0-9a-f]{3}([0-9a-f]{3})?$/i;
  var hex_color_regex = /[#a-f0-9]/i;
  var hsl_color_regex = /^hsl\(\s*(0|[1-9]\d?|[12]\d\d|3[0-5]\d)\s*,\s*((0|[1-9]\d?|100)%)\s*,\s*((0|[1-9]\d?|100)%)\s*\)$/;
  var rgba_color_regex = /rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)/ig;
  var rgb_color_regex = /^rgb\((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\s?,\s?){2}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\)/;

  if (!hex_color_regex.test(color) && !rgb_color_regex.test(color) && !rgba_color_regex.test(color) && !hsl_color_regex.test(color)) {
    return false;
  } else {
    if (hex_color_regex.test(color) && color.substring(0, 1) !== '#') {
      return '#' + color;
    } else {
      return color;
    }
  }
};

prx.utils.getOpacity = function (opacity) {
  if (typeof opacity == 'undefined') {
    return '';
  } //alphanumeric , .


  var regex = /^[A-Z0-9,.%]+$/;

  if (regex.test(opacity)) {
    return opacity;
  } else {
    return 1;
  }

  return opacity;
};

prx.utils.checkURL = function (url) {
  var regex = /^(http|https)/i;

  if (regex.test(url)) {
    return url;
  } else {
    return 'url';
  }
};

prx.utils.isURL = function (url) {
  return url === prx.utils.checkURL(url);
}; //this returns the same output as cf getNormalizedFilename()


prx.utils.getNormalizedFilename = function (value) {
  if (typeof value == 'undefined') {
    return '';
  }

  value = value.replace(/[<,>,:,"",/,\,|,?,*]/gi, '-');
  return value;
};

prx.utils.escapeHTML = function (str) {
  if (typeof str !== 'string') {
    return str;
  } else {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
  }
};

prx.utils.unEscapeHTML = function (str) {
  if (typeof str !== 'string') {
    return str;
  } else {
    return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#039;/g, '\'');
  }
};

prx.utils.escapeEditableProperties = function (str) {
  if (typeof str !== 'string') {
    return str;
  } else {
    return str.replace(/&/g, '&amp;').replace(/(?!<br>|<br\/>|<br \/>)</g, '&lt;') //.replace(/[^<br\/>](>)/gi, "&gt;")
    .replace(/"/g, '&quot;').replace(/'/g, '&#039;');
  }
};

prx.utils.escapeForRegEx = function (str) {
  if (typeof str !== 'string') {
    return str;
  } else {
    return str.replace(/"/g, "\\\\").replace(/\//g, "\\\/").replace(/\*/g, "\\\*").replace(/\+/g, "\\\+").replace(/\[/g, "\\\[").replace(/\]/g, "\\\]").replace(/\-/g, "\\\-").replace(/\(/g, "\\\(").replace(/\)/g, "\\\)");
  }
};

prx.utils.escapeRichText = function (str, whitelist) {
  if (typeof whitelist == 'undefined') {
    whitelist = prx.utils.XSSJSWhitelistForFroala;
  }

  if (typeof str !== 'string') {
    return str;
  } else {
    str = filterXSS(str, {
      whiteList: whitelist,
      // empty, means filter out all tags
      stripIgnoreTag: true,
      // for all tags not in whitelist, strip the tags
      stripIgnoreTagBody: ['script'] // the script tag is a special case, we need
      // to filter out its content

    });
    str = str.replace(/&#8203;/gi, '');
    return str;
  }
};

prx.utils.getEventPageXY = function (e) {
  var out = {
    x: 0,
    y: 0
  };

  if (e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel') {
    var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
    out.x = touch.pageX;
    out.y = touch.pageY;
  } else if (e.type == 'click' || e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover' || e.type == 'mouseout' || e.type == 'mouseenter' || e.type == 'mouseleave') {
    out.x = e.pageX;
    out.y = e.pageY;
  }

  return out;
};

prx.utils.getAssetsServer = function (assetFilename_real) {
  if (assetFilename_real) {
    var max = prx.nodejsassetsserver.maxsubdomains;
    var num = 0;

    for (var i = 0; i < assetFilename_real.length; i++) {
      num += assetFilename_real.charCodeAt(i);
    }

    num = num % (max - 1) + 2; //number one is resurved for non editor/player assests

    if (num > max || num < 1) num = 2;
    return prx.nodejsassetsserver.subdomainprefix + num + prx.nodejsassetsserver.host;
  } else {
    return prx.nodejsassetsserver.subdomainprefix + '1' + prx.nodejsassetsserver.host;
  }
};

prx.utils.forceWebkitRerender = function ($el) {
  // stupid webkit
  // from http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
  var sel = $el.get(0);
  var originalstyle = sel.style.display;
  sel.style.display = 'none';
  sel.offsetHeight; // no need to store this anywhere, the reference is enough

  sel.style.display = originalstyle;
}; // this function gets an element with text inside and the maxHeight that we want it to be,
// and it truncates the text so it fits in the required space adding ... at the end.


prx.utils.multilineEllipsis = function (parentSelector, elementSelector, maxHeight, isFileName, maxEstimatedLength) {
  if (!maxEstimatedLength) maxEstimatedLength = 25; // this is used in cases that element is
  // hidden so it has 0 height or there are
  // no more words to cut off

  if (isFileName !== true) isFileName = false; // get a copy of the parent container to do operations on before display
  // this is done to avoid reflow performance issues in asset manager with thousands of assets

  var parentClone = $(parentSelector).clone(true, true);
  $(elementSelector, parentClone).each(function (index, targetElement) {
    var ext = '';
    var ext_length = 0;
    var text = '';

    if ($(targetElement).outerHeight() === 0) // element is hidden/displayed none
      {
        text = $(targetElement).text();

        if (text.length > maxEstimatedLength) {
          if (isFileName) {
            if (text.indexOf('.') != -1) {
              ext = text.substring(text.lastIndexOf('.') + 1);
              text = text.substring(0, text.lastIndexOf('.'));
              ext_length = ext.length;
            }
          }

          text = text.substr(0, maxEstimatedLength - 3 - ext_length) + '...' + ext;
          $(targetElement).text(text);
        }

        return;
      }

    while ($(targetElement).outerHeight() > maxHeight) {
      text = $(targetElement).text();

      if (isFileName) {
        if (text.indexOf('.') != -1) {
          ext = text.substring(text.lastIndexOf('.'));
          text = text.substring(0, text.lastIndexOf('.'));
          ext_length = ext.length;
        }
      }

      var truncatedText = text.replace(/\W*\s(\S)*$/, '...'); // in case there are no more words to cut off

      if (text.length == truncatedText.length) {
        truncatedText = truncatedText.substr(0, maxEstimatedLength - 3 - ext_length) + '...' + ext;
        $(targetElement).text(truncatedText);
        break;
      }

      text = text + ext;
      $(targetElement).text(truncatedText);
    }
  });
  $(parentSelector).replaceWith(parentClone);
};

prx.utils.bindScreenshotsFunctionality = function (selector) {
  $(selector).find('.thumbnail-img').on('error', function () {
    $(this).hide();
    $(this).siblings('.dummy-img').hide();
    $(this).siblings('.loading-placeholder-img').show();
  });
  $(selector).find('.thumbnail-img').on('load', function () {
    $(this).siblings('.loading-placeholder-img').hide();
    $(this).show();
    if ($(this).parents('.containerLI, .screenLI').hasClass('has-multiple-states')) $(this).siblings('.dummy-img').show();
  });
};

prx.utils.arraysAreIdentical = function (arr1, arr2) {
  if (arr1.length !== arr2.length) return false;

  for (var i = 0, len = arr1.length; i < len; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
};

prx.utils.getNewBezierEase = function (a, b, c, d) {
  return new Ease(BezierEasing(a, b, c, d));
}; // Return a function, that, as long as it continues to be invoked, will
// not be triggered. The function will be called after it stops being
// called for `wait` milliseconds. If `immediate` is passed, trigger the
// function on the leading edge, instead of the trailing.


prx.utils.debounceFunction = function (func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};

prx.utils.raf = function (fun) {
  window.requestAnimationFrame(fun);
};

prx.utils.isValidUrl = function (url) {
  /*
      var re_weburl = new RegExp(
          "^" +
          // protocol identifier
          "(?:(?:https?|ftp)://)" +
          // user:pass authentication
          "(?:\\S+(?::\\S*)?@)?" +
          "(?:" +
          // IP address exclusion
          // private & local networks
          "(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
          "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
          "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" +
          // IP address dotted notation octets
          // excludes loopback network 0.0.0.0
          // excludes reserved space >= 224.0.0.0
          // excludes network & broacast addresses
          // (first & last IP address of each class)
          "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
          "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
          "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
          "|" +
          // host name
          "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" +
          // domain name
          "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" +
          // TLD identifier
          "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" +
          // TLD may end with dot
          "\\.?" +
          ")" +
          // port number
          "(?::\\d{2,5})?" +
          // resource path
          "(?:[/?#]\\S*)?" +
          "$", "i"
      );
  
      url:    https://gist.github.com/dperini/729294
  */
  var urlregex = new RegExp(/^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/i);
  return urlregex.test(url);
};

prx.utils.isFaceTimeUrl = function (url) {
  if (url.startsWith('facetime:') || url.startsWith('facetime-audio:')) {
    url = url.replace(/^facetime:/, '').replace(/^facetime-audio:/, '');

    if (url.indexOf(':') > -1) {
      return false;
    }

    return true;
  }

  return false;
};

prx.utils.isValidUserPreset = function (uuid) {
  if (/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}$/.test(uuid) && typeof prx.easing._customEasings[uuid] !== 'undefined') {
    return true;
  } else {
    return false;
  }
};

prx.utils.isSpringrk4 = function (value) {
  if (value.substr(0, 10) === 'springrk4(') {
    return true;
  } else {
    return false;
  }
};

prx.utils.getDefaultDefaultTransition = function () {
  return {
    duration: 250,
    delay: 0,
    easing: 'out'
  };
}; // prx.utils.isSafariV1111orGreater = function () {
//     if(typeof(navigator) == 'undefined' || (typeof(navigator) != 'undefined' && typeof(navigator.userAgent) == 'undefined')) {
//         return false;
//     }
//
//     return (
//         (navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') === -1 && parseInt(navigator.userAgent.substr(navigator.userAgent.indexOf("Version/")+8, 6).replace(/\./g,'').trim()) >= 1111)
//     );
// }


prx.utils.isSafariV1111orGreater = function () {
  if (typeof navigator == 'undefined' || typeof navigator != 'undefined' && typeof navigator.userAgent == 'undefined') {
    return false;
  }

  if (navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') === -1) {
    var browserV = navigator.userAgent.substring(navigator.userAgent.indexOf("Version")).split("/")[1].replace('Safari', '').trim();
    var compareWithV = '11.1.1';
    return prx.utils.compareVersions(browserV, compareWithV) > -1; // true only if browser version is equal or greater than 11.1.1
  }

  return false;
};
/**
 * Source: https://github.com/omichelsen/compare-versions/blob/master/index.js
 *
 * Functionality: compares two version by taking in consideration dots in between them
 * Params: you are comparing v1 against v2. In order words v1 is newer/equal/older than v2
 * Returns: -1 means than v1 is older than v2
 * 0 means than both versions are equal
 * 1 means that v1 is newer than v2
 * -2 means that something is wrong with the passed variables/version (they are being checked with the regex below)
 */


prx.utils.compareVersions = function (v1, v2) {
  var semver = /^v?(?:\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+))?(?:-[\da-z\-]+(?:\.[\da-z\-]+)*)?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
  return compareVersions(v1, v2);

  function indexOrEnd(str, q) {
    return str.indexOf(q) === -1 ? str.length : str.indexOf(q);
  }

  function split(v) {
    var c = v.replace(/^v/, '').replace(/\+.*$/, '');
    var patchIndex = indexOrEnd(c, '-');
    var arr = c.substring(0, patchIndex).split('.');
    arr.push(c.substring(patchIndex + 1));
    return arr;
  }

  function tryParse(v) {
    return isNaN(Number(v)) ? v : Number(v);
  }

  function validate(version) {
    if (typeof version !== 'string') {
      return false;
    }

    if (!semver.test(version)) {
      return false;
    }

    return true;
  }

  function compareVersions(v1, v2) {
    if (!validate(v1) || !validate(v2)) {
      return -2;
    }

    var s1 = split(v1);
    var s2 = split(v2);

    for (var i = 0; i < Math.max(s1.length - 1, s2.length - 1); i++) {
      var n1 = parseInt(s1[i] || 0, 10);
      var n2 = parseInt(s2[i] || 0, 10);
      if (n1 > n2) return 1;
      if (n2 > n1) return -1;
    }

    var sp1 = s1[s1.length - 1];
    var sp2 = s2[s2.length - 1];

    if (sp1 && sp2) {
      var p1 = sp1.split('.').map(tryParse);
      var p2 = sp2.split('.').map(tryParse);

      for (i = 0; i < Math.max(p1.length, p2.length); i++) {
        if (p1[i] === undefined || typeof p2[i] === 'string' && typeof p1[i] === 'number') return -1;
        if (p2[i] === undefined || typeof p1[i] === 'string' && typeof p2[i] === 'number') return 1;
        if (p1[i] > p2[i]) return 1;
        if (p2[i] > p1[i]) return -1;
      }
    } else if (sp1 || sp2) {
      return sp1 ? -1 : 1;
    }

    return 0;
  }

  ;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/editor/js/components/_html-text-editor.js":
/*!********************************************************!*\
  !*** ./sass/editor/js/components/_html-text-editor.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {/**
 * Created by George on 21/02/16.
 */
prx.htmlTextEditor = {};
prx.htmlTextEditor.enableShowStyle = true;
prx.htmlTextEditor.selection = false;
prx.htmlTextEditor.currentEditorInstance = undefined;
prx.htmlTextEditor.mappingsOfRichTextEditorAndRelatedCSSprops = {
  "font-weight": "commands.",
  "font-style": "commands.",
  "text-decoration": "commands.",
  color: "format.applyStyle",
  "letter-spacing": "format.applyStyle",
  "line-height": "format.applyStyle",
  "font-size": "fontSize.apply",
  "font-family": "fontFamily.apply",
  "text-align": "align.apply"
};
prx.htmlTextEditor.XSSJSWhitelistForFroala = {
  //a: ['target', 'href', 'title', 'style'],
  b: ["style"],
  br: [],
  div: ["style"],
  em: ["style"],
  i: ["style"],
  //p: ['style'],
  span: ["style", "class"],
  strong: ["style"],
  strike: ["style"],
  s: ["style"],
  u: ["style"]
};

prx.htmlTextEditor.fr = function () {
  return "uAJb1Nd1ZWPXDa1FQd1E==";
};

prx.htmlTextEditor["class"] = function () {
  return 'froala-instance';
};

prx.htmlTextEditor.iframeEl = function () {
  return ".fr-iframe";
};

prx.htmlTextEditor.initFullScale = function (el, paragraphize, multiline, cssStyle, cssFiles) {
  if (typeof el == "undefined" || $(".fr-wrapper iframe").length > 0) return false;
  var multiline = typeof paragraphize != "undefined" ? multiline : false;
  var cssStyle = typeof cssStyle != "undefined" ? cssStyle : "";
  var cssFiles = typeof cssFiles != "undefined" ? cssFiles : [];
  var paragraphize = paragraphize == true ? $.FroalaEditor.ENTER_P : $.FroalaEditor.ENTER_BR;
  $(el).on('froalaEditor.initialized', function (e, editor) {
    prx.htmlTextEditor.currentEditorInstance = $(el);
  });
  $(el).on('froalaEditor.destroy', function (e, editor) {
    prx.htmlTextEditor.currentEditorInstance = undefined;
  });
  $(el).froalaEditor({
    fontFamily: prx.comps.fontForRichTextEditor(),
    placeholderText: "",
    pluginsEnabled: ["align", "fontFamily", "fontSize", "colors", "inlineStyle"],
    toolbarButtons: ["fontFamily", "|", "fontSize", "|", "align", "|", "bold", "italic", "underline", "colors"],
    shortcutsEnabled: ["bold", "italic", "underline", "undo", "redo", "strikeThrough"],
    fontSizeSelection: true,
    fontFamilySelection: true,
    multiLine: multiline,
    enter: paragraphize,
    iframe: true,
    iframeStyle: cssStyle,
    iframeStyleFiles: cssFiles,
    key: prx.htmlTextEditor.fr(),
    spellcheck: false
  }).addClass(prx.htmlTextEditor["class"]());
};

prx.htmlTextEditor.destroy = function (el) {
  prx.htmlTextEditor.currentEditorInstance = undefined;
  $(el).froalaEditor('destroy');
};

prx.htmlTextEditor.getValue = function (el) {
  return $(el).froalaEditor("html.get", true);
};

prx.htmlTextEditor.getCurrentValue = function (itemId, relatedEditableProperty, dynPropI) {
  var el = prx.htmlTextEditor.normaliseTextEditorID("#" + itemId + " #editable-properties-" + relatedEditableProperty);
  return $(el).froalaEditor("html.get", true);
};

prx.htmlTextEditor.normaliseTextEditorID = function (id) {
  return id.replace(".", "-");
};

prx.htmlTextEditor.unNormaliseTextEditorID = function (id) {
  return id.replace("-", ".");
};

prx.htmlTextEditor.isActive = function (itemId, relatedEditableProperty, dynPropI) {
  if (dynPropI === false) {
    dynPropI = undefined;
  }

  if (typeof relatedEditableProperty != "undefined") {
    relatedEditableProperty = $.isArray(relatedEditableProperty) ? relatedEditableProperty : [relatedEditableProperty];
    var isCustomProperty = relatedEditableProperty[0].split(/[.]+/).length > 1 ? true : false;

    if (isCustomProperty && typeof relatedEditableProperty[0].split(/[.]+/)[1] != "undefined") {
      relatedEditableProperty = relatedEditableProperty[0].split(/[.]+/)[1];
    }
  } else {
    relatedEditableProperty = [""];
  }

  var el = prx.htmlTextEditor.normaliseTextEditorID("#" + itemId + " #editable-properties-" + relatedEditableProperty[0]);
  return $(el).data("froala.editor") !== undefined && $(el).data("dynPropI") == dynPropI ? true : false;
};

prx.htmlTextEditor.checkInstanceActiveFromClass = function () {
  return $('.' + prx.htmlTextEditor["class"]()).length > 0;
};

prx.htmlTextEditor.selectAll = function (itemId, relatedEditableProperty, dynPropI) {
  var el = prx.htmlTextEditor.normaliseTextEditorID("#" + itemId + " #editable-properties-" + relatedEditableProperty);
  $(el).froalaEditor("events.focus");
  $(el).froalaEditor("commands.selectAll");
  $(el).froalaEditor("events.trigger", "buttons.refresh", [], false);
};

prx.htmlTextEditor.selectAllTemp = function (el) {
  $(el).froalaEditor("events.focus");
  $(el).froalaEditor("commands.selectAll");
};

prx.htmlTextEditor.isSelectedAll = function (el) {
  var selectedText = $(el).froalaEditor("selection.text").replace(/\s/g, "");
  var isSelectedAll = selectedText != "" && selectedText.localeCompare($(".fr-iframe").contents().find(".fr-view").text().replace(/\s/g, "")) == 0 || $(el).froalaEditor("selection.isFull") == true ? true : false;
  return isSelectedAll;
};

prx.htmlTextEditor.focus = function (el) {
  $(el).froalaEditor("events.focus");
};

prx.htmlTextEditor.getSelectedText = function (itemId, relatedEditableProperty, dynPropI) {
  var el = prx.htmlTextEditor.normaliseTextEditorID("#" + itemId + " #editable-properties-" + relatedEditableProperty);
  return $(el).froalaEditor("selection.text");
};

prx.htmlTextEditor.getSelection = function (itemId, relatedEditableProperty, dynPropI) {
  var el = prx.htmlTextEditor.normaliseTextEditorID("#" + itemId + " #editable-properties-" + relatedEditableProperty);
  return $(el).froalaEditor("selection.get");
};

prx.htmlTextEditor.setHTML = function (html, itemId, relatedEditableProperty, dynPropI) {
  var el = prx.htmlTextEditor.normaliseTextEditorID("#" + itemId + " #editable-properties-" + relatedEditableProperty);
  $(el).froalaEditor("html.set", html);
};

prx.htmlTextEditor.createWYSIWYGeditorForEditableProperty = function (el, paragrahize, multiline, cssStyle, cssFiles) {
  //depreciated
  prx.htmlTextEditor.initFullScale(el, paragrahize, multiline, cssStyle, cssFiles);
};

prx.htmlTextEditor.applyStyleToWYSIWYGeditorTextFromPropertiesPanel = function (el, cssProperty, propName, newValue, itemId) {
  // isTextProperties = U Button - we get one value (underline)
  var isTextProperties = propName.toLowerCase().indexOf("properties") > -1;
  var isTextFontStyleProperties = propName.toLowerCase().indexOf("fontstyle") > -1; //font weight & font style i.e 300italic two values on change

  delete $(el).froalaEditor().data("froala.editor").prtofontValue; //normalize new value

  var newValue = cssProperty == "letter-spacing" || cssProperty == "line-height" || cssProperty == "font-size" ? newValue + "px" : newValue;

  if ($.isArray(cssProperty)) {
    if (isTextProperties) {
      //checkbox [u]
      $(el).froalaEditor("commands." + newValue);
    } else if (isTextFontStyleProperties) {
      var style = prx.componentsHelper.getProp(newValue, "font-style-value");
      var weight = prx.componentsHelper.getProp(newValue, "font-weight-value");
      $(el).froalaEditor("format.applyStyle", "font-weight", weight);
      $(el).froalaEditor("format.applyStyle", "font-style", style);
    }
  } else {
    //color,letter-spacing,line-height
    if (typeof prx.htmlTextEditor.mappingsOfRichTextEditorAndRelatedCSSprops[cssProperty] != "undefined") {
      if (cssProperty == "font-size" || cssProperty == "text-align") {
        $(el).froalaEditor(prx.htmlTextEditor.mappingsOfRichTextEditorAndRelatedCSSprops[cssProperty], newValue);
      } else if (cssProperty == "font-family") {
        newValue = prx.componentsHelper // .getFontCssFromFontFamily(newValue.trim() + ", " + prx.comps.fallbackFont)
        .getFontCssFromFontFamily(newValue.trim()).replace("font-family:", "").replace(/;/g, "");
        $(el).froalaEditor().data("froala.editor").prtofontValue = newValue;
        $(el).froalaEditor(prx.htmlTextEditor.mappingsOfRichTextEditorAndRelatedCSSprops["font-family"], newValue);
      } else if (cssProperty === "font-weight") {
        if (newValue && newValue !== "") {
          var _style = (newValue.match(/[^0-9]+/) || "normal").toString();

          var _weight = (newValue.match(/[0-9]{3}/) || 400).toString();

          $(el).froalaEditor("format.applyStyle", "font-weight", _weight);
          $(el).froalaEditor("format.applyStyle", "font-style", _style);
        }
      } else {
        $(el).froalaEditor(prx.htmlTextEditor.mappingsOfRichTextEditorAndRelatedCSSprops[cssProperty], cssProperty, newValue);
      }
    }
  } //trigger this for saving purposes


  $(el).froalaEditor("events.trigger", "input", [], false);
  $(el).froalaEditor("events.trigger", "buttons.afterRefresh.protoio", false);
};

prx.htmlTextEditor.createTempWYSIWYGeditor = function (val) {
  $("body").append($('<textarea id="tempWYSIWYGeditor" style="display:block">' + val + "</textarea>").data("original-value", val) //.data('index', prxy.iSelectedIndex)
  );
  prx.htmlTextEditor.initTempiFrame("#tempWYSIWYGeditor", false, true);
};

prx.htmlTextEditor.initTempiFrame = function (el, visible, iframe) {
  var isVisible = visible ? "" : "hidden";
  var isIframe = iframe ? true : false;
  $(el).froalaEditor({
    fontFamily: prx.comps.fontForRichTextEditor(),
    placeholderText: "",
    pluginsEnabled: ["align", "fontFamily", "fontSize", "colors", "inlineStyle"],
    toolbarButtons: ["fontFamily", "|", "fontSize", "|", "align", "|", "bold", "italic", "underline", "colors"],
    fontFamilySelection: true,
    fontSizeSelection: true,
    //useClasses: false,
    //multiLine: true,
    iframe: isIframe,
    editorClass: isVisible,
    enter: $.FroalaEditor.ENTER_BR,
    key: prx.htmlTextEditor.fr(),
    spellcheck: false //zindex: 9999

  });
  if (typeof el == "undefined") return false;
  var multiline = typeof paragraphize != "undefined" ? multiline : false;
  var cssStyle = typeof cssStyle != "undefined" ? cssStyle : "";
  var cssFiles = typeof cssFiles != "undefined" ? cssFiles : [];
  var paragraphize = paragraphize == true ? $.FroalaEditor.ENTER_P : $.FroalaEditor.ENTER_BR;
  $(el).froalaEditor({
    fontFamily: prx.comps.fontForRichTextEditor(),
    placeholderText: "",
    pluginsEnabled: ["align", "fontFamily", "fontSize", "colors", "inlineStyle"],
    toolbarButtons: ["fontFamily", "|", "fontSize", "|", "align", "|", "bold", "italic", "underline", "colors"],
    shortcutsEnabled: ["bold", "italic", "underline", "undo", "redo"],
    fontSizeSelection: true,
    fontFamilySelection: true,
    multiLine: multiline,
    enter: paragraphize,
    iframe: true,
    iframeStyle: cssStyle,
    iframeStyleFiles: cssFiles,
    key: prx.htmlTextEditor.fr(),
    spellcheck: false
  });
};

prx.htmlTextEditor.getValFromTempWYSIWYGeditor = function () {
  return $("#tempWYSIWYGeditor").froalaEditor("html.get", true);
};

prx.htmlTextEditor.destroyTempWYSIWYGeditor = function (el) {
  if (typeof el == "undefined") {
    var el = "#tempWYSIWYGeditor";
  }

  $(el).froalaEditor("destroy");
  $(el).remove();
};

prx.htmlTextEditor.getSelectedNodes = function (iframe, selIsCollapsed) {
  function nextNode(node) {
    if (node.hasChildNodes()) {
      return node.firstChild;
    } else {
      while (node && !node.nextSibling) {
        node = node.parentNode;
      }

      if (!node) {
        return null;
      }

      return node.nextSibling;
    }
  }

  function getRangeSelectedNodes(range) {
    var node = range.startContainer;
    var endNode = range.endContainer; // Special case for a range that is contained within a single node

    if (node == endNode) {
      return [node];
    } // Iterate nodes until we hit the end container


    var rangeNodes = [];

    while (node && node != endNode && node.className !== "fr-view") {
      rangeNodes.push(node = nextNode(node));
    } // Add partially selected nodes at the start of the range


    node = range.startContainer;

    while (node && node != range.commonAncestorContainer && node.className !== "fr-view") {
      rangeNodes.unshift(node);
      node = node.parentNode;
    }

    return rangeNodes;
  }

  if (iframe.getSelection) {
    var sel = iframe.getSelection();

    if (!selIsCollapsed) {
      return getRangeSelectedNodes(sel.getRangeAt(0));
    } else {
      if (sel.rangeCount) {
        var rangeNodes = sel.getRangeAt(0).commonAncestorContainer; // Make sure we have an element rather than a text node

        if (rangeNodes.nodeType == 3) {
          return [rangeNodes.parentNode];
        }
      } else if ((sel = iframe.selection) && sel.type != "Control") {
        return [sel.createRange().parentElement()];
      }
    }
  }

  return [];
};

prx.htmlTextEditor.checkParentsForUndeline = function (node) {
  if (typeof node !== "undefined" && node !== null) {
    while (node && node.className !== "fr-view") {
      node = node.parentNode;

      if (node !== null && node.textContent !== null && node.textContent.trim() !== ""
      /* && node.nodeType == 3*/
      && node.className !== "fr-marker") {
        if (getComputedStyle(node, null).getPropertyValue("text-decoration") == "underline" || node.nodeName == "U") {
          return true;
        }
      }
    }
  }

  return false;
};

prx.htmlTextEditor.showStyle = function (propname, editor, dynPropI, isSelectedAll) {
  //3 cases
  //AllSelected, no selection, partial selection
  // var fontFamChangeInitiated = (typeof(editor.prtofontValue) !== 'undefined') ? editor.prtofontValue : false;
  delete editor.prtofontValue;
  if (prx.htmlTextEditor.enableShowStyle == false) return false;
  prx.properties.editable.froalaEditorKeydownInitiated = false;
  var _item = prxy.items[prxy.iSelectedIndex];
  if (typeof _item == "undefined") return false;
  var itemId = _item.id;
  var itemType = _item.type;
  var iframe = $(prx.htmlTextEditor.iframeEl()).get(0).contentDocument || $(prx.htmlTextEditor.iframeEl()).get(0).contentWindow.document;
  var selIsCollapsed = iframe.getSelection().isCollapsed == true ? true : false;
  var selectedNodes = prx.htmlTextEditor.getSelectedNodes(iframe, selIsCollapsed);
  var relatedEditablePropertiesLength = 0;
  if (selectedNodes.length == 0) return;

  if (typeof dynPropI !== "undefined") {
    if (typeof prx.types[itemType].dynamicProperties.propertyGroups !== "undefined") {
      for (var j = 0; j < prx.types[itemType].dynamicProperties.propertyGroups.length; j++) {
        for (var k = 0; k < prx.types[itemType].dynamicProperties.propertyGroups[j].properties.length; k++) {
          var _props = prx.types[itemType].dynamicProperties.propertyGroups[j].properties[k];

          for (var n = 0; n < _props.length; n++) {
            if (typeof _props[n]["relatedEditableProperties"] != "undefined") {
              var _relatedEditableProperties = $.isArray(_props[n]["relatedEditableProperties"]) ? _props[n]["relatedEditableProperties"] : [_props[n]["relatedEditableProperties"]];

              relatedEditablePropertiesLength = _relatedEditableProperties.length; //crucial for _showProperties

              for (var p = 0; p < _relatedEditableProperties.length; p++) {
                var isCustomProperty = _relatedEditableProperties[p].split(/[.]+/).length > 1 ? true : false;
                var relatedEditableProperty = isCustomProperty && typeof _relatedEditableProperties[p].split(/[.]+/)[1] != "undefined" ? _relatedEditableProperties[p].split(/[.]+/)[1] : _relatedEditableProperties[p];

                if (typeof _props[n]["relatedCSSProperties"] != "undefined" && relatedEditableProperty == propname) {
                  var _field = itemId + "-" + _props[n].name + "-" + dynPropI;

                  var _type = _props[n].type;
                  var _name = _props[n].name;

                  if (isSelectedAll && _relatedEditableProperties.length == 1) {
                    if (typeof _props[n].value != "undefined") {
                      if (typeof _props[n].value == "function") {
                        var _value = _props[n].value(_item, _name, dynPropI);
                      } else {
                        var _value = $("#" + _field).html();
                      }
                    } else {
                      var _value = $("#" + _field).html();
                    }

                    _value = typeof _value == "undefined" ? "" : _value;
                    _value = $.isArray(_value) && _value.length == 1 ? _value.join("") : _value;

                    if (typeof _props[n].values != "undefined") {
                      if (typeof _props[n].values == "function") {
                        var _values = _props[n].value(_item, _name, dynPropI);
                      } else {
                        var _values = _props[n].values;
                      }
                    }

                    var _data = {
                      props: _props[n],
                      value: _value,
                      values: _values,
                      _index: dynPropI,
                      _dynamicProp: true,
                      _html: editor.html.get()
                    };
                    var newValue = prx.properties.popup.helper.getInspectorPropsForRichText(_data);

                    if (newValue != -1) {
                      if (newValue !== undefined && newValue != "multiplestyles") {
                        _value = newValue;
                      } else {
                        _value = "";
                      }

                      var relatedCSSProperties = $.isArray(_props[n]["relatedCSSProperties"]) == false ? [_props[n]["relatedCSSProperties"]] : _props[n]["relatedCSSProperties"];
                      relatedCSSProperties.forEach(function (value) {
                        _showProperties(_field, _type, value, _value, void 0, isSelectedAll, _name, dynPropI);
                      });
                    }
                  } else {
                    var relatedCSSProperties = $.isArray(_props[n]["relatedCSSProperties"]) == false ? [_props[n]["relatedCSSProperties"]] : _props[n]["relatedCSSProperties"];
                    relatedCSSProperties.forEach(function (value) {
                      _showProperties(_field, _type, value, prx.htmlTextEditor._getCSSValue(value), editor, isSelectedAll, _name, dynPropI);
                    });
                  }
                }
              }
            }
          }
        }
      }
    }
  } else {
    if (typeof prx.types[itemType].propertyGroups !== "undefined") {
      for (var j = 0; j < prx.types[itemType].propertyGroups.length; j++) {
        for (var k = 0; k < prx.types[itemType].propertyGroups[j].properties.length; k++) {
          var _props = prx.types[itemType].propertyGroups[j].properties[k];

          for (var n = 0; n < _props.length; n++) {
            if (typeof _props[n]["relatedEditableProperties"] != "undefined") {
              var _relatedEditableProperties = $.isArray(_props[n]["relatedEditableProperties"]) ? _props[n]["relatedEditableProperties"] : [_props[n]["relatedEditableProperties"]];

              relatedEditablePropertiesLength = _relatedEditableProperties.length;

              for (var p = 0; p < _relatedEditableProperties.length; p++) {
                if (typeof _props[n]["relatedCSSProperties"] != "undefined" && _relatedEditableProperties[p] == propname) {
                  var _field = itemId + "-" + _props[n].name;

                  var _type = _props[n].type;
                  var _name = _props[n].name;
                  var _values = "";

                  if (isSelectedAll && _relatedEditableProperties.length == 1) {
                    if (typeof _props[n].value != "undefined") {
                      if (typeof _props[n].value == "function") {
                        var _value = _props[n].value(_item, _name);
                      } else {
                        var _value = $("#" + _field).html();
                      }
                    }

                    _value = typeof _value == "undefined" ? "" : _value;
                    _value = $.isArray(_value) && _value.length == 1 ? _value.join("") : _value;

                    if (typeof _props[n].values != "undefined") {
                      if (typeof _props[n].values == "function") {
                        var _values = _props[n].values(_item, _name);
                      } else {
                        var _values = _props[n].values;
                      }
                    }

                    var _data = {
                      props: _props[n],
                      value: _value,
                      values: _values,
                      _html: editor.html.get()
                    };
                    var newValue = prx.properties.popup.helper.getInspectorPropsForRichText(_data);

                    if (newValue != -1) {
                      if (newValue !== undefined && newValue != "multiplestyles") {
                        _value = newValue;
                      } else {
                        _value = "";
                      }

                      var relatedCSSProperties = $.isArray(_props[n]["relatedCSSProperties"]) == false ? [_props[n]["relatedCSSProperties"]] : _props[n]["relatedCSSProperties"];
                      relatedCSSProperties.forEach(function (value) {
                        _showProperties(_field, _type, value, _value, void 0, isSelectedAll, _name, dynPropI);
                      });
                    }
                  } else {
                    var relatedCSSProperties = $.isArray(_props[n]["relatedCSSProperties"]) == false ? [_props[n]["relatedCSSProperties"]] : _props[n]["relatedCSSProperties"];
                    relatedCSSProperties.forEach(function (value) {
                      _showProperties(_field, _type, value, prx.htmlTextEditor._getCSSValue(value), editor, isSelectedAll, _name, dynPropI);
                    });
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  function _showProperties(selectorName, formType, cssProp, newValue, editor, isSelectedAll, propName, dynPropI) {
    if (typeof newValue == "undefined") return;

    if ($("#p-" + selectorName).parents(".property-group:first").hasClass("active") == false) {
      $("#p-" + selectorName).parents(".property-group:first").addClass("active");
    }

    switch (formType) {
      case "select":
        //Font-family && Font-Style
        if ($("#p-" + selectorName).length == 1) {
          if (cssProp == "font-weight" || cssProp == "font-style") {
            var $selector = $("#p-".concat(selectorName));
            var specialValues = ["", " ", "N/A", "multiplestyles"];
            $selector.find("option:selected").each(function () {
              $(this).prop("selected", "false");
            });
            var newText = newValue;

            if (typeof newValue.value != "undefined") {
              newText = newValue.value.replace(/['";]+/g, "");
            }

            newText = newText.toString();

            if (specialValues.indexOf(newText) == -1) {
              var fontWeightValue = prx.componentsHelper.getProp(newText, "font-weight-value");
              var fontStyleValue = prx.componentsHelper.getProp(newText, "font-style-value");
              fontStyleValue = fontStyleValue == "normal" ? "" : fontStyleValue;
              newText = fontWeightValue + fontStyleValue;
            }

            if (newText == "") newText = "multiplestyles";

            if ($("#p-" + selectorName).attr("disabled") == "disabled") {
              $("#p-" + selectorName + " option").filter(function () {
                return this.value == "N/A";
              }).prop("selected", true);
            } else {
              $("#p-" + selectorName + " option").filter(function () {
                return this.value == newText;
              }).prop("selected", true);
            }

            $("#p-" + selectorName).trigger("change.select2"); // Notify only Select2 of changes
          } else if (cssProp == "font-family") {
            var _$selector = $("#p-".concat(selectorName));

            var $selected = _$selector.find("option:selected");

            var currentValue = null;
            currentValue = [];

            if (typeof $selected[0] != "undefined" && typeof $selected[0].value != "undefined") {
              currentValue.push($selected[0].text, $selected[0].value);
            }

            _$selector.find("option:selected").each(function () {
              $(this).prop("selected", "false");
            });

            var newText = newValue;

            if (typeof newValue.name != "undefined") {
              newText = newValue.name.replace(/['";]+/g, "");
            }

            if (typeof newValue.value != "undefined") {
              newValue.value = newValue.value.replace(/['";]+/g, "");
            }

            newText = newText.toString();
            var isMultiSelection = prxy.iSelectedIndex == -1 ? true : false;
            var selector,
                $styleSelector,
                $familySelector,
                family = typeof newValue.name != "undefined" ? newValue.name : newValue,
                familyValue = typeof newValue.value != "undefined" ? newValue.value : newValue,
                isDynProp = false;
            if (family == "multiple-fonts") family = "Multiple";

            if (typeof dynPropI !== "undefined") {
              dynPropI = "-" + dynPropI;
              isDynProp = true;
            } else {
              dynPropI = "";
            }

            if (isMultiSelection) {
              selector = "all-selected";
              $styleSelector = $("#p-all-selected-".concat(propName, "Style").concat(dynPropI));
              $familySelector = $("#p-all-selected-".concat(propName).concat(dynPropI));
            } else {
              selector = _item["id"];
              $styleSelector = $("#p-".concat(_item["id"], "-").concat(propName, "Style").concat(dynPropI));
              $familySelector = $("#p-".concat(_item["id"], "-").concat(propName).concat(dynPropI));
            }

            var isAvailebleAsDisplayValue = $("#p-" + selectorName + " option").filter(function () {
              return this.text.toLowerCase() == family.toLowerCase();
            }).length > 0;
            var isAvailebleAsValue = $("#p-" + selectorName + " option").filter(function () {
              return this.value.toLowerCase() == family.toLowerCase();
            }).length > 0;

            if (!isAvailebleAsDisplayValue && !isAvailebleAsValue) {
              family = "";
            }

            var relatedTextProp = prx.componentsHelper.getTextandFontStylePropsName(itemType, propName + "Style", isDynProp)["relatedTextPropsName"];

            if (relatedTextProp) {
              prx.fontManager.showCorrectTextStyleOptions(family, $styleSelector, selector, relatedTextProp, dynPropI);
            }

            if (isAvailebleAsDisplayValue || family == "") {
              $("#p-" + selectorName + " option").filter(function () {
                return this.text.toLowerCase() == family.toLowerCase();
              }).prop("selected", true);
            } else if (isAvailebleAsValue) {
              $("#p-" + selectorName + " option").filter(function () {
                return this.value.toLowerCase() == family.toLowerCase();
              }).prop("selected", true);
            }

            $("#p-" + selectorName).trigger("change.select2"); // Notify only Select2 of change

            var variantsArray = prx.fontManager.getVariantsFromFamilyName(family, familyValue);
            prx.fontManager.updateStyleSelector($styleSelector, variantsArray, familyValue, "");
          }
        }

        break;

      case "combo-select":
        //FONT SIZE
        if ($("#p-" + selectorName + "-select").length == 1) {
          _addValueIfNotExists(selectorName, formType, newValue);

          $("#p-" + selectorName).prop("selected", "false").val(newValue);
          $("#p-" + selectorName + "-select option:selected").prop("selected", "false");
          $("#p-" + selectorName + '-select [value="' + newValue + '"]').prop("selected", true);
        }

        break;

      case "colorpicker":
        if ($("#p-" + selectorName).length == 1) {
          $("#p-" + selectorName).attr("value", newValue);
        }

        $("#p-" + selectorName + " ~ .colorpicker-wrapper .loadColorpickerBtn").each(function () {
          $(this).css("background-color", newValue).attr("data-color", newValue);
        });
        break;

      case "combo-colorpicker":
        if ($("#p-" + selectorName).length == 1) {
          $("#p-" + selectorName).attr("value", newValue);
        }

        $("#p-" + selectorName + " ~ .colorpicker-wrapper .loadColorpickerBtn").each(function () {
          $(this).css("background-color", newValue).attr("data-color", newValue);
        });
        break;

      case "input-numeric":
        //line height
        if ($("#p-" + selectorName).length == 1) {
          if (!isNaN(newValue)) {
            $("#p-" + selectorName).val(newValue);
          } else {
            $("#p-" + selectorName).val("0");
          }
        }

        break;

      case "checkbox":
        if (cssProp == "text-decoration") {
          if ($("#p-" + selectorName + "-" + 0).length == 1) {
            if (isSelectedAll && relatedEditablePropertiesLength == 1) {
              newValue = newValue.indexOf("underline") > -1 ? true : false;
            } else {
              if (typeof newValue != "boolean") {
                newValue = newValue.indexOf("underline") > -1 ? true : false;
              }
            }

            $("#p-" + selectorName + "-" + 0).prop("checked", newValue);
          }
        }

        break;

      case "radio":
        if (cssProp == "text-align") {
          if (editor) editor.textAlign = newValue;

          for (var i = 0; i < 4; i++) {
            if ($("#p-" + selectorName + "-" + i).length == 1) {
              var _newValue = $("#p-" + selectorName + "-" + i).val() == newValue ? true : false;

              $("#p-" + selectorName + "-" + i).prop("checked", _newValue);
            }
          }
        }

        break;

      default:
        break;
    }
  }

  function _addValueIfNotExists(selectorName, formType, newValue) {
    if (formType == "select") {
      var newValueCheck = $("#p-" + selectorName + " option").filter(function () {
        return this.text == newValue;
      });

      if (newValueCheck.length == 0) {
        $("#p-" + selectorName).prepend($("<option>", {
          value: newValue,
          text: newValue
        }));
      }
    } else if (formType == "combo-select") {
      var newValueCheck = $("select[id=p-" + selectorName + "-select] option").filter(function () {
        return this.text == newValue;
      });

      if (newValueCheck.length == 0) {
        $("#p-" + selectorName + "-select").prepend($("<option>", {
          value: newValue,
          text: newValue
        }));
      }
    }
  }
};

prx.htmlTextEditor._getCSSValue = function (_value) {
  var iframe = $(prx.htmlTextEditor.iframeEl()).get(0).contentDocument || $(prx.htmlTextEditor.iframeEl()).get(0).contentWindow.document;
  var selIsCollapsed = iframe.getSelection().isCollapsed == true ? true : false;
  var selectedNodes = prx.htmlTextEditor.getSelectedNodes(iframe, selIsCollapsed);

  if (selIsCollapsed) {
    var computedStyles = getComputedStyle(selectedNodes[0], null);
    var newValue = computedStyles.getPropertyValue(_value);

    switch (_value) {
      case "font-style":
        return "".concat(computedStyles.getPropertyValue("font-weight")).concat(computedStyles.getPropertyValue("font-style"));
        break;

      case "font-weight":
        return "".concat(computedStyles.getPropertyValue("font-weight")).concat(computedStyles.getPropertyValue("font-style"));
        break;

      case "text-decoration":
        //special case
        if (newValue.indexOf("underline") > -1) {
          return true;
        } else {
          //special call function
          if (prx.htmlTextEditor.checkParentsForUndeline(selectedNodes[0])) {
            return true;
          } else {
            return false;
          }
        }

        break;

      case "font-family":
        return prx.componentsHelper.getFontFamilyFromCSS(newValue);
        break;

      case "font-size":
      case "letter-spacing":
      case "line-height":
      case "text-align":
      case "color":
        return newValue.replace("px", "");
        break;

      default:
        return newValue;
        break;
    }
  } else {
    var cssValues = [];
    var mappings = {
      "font-weight": "bold",
      "font-style": "italic",
      "text-decoration": "underline"
    };
  }

  for (var i = 0; i < selectedNodes.length; i++) {
    if (selectedNodes[i] !== null && typeof selectedNodes[i + 1] != "undefined" && selectedNodes[i + 1] !== null && selectedNodes[i + 1].textContent.trim() !== "" && selectedNodes[i + 1].className !== "fr-marker" && selectedNodes[i + 1].nodeType == 3) {
      selectedNodes[i]["getStyle"] = true;
    } else if (selectedNodes[i] !== null && typeof selectedNodes[i - 1] != "undefined" && selectedNodes[i - 1] !== null && selectedNodes[i - 1].textContent.trim() !== "" && selectedNodes[i - 1].className !== "fr-marker" && selectedNodes[i - 1].nodeType == 3) {
      selectedNodes[i]["getStyle"] = true;
    } else if (selectedNodes[i] !== null && selectedNodes[i].textContent.trim() !== "" && selectedNodes[i].className !== "fr-marker" && selectedNodes[i].nodeType == 3) {
      selectedNodes[i]["getStyle"] = true;
    } else if (selectedNodes[i] !== null) {
      selectedNodes[i]["getStyle"] = false;
    }
  }

  for (var i = 0; i < selectedNodes.length; i++) {
    if (selectedNodes[i] == null || !selectedNodes[i]["getStyle"]) continue;

    if (_value === "font-style" || _value === "font-weight") {
      var currentNode = selectedNodes[i];

      if (!currentNode.nodeType || !currentNode.style) {
        currentNode = currentNode.parentNode;
      }

      var style = getComputedStyle(currentNode, null).getPropertyValue("font-style");
      var weight = getComputedStyle(currentNode, null).getPropertyValue("font-weight");
      if (style !== "italic") style = "";
      if (weight === "bold") weight = "700";
      if (weight === "normal") weight = "400";
      cssValues.push("".concat(weight).concat(style));
    } else {
      var _currentNode = selectedNodes[i];

      if (!_currentNode.nodeType || !_currentNode.style) {
        _currentNode = _currentNode.parentNode;
      }

      cssValues.push(window.getComputedStyle(_currentNode, null).getPropertyValue(_value));
    }
  }

  switch (_value) {
    case "font-weight":
      if (cssValues.length > 0 && prx.htmlTextEditor.arrayHasTheSameValues(cssValues)) {
        return cssValues[0];
      } else {
        return "multiplestyles";
      }

      break;

    case "font-style":
      if (cssValues.length > 0 && prx.htmlTextEditor.arrayHasTheSameValues(cssValues)) {
        return cssValues[0];
      } else {
        return "multiplestyles";
      }

      break;

    case "text-decoration":
      //special case
      if (cssValues.length > 0 && prx.htmlTextEditor.arrayHasTheSameValues(cssValues)) {
        if (cssValues[0] == mappings[_value]) {
          return true;
        } else {
          if (prx.htmlTextEditor.checkParentsForUndeline(selectedNodes[0])) {
            return true;
          } else {
            return false;
          }
        }
      }

      break;

    case "font-size":
    case "letter-spacing":
    case "line-height":
    case "text-align":
    case "color":
      if (cssValues.length > 0 && prx.htmlTextEditor.arrayHasTheSameValues(cssValues)) {
        return cssValues[0].replace("px", "");
      } else {
        return "";
      }

      break;

    case "font-family":
      if (cssValues.length > 0 && prx.htmlTextEditor.arrayHasTheSameValues(cssValues)) {
        return prx.componentsHelper.getFontFamilyFromCSS(cssValues[0]);
      } else {
        return {
          name: "Multiple",
          value: "multiple-fonts"
        };
      }

      break;

    default:
      return "";
      break;
  }
};

prx.htmlTextEditor.getStyleSheetsFromParentForIframe = function (searchFor) {
  var cssFilesArray = [];
  Array.prototype.forEach.call(window.document.querySelectorAll("link[rel=stylesheet]"), function (link) {
    var newLink = document.createElement("link");
    newLink.rel = link.rel;
    newLink.href = link.href;

    if (typeof searchFor !== "undefined") {
      if (newLink.href.indexOf(searchFor) > -1) {
        cssFilesArray.push(link.href);
      }
    } else {
      cssFilesArray.push(link.href);
    }
  });
  return cssFilesArray;
};

prx.htmlTextEditor.arrayHasTheSameValues = function (array) {
  for (var i = 0; i < array.length - 1; i++) {
    if (array[i] !== array[i + 1]) {
      return false;
    }
  }

  return true;
};

prx.htmlTextEditor.checkForRelatedEditableProperties = function (itemType, propname, dynPropI) {
  if (typeof itemType == "undefined" || typeof propname == "undefined") {
    return false;
  }

  if (typeof dynPropI !== "undefined") {
    if (typeof prx.types[itemType].dynamicProperties.propertyGroups !== "undefined") {
      for (var j = 0; j < prx.types[itemType].dynamicProperties.propertyGroups.length; j++) {
        for (var k = 0; k < prx.types[itemType].dynamicProperties.propertyGroups[j].properties.length; k++) {
          var _props = prx.types[itemType].dynamicProperties.propertyGroups[j].properties[k];

          for (var n = 0; n < _props.length; n++) {
            if (typeof _props[n]["relatedEditableProperties"] != "undefined") {
              var _relatedEditableProperties = $.isArray(_props[n]["relatedEditableProperties"]) ? _props[n]["relatedEditableProperties"] : [_props[n]["relatedEditableProperties"]];

              for (var p = 0; p < _relatedEditableProperties.length; p++) {
                var isCustomProperty = _relatedEditableProperties[p].split(/[.]+/).length > 1 ? true : false;

                if (isCustomProperty) {
                  var path = _relatedEditableProperties[p].split(/[.]+/);

                  if (typeof path[1] !== "undefined" && path[1] == propname) {
                    return true;
                  }
                } else if (typeof _props[n]["relatedCSSProperties"] != "undefined" && _relatedEditableProperties[p] == propname) {
                  return true;
                }
              }
            }
          }
        }
      }
    } //check for custom props i.e subtitles.text in propertyGroups


    if (typeof prx.types[itemType].propertyGroups !== "undefined") {
      for (var j = 0; j < prx.types[itemType].propertyGroups.length; j++) {
        for (var k = 0; k < prx.types[itemType].propertyGroups[j].properties.length; k++) {
          var _props = prx.types[itemType].propertyGroups[j].properties[k];

          for (var n = 0; n < _props.length; n++) {
            if (typeof _props[n]["relatedEditableProperties"] != "undefined") {
              var _relatedEditableProperties = $.isArray(_props[n]["relatedEditableProperties"]) ? _props[n]["relatedEditableProperties"] : [_props[n]["relatedEditableProperties"]];

              for (var p = 0; p < _relatedEditableProperties.length; p++) {
                var isCustomProperty = _relatedEditableProperties[p].split(/[.]+/).length > 1 ? true : false;

                if (isCustomProperty) {
                  var path = _relatedEditableProperties[p].split(/[.]+/);

                  if (typeof path[1] !== "undefined" && path[1] == propname) {
                    return true;
                  }
                }
              }
            }
          }
        }
      }
    }
  } else {
    if (typeof prx.types[itemType].propertyGroups !== "undefined") {
      for (var j = 0; j < prx.types[itemType].propertyGroups.length; j++) {
        for (var k = 0; k < prx.types[itemType].propertyGroups[j].properties.length; k++) {
          var _props = prx.types[itemType].propertyGroups[j].properties[k];

          for (var n = 0; n < _props.length; n++) {
            if (typeof _props[n]["relatedEditableProperties"] != "undefined") {
              var _relatedEditableProperties = $.isArray(_props[n]["relatedEditableProperties"]) ? _props[n]["relatedEditableProperties"] : [_props[n]["relatedEditableProperties"]];

              for (var p = 0; p < _relatedEditableProperties.length; p++) {
                if (typeof _props[n]["relatedCSSProperties"] != "undefined" && _relatedEditableProperties[p] == propname) {
                  return true;
                }
              }
            }
          }
        }
      }
    }
  }

  return false;
}; //BIU when froala closed


prx.htmlTextEditor.keyboardShortCutsBIU = function (event) {
  var action = event.key == "b" ? "bold" : event.key == "i" ? "italic" : "underline";
  var style = event.key == "b" ? "font-weight" : event.key == "i" ? "font-style" : "underline";
  var isMultiSelection = prxy.iSelectedIndex == -1 && prxy.iSelectedIndexes.length > 0;
  var selectedItemsIndexes = isMultiSelection ? prxy.iSelectedIndexes : [prxy.iSelectedIndex];
  var selectedAllowedItemIds = [];
  var selectedInvalidItemIds = [];
  var validSelectedItemsIndex = [];
  var validItemTypes = ["text", "rectangle", "shape", "circle"];
  var itemsToUpdate = {}; //find valid items with a valid item type

  selectedItemsIndexes.forEach(function (itemIndex) {
    if (typeof prxy.items[itemIndex] != "undefined" && typeof prxy.items[itemIndex]["type"] != "undefined") {
      if (validItemTypes.indexOf(prxy.items[itemIndex]["type"]) === -1) {
        selectedInvalidItemIds.push(itemIndex);
      } else {
        selectedAllowedItemIds.push(prxy.items[itemIndex].id);
        validSelectedItemsIndex.push(itemIndex);
      }
    }
  });
  validSelectedItemsIndex.forEach(function (itemIndex) {
    var item = prxy.items[itemIndex];
    var itemType = prxy.items[itemIndex]["type"];
    var groupPropsSimplified = [];
    var groupProps; //get property groups for each valid item

    if (typeof prx.types[itemType].propertyGroups != "undefined") {
      prx.types[itemType].propertyGroups.forEach(function (propertyGroup) {
        groupProps = propertyGroup.properties.reduce(function (a, b) {
          return a.concat(b);
        });
        groupPropsSimplified = groupPropsSimplified.concat(groupProps);
      });
    } //loop props and find textProperties && font family properties


    for (var i = 0; i < groupPropsSimplified.length; i++) {
      //check if font family is overwritten
      if (action != "underline") {
        if (prx.componentsHelper.isFontFamilyProp(groupPropsSimplified[i])) {
          if (typeof itemsToUpdate[itemIndex] == "undefined") itemsToUpdate[itemIndex] = {};
          var diagnosticMode = true;
          var currentFontFamilyIsOverwritten = typeof prx.properties.popup.helper.getInspectorPropsForRichText({
            props: groupPropsSimplified[i],
            value: prxy.items[itemIndex]["textFont"]
          }, itemIndex, diagnosticMode)["font-family"] == "undefined" || prx.properties.popup.helper.getInspectorPropsForRichText({
            props: groupPropsSimplified[i],
            value: prxy.items[itemIndex]["textFont"]
          }, itemIndex, diagnosticMode)["font-family"] == "" || prx.properties.popup.helper.getInspectorPropsForRichText({
            props: groupPropsSimplified[i],
            value: prxy.items[itemIndex]["textFont"]
          }, itemIndex, diagnosticMode)["font-family"] == " ";
          itemsToUpdate[itemIndex]["fontFamilyPropsGroup"] = groupPropsSimplified[i];
          itemsToUpdate[itemIndex]["currentFontFamily"] = prxy.items[itemIndex]["textFont"];
          itemsToUpdate[itemIndex]["currentFontFamilyIsOverwritten"] = currentFontFamilyIsOverwritten;
        }
      } //check if font style is overwritten and decide for action to be taken


      if (prx.componentsHelper.isTextPropertiesProp(groupPropsSimplified[i])) {
        //analyze each item(search for overwrites of bold/itali/underline) and save info for next step. Check also if they can be bolded, unbolded, italiced, unitaliced
        var relatedEditableProperties = $.isArray(groupPropsSimplified[i]["relatedEditableProperties"]) ? groupPropsSimplified[i]["relatedEditableProperties"][0] : groupPropsSimplified[i]["relatedEditableProperties"];

        if (groupPropsSimplified[i].value !== undefined && typeof groupPropsSimplified[i].value === "function") {
          if (typeof itemsToUpdate[itemIndex] == "undefined") itemsToUpdate[itemIndex] = {};
          var _diagnosticMode = true;
          var overwrites = prx.properties.popup.helper.getInspectorPropsForRichText({
            props: groupPropsSimplified[i],
            value: groupPropsSimplified[i].value(item, groupPropsSimplified[i], false)
          }, itemIndex, _diagnosticMode);
          var getRelatedProps = prx.componentsHelper.getTextandFontStylePropsName(prxy.items[itemIndex]["type"], groupPropsSimplified[i]["name"]);
          var availableFontStyles = prx.fontManager.getVariantsFromFamilyName(prxy.items[itemIndex][getRelatedProps["relatedFontFamilyPropsName"]]);
          itemsToUpdate[itemIndex]["itemIndex"] = itemIndex;
          itemsToUpdate[itemIndex]["item"] = prxy.items[itemIndex];
          itemsToUpdate[itemIndex]["textPropsGroup"] = groupPropsSimplified[i];
          itemsToUpdate[itemIndex]["relatedTextPropName"] = groupPropsSimplified[i]["name"];
          itemsToUpdate[itemIndex]["relatedFontStylePropName"] = getRelatedProps["relatedTextFontStylePropsName"];
          itemsToUpdate[itemIndex]["relatedFontStylePropsGroup"] = getRelatedProps["textFontStyleGroup"];
          itemsToUpdate[itemIndex]["relatedFontFamilyPropName"] = getRelatedProps["relatedFontFamilyPropsName"];
          itemsToUpdate[itemIndex]["availableFontStyles"] = availableFontStyles;

          if (overwrites[action]) {
            itemsToUpdate[itemIndex]["fontStyleIsOverwritten"] = true;
            itemsToUpdate[itemIndex]["action"] = action;
            itemsToUpdate[itemIndex]["relatedEditableProperties"] = relatedEditableProperties;
            itemsToUpdate[itemIndex]["html"] = item[relatedEditableProperties];

            if (groupPropsSimplified[i].value(item, groupPropsSimplified[i], false).indexOf(action) > -1) {
              //is currently bold/italic/underline but overwritten
              itemsToUpdate[itemIndex]["status"] = "disabled";
            } else {
              //is currently unbold/unitalic/ununderline but overwritten
              itemsToUpdate[itemIndex]["status"] = "disabled";
            }
          } else {
            itemsToUpdate[itemIndex]["fontStyleIsOverwritten"] = false;
            itemsToUpdate[itemIndex]["action"] = action;
            itemsToUpdate[itemIndex]["relatedEditableProperties"] = relatedEditableProperties;
            itemsToUpdate[itemIndex]["html"] = item[relatedEditableProperties];

            if (groupPropsSimplified[i].value(item, groupPropsSimplified[i], false).indexOf(action) > -1) {
              //is currently fully bold/italic/underline
              itemsToUpdate[itemIndex]["status"] = "enabled";
            } else {
              //is currently fully unbold/unitalic/ununderline
              itemsToUpdate[itemIndex]["status"] = "disabled";
            }
          } //check wether the opposite action from the current status can be done or not - we remove those items later


          if (action != "underline") {
            var _data2 = {
              _iprop: prx.toolbox.clone(groupPropsSimplified[i]),
              _action: itemsToUpdate[itemIndex]["status"] == "enabled" ? "disabled" : "enabled",
              _value: action,
              //bold , italic
              _item: prxy.items[itemIndex]
            };
            _data2._iprop.name = getRelatedProps["relatedTextFontStylePropsName"];
            _data2._iprop["relatedCSSProperties"] = ["font-weight", "font-style"];

            var _desiredFontStyleValue = prx.properties.popup.helper.convertBIValueToFontStyleValues(_data2);

            itemsToUpdate[itemIndex]["desiredFontStyle"] = _desiredFontStyleValue;
            itemsToUpdate[itemIndex]["desiredFontStyleIsAvailable"] = availableFontStyles.indexOf(_desiredFontStyleValue) > -1;
          }
        }
      }
    }
  }); //remove items that new style cannot be applied

  if (action != "underline") {
    for (var key in itemsToUpdate) {
      if (!itemsToUpdate[key]["desiredFontStyleIsAvailable"] || itemsToUpdate[key]["currentFontFamilyIsOverwritten"]) {
        delete itemsToUpdate[key];
      }
    }
  }

  if (Object.keys(itemsToUpdate).length == 0) {
    return false;
  }

  var currentActionStatus = [];

  for (var key in itemsToUpdate) {
    currentActionStatus.push(itemsToUpdate[key]["status"]);
  } //check if all items have overwrites and if they have the same status ('enable' or 'disable')


  var allActionStatusEqual = !!currentActionStatus.reduce(function (a, b) {
    return a === b ? a : NaN;
  });

  if (!allActionStatusEqual) {
    //have bolded and ubolded items in selection (or italic, or underline) -
    for (var key in itemsToUpdate) {
      var itemIndex = itemsToUpdate[key]["itemIndex"];
      var relatedEditableProperties = itemsToUpdate[key]["relatedEditableProperties"];
      var relatedTextProp = itemsToUpdate[key]["relatedTextPropName"];
      var fontStyleProps = itemsToUpdate[key]["relatedFontStylePropName"];
      var itemHtml = itemsToUpdate[key]["html"];

      if (action == "underline") {
        prxy.items[itemIndex][relatedTextProp] = [];
        prxy.items[itemIndex][relatedEditableProperties] = prx.componentsHelper.stripStyle(itemHtml, style, false);
      } else {
        var data = {
          _iprop: prx.toolbox.clone(itemsToUpdate[key]["textPropsGroup"])
        };
        data._iprop.name = fontStyleProps;
        data._iprop["relatedCSSProperties"] = ["font-weight", "font-style"];
        data._action = "disable";
        data._value = action; //bold , italic

        data._item = itemsToUpdate[key]["item"];
        var desiredFontStyleValue = prx.properties.popup.helper.convertBIValueToFontStyleValues(data);

        if (itemsToUpdate[key]["availableFontStyles"].indexOf(desiredFontStyleValue) > -1) {
          prxy.items[itemIndex][fontStyleProps] = desiredFontStyleValue; //update textFontStyle props

          prxy.items[itemIndex][relatedEditableProperties] = prx.componentsHelper.stripStyle(itemHtml, style, false); // update item text value
        }

        if (typeof itemsToUpdate[itemIndex]["relatedFontStylePropsGroup"].onChange == "function") {
          itemsToUpdate[itemIndex]["relatedFontStylePropsGroup"].onChange(itemsToUpdate[key]["item"]);
        }
      }

      prx.items.update(itemsToUpdate[key]["item"], validSelectedItemsIndex.length == 1);
    }
  } else if (allActionStatusEqual) {
    if (currentActionStatus[0] == "disabled") {
      //have only unbolded items in selection (or italic, or underline)
      for (var key in itemsToUpdate) {
        var _itemIndex = itemsToUpdate[key]["itemIndex"];
        var _relatedEditableProperties2 = itemsToUpdate[key]["relatedEditableProperties"];
        var _relatedTextProp = itemsToUpdate[key]["relatedTextPropName"];
        var _fontStyleProps = itemsToUpdate[key]["relatedFontStylePropName"];
        var _itemHtml = itemsToUpdate[key]["html"];

        if (action == "underline") {
          var _strippedText = prx.componentsHelper.stripStyle(_itemHtml, style, false);

          prxy.items[_itemIndex][_relatedTextProp] = ["underline"]; //update text props

          prxy.items[_itemIndex][_relatedEditableProperties2] = "<u>" + _strippedText + "</u>";
        } else {
          var data = {
            _iprop: prx.toolbox.clone(itemsToUpdate[key]["textPropsGroup"])
          };
          data._iprop.name = itemsToUpdate[key]["relatedFontStylePropName"];
          data._iprop["relatedCSSProperties"] = ["font-weight", "font-style"];
          data._action = "enable";
          data._value = action; //bold , italic

          data._item = itemsToUpdate[key]["item"];
          var desiredFontStyleValue = prx.properties.popup.helper.convertBIValueToFontStyleValues(data);

          if (itemsToUpdate[key]["availableFontStyles"].indexOf(desiredFontStyleValue) > -1) {
            var _strippedText2 = prx.componentsHelper.stripStyle(itemsToUpdate[key].html, style, false);

            prxy.items[_itemIndex][_fontStyleProps] = itemsToUpdate[_itemIndex]["desiredFontStyle"]; //update textFontStyle props

            prxy.items[_itemIndex][_relatedEditableProperties2] = _strippedText2; // update item text value

            var newHTML = "";

            if (action == "bold") {
              newHTML = '<span style="font-weight:' + prx.componentsHelper.getProp(desiredFontStyleValue, "font-weight-value") + ';">' + _strippedText2 + "</span>";
            } else {
              newHTML = '<span style="font-style:' + prx.componentsHelper.getProp(desiredFontStyleValue, "font-style-value") + '">' + _strippedText2 + "</span>";
            } // let newHTML = '<span style="font-weight:'+ prx.componentsHelper.getProp(newValue, 'font-weight-value') +';font-style:'+ prx.componentsHelper.getProp(newValue, 'font-style-value') +'">' + strippedText + '</span>';


            prxy.items[_itemIndex][_relatedEditableProperties2] = newHTML;
            prxy.items[_itemIndex][_fontStyleProps] = desiredFontStyleValue;
          }

          if (typeof itemsToUpdate[_itemIndex]["relatedFontStylePropsGroup"].onChange == "function") {
            itemsToUpdate[_itemIndex]["relatedFontStylePropsGroup"].onChange(itemsToUpdate[key]["item"]);
          }
        }

        prx.items.update(itemsToUpdate[key]["item"], validSelectedItemsIndex.length == 1);
      }
    }

    if (currentActionStatus[0] == "enabled") {
      //have only bolded items in selection (or italic, or underline)
      for (var key in itemsToUpdate) {
        var _itemIndex2 = itemsToUpdate[key]["itemIndex"];
        var _relatedEditableProperties3 = itemsToUpdate[key]["relatedEditableProperties"];
        var _relatedTextProp2 = itemsToUpdate[key]["relatedTextPropName"];
        var _fontStyleProps2 = itemsToUpdate[key]["relatedFontStylePropName"];
        var _itemHtml2 = itemsToUpdate[key]["html"];

        if (action == "underline") {
          var _strippedText3 = prx.componentsHelper.stripStyle(_itemHtml2, style, false);

          prxy.items[_itemIndex2][_relatedTextProp2] = [];
          prxy.items[_itemIndex2][_relatedEditableProperties3] = _strippedText3;
        } else {
          var strippedText = prx.componentsHelper.stripStyle(_itemHtml2, style, false);
          var data = {
            _iprop: prx.toolbox.clone(itemsToUpdate[key]["textPropsGroup"])
          };
          data._iprop.name = _fontStyleProps2;
          data._iprop["relatedCSSProperties"] = ["font-weight", "font-style"];
          data._action = "disable";
          data._value = action; //bold , italic

          data._item = itemsToUpdate[key]["item"];
          var desiredFontStyleValue = prx.properties.popup.helper.convertBIValueToFontStyleValues(data);

          if (itemsToUpdate[key]["availableFontStyles"].indexOf(desiredFontStyleValue) > -1) {
            var strippedText = prx.componentsHelper.stripStyle(_itemHtml2, style, false);
            prxy.items[_itemIndex2][_fontStyleProps2] = desiredFontStyleValue; //update textFontStyle props

            prxy.items[_itemIndex2][_relatedEditableProperties3] = strippedText; // update item text value
          }

          if (typeof itemsToUpdate[_itemIndex2]["relatedFontStylePropsGroup"].onChange == "function") {
            itemsToUpdate[_itemIndex2]["relatedFontStylePropsGroup"].onChange(itemsToUpdate[key]["item"]);
          }
        }

        prx.items.update(itemsToUpdate[key]["item"], validSelectedItemsIndex.length == 1);
      }
    }
  }

  prx.properties.popup.show();
  prx.states.checkBuildTimeline(selectedAllowedItemIds, ["textFontstyle"]);
  prx.screenshots.addIconToOutdated();
  prx.history.reset();
  prx.history.append();
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/css/player-engine-export-min.scss":
/*!**************************************************************!*\
  !*** ./sass/player-engine/css/player-engine-export-min.scss ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./sass/player-engine/css/player-engine-min.scss":
/*!*******************************************************!*\
  !*** ./sass/player-engine/css/player-engine-min.scss ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./sass/player-engine/js/components/_actions-library.js":
/*!**************************************************************!*\
  !*** ./sass/player-engine/js/components/_actions-library.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

prx.actionsLibrary = {};

prx.actionsLibrary.loadPage = function (action) {
  if (action.animation == '') {
    action.animation = 'none';
  }
  /* Overwrite default transitions with custom  for load*/

  /*
   var _loadTransitions = [];
   _loadTransitions['slide'] = 'slidenofadeload';
   _loadTransitions['slideback'] = 'slidebacknofadeload';
   _loadTransitions['slidedown'] = 'slidedownnofadeload';
   _loadTransitions['slideup'] = 'slideupnofadeload';
   _loadTransitions['pop'] = 'popnofadeload';
   _loadTransitions['fade'] = 'fadenofadeload';
   _loadTransitions['flip'] = 'flipnofadeload';
   _loadTransitions['turn'] = 'turnnofadeload';
   _loadTransitions['flow'] = 'flownofadeload';
       if (typeof _loadTransitions[action.animation] != "undefined") {
   action.animation = _loadTransitions[action.animation];
   }
   */


  var _activePage = prx.navigation._activepage;
  $('#p-' + action.pageId).attr('loadedFrom', _activePage);

  var _loadedFrom = $('#' + _activePage); //giving class and z-index value based on the fact that there might be multiple loaded overlays in the DOM.
  //each class (loadedTo-1,loadedTo-2,loadedTo-3.....have a limit up to 30) has higher z-index value


  var loadedToOrdering = Math.max.apply(this, $(_loadedFrom).map(function (el) {
    var regex = /(^|\s)loadedTo-(\d)*/g;
    var classes = $(this).attr('class');
    var match = classes.match(regex);
    if (match === null) return 0;
    return classes.match(regex)[0].replace(' loadedTo-', '').replace('loadedTo-', '');
  }));
  $(_loadedFrom).addClass('loadedFrom'); // $('#p-' + action.pageId).addClass('loadedTo');

  $('#p-' + action.pageId).removeClass(function (index, css) {
    //remove existing 'loadedTo-X' and add new
    var regx = new RegExp('(^|)loadedTo-\\d*', 'g');
    return (css.match(regx) || []).join(' ');
  }).addClass('loadedTo-' + parseInt(loadedToOrdering + 1)); //.css('z-index','9999999');

  var _transition = action.animation;
  $('#p-' + action.pageId).one('pageshow', function () {
    prx.actions.callback(action);
  });
  prx.navigation.pushToBackStack('#' + prx.navigation._activepage, _transition, action.duration, action.animationEasing, 'loadscreens');
  setTimeout(function () {
    prx.navigation.changePage($('#p-' + action.pageId), {
      transition: _transition,
      duration: action.duration,
      easing: action.animationEasing,
      allowSamePageTransition: false,
      overlay: 'in'
    }); // $('p-' + action.pageId +  ' .bodymovin').each(function(){
    //     // lottie.registerAnimation($(this)[0])
    //     lottie.loadAnimation({
    //         container: $(this)[0], // the dom element
    //         renderer: 'svg',
    //         loop: $(this).attr('data-anim-loop'),
    //         autoplay: true,
    //         path: $(this).attr('data-bm-path'), // the animation data
    //         // rendererSettings: {
    //         //     context: canvasContext, // the canvas context
    //         //     scaleMode: 'noScale',
    //         //     clearCanvas: false,
    //         //     progressiveLoad: false, // Boolean, only svg renderer, loads dom elements when needed. Might speed up initialization for large number of elements.
    //         //     hideOnTransparent: true //Boolean, only svg renderer, hides elements when opacity reaches 0 (defaults to true)
    //         // }
    //     });
    // });
  }, action.delay);
};

prx.actionsLibrary.unloadPage = function (action) {
  /* BACKWARD COMPATIBILITY WITH OLD JQUERY TRANSITIONS FOR OVERLAY UNLOAD*/

  /*
   var _unloadTransitions = [];
   _unloadTransitions['slide'] = 'slidenofadeunload';
   _unloadTransitions['slideback'] = 'slidebacknofadeunload';
   _unloadTransitions['slidedown'] = 'slidedownnofadeunload';
   _unloadTransitions['slideup'] = 'slideupnofadeunload';
   _unloadTransitions['pop'] = 'popnofadeunload';
   _unloadTransitions['fade'] = 'fadenofadeunload';
   _unloadTransitions['flip'] = 'flipnofadeunload';
   _unloadTransitions['turn'] = 'turnnofadeunload';
   _unloadTransitions['flow'] = 'flownofadeunload';
       if (typeof _unloadTransitions[action.animation] != "undefined") {
   action.animation = _unloadTransitions[action.animation];
   }
   */
  if (action.animation == '') {
    action.animation = 'none';
  }

  var _loadedPage = prx.navigation._activepage;

  var _showPage = $('#' + _loadedPage).attr('loadedFrom');

  if (typeof _showPage != "undefined") {
    var _transition = action.animation;

    if (_transition === '_reversePrevTransition') {
      if (prx.navigation._gobackstack.loadscreens.length > 0) {
        _transition = prx.screenTransitions.reverseMapping[prx.navigation._gobackstack.loadscreens[prx.navigation._gobackstack.loadscreens.length - 1].transition] || 'none';
        action.duration = prx.navigation._gobackstack.loadscreens[prx.navigation._gobackstack.loadscreens.length - 1].duration;
        action.animationEasing = prx.navigation._gobackstack.loadscreens[prx.navigation._gobackstack.loadscreens.length - 1].easing;
      } else {
        _transition = 'none';
      }
    }

    prx.navigation._gobackstack.loadscreens.pop(); // very risky patenta for not calling pageshow - warning, $._data could break at any jQuery update
    // v5.16.1 now handling in navigation.changepage . not triggering pageshow etc
    // var _events = $._data($('#' + _showPage).get(0), "events").pageshow
    // delete $._data($('#' + _showPage).get(0), "events").pageshow;
    // v5.16.1 changed this to _showpage.onpageshow to _loadedpage.pageshow


    $('#' + _loadedPage).one('pagehide', function () {
      // very risky patenta for not calling pageshow part 2
      // $._data($(this).get(0), "events").pageshow = _events;
      //finding and removing "loadedTo-{X}" classes (see prx.actionsLibrary.loadPage function)
      var regx = new RegExp('(^|)loadedTo-\\d*', 'g');
      $('#' + _loadedPage).removeClass(function (index, css) {
        return (css.match(regx) || []).join(' ');
      }); // $('#' + _loadedPage).removeClass('loadedTo');//.css('z-index','');

      $('#' + _showPage).removeClass('loadedFrom');
      var sel = $('#' + _showPage).get(0);
      var origDisp = sel.style.display;
      sel.style.display = 'none';
      sel.offsetHeight; // no need to store this anywhere, the reference is enough

      sel.style.display = origDisp; // 'block';

      _showPage = null; // perf+

      prx.actions.callback(action);
    });
    setTimeout(function () {
      prx.navigation.changePage($('#' + _showPage), {
        transition: _transition,
        duration: action.duration,
        easing: action.animationEasing,
        overlay: 'out'
      });
    }, action.delay);
  } else {
    prx.actions.callback(action);
  }
};

prx.actionsLibrary.hideItem = function (action) {
  var targetId = action.targetId; // if (typeof(action.pageId) != "undefined" && action.pageId != -1) {
  //     targetId = '#p-' + action.pageId + '-' + action.itemId;
  // }

  var _duration = action.duration;
  var _easing = action.animationEasing;
  _easing = prx.easing.get(_easing);
  if (typeof _duration == "undefined") _duration = 0;

  if (targetId.indexOf('group') != -1) {
    targetId = action.targetId.replace('-group-', ' .group-');
    var groupdata = prx.groups.getGroupData(targetId);

    if (!groupdata) {
      prx.actions.callback(action);
      return;
    }

    groupdata.targetids.forEach(function (targetId, index) {
      prx.items.updateTransformIfHidden(targetId);
    });
    prx.visibility.set(targetId, 'visible', false);
    var callCallback = {
      val: true
    };
    groupdata.targetids.forEach(function (targetId, index) {
      new TimelineMax().add(function () {
        $(targetId).addClass('animating-out');
      }, action.delay / 1000).to(targetId, _duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
        opacity: 0,
        ease: _easing
      })).call(function () {
        $(targetId).addClass('hidden').removeClass('animating-out');
        prx.groups.redrawGroupActionDiv(targetId);

        if (callCallback.val) {
          callCallback.val = false;
          prx.actions.callback(action);
        }
      });
    });
  } else {
    prx.items.updateTransformIfHidden(targetId);
    prx.visibility.set(targetId, 'visible', false);
    new TimelineMax().add(function () {
      $(targetId).addClass('animating-out');
    }, action.delay / 1000).to(targetId, _duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 0,
      ease: _easing
    })).call(function () {
      $(targetId).addClass('hidden').removeClass('animating-out');
      prx.actions.callback(action);
    });
  }
};

prx.actionsLibrary.showHide = function (action) {
  var targetId = action.targetId; // if (typeof(action.pageId) != "undefined" && action.pageId != -1) {
  //     targetId = '#p-' + action.pageId + '-' + action.itemId;
  // }

  var _duration = action.duration;
  var _animationDuration = action.animationDuration;
  var _easing = action.animationEasing;
  _easing = prx.easing.get(_easing);
  if (typeof _duration == "undefined") _duration = 200;
  if (typeof _animationDuration == "undefined") _animationDuration = 0;

  if (targetId.indexOf('group') != -1) {
    targetId = action.targetId.replace('-group-', ' .group-');
    var groupdata = prx.groups.getGroupData(targetId);

    if (!groupdata) {
      prx.actions.callback(action);
      return;
    }

    groupdata.targetids.forEach(function (targetId, index) {
      prx.items.updateTransformIfHidden(targetId);
    });
    prx.visibility.set(targetId, 'visible', false);
    $(targetId + '.group-action-prediv').css('display', 'none');
    var callCallback = {
      val: true
    };
    groupdata.targetids.forEach(function (targetId, index) {
      if (!$(targetId).hasClass('animating-in') && !$(targetId).hasClass('animating-out')) {
        var currentOpacity = prx.visibility.get(targetId, 'visible-all', [action.targetId.replace('-group-', ' .group-')]);
        currentOpacity = currentOpacity === false ? 0 : currentOpacity;
      } else {
        var currentOpacity = 1;
      }

      if (prx.visibility.get(targetId, 'visible') === false) return;
      callCallback.val = 'tobecalled';
      new TimelineMax().add(function () {
        if ($(targetId).hasClass('hidden')) $(targetId).css('opacity', 0).removeClass('hidden');
      }, action.delay / 1000).to(targetId, _animationDuration / 1000, Object.assign({}, prx.basicGreensockOptions, {
        opacity: currentOpacity,
        ease: _easing
      })).to(targetId, _animationDuration / 1000, Object.assign({}, prx.basicGreensockOptions, {
        opacity: 0,
        delay: _duration / 1000,
        ease: _easing
      })).call(function () {
        $(targetId).addClass('hidden');
        $(targetId).css("opacity", currentOpacity);
        prx.groups.redrawGroupActionDiv(targetId);

        if (callCallback.val) {
          callCallback.val = false;
          prx.actions.callback(action);
        }
      });
    });
    if (callCallback.val === true) prx.actions.callback(action);
  } else {
    if (!$(targetId).hasClass('animating-in') && !$(targetId).hasClass('animating-out')) {
      currentOpacity = prx.visibility.get(targetId);
    } else {
      var currentOpacity = 1;
    }

    prx.items.updateTransformIfHidden(targetId);

    if (prx.visibility.get(targetId, 'visible-rest') === false) {
      prx.actions.callback(action);
      return;
    }

    prx.visibility.set(targetId, 'visible', false);
    new TimelineMax().add(function () {
      if ($(targetId).hasClass('hidden')) $(targetId).css('opacity', 0).removeClass('hidden');
    }, action.delay / 1000).to(targetId, _animationDuration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      opacity: currentOpacity,
      ease: _easing
    })).to(targetId, _animationDuration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 0,
      delay: _duration / 1000,
      ease: _easing
    })).call(function () {
      $(targetId).addClass('hidden');
      $(targetId).css("opacity", currentOpacity);
      prx.actions.callback(action);
    });
  }
};

prx.actionsLibrary.restartGif = function (action) {
  var targetId = action.targetId;

  if (typeof action.pageId != "undefined" && action.pageId != -1) {
    targetId = '#p-' + action.pageId + '-' + action.itemId;
  }

  setTimeout(function () {
    $(targetId + ' div .gif img').each(function () {
      var $this = $(this);
      $this.attr('src', $this.attr('src'));
    });
  }, action.delay);
  setTimeout(function () {
    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.showItem = function (action) {
  var targetId = action.targetId; // if (typeof(action.pageId) != "undefined" && action.pageId != -1) {
  //     targetId = '#p-' + action.pageId + '-' + action.itemId;
  // }

  var _duration = action.duration;
  var _easing = action.animationEasing;
  if (typeof _duration == "undefined") _duration = 0;
  _easing = prx.easing.get(_easing);

  if (targetId.indexOf('group') != -1) {
    targetId = action.targetId.replace('-group-', ' .group-');
    var groupdata = prx.groups.getGroupData(targetId);

    if (!groupdata) {
      prx.actions.callback(action);
      return;
    }

    groupdata.targetids.forEach(function (targetId, index) {
      prx.items.updateTransformIfHidden(targetId);
    });
    prx.visibility.set(targetId, 'visible', true);
    var callCallback = {
      val: true
    };
    groupdata.targetids.forEach(function (targetId, index) {
      if (!$(targetId).hasClass('animating-in') && !$(targetId).hasClass('animating-out')) {
        var currentOpacity = prx.visibility.get(targetId);
      } else {
        var currentOpacity = 1;
      }

      if (prx.visibility.get(targetId, 'visible') === false) return;
      callCallback.val = 'tobecalled';
      new TimelineMax().add(function () {
        var $target = $(targetId);

        if ($target.hasClass('hidden')) {
          $target.removeClass('hidden');
          var actionTargetId = action.targetId.replace('-group-', ' .group-');
          prx.vr.refresh(actionTargetId, true);
          $target.css('opacity', 0);
        }

        $target.addClass('animating-in');
      }, action.delay / 1000).to(targetId, _duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
        opacity: currentOpacity,
        ease: _easing
      })).call(function () {
        $(targetId).removeClass('animating-in');
        prx.scrollable.refresh(targetId);
        prx.groups.redrawGroupActionDiv(targetId);

        if (callCallback.val) {
          callCallback.val = false;
          prx.actions.callback(action);
        }
      });
    });
    if (callCallback.val === true) prx.actions.callback(action);
  } else {
    if (!$(targetId).hasClass('animating-in') && !$(targetId).hasClass('animating-out')) {
      currentOpacity = prx.visibility.get(targetId);
    } else {
      var currentOpacity = 1;
    }

    prx.items.updateTransformIfHidden(targetId);
    prx.visibility.set(targetId, 'visible', true);

    if (prx.visibility.get(targetId, 'visible-all') === false) {
      prx.actions.callback(action);
      return;
    }

    new TimelineMax().add(function () {
      var $target = $(targetId);

      if ($target.hasClass('hidden')) {
        $target.removeClass('hidden');
        var actionTargetId = action.targetId.replace('-group-', ' .group-');
        prx.vr.refresh(actionTargetId, true);
        $target.css('opacity', 0);
      }

      $target.addClass('animating-in');
    }, action.delay / 1000).to(targetId, _duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      opacity: currentOpacity,
      ease: _easing
    })).call(function () {
      $(targetId).removeClass('animating-in');
      prx.scrollable.refresh(targetId);
      prx.actions.callback(action);
    });
  }
};

prx.actionsLibrary.toggleItem = function (action) {
  var targetId = action.targetId.replace('-group-', ' .group-');

  if (prx.visibility.get(targetId, 'visible') === false || $(targetId).hasClass('animating-out')) {
    prx.actionsLibrary.showItem(action);
  } else {
    prx.actionsLibrary.hideItem(action);
  }
};

prx.actionsLibrary.goToPage = function (action) {
  $('.prx-page-active').find('a-scene').on("exit-vr", function () {
    setTimeout(function () {
      goToPage();
    }, 100);
  });

  if ($('.prx-page-active').find('a-scene.fullscreen').length > 0) {
    $('.prx-page-active').find('a-scene').each(function () {
      this.exitVR();
    });
  } else {
    goToPage();
  }

  function goToPage() {
    var _pageid = '#p-' + action.pageId;

    var _currentpage = _pageid;
    action.pageId = action.pageId;
    _currentpage = '#' + prx.navigation._activepage; // remember scroll position

    var _pgId = _currentpage.substr(1);
    /*
     $.each(prx.scrollable._scrollables, function (i, elm) {
     if (i.indexOf(_pgId+'-')==0) { // only save scroll position if in currently displayed page, otherwise it messes scroll position
     prx.scrollable._scrollPositions[i] = [elm.x, elm.y];
     }
     });
     */


    if (typeof action.delay == "undefined") {
      action.delay = 0;
    }

    if (action.animation == '') {
      action.animation = 'none';
    }

    if (_pageid != _currentpage) {
      var _transition = action.animation;

      if (action.pageId == "_back") {
        if (prx.navigation._gobackstack.screens.length === 0) {
          prx.actions.callback(action);
          return;
        }

        _pageid = prx.navigation._gobackstack.screens[prx.navigation._gobackstack.screens.length - 1].pageid;

        if (_transition === '_reversePrevTransition') {
          _transition = prx.screenTransitions.reverseMapping[prx.navigation._gobackstack.screens[prx.navigation._gobackstack.screens.length - 1].transition] || 'none';
          action.duration = prx.navigation._gobackstack.screens[prx.navigation._gobackstack.screens.length - 1].duration;
          action.animationEasing = prx.navigation._gobackstack.screens[prx.navigation._gobackstack.screens.length - 1].easing;
        }

        prx.navigation._gobackstack.screens.pop();

        if (typeof _pageid == "undefined") {
          setTimeout(function () {
            prx.actions.callback(action);
          }, action.delay);
          return true;
        }
      }

      var _targetPage = prx.stc.screens.getStructFromId(_pageid);

      if (typeof _targetPage == "undefined") {
        prx.actions.callback(action);
        return;
      }

      var _pageOrientation = prx.orientation.getPage(_targetPage);
      /* HANDLE PAGE ORIENTATION WHEN TRY TO GO TO PAGE WITH DIFFERENT ORIENTATION SET, THEN AUTO ROTATE BEFORE */


      if (_pageOrientation != prx.orientation.get()) {
        /* change skin orientation if on web player */
        if (!prx.embed && parent != window) {
          try {
            prx.crossmsg.send({
              action: 'switch-orientation'
            });
          } catch (err) {}
        }
        /********** TODO: check if targetpage has orientationchange events and trigger them *********/

      }

      $('.loadedFrom').removeClass('loadedFrom').addClass('remove-on-pageshow');

      if (action.pageId != "_back") {
        prx.navigation.pushToBackStack(_currentpage, _transition, action.duration, action.animationEasing, 'screens');
      }

      setTimeout(function () {
        prx.navigation.changePage($(_pageid), {
          transition: _transition,
          duration: action.duration,
          easing: action.animationEasing,
          allowSamePageTransition: false
        });
        prx.eventTransitionPage = '#p-' + action.pageId;
      }, action.delay);
      $(_pageid).one('pageshow', function () {
        // Scroll to last scrolled position (for mouse event)

        /* var _pgId = _pageid.substr(1);
         if (typeof(prx.scrollable._scrollables) != "undefined") {
         $.each(prx.scrollable._scrollables, function (i, elm) {
         if (i.substr(0, _pgId.length) == _pgId) { // only fix scroll position if in currently displayed page, otherwise it messes scroll position
         if (typeof(prx.scrollable._scrollPositions[i]) != "undefined") {
         elm.scrollTo(prx.scrollable._scrollPositions[i][0], prx.scrollable._scrollPositions[i][1], 0);
         }
         }
         });
         }*/
        prx.actions.callback(action);
      }); //prx.vr.refresh(_pageid);
    } else {
      setTimeout(function () {
        prx.actions.callback(action);
      }, action.delay);
    }
  }
};

prx.actionsLibrary.goToCarouselPage = function (action) {
  var _snap = false;

  if (typeof prx.scrollable._scrollables[action.targetId.substr(1).replace(/ *\[[^)]*\] */g, "") + '-inner'] != "undefined") {
    _snap = prx.scrollable._scrollables[action.targetId.substr(1).replace(/ *\[[^)]*\] */g, "") + '-inner'].options.snap;
  } else {
    prx.actions.callback(action);
    return false;
  }

  if (_snap) {
    // wrong target id, regenerate
    // not being used???
    if (typeof action.pageId != "undefined" && action.pageId != -1) {
      var targetId = '#p-' + action.pageId + '-' + action.itemId;
    } else {
      var targetId = action.targetId.replace(/ *\[[^)]*\] */g, "");
    }

    var _pageX = action.itemIndex[0];
    var _pageY = action.itemIndex[1];

    if (_pageX == "") {
      _pageX = "nochange";
    }

    if (_pageY == "") {
      _pageY = "nochange";
    }

    if (typeof action.animationDuration == "undefined") {
      action.animationDuration = 400;
    }

    var _scroller = prx.scrollable._scrollables[action.targetId.substr(1).replace(/ *\[[^)]*\] */g, "") + '-inner']; //refreshing hidden container to update _scroller with the correct data


    if (typeof _scroller !== 'undefined' && _scroller.pages.length == 0) {
      var pageId = action.targetId.substr(1).split('-')[1];
      $('#p-' + pageId + ',' + action.targetId).addClass('initialise-hidden-container');

      _scroller.refresh();

      $('#p-' + pageId + ',' + action.targetId).removeClass('initialise-hidden-container');
    }

    var _targetPageX = _scroller.currentPage.pageX;
    var _targetPageY = _scroller.currentPage.pageY;
    setTimeout(function () {
      switch (_pageX) {
        case "previous":
          _targetPageX--;

          if (_targetPageX < 0) {
            _targetPageX = 0;
          }

          break;

        case "next":
          _targetPageX++;

          if (_targetPageX > _scroller.pages.length) {
            _targetPageX = _scroller.pages.length;
          }

          break;

        case "nochange":
          _targetPageX = _scroller.currentPage.pageX;
          break;

        default:
          _targetPageX = parseInt(_pageX);
          break;
      }

      switch (_pageY) {
        case "previous":
          _targetPageY--;

          if (_targetPageY < 0) {
            _targetPageY = 0;
          } //_pageY = (prx.scrollable._scrollables[action.targetId.substr(1) + '-inner'].currentPage.pageY > 0 && prx.scrollable._scrollables[action.targetId.substr(1) + '-inner'].directionY) ? parseInt(prx.scrollable._scrollables[action.targetId.substr(1) + '-inner'].currentPage.pageY) - 1 : 0;


          break;

        case "next":
          _targetPageY++;

          if (_targetPageY > _scroller.pages[0].length) {
            _targetPageY = _scroller.pages[0].length;
          } //_pageY = (prx.scrollable._scrollables[action.targetId.substr(1) + '-inner'].directionY) ? parseInt(prx.scrollable._scrollables[action.targetId.substr(1) + '-inner'].currentPage.pageY) + 1 : 0;


          break;

        case "nochange":
          _targetPageY = _scroller.currentPage.pageY; //_pageY = parseInt(prx.scrollable._scrollables[action.targetId.substr(1) + '-inner'].currentPage.pageY);

          break;

        default:
          _targetPageY = parseInt(_pageY); //_pageY = parseInt(_pageY);

          break;
      }

      _pageX = parseInt(_targetPageX);
      _pageY = parseInt(_targetPageY);
      var _scrollableTabbarContainer = false;

      for (var i = 0; i < prx.scrollable._scrollableTabbars.length; i++) {
        if (action.targetId.replace(/ *\[[^)]*\] */g, "") == '#' + prx.scrollable._scrollableTabbars[i].container + '-' + prx.scrollable._scrollableTabbars[i].linked) {
          _scrollableTabbarContainer = prx.scrollable._scrollableTabbars[i].container + '-' + prx.scrollable._scrollableTabbars[i].id;
          break;
        }
      }

      prx.scrollable._scrollables[action.targetId.substr(1).replace(/ *\[[^)]*\] */g, "") + '-inner'].goToPage(_pageX, _pageY, parseInt(action.scrollDuration));

      if (_scrollableTabbarContainer != false) {
        prx.scrollable._scrollables[_scrollableTabbarContainer + '-inner'].goToPage(_pageX, 0, parseInt(action.scrollDuration));
      }

      if ($(action.targetId).is(":hidden")) {
        var event = $.Event('mouseup');
        event.target = _scroller.scroller;

        prx.scrollable._scrollables[action.targetId.substr(1).replace(/ *\[[^)]*\] */g, "") + '-inner']._transitionEnd(event);
      }
    }, action.delay);
  }

  setTimeout(function () {
    prx.actions.callback(action);
  }, parseInt(action.delay) + parseInt(action.scrollDuration));
};

prx.actionsLibrary.scrollScrollableContainer = function (action) {
  var _scroller = prx.scrollable._scrollables[action.targetId.substr(1).replace(/ *\[[^)]*\] */g, "") + '-inner'];

  if (typeof _scroller == "undefined") {
    prx.actions.callback(action);
    return false;
  }

  if (typeof action.horizontalPx == "undefined") {
    action.horizontalPx = 0;
  }

  if (typeof action.verticalPx == "undefined") {
    action.verticalPx = 0;
  } //refreshing hidden container to update _scroller with the correct data


  if (typeof _scroller !== 'undefined' && _scroller.scrollerHeight == 0 && _scroller.scrollerWidth == 0) {
    var pageId = action.targetId.substr(1).split('-')[1];
    $('#p-' + pageId + ',' + action.targetId).addClass('initialise-hidden-container');

    _scroller.refresh();

    $('#p-' + pageId + ',' + action.targetId).removeClass('initialise-hidden-container');
  }

  switch (action.scrollType) {
    case "scroll-to":
      var _horizontalPx = -parseInt(action.horizontalPx);

      var _verticalPx = -parseInt(action.verticalPx);

      if (action.horizontalPx == "*") {
        _horizontalPx = _scroller.x;
      }

      if (action.verticalPx == "*") {
        _verticalPx = _scroller.y;
      }

      setTimeout(function () {
        var scrollable = prx.scrollable._scrollables[action.targetId.substr(1).replace(/ *\[[^)]*\] */g, "") + '-inner'];

        scrollable.scrollTo(_horizontalPx, _verticalPx, parseInt(action.scrollDuration));

        if (typeof scrollable.pages !== 'undefined') {
          var pageX = Math.floor(Math.abs(_horizontalPx) / scrollable.wrapperWidth);
          var pageY = Math.floor(Math.abs(_verticalPx) / scrollable.wrapperHeight);
          scrollable.currentPage.pageX = pageX;
          scrollable.currentPage.pageY = pageY;
          scrollable.currentPage.x = -(pageX * scrollable.wrapperWidth);
          scrollable.currentPage.y = -(pageY * scrollable.wrapperHeight);
        }
      }, action.delay);
      break;

    case "scroll-by":
      var _horizontalPx = parseInt(action.horizontalPx);

      var _verticalPx = parseInt(action.verticalPx);

      if (action.horizontalPx == "*") {
        _horizontalPx = 0;
      }

      if (action.verticalPx == "*") {
        _verticalPx = 0;
      }

      setTimeout(function () {
        prx.scrollable._scrollables[action.targetId.substr(1).replace(/ *\[[^)]*\] */g, "") + '-inner'].scrollBy(_horizontalPx, _verticalPx, parseInt(action.scrollDuration));
      }, action.delay);
      break;
  }

  setTimeout(function () {
    prx.actions.callback(action);
  }, parseInt(action.delay) + parseInt(action.scrollDuration));
};

prx.actionsLibrary.fireItemsEvent = function (action) {
  // v5.0.13 always changing click to tap.
  if (action.itemEvent == 'click') {
    action.itemEvent = 'tap';
  } // hammer


  if (action.itemEvent == 'taphold' || action.itemEvent == 'forcetouch') {
    action.itemEvent = 'press';
  } // need to reset action.targetId if targeting container


  if (action.targetType == 'container') {
    var pageid = action.containerid.split('-')[1]; // $= is correct because there may be more than one containers in the page so we want to select all of them (the user didnt select a specific one)
    // but later action.targetId = '#' + $item.attr('id') gets only the first anw

    action.targetId = '#p-' + pageid + ' .type-symbol[data-symbol-id=' + action.symbolId + '] .box[id$=-' + action.itemId + ']';

    if (action.targetId !== undefined && action.targetId.indexOf('group') > -1) {
      var $item = $(action.targetId + '-actions');
    } else {
      var $item = $(action.targetId);
    } // to makesure callbackaction is called


    if ($item.length == 0) {
      prx.actions.callback(action);
      return;
    } else {
      action.targetId = '#' + $item.attr('id');
    }
  } else {
    if (action.pageId == -1) {
      action.targetId = '#' + action.containerid + '-' + action.itemId;
    } else {
      action.targetId = '#p-' + action.pageId + '-' + action.itemId;
    }
  }

  setTimeout(function () {
    if (action.targetId !== undefined && action.targetId.indexOf('group') > -1) {
      $(action.targetId + '-actions').trigger(action.itemEvent);
    } else if (typeof action.itemIndex == "undefined") {
      $(action.targetId).trigger(action.itemEvent);
    } else if (parseInt(action.itemIndex) == action.itemIndex) {
      // if is numeric - refers to dynamic property
      $(action.targetId + "-" + action.itemDynProps + "-" + action.itemIndex).trigger(action.itemEvent);
    } else {
      switch (action.itemIndex) {
        case 'actionbarUpCaretActions':
          $(action.targetId + ' .left-icon').trigger(action.itemEvent);
          break;

        case 'actionbarActionOverflowActions':
          //currently for android actionbar - will propably need to change its name on the component
          $(action.targetId + ' .actionOverflow').trigger(action.itemEvent);
          break;

        case 'flipswitchActionsOnActive':
          $(action.targetId + ' input:checked[id=' + action.targetId.replace('#', '') + '-flipswitch]').trigger(action.itemEvent);
          break;

        case 'flipswitchActionsOnDeactive':
          $(action.targetId + ' input[id=' + action.targetId.replace('#', '') + '-flipswitch]:not(:checked)').trigger(action.itemEvent);
          break;

        case 'checkboxActionsOnActive':
          if (action.itemEvent == "tap") {
            action.itemEvent = "change";
          }

          ;
          $(action.targetId + ' input[id=' + action.targetId.replace('#', '') + '-checkbox]:not(:checked)').prop('checked', true).trigger(action.itemEvent);
          break;

        case 'checkboxActionsOnDeactive':
          if (action.itemEvent == "tap") {
            action.itemEvent = "change";
          }

          ;
          $(action.targetId + ' input:checked[id=' + action.targetId.replace('#', '') + '-checkbox]').prop('checked', false).trigger(action.itemEvent);
          break;

        case 'ios7NavbarActionsTitle':
          $(action.targetId + ' .ios7-navbar-title').trigger(action.itemEvent);
          break;

        case 'ios7NavbarActionsLeftBtn':
          $(action.targetId + ' .ios7-navbar-button-left').trigger(action.itemEvent);
          break;

        case 'ios7NavbarActionsRightBtn':
          $(action.targetId + ' .ios7-navbar-button-right').trigger(action.itemEvent);
          break;

        default:
          if (action.itemIndex == "actions") {
            $(action.targetId).trigger(action.itemEvent);

            if ($(action.targetId + ' input[type=checkbox]:not(:disabled)').length > 0) {
              $(action.targetId + ' input[type=checkbox]').prop('checked', !$(action.targetId + ' input[type=checkbox]').is(':checked'));
            }
          } else {
            $(action.targetId + ' .actions-' + action.itemIndex).trigger(action.itemEvent);
          }

          break;
      }
    }

    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.animateItem = function (action) {
  var props = {};
  var actionTargetId = action.targetId.replace('-group-', ' .group-');
  var options = {
    duration: parseInt(action.duration),
    easing: prx.easing.get(action.animationEasing),
    queue: false,
    complete: function complete() {
      prx.groups.redrawGroupActionDiv(actionTargetId);
      prx.actions.callback(action);
    }
  };
  props.easing = prx.easing.get(action.animationEasing);

  switch (action.animationType) {
    case "move-item":
      switch (action.moveType) {
        case "move-by":
          var opt = Object.assign({}, prx.basicGreensockOptions, {
            ease: options.easing,
            delay: action.delay / 1000
          });

          if (action.moveXBy != '*') {
            var x = Number(action.moveXBy);

            if (x >= 0) {
              x = '+=' + x;
            } else {
              x = '-=' + -x;
            }

            opt.x = x;
          }

          if (action.moveYBy != '*') {
            var y = Number(action.moveYBy);

            if (y >= 0) {
              y = '+=' + y;
            } else {
              y = '-=' + -y;
            }

            opt.y = y;
          }

          if (actionTargetId.indexOf('.group-') > -1) {
            var groupdata = prx.groups.getGroupData(actionTargetId);

            if (groupdata) {
              groupdata.targetids.forEach(function (targetId, index) {
                prx.items.updateTransformIfHidden(targetId);
              });
            }
          } else {
            prx.items.updateTransformIfHidden(actionTargetId);
          }

          new TimelineMax().to(actionTargetId, options.duration / 1000, opt).call(options.complete);
          break;

        case "move-to":
          var ops = Object.assign({}, prx.basicGreensockOptions, {
            ease: options.easing,
            delay: action.delay / 1000
          });

          if (action.itemId !== undefined && action.itemId.indexOf('group') !== -1) {
            var groupdata = prx.groups.getGroupData(actionTargetId);

            if (!groupdata) {
              prx.actions.callback(action);
              return;
            }

            groupdata.targetids.forEach(function (targetId, index) {
              prx.items.updateTransformIfHidden(targetId);
            });
            var itemdimentions = prx.groups.getItemDimentions(groupdata);
            var groupdimentions = prx.toolbox.calculateBox(itemdimentions, groupdata.group.rotation, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);

            if (action.moveXTo != '*') {
              var diff = Number(action.moveXTo) - groupdimentions.left;
              ops.x = diff >= 0 ? '+=' + diff : '-=' + -diff;
            }

            if (action.moveYTo != '*') {
              var diff = Number(action.moveYTo) - groupdimentions.top;
              ops.y = diff >= 0 ? '+=' + diff : '-=' + -diff;
            }
          } else {
            if (action.moveXTo != '*') {
              ops.x = Number(action.moveXTo);
            }

            if (action.moveYTo != '*') {
              ops.y = Number(action.moveYTo);
            }

            prx.items.updateTransformIfHidden(actionTargetId);
          }

          new TimelineMax().to(actionTargetId, options.duration / 1000, ops).call(options.complete);
          break;

        case "move-to-animation-target":
          if (action.pageId != -1) {
            var ap = '#p-' + action.pageId + '-' + (action.item2Id || action.animationPointId);
          } else {
            var ap = '#' + action.containerid + '-' + (action.item2Id || action.animationPointId);
          }

          if ($(ap).length == 0) {
            prx.actions.callback(action);
            return;
          }

          var dims = prx.items.getRealDimsAndPosFromDom(ap);

          if (action.itemId !== undefined && action.itemId.indexOf('group') !== -1) {
            var groupdata = prx.groups.getGroupData(actionTargetId);

            if (!groupdata) {
              prx.actions.callback(action);
              return;
            }

            groupdata.targetids.forEach(function (targetId, index) {
              prx.items.updateTransformIfHidden(targetId);
            });
            var itemdimentions = prx.groups.getItemDimentions(groupdata);
            var groupdimentions = prx.toolbox.calculateBox(itemdimentions, groupdata.group.rotation, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            x = dims.left - groupdimentions.left;
            y = dims.top - groupdimentions.top;
            x = x >= 0 ? '+=' + x : '-=' + -x;
            y = y >= 0 ? '+=' + y : '-=' + -y;
          } else {
            x = dims.left;
            y = dims.top;
            prx.items.updateTransformIfHidden(actionTargetId);
          }

          new TimelineMax().to(actionTargetId, options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
            x: x,
            y: y,
            ease: options.easing,
            delay: parseInt(action.delay) / 1000
          })).call(options.complete);
          break;

        default:
          break;
      }

      break;

    case "resize-item":
      props.scale = 1;

      options.complete = function () {
        prx.groups.redrawGroupActionDiv(actionTargetId);
        prx.actions.callback(action);

        if (typeof prx.scrollable._scrollables[actionTargetId.substring(1).replace(/ *\[[^)]*\] */g, "") + '-inner'] != 'undefined') {
          prx.scrollable._scrollables[actionTargetId.substring(1).replace(/ *\[[^)]*\] */g, "") + '-inner'].refresh();
        }
      };

      switch (action.resizeType) {
        case "resize-by":
          if (action.itemId !== undefined && action.itemId.indexOf('group') !== -1) {
            var groupdata = prx.groups.getGroupData(actionTargetId);

            if (!groupdata) {
              prx.actions.callback(action);
              return;
            }

            groupdata.targetids.forEach(function (targetId, index) {
              prx.items.updateTransformIfHidden(targetId);
            });
            var itemdimentions = prx.groups.getItemDimentions(groupdata);
            var groupDimentions = prx.toolbox.calculateBox(itemdimentions, groupdata.group.rotation, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            var unrotatedItems = itemdimentions.map(function (item) {
              var item = prx.toolbox.rotate(item, {
                x: groupDimentions.x,
                y: groupDimentions.y
              }, 360 - groupDimentions.rotation);
              return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            });
            var itemPercentages = unrotatedItems.map(function (item) {
              var p = {};
              p.width = item.width / groupDimentions.width;
              p.height = item.height / groupDimentions.height;
              p.top = (item.top - groupDimentions.top) / groupDimentions.height;
              p.left = (item.left - groupDimentions.left) / groupDimentions.width;
              return p;
            });
            if (action.resizeXBy != '*') groupDimentions.width += Number(action.resizeXBy);
            if (action.resizeYBy != '*') groupDimentions.height += Number(action.resizeYBy);
            var newGroupDimentions = prx.toolbox.itemDimensions(groupDimentions, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            var newItemDimentions = unrotatedItems.map(function (item, index) {
              item.width = itemPercentages[index].width * newGroupDimentions.width;
              item.height = itemPercentages[index].height * newGroupDimentions.height;
              item.top = newGroupDimentions.top + itemPercentages[index].top * newGroupDimentions.height;
              item.left = newGroupDimentions.left + itemPercentages[index].left * newGroupDimentions.width;
              return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            });
            var rerotatedItems = newItemDimentions.map(function (item) {
              item = prx.toolbox.rotate(item, {
                x: newGroupDimentions.x,
                y: newGroupDimentions.y
              }, newGroupDimentions.rotation);
              return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            });
            var callCallback = {
              val: true
            };
            groupdata.targetids.forEach(function (target, index) {
              if (action.resizeXBy != '*') {
                props.width = rerotatedItems[index].width;
              }

              if (action.resizeYBy != '*') {
                props.height = rerotatedItems[index].height;
              }

              var _transition = Object.assign({}, props);

              var itemid = 'box-' + target.split('box-').last();
              var item = prx.items.getFromAllItemStruct(itemid, groupdata.stateid);

              if (typeof prx.types[item.type].onResize == 'function') {
                _transition.onUpdate = function (item, target, container) {
                  item.htype = "fixed";
                  item.vtype = "fixed";
                  item.width = $(target).width();
                  item.height = $(target).height();
                  prx.types[item.type].onResize(item, container);
                };

                _transition.onUpdateParams = [item, target, target.replace('-' + itemid, '').replace('#', '')];
              }

              _transition.scaleX = prx.scale.get(target, 'scalex');
              _transition.scaleY = prx.scale.get(target, 'scaley');
              _transition.width = props.width;
              _transition.height = props.height;
              _transition.x = rerotatedItems[index].left;
              _transition.y = rerotatedItems[index].top;
              _transition.ease = options.easing;
              _transition.delay = action.delay / 1000;
              _transition = Object.assign({}, prx.basicGreensockOptions, _transition);
              delete _transition.easing;
              new TimelineMax().to(target, options.duration / 1000, _transition).call(function () {
                prx.groups.redrawGroupActionDiv(actionTargetId);

                if (callCallback.val) {
                  callCallback.val = false;
                  prx.actions.callback(action);
                }
              });
            });
          } else {
            if (action.resizeXBy != '*') {
              var x = Number(action.resizeXBy);

              if (x >= 0) {
                x = '+=' + x;
              } else {
                x = '-=' + -x;
              }

              props.width = x;
            }

            if (action.resizeYBy != '*') {
              var y = Number(action.resizeYBy);

              if (y >= 0) {
                y = '+=' + y;
              } else {
                y = '-=' + -y;
              }

              props.height = y;
            }

            prx.items.updateTransformIfHidden(actionTargetId);
            new TimelineMax().to(actionTargetId, options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
              width: props.width,
              height: props.height,
              ease: options.easing,
              delay: action.delay / 1000
            })).call(options.complete);
          }

          break;

        case "resize-to":
          if (action.itemId !== undefined && action.itemId.indexOf('group') !== -1) {
            var groupdata = prx.groups.getGroupData(actionTargetId);

            if (!groupdata) {
              prx.actions.callback(action);
              return;
            }

            groupdata.targetids.forEach(function (targetId, index) {
              prx.items.updateTransformIfHidden(targetId);
            });
            var itemdimentions = prx.groups.getItemDimentions(groupdata);
            var groupDimentions = prx.toolbox.calculateBox(itemdimentions, groupdata.group.rotation, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            var unrotatedItems = itemdimentions.map(function (item) {
              var item = prx.toolbox.rotate(item, {
                x: groupDimentions.x,
                y: groupDimentions.y
              }, 360 - groupDimentions.rotation);
              return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            });
            var itemPercentages = unrotatedItems.map(function (item) {
              var p = {};
              p.width = item.width / groupDimentions.width;
              p.height = item.height / groupDimentions.height;
              p.top = (item.top - groupDimentions.top) / groupDimentions.height;
              p.left = (item.left - groupDimentions.left) / groupDimentions.width;
              return p;
            });
            if (action.resizeXTo != '*') groupDimentions.width = Number(action.resizeXTo);
            if (action.resizeYTo != '*') groupDimentions.height = Number(action.resizeYTo);
            var newGroupDimentions = prx.toolbox.itemDimensions(groupDimentions, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            var newItemDimentions = unrotatedItems.map(function (item, index) {
              item.width = itemPercentages[index].width * newGroupDimentions.width;
              item.height = itemPercentages[index].height * newGroupDimentions.height;
              item.top = newGroupDimentions.top + itemPercentages[index].top * newGroupDimentions.height;
              item.left = newGroupDimentions.left + itemPercentages[index].left * newGroupDimentions.width;
              return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            });
            var rerotatedItems = newItemDimentions.map(function (item) {
              item = prx.toolbox.rotate(item, {
                x: newGroupDimentions.x,
                y: newGroupDimentions.y
              }, newGroupDimentions.rotation);
              return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            });
            var callCallback = {
              val: true
            };
            groupdata.targetids.forEach(function (target, index) {
              if (action.resizeXTo != '*') {
                props.width = rerotatedItems[index].width;
              }

              if (action.resizeYTo != '*') {
                props.height = rerotatedItems[index].height;
              }

              var _transition = Object.assign({}, props);

              var itemid = 'box-' + target.split('box-').last();
              var item = prx.items.getFromAllItemStruct(itemid, groupdata.stateid);

              if (typeof prx.types[item.type].onResize == 'function') {
                _transition.onUpdate = function (item, target, container) {
                  item.htype = "fixed";
                  item.vtype = "fixed";
                  item.width = $(target).width();
                  item.height = $(target).height();
                  prx.types[item.type].onResize(item, container);
                };

                _transition.onUpdateParams = [item, target, target.replace('-' + itemid, '').replace('#', '')];
              }

              _transition.scaleX = prx.scale.get(target, 'scalex');
              _transition.scaleY = prx.scale.get(target, 'scaley');
              _transition.width = props.width;
              _transition.height = props.height;
              _transition.x = rerotatedItems[index].left;
              _transition.y = rerotatedItems[index].top;
              _transition.ease = options.easing;
              _transition.delay = action.delay / 1000;
              _transition = Object.assign({}, prx.basicGreensockOptions, _transition);
              delete _transition.easing;
              new TimelineMax().to(target, options.duration / 1000, _transition).call(function () {
                prx.groups.redrawGroupActionDiv(actionTargetId);

                if (callCallback.val) {
                  callCallback.val = false;
                  prx.actions.callback(action);
                }
              });
            });
          } else {
            if (action.resizeXTo != '*') {
              var x = Number(action.resizeXTo);
              props.width = x;
            }

            if (action.resizeYTo != '*') {
              var y = Number(action.resizeYTo);
              props.height = y;
            }

            prx.items.updateTransformIfHidden(actionTargetId);
            new TimelineMax().to(actionTargetId, options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
              width: props.width,
              height: props.height,
              ease: options.easing,
              delay: action.delay / 1000
            })).call(options.complete);
          }

          break;

        default:
          break;
      }

      break;

    case "scale-item":
      var newx = Number(action.scaleX);
      var newy = Number(action.scaleY);

      if (action.itemId !== undefined && action.itemId.indexOf('group') !== -1) {
        var groupdata = prx.groups.getGroupData(actionTargetId);

        if (!groupdata) {
          prx.actions.callback(action);
          return;
        }

        groupdata.targetids.forEach(function (targetId, index) {
          prx.items.updateTransformIfHidden(targetId);
        });
        var visibleItemDimentions = prx.groups.getItemDimentions(groupdata, true);
        var visibleGroupDimentions = prx.toolbox.calculateBox(visibleItemDimentions, groupdata.group.rotation, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
        var unrotatedActualItems = visibleItemDimentions.map(function (item) {
          var item = prx.toolbox.rotate(item, {
            x: visibleGroupDimentions.x,
            y: visibleGroupDimentions.y
          }, 360 - visibleGroupDimentions.rotation);
          return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
        });
        var itemPercentages = unrotatedActualItems.map(function (item) {
          var p = {};
          p.width = item.width / visibleGroupDimentions.width;
          p.height = item.height / visibleGroupDimentions.height;
          p.top = (item.top - visibleGroupDimentions.top) / visibleGroupDimentions.height;
          p.left = (item.left - visibleGroupDimentions.left) / visibleGroupDimentions.width;
          return p;
        });
        var realItemDimentions = prx.groups.getItemDimentions(groupdata);
        var scalex = newx / prx.scale.get(actionTargetId, 'scalex');
        var scaley = newy / prx.scale.get(actionTargetId, 'scaley');
        prx.scale.set(actionTargetId, 'scalex', newx);
        prx.scale.set(actionTargetId, 'scaley', newy);
        var scaledGroupDimensions = Object.assign({}, visibleGroupDimentions);
        scaledGroupDimensions.width = visibleGroupDimentions.width * scalex;
        scaledGroupDimensions.height = visibleGroupDimentions.height * scaley;
        scaledGroupDimensions = prx.toolbox.itemDimensions(scaledGroupDimensions, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
        var ldiff = scaledGroupDimensions.x - visibleGroupDimentions.x;
        var tdiff = scaledGroupDimensions.y - visibleGroupDimentions.y;
        scaledGroupDimensions.left = Math.ceil(scaledGroupDimensions.left - ldiff);
        scaledGroupDimensions.top = Math.floor(scaledGroupDimensions.top - tdiff);
        scaledGroupDimensions = prx.toolbox.itemDimensions(scaledGroupDimensions, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
        var scaledItemDimentions = itemPercentages.map(function (itemPercentage, index) {
          var temp = Object.assign({}, unrotatedActualItems[index]);
          temp.width = itemPercentage.width * scaledGroupDimensions.width;
          temp.height = itemPercentage.height * scaledGroupDimensions.height;
          temp.top = scaledGroupDimensions.top + itemPercentage.top * scaledGroupDimensions.height;
          temp.left = scaledGroupDimensions.left + itemPercentage.left * scaledGroupDimensions.width;
          return prx.toolbox.itemDimensions(temp, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
        }).map(function (item) {
          item = prx.toolbox.rotate(item, {
            x: scaledGroupDimensions.x,
            y: scaledGroupDimensions.y
          }, scaledGroupDimensions.rotation);
          return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
        });
        var callCallback = {
          val: true
        };
        groupdata.targetids.forEach(function (target, index) {
          var correctionX = scaledItemDimentions[index].x - realItemDimentions[index].x;
          var correctionY = scaledItemDimentions[index].y - realItemDimentions[index].y;
          var mscalex = prx.scale.get(target, 'scalex');
          var mscaley = prx.scale.get(target, 'scaley');
          new TimelineMax().to(target, action.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
            scaleX: mscalex,
            scaleY: mscaley,
            x: realItemDimentions[index].left + correctionX,
            y: realItemDimentions[index].top + correctionY,
            ease: options.easing,
            delay: action.delay / 1000
          })).call(function () {
            prx.groups.redrawGroupActionDiv(actionTargetId);

            if (callCallback.val) {
              callCallback.val = false;
              prx.actions.callback(action);
            }
          });
        });
      } else {
        prx.scale.set(actionTargetId, 'scalex', newx);
        prx.scale.set(actionTargetId, 'scaley', newy);
        prx.items.updateTransformIfHidden(actionTargetId);
        new TimelineMax().to(actionTargetId, options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
          scaleX: prx.scale.get(actionTargetId, 'scalex'),
          scaleY: prx.scale.get(actionTargetId, 'scaley'),
          ease: options.easing,
          delay: action.delay / 1000
        })).call(options.complete);
      }

      break;

    case "fade-item":
      if (action.itemId.indexOf('group') !== -1) {
        var groupdata = prx.groups.getGroupData(actionTargetId);

        if (!groupdata) {
          prx.actions.callback(action);
          return;
        }

        groupdata.targetids.forEach(function (targetId, index) {
          prx.items.updateTransformIfHidden(targetId);
        });
        prx.visibility.set(actionTargetId, 'opacity', Number(action.fadeTo));
        var callCallback = {
          val: true
        };
        groupdata.targetids.forEach(function (target, index) {
          new TimelineMax().to(target, action.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
            opacity: prx.visibility.get(target),
            ease: options.easing,
            delay: action.delay / 1000
          })).call(function () {
            prx.groups.redrawGroupActionDiv(actionTargetId);

            if (callCallback.val) {
              callCallback.val = false;
              prx.actions.callback(action);
            }
          });
        });
      } else {
        prx.items.updateTransformIfHidden(actionTargetId);
        prx.visibility.set(actionTargetId, 'opacity', Number(action.fadeTo));
        new TimelineMax().to(actionTargetId, options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
          opacity: prx.visibility.get(actionTargetId),
          ease: options.easing,
          delay: action.delay / 1000
        })).call(options.complete);
      }

      break;

    case "rotate-item":
      switch (action.rotateType) {
        case "rotate-by":
          var deg = Number(action.rotateBy);

          if (deg >= 0) {
            deg = '+=' + deg;
          } else {
            deg = '-=' + -deg;
          }

          prx.items.updateTransformIfHidden(actionTargetId);
          new TimelineMax().to(actionTargetId, options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
            rotation: deg,
            ease: options.easing,
            delay: action.delay / 1000
          })).call(options.complete);
          break;

        case "rotate-to":
          var _rotateTo = Number(action.rotateTo);

          if (typeof action.rotationDirection != "undefined") {
            _rotateTo += '_' + action.rotationDirection;
          }

          prx.items.updateTransformIfHidden(actionTargetId);
          new TimelineMax().to(actionTargetId, options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
            rotation: _rotateTo,
            ease: options.easing,
            delay: action.delay / 1000
          })).call(options.complete);
          break;

        default:
          break;
      }

      break;

    default:
      break;
  }
};

prx.actionsLibrary.moveScreen = function (action) {
  var targetId = action.targetId;

  if (action.pageId == -2) {
    var split = targetId.split(/[-\[]/);
    targetId = '#p-' + split[1];
  }
  /* SETTINGS FOR JQUERY.ANIMATE AND TWEENMAX */


  var props = {};
  var options = {
    duration: parseInt(action.duration),
    easing: action.animationEasing,
    queue: false,
    complete: function complete() {
      prx.actions.callback(action);
    }
  };
  props.easing = prx.easing.get(action.animationEasing);

  switch (action.moveType) {
    case "move-by":
      props.top = true;
      props.left = true;
      props.overlaytop = true;
      props.overlayleft = true;

      if (action.moveXBy != '*') {
        var x = Number(action.moveXBy);

        if (x >= 0) {
          props.overlayleft = '-=' + x;
        } else {
          props.overlayleft = '+=' + -x;
        }

        if (x >= 0) {
          x = '+=' + x;
        } else {
          x = '-=' + -x;
        }

        props.x = x;
      }

      if (action.moveYBy != '*') {
        var y = Number(action.moveYBy);
        var pageid = targetId.split(/[-\[]/)[1];

        if (prx.allowstatusbar && prx.canvas._statusbars[pageid].statusbar == 1) {
          y += prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[pageid].orientation];
        }

        if (y <= 0) {
          props.overlaytop = '-=' + y;
        } else {
          props.overlaytop = '+=' + -y;
        }

        if (y >= 0) {
          y = '+=' + y;
        } else {
          y = '-=' + -y;
        }

        props.y = y;
      } //TweenMax.to(targetId,options.duration/1000,{left:props.left,top:props.top, ease: options.easing, delay: action.delay/1000, onComplete: options.complete});


      new TimelineMax().to(targetId, options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
        x: props.x,
        y: props.y,
        ease: props.easing,
        delay: action.delay / 1000
      })).call(options.complete);
      new TimelineMax().to(targetId + ' .box[data-mpoverlay="1"]', options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
        x: props.overlayleft,
        y: props.overlaytop,
        ease: props.easing,
        delay: action.delay / 1000
      }));
      break;

    case "move-to":
      props.top = true;
      props.left = true;
      props.overlaytop = true;
      props.overlayleft = true;

      if (action.moveXTo != '*') {
        var x = Number(action.moveXTo);
        props.x = x;
        props.overlayleft = ($(targetId).offset().left - x < 0 ? '-=' : '+=') + Math.abs($(targetId).offset().left - x);
      }

      if (action.moveYTo != '*') {
        var y = Number(action.moveYTo);
        var pageid = targetId.split(/[-\[]/)[1];

        if (prx.allowstatusbar && prx.canvas._statusbars[pageid].statusbar == 1) {
          y += prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[pageid].orientation];
        }

        props.y = y;
        props.overlaytop = ($(targetId).offset().top - y < 0 ? '-=' : '+=') + Math.abs($(targetId).offset().top - y);
      } //TweenMax.to(targetId,options.duration/1000,{left:props.left,top:props.top, ease: options.easing, delay: action.delay/1000, onComplete: options.complete});


      new TimelineMax().to(targetId, options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
        x: props.x,
        y: props.y,
        ease: props.easing,
        delay: action.delay / 1000
      })).call(options.complete);
      new TimelineMax().to(targetId + ' .box[data-mpoverlay="1"]', options.duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
        x: props.overlayleft,
        y: props.overlaytop,
        ease: props.easing,
        delay: action.delay / 1000
      }));
      break;

    default:
      break;
  }
};

prx.actionsLibrary.changeProperty = function (action) {
  // console.log('---');
  // console.log(action);
  var _duration = 1;
  var _delay = 0;

  if (typeof action.duration != "undefined") {
    _duration = action.duration / 1000;
  }

  if (typeof action.delay != "undefined") {
    _delay = action.delay / 1000;
  }

  var _easing = prx.easing.get(action.animationEasing);

  var _property;

  if (typeof action._timelineToUse != "undefined") {
    var timeline = action._timelineToUse;
  } else {
    // without { paused: true }, it will start playing immediately
    var timeline = new TimelineMax();
  }

  var _execute_in_timeline = false; ////check if the item is masked only in one of the two states
  //if(action.propertyId == "mask_missing")
  //{
  //    //if mask is missing from the starting state we render the mask elements with out cropping
  //    //this is done i order to be able to annimate the mask elements to the the target state, where the item is masked
  //    if(action.oldvalue == true)
  //    {
  //        var $item = $(action.targetId);
  //
  //        $item.addClass("mask-active");
  //
  //        $item.wrapInner('<div id="' + action.containerid + "-" + action.itemId + '-mask-inner" class = "mask-inner"></div>');
  //
  //        var inner = $(action.targetId + '-mask-inner');
  //        inner.css({
  //            //width: action.sourceitem.width + "px",
  //            //height: action.sourceitem.height + "px",
  //            //TODO: pass source item in action and get w & h from there
  //            width: $item.width() + "px",
  //            height: $item.height() + "px",
  //            top: "0px",
  //            left: "0px",
  //        });
  //
  //        $item.wrapInner('<div id="' + action.containerid + "-" + action.itemId + '-mask" class = "mask-wrapper"></div>');
  //
  //        var mask = $(action.targetId + '-mask');
  //
  //        mask.css({
  //            "border-radius" : "0px"
  //        });
  //    }
  //    else
  //    {
  //        $(action.targetId + '-mask-inner').unwrap();
  //        $(action.targetId + '-mask-inner').children().unwrap();
  //    }
  //
  //    return timeline;
  //}

  var actionComponentType = prx.actionsLibrary.getComponentItemTypeFromDom(action.targetId); // v5.11 compatibility eleos

  if (typeof actionComponentType != "undefined") {
    actionComponentType = actionComponentType.replace("_retina", "");
  } // annam v5.2.22 moving this above the property declaration because i use variables in "visible" case.
  // Accommodate variables


  switch (action.valueType) {
    case "customValue":
      //action.newvalue already exists and it's OK
      //action.newvalue = prx.variables.recursivelyEvaluate(action.newvalue,"");
      break;

    case "readFromVariable":
      if (_typeof(action.variableName != "undefined")) {
        if (typeof prx.variables._variables[action.variableName] != "undefined") {
          if (typeof prx.variables._variables[action.variableName].parsed == "undefined") {
            prx.variables.recursivelyEvaluate(prx.variables._variables[action.variableName].value, action.variableName);
          }

          action.newvalue = prx.variables._variables[action.variableName].parsed;
        }
      }

      break;
  }

  var _newvalue = action.newvalue;
  var _oldvalue = action.oldvalue;
  var propertyType = action.propertyType;

  if (typeof propertyType == "undefined") {
    propertyType = 'component-property';
  }

  var actionTargetId = action.targetId.replace('-group-', ' .group-');

  switch (action.propertyId) {
    case "mask_missing":
      _property = {
        selector: "",
        property: "mask_missing"
      };
      break;

    case "mask_border_radius":
      _property = {
        selector: action.targetId + '-mask',
        property: "border-radius"
      };
      break;

    case "mask_x":
      _execute_in_timeline = true;
      _property = {
        selector: action.targetId + '-mask-inner',
        property: "x"
      };
      break;

    case "mask_y":
      _execute_in_timeline = true;
      _property = {
        selector: action.targetId + '-mask-inner',
        property: "y"
      };
      break;

    case "mask_border_width":
      _property = {
        rerender: true
      };
      break; //
      // _property.changeFunction = function(item, containerid, duration, easing, index) {
      //
      //     var value = item.mask_border_width;
      //
      //     var id = item.id.replace("-rerendered","");
      //     if(containerid)
      //         var selector = "#" + containerid + "-" + id + "-mask";
      //     else
      //         var selector = "#" + id + "-mask";
      //
      //
      //     var isInside = $(selector).hasClass("borderPos-inside");
      //
      //     if(isInside)
      //     {
      //         $(selector).css({"border-width":prx.componentsHelper.getProp(value,'border-width') });
      //         $(selector + "-inner").css({
      //             "margin-top": "-" + prx.componentsHelper.getProp(value,'border-width-t'),
      //             "margin-right": "-" + prx.componentsHelper.getProp(value,'border-width-r'),
      //             "margin-bottom": "-" + prx.componentsHelper.getProp(value,'border-width-b'),
      //             "margin-left": "-" + prx.componentsHelper.getProp(value,'border-width-l')
      //         });
      //     }
      //     else
      //     {
      //         $(selector).css({
      //             "border-width": prx.componentsHelper.getProp(value,'border-width'),
      //             "margin-top": "-" + prx.componentsHelper.getProp(value,'border-width-t'),
      //             "margin-right": "-" + prx.componentsHelper.getProp(value,'border-width-r'),
      //             "margin-bottom": "-" + prx.componentsHelper.getProp(value,'border-width-b'),
      //             "margin-left": "-" + prx.componentsHelper.getProp(value,'border-width-l')
      //         });
      //     }
      // };

      break;

    case "mask_border_style":
      _property = {
        selector: action.targetId + '-mask',
        property: "border-style"
      };
      break;

    case "mask_border_color":
      _execute_in_timeline = true;
      _property = {
        selector: action.targetId + '-mask',
        property: "border-color"
      };
      break;

    case "mask_border_pos":
      _property = {
        rerender: true
      };
      break;

    case "left":
      _property = {
        selector: '',
        property: 'x' //_newvalue = _newvalue - parseInt($(action.targetId).css('left')); // normalization for draggable items/components moved with css transform

      };
      break;

    case "top":
      _property = {
        selector: '',
        property: 'y' //_newvalue = _newvalue - parseInt($(action.targetId).css('top'));

      };
      break;

    case "opacity":
      if (parseFloat(_newvalue) == _newvalue) {
        _newvalue = parseFloat(_newvalue);
        prx.visibility.set(actionTargetId, 'opacity', _newvalue);
        _newvalue = prx.visibility.get(actionTargetId, 'visible-all');
        if (_newvalue === false) _newvalue = 0;
      }

      _property = {
        selector: '',
        property: action.propertyId
      };
      break;

    case "mask_inner_width":
      _execute_in_timeline = true;
      _property = {
        selector: action.targetId + '-mask-inner',
        property: "width"
      };

      if (typeof actionComponentType != "undefined" && typeof prx.types[actionComponentType].onResize != "undefined") {
        _property.onResize = prx.types[actionComponentType].onResize;
      }

      break;

    case "mask_inner_height":
      _execute_in_timeline = true;
      _property = {
        selector: action.targetId + '-mask-inner',
        property: "height"
      };

      if (typeof actionComponentType != "undefined" && typeof prx.types[actionComponentType].onResize != "undefined") {
        _property.onResize = prx.types[actionComponentType].onResize;
      }

      break;

    case "width":
    case "height":
      _property = {
        selector: '',
        property: action.propertyId
      };

      if (typeof actionComponentType != "undefined" && typeof prx.types[actionComponentType].onResize != "undefined") {
        _property.onResize = prx.types[actionComponentType].onResize;
      }

      break;

    case "strokeWidth":
      _property = {
        rerender: true
      };
      break;

    case "templatestateid":
      _property = {
        property: 'template-state'
      };
      break;

    case "background":
      if (action.itemId == 'current-page' || action.itemId == 'current-page-template' || action.itemId == 'current-container') {
        _property = {
          type: 'colorpicker',
          selector: '',
          property: 'background-color'
        };
      }

      break;

    case "dynamicProperties":
      _property = {
        rerender: true
      };
      break;

    case "visible":
      if (action.itemId.indexOf('group') != -1) {
        var groupdata = prx.groups.getGroupData(actionTargetId);

        if (!groupdata) {
          prx.actions.callback(action);
          return;
        }

        groupdata.targetids.forEach(function (target) {
          prx.items.updateTransformIfHidden(target);
        });

        if (_typeof(_newvalue) === 'object') {
          prx.visibility.set(actionTargetId, 'visible', _newvalue.visible == 0 || _newvalue.visible == false ? false : true);
          _newvalue = _newvalue.opacity;
        } else if (_newvalue == 0 || _newvalue == false) {
          // fading out
          _newvalue = 0;
          prx.visibility.set(actionTargetId, 'visible', false);
        } else {
          // fading in
          if (_newvalue === true) _newvalue = 1;
          prx.visibility.set(actionTargetId, 'visible', true);
        }

        groupdata.targetids.forEach(function (target) {
          prx.groups.redrawGroupActionDiv(target);
          timeline.add(function () {
            if (prx.visibility.get(target, 'visible-all') === false) {
              $(target).addClass('hidden');
            } else {
              $(target).removeClass('hidden');
            }
          }, _delay);
        });
      } else {
        prx.items.updateTransformIfHidden(actionTargetId);
        var oldvisibility = prx.visibility.get(actionTargetId, 'visible-all');

        if (_typeof(_newvalue) === 'object') {
          prx.visibility.set(actionTargetId, 'visible', _newvalue.visible == 0 || _newvalue.visible == false ? false : true);
          _newvalue = _newvalue.opacity;
        } else if (_newvalue == 0 || _newvalue == false) {
          // fading out
          _newvalue = 0;
          prx.visibility.set(actionTargetId, 'visible', false);
        } else {
          // fading in
          if (_newvalue === true) _newvalue = 1;
          prx.visibility.set(actionTargetId, 'visible', true);
        }

        var newvisibility = prx.visibility.get(actionTargetId, 'visible-all'); // annam === because if we get newvisibility = 0, this means that its visible but opacity 1

        if (newvisibility === false) {
          // fading out
          _newvalue = 0;

          (function (delay, duration) {
            timeline.add(function () {
              $(actionTargetId).addClass('hidden');
            }, parseFloat(delay) + parseFloat(duration));
          })(_delay, _duration);
        } else {
          // fading in
          // on changestate- visibility, we send the opacity as the target visibility value
          // this is needed because if we have both opacity and visibility changes, we only perform the visibility ones because otherwise we have a conflict because of overwritten tweens
          // due to this we need to also set the opacity here.
          if (_newvalue !== true) prx.visibility.set(actionTargetId, 'opacity', _newvalue);
          _newvalue = prx.visibility.get(actionTargetId);

          (function (delay) {
            timeline.add(function () {
              $(actionTargetId).removeClass('hidden');
            }, delay);
          })(_delay); // do it now before timeline changes and tweens added
          // its hidden anw so we don't care
          // annam translate it could be that we are dummy animating to "new" visibility to make sure its ok.


          if (oldvisibility != newvisibility) $(actionTargetId).css('opacity', 0);
          _delay = parseFloat(_delay) + 0.001;
        }
      }

      prx.vr.refresh(actionTargetId, true);
      _property = {
        selector: '',
        property: 'opacity'
      };
      break;

    case "rotation":
      _property = {
        selector: '',
        property: 'rotation'
      };
      _newvalue = parseInt(_newvalue);

      if (typeof action.rotationDirection != "undefined") {
        _newvalue += '_' + action.rotationDirection;
      } else {
        _newvalue += '_short';
      }

      break;

    case "grayscale":
    case "sepia":
    case "saturate":
    case "hueRotate":
    case "invert":
    case "brightness":
    case "contrast":
    case "blur":
    case "dropShadowX":
    case "dropShadowY":
    case "dropShadowBlur": //case "dropShadowSpread":

    case "dropShadowColor":
      _property = {
        selector: '',
        property: 'filter'
      };
      break;

    case "parentgroups":
      _property = {
        selector: '',
        property: 'parentgroups'
      };
      break;

    case "draggable":
      _property = {
        rerender: true
      };
      break;

    case "playbackSpeed":
      // _property = {rerender: false, property: 'playbackSpeed'}
      _property = {
        rerender: true
      };
      break;

    default:
      break;
  } // annam v5.5.10 - moving this outside of switch so that in case "background" i can exit without defining a property


  if (typeof _property == "undefined") {
    if (actionComponentType === undefined) {
      prx.actions.callback(action);
      return timeline;
    }

    switch (propertyType) {
      case "component-property":
        if (typeof prx.types[actionComponentType].editableProperties != "undefined") {
          for (var i = 0; i < prx.types[actionComponentType].editableProperties.length; i++) {
            if (prx.types[actionComponentType].editableProperties[i].name == action.propertyId) {
              _property = prx.types[actionComponentType].editableProperties[i].changeProperty;
              _property.type = prx.types[actionComponentType].editableProperties[i].type;
              break;
            }
          }
        }

        if (typeof _property == "undefined") {
          if (typeof prx.types[actionComponentType].interactions != "undefined") {
            for (var i = 0; i < prx.types[actionComponentType].interactions.length; i++) {
              if (prx.types[actionComponentType].interactions[i].name == action.propertyId) {
                _property = {
                  property: 'action'
                };
                break;
              }
            }
          }
        }

        if (typeof _property == "undefined") {
          if (typeof prx.types[actionComponentType].propertyGroups != "undefined") {
            for (var i = 0; i < prx.types[actionComponentType].propertyGroups.length; i++) {
              for (var j = 0; j < prx.types[actionComponentType].propertyGroups[i].properties.length; j++) {
                for (var k = 0; k < prx.types[actionComponentType].propertyGroups[i].properties[j].length; k++) {
                  if (prx.types[actionComponentType].propertyGroups[i].properties[j][k].name == action.propertyId) {
                    _property = prx.types[actionComponentType].propertyGroups[i].properties[j][k].changeProperty;
                    _property.type = prx.types[actionComponentType].propertyGroups[i].properties[j][k].type;
                    break;
                  }
                }
              }
            }
          }
        }

        break;

      case "dynamic-property":
        if (typeof prx.types[actionComponentType].dynamicProperties != "undefined") {
          if (typeof prx.types[actionComponentType].dynamicProperties.editableProperties != "undefined") {
            for (var i = 0; i < prx.types[actionComponentType].dynamicProperties.editableProperties.length; i++) {
              if (prx.types[actionComponentType].dynamicProperties.editableProperties[i].name == action.propertyId) {
                _property = prx.types[actionComponentType].dynamicProperties.editableProperties[i].changeProperty;
                _property.type = prx.types[actionComponentType].dynamicProperties.editableProperties[i].type;
                break;
              }
            }
          }

          if (typeof _property == "undefined") {
            if (typeof prx.types[actionComponentType].dynamicProperties.interactions != "undefined") {
              for (var i = 0; i < prx.types[actionComponentType].dynamicProperties.interactions.length; i++) {
                if (prx.types[actionComponentType].dynamicProperties.interactions[i].name == action.propertyId) {
                  _property = {
                    property: 'action'
                  };
                  break;
                }
              }
            }
          }

          if (typeof _property == "undefined") {
            if (typeof prx.types[actionComponentType].dynamicProperties.propertyGroups != "undefined") {
              for (var i = 0; i < prx.types[actionComponentType].dynamicProperties.propertyGroups.length; i++) {
                for (var j = 0; j < prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties.length; j++) {
                  for (var k = 0; k < prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties[j].length; k++) {
                    if (prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties[j][k].name == action.propertyId) {
                      _property = prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties[j][k].changeProperty;
                      _property.type = prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties[j][k].type;
                      break;
                    }
                  }
                }
              }
            }
          }
        }

        break;
    }
  }

  if (typeof _property != "undefined") {
    //if (typeof _newvalue === 'undefined' || _newvalue == null) _property = {rerender: true};
    // if it has on resize, evaljson(tojson()) removes functions from json struct
    // also if it has changefunction :(
    if (typeof _property.onResize == "undefined" && typeof _property.changeFunction == "undefined") {
      _property = JSON.parse(JSON.stringify(_property));
    }

    if (typeof _property.property != "undefined" && typeof _property.changeFunction == "undefined") {
      // handle color objects conversion into css
      var isColorpickerProperty = typeof _property.type !== 'undefined' && _property.type.indexOf('colorpicker') > -1;
      var isMaskBorderColor = action.propertyId === 'mask_border_color';

      if (isColorpickerProperty || isMaskBorderColor) {
        if (prx.gradients.isColorObject(_newvalue) || typeof _newvalue === 'string' && /^#?([a-f0-9]{3}|[a-f0-9]{6})$/i.test(_newvalue)) {
          _newvalue = prx.gradients.prxToCss(_newvalue);
        } else {
          _newvalue = 'rgba(0,0,0,0)';
        }
      } // console.log(_property.property);


      switch (_property.property) {
        case "mask_missing":
          //check if the item is masked only in one of the two states
          if (action.propertyId == "mask_missing") {
            //if mask is missing from the starting state we render the mask elements with out cropping
            //this is done i order to be able to annimate the mask elements to the the target state, where the item is masked
            if (action.oldvalue == true) timeline.add(function () {
              //add mask elements
              var $item = $(action.targetId);
              $item.wrapInner('<div id="' + action.containerid + "-" + action.itemId + '-mask" class = "mask-wrapper" style=" border: 0px solid #000; border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-left-radius: 0px; border-bottom-right-radius: 0px;"><div id="' + action.containerid + "-" + action.itemId + '-mask-inner" class = "mask-inner" style=" border: 0px solid #000; width: ' + $item.width() + 'px;' + 'height: ' + $item.height() + 'px; ' + 'top: 0px; left: 0px"></div></div>');
            }, _delay);else {
              //remove mask elements
              timeline.add(function () {
                $(action.targetId + '-mask-inner').unwrap();
                $(action.targetId + '-mask-inner').children().unwrap();
              }, _delay);
            }
          }

          break;

        case "text":
          switch (propertyType) {
            case "component-property":
              timeline.add(function () {
                var oldValue = $(action.targetId + ' ' + _property.selector).html();
                var resultingValue = prx.actionsLibrary.replaceTextValue(oldValue, _newvalue);
                $(action.targetId + ' ' + _property.selector).html(prx.componentsHelper.getProp(resultingValue, 'text-textarea'));
                prx.actions.callback(action);
              }, _delay);
              break;

            case "dynamic-property":
              timeline.add(function () {
                var oldValue = $(action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"] ' + _property.selector + ', ' + action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"]' + _property.selector).first().html();
                var resultingValue = prx.actionsLibrary.replaceTextValue(oldValue, _newvalue);
                $(action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"] ' + _property.selector + ', ' + action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"]' + _property.selector).first().html(prx.componentsHelper.getProp(resultingValue, 'text-textarea'));
                prx.actions.callback(action);
              }, _delay);
              break;
          }

          break;

        case "input-value":
          timeline.add(function () {
            $(action.targetId + ' ' + _property.selector).val(_newvalue);
            prx.actions.callback(action);
          }, _delay);
          break;

        case "textarea-value":
          timeline.add(function () {
            $(action.targetId + ' ' + _property.selector).val(prx.componentsHelper.getProp(_newvalue, 'text-textarea').toString().replace(/<br \/>/g, "\n"));
            prx.actions.callback(action);
          }, _delay);
          break;

        case "checkbox-state":
          timeline.add(function () {
            if (_newvalue == "true") _newvalue = true;
            if (_newvalue == "false") _newvalue = false;
            $(action.targetId + ' ' + _property.selector).prop('checked', _newvalue).trigger('change');
            prx.actions.callback(action);
          }, _delay);
          break;

        case "action":
          var oldvalue = action.oldvalue;
          var newvalue = _newvalue;

          if (typeof newvalue == "undefined" || newvalue == null) {
            newvalue = [];
          }

          if (typeof oldvalue == "undefined" || oldvalue == null) {
            oldvalue = [];
          }

          (function (oldvalue, newvalue, timeline) {
            timeline.add(function () {
              var item = {
                type: actionComponentType,
                id: action.itemId
              };

              if (action.propertyType == "dynamic-property" && typeof actionComponentType != 'undefined') {
                item[prx.types[actionComponentType].dynamicProperties.data] = [];
                item[prx.types[actionComponentType].dynamicProperties.data][action.itemIndex] = {};

                if (this.timeline.data.reversing) {
                  item[prx.types[actionComponentType].dynamicProperties.data][action.itemIndex][action.propertyId] = oldvalue;
                } else {
                  item[prx.types[actionComponentType].dynamicProperties.data][action.itemIndex][action.propertyId] = newvalue;
                }
              } else {
                if (this.timeline.data.reversing) {
                  item[action.propertyId] = oldvalue;
                } else {
                  item[action.propertyId] = newvalue;
                }
              }

              prx.actions.parseItemAction(item, action.containerid, action.pageId);
              prx.actions.callback(action);
            }, _delay);
          })(oldvalue, newvalue, timeline);

          if (typeof action._timelineToUse != "undefined") {
            return timeline;
          }

          break;

        case "container-state":
          //var timeline2 = new TimelineMax({ paused: true });
          var action2 = {
            //_timelineToUse: timeline2,
            pageId: action.pageId,
            targetId: action.targetId,
            stateId: _newvalue,
            itemId: action.itemId,
            guid: action.guid,
            containerid: action.containerid //delay: action.delay

          };

          if (typeof action.loop === 'boolean') {
            action2.loop = action.loop;
          }

          if (typeof action.loopGUID === 'string') {
            action2.loopGUID = action.loopGUID;
          }

          if (typeof action.previousActions != "undefined") {
            action2.previousActions = JSON.parse(JSON.stringify(action.previousActions));
          }

          if (typeof action.callbackAction != "undefined") {
            action2.callbackAction = JSON.parse(JSON.stringify(action.callbackAction));
          }

          if (typeof action.callback != "undefined") {
            action2.callback = action.callback;
          } //timeline2 = prx.actionsLibrary.changeState(action2, 'symbols');
          //setTimeout(function () {


          timeline.add(function () {
            prx.actionsLibrary.changeState(action2, 'symbols'); //timeline2.play()
            //}, action.delay);
          }, _delay); //}, action.delay - timeline2.totalDuration() * 1000);
          // this was a very quick thought that i didnt really look into. it would probably work.
          // it targets reverse change state transitions on containers that would start at the wrong time on reverse

          break;

        case "template-state":
          var action2 = {
            //_timelineToUse: timeline,
            pageId: action.pageId,
            targetId: action.targetId,
            stateId: _newvalue,
            itemId: action.itemId //delay: action.delay

          };

          if (typeof action.previousActions != "undefined") {
            action2.previousActions = JSON.parse(JSON.stringify(action.previousActions));
          }

          if (typeof action.callbackAction != "undefined") {
            action2.callbackAction = JSON.parse(JSON.stringify(action.callbackAction));
          }

          if (typeof action.callback != "undefined") {
            action2.callback = action.callback;
          }

          setTimeout(function () {
            return prx.actionsLibrary.changeState(action2, 'templates');
          }, action.delay);
          break;

        case "font-family":
          var fullid = action.containerid + '-' + action.itemId;
          var split = fullid.split('box-');
          action.itemId = 'box-' + split[split.length - 1];
          action.containerid = fullid.replace('-' + action.itemId, "");
          var stateid = $(action.targetId).parents('[data-state-id]').first().attr('data-state-id');
          var item = prx.items.getFromAllItemStruct(action.itemId, stateid);
          var getInfo = prx.componentsHelper.getTextandFontStylePropsName(item.type, action.propertyId, propertyType == 'dynamic-property');
          var textFontStyleGroup = getInfo['textFontStyleGroup'];
          var textFontStylePropName = getInfo['relatedTextFontStylePropsName'];
          var textFontValue = '400';

          if (typeof textFontStyleGroup['value'] == 'function' && textFontStylePropName) {
            textFontValue = textFontStyleGroup['value'](item, textFontStylePropName, action.itemIndex);
          }

          var str = prx.componentsHelper.getProp(_newvalue + '|' + textFontValue, 'font-family');
          var props = str.split(';');
          var _newvalue = {};

          for (var i = 0; i < props.length; i++) {
            var split = props[i].split(':');
            if (split.length == 2) _newvalue[split[0].trim()] = split[1].trim();
          }

          timeline.add(function () {
            if (propertyType == 'dynamic-property') {
              var $editableText = $(action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"] ' + _property.selector + ', ' + action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"]' + _property.selector + ' span[data-editableproperty="' + action.propertyId.replace('Font', '') + '"]');

              if ($editableText.length > 0) {
                for (var i = 0; i < $editableText.length; i++) {
                  $($editableText[i]).html(prx.componentsHelper.stripStyle($($editableText[i]).html(), 'font-family'));
                }
              }

              $(action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"] ' + _property.selector + ', ' + action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"]' + _property.selector).first().css(_newvalue);
            } else {
              var $editableText = $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector + ' span[data-editableproperty="' + action.propertyId.replace('Font', '') + '"]');

              if ($editableText.length > 0) {
                for (var i = 0; i < $editableText.length; i++) {
                  $($editableText[i]).html(prx.componentsHelper.stripStyle($($editableText[i]).html(), 'font-family'));
                }
              }

              $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).css(_newvalue);
            }

            prx.actions.callback(action);
          }, _delay);
          break;

        case "background-color":
        case "fill":
        case "fill,background-color":
          var validAnimation = false; // find out what the current status is

          var oldBackgroundImage = $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).css('background-image');
          var oldBackgroundPrxData = oldBackgroundImage ? prx.gradients.cssToPrx(oldBackgroundImage) : prx.gradients.cssToPrx('none');

          if (!oldBackgroundImage || oldBackgroundImage === 'none') {
            var oldBackgroundColor = $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).css('background-color');

            if (_property.property.indexOf('fill') > -1) {
              oldBackgroundColor = $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).css('fill');
            }

            oldBackgroundPrxData = oldBackgroundColor ? prx.gradients.cssToPrx(oldBackgroundColor) : prx.gradients.cssToPrx('none');
          }

          var newBackgroundPrxData = _newvalue;

          if (_typeof(newBackgroundPrxData) !== 'object') {
            newBackgroundPrxData = prx.gradients.stringToPrxData(_newvalue);
          }

          var _gradient_transition = {};
          _gradient_transition.ease = _easing;
          _gradient_transition = Object.assign({}, prx.basicGreensockOptions, _gradient_transition);

          switch (oldBackgroundPrxData.type) {
            case 'radial':
              // from radial to radial
              if (newBackgroundPrxData.type === 'radial') {
                // find out which gradient has more colors and add to the other if required
                var maxColors = Math.max(oldBackgroundPrxData.colors.length, newBackgroundPrxData.colors.length);

                while (oldBackgroundPrxData.colors.length < maxColors) {
                  oldBackgroundPrxData.colors.push(oldBackgroundPrxData.colors.slice(-1).pop());
                }

                while (newBackgroundPrxData.colors.length < maxColors) {
                  newBackgroundPrxData.colors.push(newBackgroundPrxData.colors.slice(-1).pop());
                }

                $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).css('background-image', prx.gradients.prxToCss(oldBackgroundPrxData));
                _gradient_transition['background-image'] = prx.gradients.prxToCss(newBackgroundPrxData);
                validAnimation = true;
              } // from radial to solid


              if (newBackgroundPrxData.type === 'solid') {
                // convert final solid into equal gradient
                var equalNewBackgroundPrxData = prx.toolbox.clone(oldBackgroundPrxData);
                oldBackgroundPrxData.colors.forEach(function (value, index) {
                  equalNewBackgroundPrxData.colors[index].color = newBackgroundPrxData.color;
                }); // define transition

                _gradient_transition['background-image'] = prx.gradients.prxToCss(equalNewBackgroundPrxData);

                _gradient_transition.onComplete = function () {
                  $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).css('background-color', prx.gradients.prxToCss(newBackgroundPrxData)).css('background-image', 'none');
                };

                validAnimation = true;
              } // from radial to linear not supported


              if (newBackgroundPrxData.type === 'linear') {
                _gradient_transition['background-image'] = prx.gradients.prxToCss(newBackgroundPrxData);
                _duration = 0;
                validAnimation = true;
              }

              break;

            case 'linear':
              // from linear to linear
              if (newBackgroundPrxData.type === 'linear') {
                // find out which gradient has more colors and add to the other if required
                var maxColors = Math.max(oldBackgroundPrxData.colors.length, newBackgroundPrxData.colors.length);

                while (oldBackgroundPrxData.colors.length < maxColors) {
                  oldBackgroundPrxData.colors.push(oldBackgroundPrxData.colors.slice(-1).pop());
                }

                while (newBackgroundPrxData.colors.length < maxColors) {
                  newBackgroundPrxData.colors.push(newBackgroundPrxData.colors.slice(-1).pop());
                }

                $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).css('background-image', prx.gradients.prxToCss(oldBackgroundPrxData));
                _gradient_transition['background-image'] = prx.gradients.prxToCss(newBackgroundPrxData);
                validAnimation = true;
              } // from linear to solid


              if (newBackgroundPrxData.type === 'solid') {
                // convert final solid into equal gradient
                var equalNewBackgroundPrxData = prx.toolbox.clone(oldBackgroundPrxData);
                oldBackgroundPrxData.colors.forEach(function (value, index) {
                  equalNewBackgroundPrxData.colors[index].color = newBackgroundPrxData.color;
                }); // define transition

                _gradient_transition['background-image'] = prx.gradients.prxToCss(equalNewBackgroundPrxData);

                _gradient_transition.onComplete = function () {
                  $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).css('background-color', prx.gradients.prxToCss(newBackgroundPrxData)).css('background-image', 'none');
                };

                validAnimation = true;
              } // from linear to radial not supported


              if (newBackgroundPrxData.type === 'radial') {
                _gradient_transition['background-image'] = prx.gradients.prxToCss(newBackgroundPrxData);
                _duration = 0;
                validAnimation = true;
              }

              break;

            case 'solid':
              // from solid to radial or linear
              if (newBackgroundPrxData.type === 'radial' || newBackgroundPrxData.type === 'linear') {
                // convert final solid into equal gradient
                var equalOldBackgroundPrxData = prx.toolbox.clone(newBackgroundPrxData);
                newBackgroundPrxData.colors.forEach(function (value, index) {
                  equalOldBackgroundPrxData.colors[index].color = oldBackgroundPrxData.color;
                }); // define transition

                $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).css('background-image', prx.gradients.prxToCss(equalOldBackgroundPrxData)).css('background-color', 'inherit');
                _gradient_transition['background-image'] = prx.gradients.prxToCss(newBackgroundPrxData);
                validAnimation = true;
              } // from solid to solid


              if (newBackgroundPrxData.type === 'solid') {
                if (_property.property.indexOf('fill') > -1) {
                  _gradient_transition['fill'] = prx.gradients.prxToCss(newBackgroundPrxData);
                } else {
                  _gradient_transition['background-color'] = prx.gradients.prxToCss(newBackgroundPrxData);
                }

                validAnimation = true;
              }

              break;

            default:
          } // add the created transition to the timeline


          if (validAnimation) {
            // there's not really a need to call this if it will animate a div inside the item, because it adds the translate3d on that div and it doesn't mess with the position of the .box
            if (_property.selector === '') {
              prx.items.updateTransformIfHidden(action.targetId);
            }

            timeline.add(function () {
              TweenLite.to($(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector), _duration, _gradient_transition); // GS - in the future, if we want to also have the transition go backwards we'll need to remove the callback from here and call it manually after the duration

              prx.actions.callback(action);
            }, _delay);
          }

          break;

        case "class":
          timeline.add(function () {
            var regx = new RegExp('(^|\\s)' + action.propertyId + '-\\S*', 'g');
            $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).removeClass(function (index, css) {
              return (css.match(regx) || []).join(' ');
            }).addClass(action.propertyId + '-' + _newvalue);
            prx.actions.callback(action);
          }, _delay);
          break;

        case "parentgroups":
          //timeline.add(function () {
          var regx = new RegExp('(^|\\s)group-\\S*', 'g');
          $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector).removeClass(function (index, css) {
            return (css.match(regx) || []).join(' ');
          }).addClass(_newvalue.map(function (gid) {
            return 'group-' + gid;
          }).join(' '));
          prx.actions.callback(action); //}, _delay);

          break;
        // case "playbackSpeed":
        //     lottie.setSpeed(_newvalue, prx.bodymovinAnimation.getAnimationInstanceByName($(action.targetId + ' .bodymovin-player').attr('data-name')));
        //     break;

        case "filter":
          var targetId = action.targetId;
          var filter = action.propertyId;
          var finalValue = _newvalue;
          var initialValue = typeof prx.items.filters[targetId] !== 'undefined' && typeof prx.items.filters[targetId][filter] !== 'undefined' ? prx.items.filters[targetId][filter] : null;

          if (finalValue == null) {
            finalValue = 0;
            if (['brightness', 'contrast', 'saturate'].indexOf(filter) !== -1) finalValue = 1;

            if ('dropShadowColor' === filter) {
              finalValue = 'rgba(0,0,0,0)';
            }
          } else if ('dropShadowColor' === filter) {
            finalValue = prx.gradients.prxToCss(_newvalue);
          }

          if (initialValue == null) {
            initialValue = 0;
            if (['brightness', 'contrast', 'saturate'].indexOf(filter) !== -1) initialValue = 1;
            if ('dropShadowColor' === filter) initialValue = 'rgba(0,0,0,0)';
          } else if ('dropShadowColor' === filter) {
            initialValue = prx.gradients.prxToCss(initialValue);
          }

          var _toRGBAvals = function _toRGBAvals(color) {
            var chanels = [];
            var alpha = '1';

            if (color.toLowerCase().indexOf('rgb') > -1) {
              chanels = color.split("(")[1].split(")")[0];
              chanels = chanels.split(',');
              chanels = chanels.map(function (item) {
                return item.trim();
              });

              if (chanels.length === 3) {
                chanels.push(alpha);
              }
            } else {
              var hexToR = function hexToR(h) {
                return parseInt(cutHex(h).substring(0, 2), 16);
              };

              var hexToG = function hexToG(h) {
                return parseInt(cutHex(h).substring(2, 4), 16);
              };

              var hexToB = function hexToB(h) {
                return parseInt(cutHex(h).substring(4, 6), 16);
              };

              var cutHex = function cutHex(h) {
                return h.charAt(0) == "#" ? h.substring(1, 7) : h;
              };

              chanels.push(hexToR(color));
              chanels.push(hexToG(color));
              chanels.push(hexToB(color));
              chanels.push(alpha);
            }

            return chanels.map(function (item) {
              return parseFloat(item);
            });
          }; // end of function


          var dif = [];

          if (filter === 'dropShadowColor') {
            initialValue = _toRGBAvals(initialValue);
            finalValue = _toRGBAvals(finalValue);

            for (var i = 0; i < 4; i++) {
              dif[i] = initialValue[i] - finalValue[i];
            }
          } else {
            dif = initialValue - finalValue;
          }

          timeline.add(TweenLite.to({}, _duration, {
            onUpdate: function onUpdate(tl) {
              var progress = tl.progress();
              progress = isNaN(progress) ? 1 : progress;
              var newFilterVal = [],
                  sub = [];

              if (filter === 'dropShadowColor') {
                sub = dif.map(function (item) {
                  return item * progress;
                });

                for (var i = 0; i < 4; i++) {
                  newFilterVal[i] = initialValue[i] - sub[i];
                }

                newFilterVal = 'rgba(' + parseInt(newFilterVal[0]) + ',' + parseInt(newFilterVal[1]) + ',' + parseInt(newFilterVal[2]) + ',' + newFilterVal[3] + ')';
              } else {
                sub = dif * progress;
                newFilterVal = initialValue - sub;
              }

              if (typeof prx.items.filters[targetId] === 'undefined') prx.items.filters[targetId] = {};
              prx.items.filters[targetId][filter] = newFilterVal;
              prx.items.applyFilters(targetId);
            },
            onComplete: function onComplete() {
              prx.actions.callback(action);
            },
            onUpdateParams: ["{self}"]
          }), _delay);
          break;

        case "width":
        case "height":
        case "line-height":
        case "letter-spacing":
          if (parseInt(_newvalue) == _newvalue) {
            _newvalue += 'px';
          }

        case "border-radius":
          if (parseInt(_newvalue) == _newvalue) {
            _newvalue += 'px';
          } else if (_newvalue !== null && _typeof(_newvalue) === 'object') {
            _newvalue = _newvalue.tl + "px, " + _newvalue.tr + "px, " + _newvalue.br + "px, " + _newvalue.bl + "px";
          }

        case "border-width":
          if (parseInt(_newvalue) == _newvalue) {
            _newvalue += 'px';
          } else if (_newvalue !== null && _typeof(_newvalue) === 'object') {
            _newvalue = _newvalue.t + "px " + _newvalue.r + "px " + _newvalue.b + "px " + _newvalue.l + "px";
          }

        // not breaking!

        case "percent-width":
          if (parseInt(_newvalue) == _newvalue) {
            _newvalue += '%';
            _property.property = "width";
          }

        // not breaking!

        case "opacity":
          if (parseFloat(_newvalue) == _newvalue) {
            _newvalue = parseFloat(_newvalue);
          }

        // not breaking!

        default:
          var _onComplete = function _onComplete() {
            if (typeof action._timelineToUse == "undefined") {
              //v5.10.3 oncontainerscroll snaps back to original position if refreshing
              if (action.type != "containerscroll") {
                prx.scrollable.refresh(action.targetId);
              }

              if (['width', 'height', 'top', 'left', 'x', 'y', 'opacity', 'visible'].indexOf(_property.property) > -1) {
                prx.groups.redrawGroupActionDiv(actionTargetId);
              }
            }

            prx.actions.callback(action);
          };

          var properties = _property.property.split(',');

          for (var i = 0; i < properties.length; i++) {
            var _transition = Object.assign({}, prx.basicGreensockOptions); //fix for mask border radius / it seams that if mask-inner has 3D transformation then border radius is not working (css)


            if ((action.propertyId == "mask_x" || action.propertyId == "mask_y") && $.browser.webkit) {
              var disable3D = false;
              var fullid = action.containerid + '-' + action.itemId;
              var split = fullid.split('box-');
              action.itemId = 'box-' + split[split.length - 1];
              action.containerid = fullid.replace('-' + action.itemId, "");
              var stateid = $(action.targetId).parents('[data-state-id]').first().attr('data-state-id');
              var item = prx.items.getFromAllItemStruct(action.itemId, stateid);
              if (item.hasOwnProperty("mask") && item.mask.hasOwnProperty("borderRadius") && parseInt(item.mask.borderRadius) != 0) disable3D = true;

              if (!disable3D) {
                var br = $('#' + action.itemId + "-mask").css("border-radius");

                if (typeof br !== "undefined") {
                  br = br.split();

                  for (var i = 0; i < br.length; i++) {
                    if (parseInt(br[i]) != 0) {
                      disable3D = true;
                      break;
                    }
                  }
                }
              }

              if (disable3D) _transition.force3D = false;
            }

            _transition[properties[i].replace(/-([a-z])/g, function (m, w) {
              return w.toUpperCase();
            })] = _newvalue;
            _transition.ease = _easing;

            if ((properties[i] == "width" || properties[i] == "height") && typeof _property.onResize != "undefined") {
              // fix for itemid - action.itemId may be box-1-box-2 if targetting in a container
              var fullid = action.containerid + '-' + action.itemId;
              var split = fullid.split('box-');
              action.itemId = 'box-' + split[split.length - 1];
              action.containerid = fullid.replace('-' + action.itemId, "");
              var stateid = $(action.targetId).parents('[data-state-id]').first().attr('data-state-id');

              if (typeof prx.allItems[action.itemId] != "undefined" && typeof prx.allItems[action.itemId].states != "undefined" && typeof prx.allItems[action.itemId].states[stateid] != "undefined") {
                var data = JSON.parse(prxy[prx.allItems[action.itemId].containertype][prx.allItems[action.itemId].containerindex].states[prx.allItems[action.itemId].states[stateid].stateindex].data);

                if (typeof data.items != "undefined") {
                  item = data.items[prx.allItems[action.itemId].itemindex];
                } else {
                  item = data[prx.allItems[action.itemId].states[stateid].itemindex];
                }

                item.htype = "fixed";
                item.vtype = "fixed";

                _transition.onUpdate = function (item, _property) {
                  item.width = $(this._targets[0]).width();
                  item.height = $(this._targets[0]).height(); // patentes gia tin alexandra

                  if (item.type == "shape" || item.type == "arrow" || item.type == "arrow1" || item.type == "arrow2" || item.type == "arrow3" || item.type == "bubble" || item.type == "bubble2") {
                    $this = $(this._targets[0]);
                    var typeName = $this.attr('data-shape-type');
                    var borderWidthShape = $this.attr('data-border-width-shape');
                    var borderWidth = $this.attr('data-border-width');
                    var numOfNodes = $this.attr('data-num-nodes');
                    var spikeDepth = $this.attr('data-spike-depth');
                    var skew = $this.attr('data-skew');
                    var baseWidth = $this.attr('data-base-width');
                    var isDashed = $this.attr('data-dashed');
                    var filledArrow = $this.attr('data-filled');
                    var arrowDirection = $this.attr('data-direction-arrow');
                    var tipDirection = $this.attr('data-direction-tip');

                    if (typeof typeName != "undefined") {
                      item.typeName = typeName;
                    }

                    if (typeof borderWidthShape != "undefined") {
                      item.borderWidthShape = borderWidthShape;
                    }

                    if (typeof numOfNodes != "undefined") {
                      item.numOfNodes = numOfNodes;
                    }

                    if (typeof spikeDepth != "undefined") {
                      item.spikeDepth = spikeDepth;
                    }

                    if (typeof skew != "undefined") {
                      item.skew = skew;
                    }

                    if (typeof baseWidth != "undefined") {
                      item.baseWidth = baseWidth;
                    }

                    if (typeof borderWidth != "undefined") {
                      item.borderWidth = borderWidth;
                    }

                    if (typeof isDashed != "undefined") {
                      item.isDashed = isDashed;
                    }

                    if (typeof filledArrow != "undefined") {
                      item.filledArrow = filledArrow;
                    }

                    if (typeof arrowDirection != "undefined") {
                      item.arrowDirection = arrowDirection;
                    }

                    if (typeof tipDirection != "undefined") {
                      item.tipDirection = tipDirection;
                    }
                  }

                  var id = $(this._targets[0]).attr('id');
                  var containerid = id.substring(0, id.indexOf('-' + item.id));

                  _property.onResize(item, containerid);
                };

                _transition.onUpdateParams = [item, _property];
              }
            }

            var selector = action.targetId + ' ' + _property.selector + (properties.length > 1 ? ', ' + action.targetId + ' ' + _property.selector + '-' + properties[i] : '') + ', ' + action.targetId + _property.selector + (properties.length > 1 ? ', ' + action.targetId + ' ' + _property.selector + '-' + properties[i] : '');

            if (propertyType == "dynamic-property") {
              selector = action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"] ' + _property.selector + (properties.length > 1 ? '-' + properties[i] : '') + ', ' + action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"]' + _property.selector + (properties.length > 1 ? '-' + properties[i] : '');
            }

            if (typeof actionComponentType != 'undefined' && actionComponentType === 'image' && (typeof action.newvalue === 'undefined' || action.newvalue == null)) {
              switch (action.propertyId) {
                case 'borderColor':
                  action.newvalue = '#000000';
                  _newvalue = '#000000';
                  _transition.borderColor = '#000000';
                  _transition.borderTopColor = '#000000';
                  _transition.borderRightColor = '#000000';
                  _transition.borderBottomColor = '#000000';
                  _transition.borderLeftColor = '#000000';
                  break;

                case 'borderWidth':
                  action.newvalue = 0;
                  _newvalue = 0;
                  _transition.borderWidth = 0;
                  _transition.borderTopWidth = 0;
                  _transition.borderRightWidth = 0;
                  _transition.borderBottomWidth = 0;
                  _transition.borderLeftWidth = 0;
                  break;

                case 'borderRadius':
                  action.newvalue = 0;
                  _newvalue = 0;
                  _transition.borderRadius = 0;
                  break;
              }
            }

            if (action.itemId !== undefined && action.itemId.indexOf('group') != -1) {
              action.targetId = action.targetId.replace('-group-', ' .group-');
              var props = Object.assign({}, prx.basicGreensockOptions, {
                ease: _easing
              });

              switch (action.propertyId) {
                case 'opacity':
                case 'visible':
                  var groupdata = prx.groups.getGroupData(actionTargetId);

                  if (!groupdata) {
                    prx.actions.callback(action);
                    return;
                  }

                  groupdata.targetids.forEach(function (targetId, index) {
                    prx.items.updateTransformIfHidden(targetId);
                  });
                  prx.visibility.set(actionTargetId, 'opacity', Number(action.newvalue));
                  groupdata.targetids.forEach(function (target) {
                    timeline.add(TweenLite.to(target, _duration, Object.assign({}, prx.basicGreensockOptions, {
                      opacity: prx.visibility.get(target),
                      ease: props.easing,
                      delay: action.delay / 1000
                    })), _delay);
                  });
                  break;

                case 'width':
                case 'height':
                  var groupdata = prx.groups.getGroupData(actionTargetId);

                  if (!groupdata) {
                    prx.actions.callback(action);
                    return;
                  }

                  groupdata.targetids.forEach(function (target, index) {
                    prx.items.updateTransformIfHidden(target);
                  });
                  var itemdimentions = prx.groups.getItemDimentions(groupdata);
                  var groupDimentions = prx.toolbox.calculateBox(itemdimentions, groupdata.group.rotation, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
                  var unrotatedItems = itemdimentions.map(function (item) {
                    var item = prx.toolbox.rotate(item, {
                      x: groupDimentions.x,
                      y: groupDimentions.y
                    }, 360 - groupDimentions.rotation);
                    return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
                  });
                  var itemPercentages = unrotatedItems.map(function (item) {
                    var p = {};
                    p.width = item.width / groupDimentions.width;
                    p.height = item.height / groupDimentions.height;
                    p.top = (item.top - groupDimentions.top) / groupDimentions.height;
                    p.left = (item.left - groupDimentions.left) / groupDimentions.width;
                    return p;
                  });

                  if (action.propertyId === 'width') {
                    groupDimentions.width = Number(action.newvalue);
                  } else {
                    groupDimentions.height = Number(action.newvalue);
                  }

                  var newGroupDimentions = prx.toolbox.itemDimensions(groupDimentions, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
                  var newItemDimentions = unrotatedItems.map(function (item, index) {
                    item.width = itemPercentages[index].width * newGroupDimentions.width;
                    item.height = itemPercentages[index].height * newGroupDimentions.height;
                    item.top = newGroupDimentions.top + itemPercentages[index].top * newGroupDimentions.height;
                    item.left = newGroupDimentions.left + itemPercentages[index].left * newGroupDimentions.width;
                    return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
                  });
                  var rerotatedItems = newItemDimentions.map(function (item) {
                    item = prx.toolbox.rotate(item, {
                      x: newGroupDimentions.x,
                      y: newGroupDimentions.y
                    }, newGroupDimentions.rotation);
                    return prx.toolbox.itemDimensions(item, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
                  });
                  groupdata.targetids.forEach(function (target, index) {
                    action = prx.toolbox.clone(action);
                    action.targetId = target;
                    var toItem = rerotatedItems[index];
                    var fromItem = itemdimentions[index];

                    var _transition = Object.assign({}, prx.basicGreensockOptions, props);

                    if (fromItem.top !== toItem.top) _transition.y = toItem.top;
                    if (fromItem.left !== toItem.left) _transition.x = toItem.left;
                    if (fromItem.width !== toItem.width) _transition.width = toItem.width;
                    if (fromItem.height !== toItem.height) _transition.height = toItem.height;
                    var itemid = 'box-' + action.targetId.split('box-').last();
                    var item = prx.items.getFromAllItemStruct(itemid, groupdata.stateid);

                    if (typeof prx.types[item.type].onResize == 'function') {
                      _transition.onUpdate = function (item, target, container) {
                        item.htype = "fixed";
                        item.vtype = "fixed";
                        item.width = $(target).width();
                        item.height = $(target).height();
                        prx.types[item.type].onResize(item, container);
                      };

                      _transition.onUpdateParams = [item, action.targetId, action.targetId.replace('-' + itemid, '').replace('#', '')];
                    }

                    timeline.add(TweenLite.to(action.targetId, _duration, _transition), _delay);
                  });
                  break;

                case 'left':
                case 'top':
                  var groupdata = prx.groups.getGroupData(actionTargetId);

                  if (!groupdata) {
                    prx.actions.callback(action);
                    return;
                  }

                  groupdata.targetids.forEach(function (targetId, index) {
                    prx.items.updateTransformIfHidden(targetId);
                  });
                  var itemdimentions = prx.groups.getItemDimentions(groupdata);
                  var groupdimentions = prx.toolbox.calculateBox(itemdimentions, groupdata.group.rotation, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);

                  var _transition = Object.assign({}, prx.basicGreensockOptions, props);

                  if (action.propertyId === 'left') {
                    _transition.x = Number(action.newvalue) - groupdimentions.left;
                    _transition.x = _transition.x > 0 ? '+=' + _transition.x : '-=' + -_transition.x;
                  } else {
                    _transition.y = Number(action.newvalue) - groupdimentions.top;
                    _transition.y = _transition.y > 0 ? '+=' + _transition.y : '-=' + -_transition.y;
                  }

                  timeline.add(TweenLite.to(action.targetId, _duration, _transition), _delay);
                  break;
              }
            } else {
              if (_execute_in_timeline) //cases where animation should added while timeline is running
                timeline.add(function () {
                  timeline.add(function () {
                    prx.items.updateTransformIfHidden(action.targetId);
                  }, _delay - 0.01);
                  timeline.add(TweenLite.to(selector, _duration, _transition), _delay);
                }, _delay);else {
                //if animating mask's border-width positioned outside we have to also animate the margin of the mask
                // if(properties[i] == "border-width" && action.propertyId == "mask_border_width_out")
                //     _transition.margin =  "-" + _newvalue;
                //add animation to the time line
                timeline.add(function () {
                  prx.items.updateTransformIfHidden(action.targetId);
                }, Math.max(_delay - 0.01, 0));
                timeline.add(TweenLite.to(selector, _duration, _transition), _delay); //if animating mask's border-width positioned inside we have to also animate the margin of the mask-inner element
                // if(properties[i] == "border-width" && action.propertyId == "mask_border_width_in")
                // {
                //     var _transition2 = JSON.parse(JSON.stringify(_transition));
                //     delete _transition2.borderWidth;
                //
                //     _transition2.margin =  "-" + _newvalue;
                //
                //     var selector2 = selector.replace(/,/g,"-inner,");
                //     selector2 += "-inner";
                //
                //     timeline.add(TweenLite.to(selector2, _duration, _transition2), _delay)
                // }
              }
            }
          }

          timeline.add(_onComplete, _duration + _delay + 0.01);

          if (typeof action._timelineToUse != "undefined") {
            return timeline;
          }

          return;
      }
    }

    if (typeof _property.rerender !== "undefined" && _property.rerender || typeof _property.changeFunction != "undefined") {
      var item; // fix for itemid - action.itemId may be box-1-box-2 if targetting in a container

      var fullid = action.containerid + '-' + action.itemId;
      var split = fullid.split('box-');
      action.itemId = 'box-' + split[split.length - 1];
      action.containerid = fullid.replace('-' + action.itemId, "");
      var stateid = $(action.targetId).parents('[data-state-id]').first().attr('data-state-id');

      if (typeof prx.allItems[action.itemId].states != "undefined" && typeof prx.allItems[action.itemId].states[stateid] != "undefined") {
        var data = JSON.parse(prxy[prx.allItems[action.itemId].containertype][prx.allItems[action.itemId].containerindex].states[prx.allItems[action.itemId].states[stateid].stateindex].data);

        if (typeof data.items != "undefined") {
          item = data.items[prx.allItems[action.itemId].itemindex];
        } else {
          item = data[prx.allItems[action.itemId].states[stateid].itemindex];
        }
      }

      if (typeof item == "undefined") {
        timeline.add(function () {
          prx.actions.callback(action);
        });
        return false;
      } // if(action.propertyId.indexOf('Properties') > -1){ //text properties
      //     if (action.propertyType == "dynamic-property"  && typeof(actionComponentType) != 'undefined') {
      //         var relatedTextFontStylePropsName = prx.componentsHelper.getTextandFontStylePropsName(actionComponentType, action.propertyId, true)['relatedTextFontStylePropsName'];
      //         var newFontStyleValue = prx.componentsHelper.getFontStyleValueFromTextProperties(_newvalue);
      //
      //         item[prx.types[actionComponentType].dynamicProperties.data][action.itemIndex][relatedTextFontStylePropsName] = newFontStyleValue;
      //         item[prx.types[actionComponentType].dynamicProperties.data][action.itemIndex][action.propertyId] = _newvalue;
      //     } else {
      //         var relatedTextFontStylePropsName = prx.componentsHelper.getTextandFontStylePropsName(actionComponentType, action.propertyId, false)['relatedTextFontStylePropsName'];
      //         var newFontStyleValue = prx.componentsHelper.getFontStyleValueFromTextProperties(_newvalue);
      //
      //         item[relatedTextFontStylePropsName] = newFontStyleValue;
      //         item[action.propertyId] = _newvalue;
      //     }
      // }else {


      if (action.propertyType == "dynamic-property") {
        item[prx.types[actionComponentType].dynamicProperties.data][action.itemIndex][action.propertyId] = _newvalue;
      } else {
        item[action.propertyId] = _newvalue;
      } //}


      var regx = new RegExp('-' + item.id + '$');

      var _containerid = action.targetId.slice(1).replace(regx, '');

      if (_property.rerender) {
        timeline.add(function () {
          prx.items.rerender(item, _containerid, action.pageId);
          prx.actions.callback(action);
        }, _delay);

        if (item.type == "vectoranimation") {
          var oncCompleteLoadVectorAnimations = function oncCompleteLoadVectorAnimations() {
            prx.bodymovinAnimation.loadBodymovinPageAnimations(_containerid);
          };

          timeline.add(oncCompleteLoadVectorAnimations, _duration + _delay + 0.01);
        }
      }

      if (typeof _property.changeFunction != "undefined") {
        timeline.add(function () {
          _property.changeFunction(item, _containerid, _duration, _easing, action.itemIndex);

          prx.actions.callback(action);
        }, _delay);
      }
    }
  }

  if (typeof action._timelineToUse != "undefined") {
    return timeline;
  }
};

prx.actionsLibrary.setVariable = function (action) {
  var actionComponentType = prx.actionsLibrary.getComponentItemTypeFromDom(action.targetId); // v5.11 compatibility eleos

  if (typeof actionComponentType != "undefined") {
    actionComponentType = actionComponentType.replace("_retina", "");
  }

  var _duration = 1;
  var _delay = 0;

  if (typeof action.duration != "undefined") {
    _duration = action.duration / 1000;
  }

  if (typeof action.delay != "undefined") {
    _delay = action.delay / 1000;
  }

  var _property;

  var propertyType = action.propertyType;

  if (typeof propertyType == "undefined") {
    propertyType = 'component-property';
  }

  switch (action.valueSource) {
    case "customValue":
      //action.newvalue already exists and it's OK
      break;

    case "callbackvalue":
      _property = {
        selector: '',
        property: 'triggerdata'
      };
      break;

    case "setValueFromItemProperty":
      switch (action.propertyId) {
        case "left":
        case "top":
        case "opacity":
          _property = {
            selector: '',
            property: action.propertyId
          };
          break;

        case "width":
        case "height":
          _property = {
            selector: '',
            property: action.propertyId
          };

          if (typeof actionComponentType != 'undefined' && typeof prx.types[actionComponentType].onResize != "undefined") {
            _property.onResize = prx.types[actionComponentType].onResize;
          }

          break;

        default:
          switch (propertyType) {
            case "component-property":
              if (typeof actionComponentType != 'undefined' && typeof prx.types[actionComponentType].editableProperties != "undefined") {
                for (var i = 0; i < prx.types[actionComponentType].editableProperties.length; i++) {
                  if (prx.types[actionComponentType].editableProperties[i].name == action.propertyId) {
                    _property = prx.types[actionComponentType].editableProperties[i].changeProperty;
                    _property.type = prx.types[actionComponentType].editableProperties[i].type;
                    break;
                  }
                }
              }

              if (typeof _property == "undefined") {
                if (typeof actionComponentType != 'undefined' && typeof prx.types[actionComponentType].interactions != "undefined") {
                  for (var i = 0; i < prx.types[actionComponentType].interactions.length; i++) {
                    if (prx.types[actionComponentType].interactions[i].name == action.propertyId) {
                      _property = {
                        property: 'action'
                      };
                      break;
                    }
                  }
                }
              }

              if (typeof _property == "undefined") {
                if (typeof actionComponentType != 'undefined' && typeof prx.types[actionComponentType].propertyGroups != "undefined") {
                  for (var i = 0; i < prx.types[actionComponentType].propertyGroups.length; i++) {
                    for (var j = 0; j < prx.types[actionComponentType].propertyGroups[i].properties.length; j++) {
                      for (var k = 0; k < prx.types[actionComponentType].propertyGroups[i].properties[j].length; k++) {
                        if (prx.types[actionComponentType].propertyGroups[i].properties[j][k].name == action.propertyId) {
                          _property = prx.types[actionComponentType].propertyGroups[i].properties[j][k].changeProperty;
                          _property.type = prx.types[actionComponentType].propertyGroups[i].properties[j][k].type;
                          break;
                        }
                      }
                    }
                  }
                }
              }

              break;

            case "dynamic-property":
              if (typeof actionComponentType != 'undefined' && typeof prx.types[actionComponentType].dynamicProperties != "undefined") {
                if (typeof prx.types[actionComponentType].dynamicProperties.editableProperties != "undefined") {
                  for (var i = 0; i < prx.types[actionComponentType].dynamicProperties.editableProperties.length; i++) {
                    if (prx.types[actionComponentType].dynamicProperties.editableProperties[i].name == action.propertyId) {
                      _property = prx.types[actionComponentType].dynamicProperties.editableProperties[i].changeProperty;
                      _property.type = prx.types[actionComponentType].dynamicProperties.editableProperties[i].type;
                      break;
                    }
                  }
                }

                if (typeof _property == "undefined") {
                  if (typeof actionComponentType != 'undefined' && typeof prx.types[actionComponentType].dynamicProperties.interactions != "undefined") {
                    for (var i = 0; i < prx.types[actionComponentType].dynamicProperties.interactions.length; i++) {
                      if (prx.types[actionComponentType].dynamicProperties.interactions[i].name == action.propertyId) {
                        _property = {
                          property: 'action'
                        };
                        break;
                      }
                    }
                  }
                }

                if (typeof _property == "undefined") {
                  if (typeof actionComponentType != 'undefined' && typeof prx.types[actionComponentType].dynamicProperties.propertyGroups != "undefined") {
                    for (var i = 0; i < prx.types[actionComponentType].dynamicProperties.propertyGroups.length; i++) {
                      for (var j = 0; j < prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties.length; j++) {
                        for (var k = 0; k < prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties[j].length; k++) {
                          if (prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties[j][k].name == action.propertyId) {
                            _property = prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties[j][k].changeProperty;
                            _property.type = prx.types[actionComponentType].dynamicProperties.propertyGroups[i].properties[j][k].type;
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }

              break;
          }

          break;
      }

      break;
  }

  var _tempSelector = "";

  if (typeof _property != "undefined") {
    if (typeof _property.property != "undefined") {
      if (_property.property != "triggerdata") {
        switch (propertyType) {
          case "component-property":
            if (action.itemId.indexOf('group') !== -1) {
              var groupdata = prx.groups.getGroupData(action.targetId.replace('-group-', ' .group-'));

              if (!groupdata) {
                prx.actions.callback(action);
                return;
              }

              var itemdimentions = prx.groups.getItemDimentions(groupdata);
              var groupDimentions = prx.toolbox.calculateBox(itemdimentions, groupdata.group.rotation, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
            } else {
              _tempSelector = $(action.targetId + ' ' + _property.selector + ', ' + action.targetId + _property.selector);
            }

            break;

          case "dynamic-property":
            _tempSelector = $(action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"] ' + _property.selector + ', ' + action.targetId + ' [data-dynamic-property-index="' + action.itemIndex + '"]' + _property.selector);
            break;
        }
      }

      switch (_property.property) {
        case "text":
          action.newvalue = _tempSelector.text();
          break;

        case "input-value":
        case "textarea-value":
          action.newvalue = _tempSelector.val();
          break;

        case "width":
          if (action.itemId !== undefined && action.itemId.indexOf('group') !== -1) {
            action.newvalue = groupDimentions.width;
          } else {
            action.newvalue = Math.round(prx.items.getRealDimsAndPosFromDom('#' + _tempSelector.attr('id')).width);
          }

          break;

        case "height":
          if (action.itemId !== undefined && action.itemId.indexOf('group') !== -1) {
            action.newvalue = groupDimentions.height;
          } else {
            action.newvalue = Math.round(prx.items.getRealDimsAndPosFromDom('#' + _tempSelector.attr('id')).height);
          }

          break;

        case "left":
          if (action.itemId !== undefined && action.itemId.indexOf('group') !== -1) {
            action.newvalue = groupDimentions.left;
          } else {
            action.newvalue = Math.round(prx.items.getRealDimsAndPosFromDom('#' + _tempSelector.attr('id')).left);
          }

          break;

        case "top":
          if (action.itemId !== undefined && action.itemId.indexOf('group') !== -1) {
            action.newvalue = groupDimentions.top;
          } else {
            action.newvalue = Math.round(prx.items.getRealDimsAndPosFromDom('#' + _tempSelector.attr('id')).top);
          }

          break;

        case "triggerdata":
          if (typeof prx.variables._triggerData[action.bindTo] != "undefined") {
            if (typeof prx.variables._triggerData[action.bindTo][action.type] != "undefined") {
              if (typeof prx.variables._triggerData[action.bindTo][action.type][action.callbackvariable] != "undefined") {
                action.newvalue = prx.variables._triggerData[action.bindTo][action.type][action.callbackvariable];
              } else {
                action.newvalue = null;
              }
            } else {
              action.newvalue = null;
            }
          }

          break;

        default:
          break;
      }
    }
  }

  setTimeout(function () {
    if (_typeof(action.variableName != "undefined")) {
      if (typeof prx.variables._variables[action.variableName] != "undefined") {
        prx.variables._variables[action.variableName].value = prx.variables.recursivelyEvaluate(action.newvalue, action.variableName, true);
      }
    }

    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.changeState = function (action, type) {
  var pageId = action.pageId;

  if (pageId == -1) {
    pageId = action.containerid.split('-')[1];
  }

  ;
  var tostateid = action.stateId === undefined ? '' : action.stateId;
  var reverse = false;
  var targetId = action.targetId;
  var startfromtime = 0;
  prx.actions.setInterrupted(action);

  switch (type) {
    case "pages":
      var index = prx.stc.screens.getIndexFromId(pageId);
      var objToChange = '#p-' + pageId;
      break;

    case "templates":
      var pageindex = prx.stc.screens.getIndexFromId(pageId);

      if (pageindex == -1) {
        prx.actions.callback(action);
        return false;
      }

      var index = prx.stc.templates.getIndexFromId(prxy.pages[pageindex].states[0].template.id);
      targetId = '#p-' + pageId + '-t' + +prxy.pages[pageindex].states[0].template.id;
      var objToChange = targetId;
      break;

    case "symbols":
      var symbolid = -1;
      var itemId = action.itemId;

      if (itemId == -1 || (itemId.match(/box/g) || []).length > 1 || itemId.indexOf('t') > -1) {
        // t = template
        var split = action.targetId.split('box-');
        itemId = 'box-' + split[split.length - 1];
      }

      if (typeof prx.allItems[itemId] == "undefined") {
        prx.actions.callback(action);
        return false;
      }

      for (var stateid in prx.allItems[itemId].states) {
        if (prx.allItems[itemId].states.hasOwnProperty(stateid)) {
          // im only using this to get the symbol id. so any state (the first the item is in) will do because the symbol id will be the same in all
          var data = JSON.parse(prxy[prx.allItems[itemId].containertype][prx.allItems[itemId].containerindex].states[prx.allItems[itemId].states[stateid].stateindex].data);
          symbolid = data[prx.allItems[itemId].states[stateid].itemindex].symbolid;
          break;
        }
      }

      if (symbolid == -1) {
        prx.actions.callback(action);
        return false;
      }

      var index = prx.stc.containers.getIndexFromId(symbolid); // inner symbols don't work, anw seem to have this ready?
      // var objToChange = '#p-' + pageId + '-' + action.itemId

      var objToChange = action.targetId;
      break;
  }

  if (index == -1 || $(objToChange).length == 0) {
    prx.actions.callback(action);
    return false;
  }
  /* in case this is a ghost-component
   if (typeof($(objToChange).attr('data-state-id')) != "undefined") {
   var fromstateid = $(objToChange).attr('data-state-id');
   } else {
   var fromstateid = prxy[type][index].states[0].id;
   }
   */
  // wont try to animate anything, afou anw ghost-components are now empty


  if ($(objToChange).hasClass('ghost-component')) {
    prx.actions.callback(action);
    return false;
  }

  var fromstateid = $(objToChange).attr('data-state-id');
  var actiontype = tostateid;

  switch (tostateid) {
    case "previously-visited-state":
      if (prx.navigation._gobackstack.states[objToChange] !== undefined && prx.navigation._gobackstack.states[objToChange].length > 0) {
        tostateid = prx.navigation._gobackstack.states[objToChange][prx.navigation._gobackstack.states[objToChange].length - 1];

        prx.navigation._gobackstack.states[objToChange].pop();

        break;
      } else {
        prx.actions.callback(action);
        return false;
      }

    case "previous-state":
      for (var i = 0; i < prxy[type][index].states.length; i++) {
        if (prxy[type][index].states[i].id == fromstateid) {
          if (i == 0) {
            if (typeof action.goToLast !== 'undefined' && action.goToLast == true) {
              tostateid = prxy[type][index].states[prxy[type][index].states.length - 1].id;
            } else {
              prx.actions.callback(action);
              return false;
            }
          } else {
            tostateid = prxy[type][index].states[i - 1].id;
          }

          break;
        }
      }

      break;

    case "next-state":
      for (var i = 0; i < prxy[type][index].states.length; i++) {
        if (prxy[type][index].states[i].id == fromstateid) {
          if (i == prxy[type][index].states.length - 1) {
            if (typeof action.goToFirst !== 'undefined' && action.goToFirst == true) {
              tostateid = prxy[type][index].states[0].id;
            } else {
              prx.actions.callback(action);
              return false;
            }
          } else {
            tostateid = prxy[type][index].states[i + 1].id;
          }

          break;
        }
      }

      break;

    case "first-state":
      tostateid = prxy[type][index].states[0].id;
      break;

    case "last-state":
      tostateid = prxy[type][index].states[prxy[type][index].states.length - 1].id;
      break;

    default:
      // make sure stateid exists
      if (prx.utils.isGuid(tostateid)) {
        if (prx.stc.helper.getStateIndexFromId(tostateid, type, index) == -1) {
          prx.actions.callback(action);
          return false;
        }

        break;
      } else {
        // check if tostateid matches the name of a state - for change container state with state names as variables
        for (var i = 0; i < prxy[type][index].states.length; i++) {
          if (prxy[type][index].states[i].title.toLowerCase() == tostateid.toString().toLowerCase()) {
            tostateid = prxy[type][index].states[i].id;
            break;
          }
        } // if i didn't find it


        if (!prx.utils.isGuid(tostateid)) {
          // check again - maybe my prx.utils.isGuid algorithm is wrong again
          if (prx.stc.helper.getStateIndexFromId(tostateid, type, index) == -1) {
            prx.actions.callback(action);
            return false;
          }
        }
      }

  }

  if (tostateid == fromstateid) {
    if (typeof $(objToChange).attr('data-previous-state-id') != "undefined") {
      fromstateid = $(objToChange).attr('data-previous-state-id');
    }
  }

  if (typeof prx.navigation._gobackstack.states[objToChange] === 'undefined') {
    prx.navigation._gobackstack.states[objToChange] = [];
  }

  if (actiontype != "previously-visited-state") {
    prx.navigation._gobackstack.states[objToChange].push(fromstateid);
  }

  if (prx.navigation._gobackstack.states[objToChange].length >= 50) {
    prx.navigation._gobackstack.states[objToChange].shift();
  }

  $(objToChange).trigger('stateleave');
  $(objToChange).attr('data-state-id', tostateid).attr('data-previous-state-id', fromstateid);

  if (prxy[type][index].vr) {
    var changes = prx.states.getChangesBetweenStates(fromstateid, tostateid, type, index);
    prx.vr.changeState(objToChange.substr(1), prxy[type][index].id, tostateid, changes);
    return;
  } else {
    $('.prx-page-active').find('a-scene').each(function () {
      this.exitVR();
    });
  } // reverse


  reverse = prx.states.isReverse(type, index, fromstateid, tostateid);

  if (reverse && typeof prx.states._timelines[objToChange + '-' + tostateid + ':' + fromstateid] != "undefined" && prx.states._timelines[objToChange + '-' + tostateid + ':' + fromstateid].length > 0) {
    // get time from last, perhaps still animating
    var time = prx.states._timelines[objToChange + '-' + tostateid + ':' + fromstateid][prx.states._timelines[objToChange + '-' + tostateid + ':' + fromstateid].length - 1].time();

    var totaltime = prx.states._timelines[objToChange + '-' + tostateid + ':' + fromstateid][0].totalDuration();

    startfromtime = totaltime - time;
  }

  var changes = prx.states.getChangesBetweenStates(fromstateid, tostateid, type, index);

  if (typeof action._timelineToUse != "undefined") {
    var timeline = action._timelineToUse;
  } else {
    var timeline = new TimelineMax(Object.assign({}, prx.basicGreensockOptions, {
      paused: true
    }));
  }

  if (changes != false) {
    /*compatibility to maintain copy*/
    var _canvastype = type;
    var _index = index;
    var transitioninfo = prx.states.getChangesTransitionInfo(changes, fromstateid, tostateid, _canvastype, _index, reverse);
    var common = transitioninfo.common;
    var allchanges = transitioninfo.allchanges;
    var minstart = transitioninfo.minstart / 1000; // greensock needs minstart etc in seconds not milliseconds

    var maxendtotal = transitioninfo.maxendtotal / 1000; // greensock needs minstart etc in seconds not milliseconds
    // clean up: only one rerender per item and remove non-transitionables from the end if rerender

    var rerenderMap = {}; // first pass for rerenders

    changes = changes.map(function (elem, index) {
      if (typeof elem.changes !== "undefined") {
        var filteredChanges = {};
        var filteredChangesOrder = [];

        for (var j = 0; j < elem.changes_order.length; j++) {
          var key = elem.changes_order[j];

          if (elem.changes.hasOwnProperty(key)) {
            if (allchanges[elem.id + '-' + key].rerender === true) {
              if (!rerenderMap.hasOwnProperty(elem.id) || typeof rerenderMap[elem.id] === 'undefined') {
                rerenderMap[elem.id] = allchanges[elem.id + '-' + key].delay;
                filteredChanges[key] = elem.changes[key];
                filteredChangesOrder.push(elem.changes_order[j]);
              }
            } else {
              filteredChanges[key] = elem.changes[key];
              filteredChangesOrder.push(elem.changes_order[j]);
            }
          }
        }

        elem.changes = filteredChanges;
        elem.changes_order = filteredChangesOrder;
      }

      return elem;
    }); // second pass for non-transitionable that happen at the same time the rerender does

    changes = changes.map(function (elem, index) {
      if (typeof elem.changes !== "undefined") {
        var filteredChanges = {};
        var filteredChangesOrder = [];

        for (var j = 0; j < elem.changes_order.length; j++) {
          var key = elem.changes_order[j];

          if (elem.changes.hasOwnProperty(key)) {
            if (allchanges[elem.id + '-' + key].rerender === false && allchanges[elem.id + '-' + key].transitionable === false && rerenderMap.hasOwnProperty(elem.id) && !isNaN(parseInt(rerenderMap[elem.id])) && allchanges[elem.id + '-' + key].delay === rerenderMap[elem.id]) {
              // non-transitionable at the same delay where the item will be rerendered anyway
              continue;
            } else if (allchanges[elem.id + '-' + key].rerender === false && allchanges[elem.id + '-' + key].transitionable === true && allchanges[elem.id + '-' + key].duration === 0 && rerenderMap.hasOwnProperty(elem.id) && allchanges[elem.id + '-' + key].delay === rerenderMap[elem.id]) {
              // non-rerender transitionable with duration 0 at the same delay where the item will be rerendered anyway
              continue;
            } else {
              filteredChanges[key] = elem.changes[key];
              filteredChangesOrder.push(elem.changes_order[j]);
            }
          }
        }

        elem.changes = filteredChanges;
        elem.changes_order = filteredChangesOrder;
      }

      return elem;
    });

    for (var i = 0; i < changes.length; i++) {
      switch (changes[i].type) {
        case "new-group":
        case "removed-group":
        case "changed-group":
          var groupdata = prx.groups.getGroupData(targetId + ' .' + changes[i].id);

          if (groupdata) {
            groupdata.targetids.forEach(function (target) {
              prx.items.updateTransformIfHidden(target, fromstateid);
            });
          }

          if (changes[i].visible !== undefined) prx.visibility.set(targetId + ' .' + changes[i].id, 'visible', changes[i].visible[1] === false ? false : true);
          if (changes[i].opacity !== undefined) prx.visibility.set(targetId + ' .' + changes[i].id, 'opacity', changes[i].opacity[1]);
          break;

        case "new-component":
          (function (i) {
            prx.items.rerender(changes[i].item, targetId.slice(1), pageId);
            timeline.add(function () {
              if (!this.timeline.data.reversing) {
                //prx.items.rerender(changes[i].item, targetId.slice(1), pageId)
                $(targetId + '-' + changes[i].id).removeClass('ghost-component');
              } else {
                $(targetId + '-' + changes[i].id).addClass('ghost-component');
              }
            }, 0);
          })(i);

          break;

        case "removed-component":
          var delay = common['changed-' + changes[i].id].delay / 1000;
          var duration = common['changed-' + changes[i].id].duration / 1000;

          (function (i, delay, duration) {
            timeline.add(function () {
              if (!this.timeline.data.reversing) {
                $(targetId + '-' + changes[i].id).addClass('ghost-component');
                prx.vr.disable(targetId);
              } else {
                $(targetId + '-' + changes[i].id).removeClass('ghost-component');
              }
            }, delay + duration);
          })(i, delay, duration);

          break;

        case "changed-component":
        case "container-properties":
        case "page-properties":
        case "template-properties":
          break;

        case "reordered-components":
          (function (i) {
            timeline.add(function () {
              var t = this; //setTimeout(function(){

              if (!t.timeline.data.reversing) {
                components = changes[i].new_order.split(',');
              } else {
                components = changes[i].old_order.split(',');
              }

              for (var j = 1; j < components.length; j++) {
                $(targetId + '-' + components[j]).insertAfter(targetId + '-' + components[j - 1]);
                prx.items.helper.refreshHtmlComponent(components[j], targetId.slice(1), tostateid);
              } //}, maxendtotal*1000);
              //}, 0)

            }, maxendtotal);
          })(i);

          break;

        default:
          break;
      }

      if (typeof changes[i].changes != "undefined") {
        //for (var key in changes[i].changes) {
        for (var j = 0; j < changes[i].changes_order.length; j++) {
          var key = changes[i].changes_order[j];

          if (changes[i].changes.hasOwnProperty(key)) {
            var elm = changes[i].changes[key];

            if (typeof allchanges[changes[i].id + '-' + key] != "undefined") {
              var delay = allchanges[changes[i].id + '-' + key].delay;
              var duration = allchanges[changes[i].id + '-' + key].duration;

              switch (changes[i].id) {
                case "current-page":
                  var targetId2 = targetId;
                  break;

                case "current-container":
                  // if I will be making changes to the container it will be updating the same div which controls the scroll position.
                  // because of force3D, greensock also updates the transform and if it doesn't know the original scroll position (transform) the
                  // scroll position flickers or is lost. So we need to read from dom and update the transform through greensock so that when we
                  // animate whatever (eg container height) through greensock, when greensock also adds transform, it adds the correct
                  // one and the scroll position of the container is not affected
                  var dims = prx.items.getRealDimsAndPosFromDom(targetId + '-scroll');
                  prx.items.updateTransform($(targetId + '-scroll'), {}, dims.left, dims.top, dims.rotation, 1);
                  var targetId2 = targetId + '-scroll';
                  break;

                default:
                  var targetId2 = targetId + '-' + changes[i].id;
                  break;
              }

              var action2 = {
                _timelineToUse: timeline,
                pageId: pageId,
                itemId: changes[i].id,
                targetId: targetId2,
                containerid: targetId.slice(1),
                componentType: changes[i].componentType,
                propertyId: key,
                newvalue: elm[1],
                oldvalue: elm[0],
                // at the moment needed just for interactions
                duration: duration,
                delay: delay,
                animationEasing: allchanges[changes[i].id + '-' + key].easing
              };

              if (Array.isArray(elm) === false && typeof elm.opacity !== 'undefined' && typeof elm.visible !== 'undefined') {
                action2.newvalue = {
                  opacity: elm.opacity[1],
                  visible: elm.visible[1]
                };
                action2.oldvalue = {
                  opacity: elm.opacity[0],
                  visible: elm.visible[0]
                };
              }

              if (typeof allchanges[changes[i].id + '-' + key].rotationDirection != "undefined") {
                action2.rotationDirection = allchanges[changes[i].id + '-' + key].rotationDirection;
              }

              if (key.indexOf('dynamicProperties-') > -1) {
                var split = key.split('-');
                action2.propertyType = 'dynamic-property';
                action2.itemIndex = split[1];
                action2.propertyId = split[split.length - 1]; // should always be 2
              }

              timeline = prx.actionsLibrary.changeProperty(action2);
            }
          }
        }
      }
    }
  } else {
    // annam v5.2.24 moving all below to run even if changes == false. so that state enter etc still trigger.
    var minstart = 0;
    var maxendtotal = 1.3 / 1000; // greensock needs minstart etc in seconds not milliseconds
  }

  timeline.add(function () {
    if (!this.timeline.data.reversing) {
      $(objToChange).trigger('stateenter');
    }
  }, 0.001);
  timeline.add(function () {
    if (typeof this.timeline.data.suppressEvents == "undefined" || !this.timeline.data.suppressEvents) {
      if (!this.timeline.data.reversing) {
        $(objToChange).trigger('statetransitionstart');
      } else {
        prx.actions.reloadGroupActions(type, index, tostateid, pageId, objToChange);
        $(objToChange).trigger('statetransitionend');
      }
    }
  }, minstart);

  if (minstart == 0) {
    minstart = 0.0012; // so that it is after stateenter
  } //VO 01/08/2017 moved function into eventCallback because if we have interaction on transition end, callbacks on the original interaction that triggered the state change were not triggered

  /*timeline.add(function () {
    }, maxendtotal + 0.001);*/


  timeline.data = {
    reversing: false
  };

  if (typeof prx.states._timelines[objToChange + '-' + fromstateid + ':' + tostateid] == "undefined") {
    prx.states._timelines[objToChange + '-' + fromstateid + ':' + tostateid] = [];
  } else if (prx.states._timelines[objToChange + '-' + fromstateid + ':' + tostateid].length > 1) {
    for (var i = prx.states._timelines[objToChange + '-' + fromstateid + ':' + tostateid].length - 1; i > 0; i--) {
      prx.states._timelines[objToChange + '-' + fromstateid + ':' + tostateid][i].kill();

      prx.states._timelines[objToChange + '-' + fromstateid + ':' + tostateid].splice(i, 1);
    }
  }

  timeline.eventCallback("onComplete", function () {
    if (typeof this.data.suppressEvents == "undefined" || !this.data.suppressEvents) {
      // even though reversing is not used anymore
      if (!this.data.reversing) {
        prx.actions.reloadGroupActions(type, index, tostateid, pageId, objToChange);
        $(objToChange).trigger('statetransitionend');
      } else {
        $(objToChange).trigger('statetransitionstart');
      }
    }

    if (typeof this.data.suppressEvents == "undefined" || !this.data.suppressEvents) {
      if ($(targetId).attr('data-state-id') == tostateid) {
        prx.actions.callback(action);
      }
    }

    prx.scrollable.refresh(targetId);
    prx.vr.refresh(targetId);
    prx.bodymovinAnimation.loadBodymovinPageAnimations(targetId);
  });

  prx.states._timelines[objToChange + '-' + fromstateid + ':' + tostateid].push(timeline); // automatically stop previous state transitions
  // always do this not only on reverse
  //if(reverse && startfromtime != 0) {


  var action2 = {
    pageId: pageId,
    itemId: type == "pages" ? 'page-transition' : itemId,
    targetId: objToChange,
    stateTransition: "all-transitions",
    endTransition: false
  };
  prx.actionsLibrary.stopStateTransition(action2); //}

  if (typeof action._timelineToUse == "undefined") {
    // i believe seek was there so that i can correctly reverse my timeline using native gs reverse(), which im not using anymore
    // http://greensock.com/forums/topic/8161-tweenfromto-doesnt-trigger-tweens-that-have-not-yet-been-reached-by-normal-play/?hl=seek#entry31395
    // but i dont want to risk removing it.
    //timeline.seek(timeline.totalDuration()).play(startfromtime);
    timeline.play(startfromtime);
  } else {
    return timeline;
  } //} else {
  //prx.actions.callback(action);
  //}

};

prx.actionsLibrary.stopStateTransition = function (action) {
  if (action.pageId == -1) {
    action.pageId = action.containerid.split('-')[1];
  }

  var type = 'pages';
  var index = prx.stc.screens.getIndexFromId(action.pageId);

  switch (action.itemId) {
    case "page-transition":
      type = 'pages';
      index = prx.stc.screens.getIndexFromId(action.pageId);
      action.targetId = '#p-' + action.pageId;
      break;

    /*
     case "-1":
     // i think we never get here.
     return false;
     break;
     */

    default:
      var itemid = action.itemId;

      if (itemid == -1) {
        var split = action.containerid.split('-');
        itemid = 'box-' + split[split.length - 1];
      }

      var symbolid = prx.items.recursivelyFindItemSymbolId(itemid, type, index); // need to allow for current template, container
      //var symbolid = prx.items.recursivelyFindItemSymbolId(action.targetId, type, index) // need to allow for current template, container

      if (!symbolid) {
        prx.actions.callback(action);
        return false;
      }

      type = 'symbols';
      index = prx.stc.containers.getIndexFromId(symbolid);
      break;
  }

  var stateids = [];

  if (action.stateTransition == "all-transitions") {
    for (var i = 0; i < prxy[type][index].states.length; i++) {
      stateids.push(prxy[type][index].states[i].id);
    }
  } else {
    stateids.push(action.stateTransition);
  }

  for (var transition in prx.states._timelines) {
    if (prx.states._timelines.hasOwnProperty(transition)) {
      for (var i = 0; i < stateids.length; i++) {
        if (transition.indexOf(action.targetId) > -1 && transition.indexOf(stateids[i]) > -1) {
          for (var j = 0; j < prx.states._timelines[transition].length; j++) {
            if (action.endTransition) {
              if (typeof prx.states._timelines[transition][j].data == "undefined") {
                prx.states._timelines[transition][j].data = {};
              }

              prx.states._timelines[transition][j].data.suppressEvents = true;

              prx.states._timelines[transition][j].seek(prx.states._timelines[transition][j].totalDuration(), false);
            }

            prx.states._timelines[transition][j].pause();
          }
        }
      }
    }
  }

  prx.actions.callback(action);
};

prx.actionsLibrary.externalLink = function (action) {
  var url = '';

  switch (action.actionId) {
    // case "open-external-url":
    //     if (prx.inProtoApp) {
    //         url += 'targetblank://';
    //     }
    //     url += prx.utils.escapeHTML(action.url);
    // break;
    case "open-external-url":
      if (prx.inProtoApp) {
        url += 'targetblank://';
      }

      url += prx.utils.escapeHTML(action.url);

      if (!prx.utils.isValidUrl(prx.utils.escapeHTML(action.url))) {
        if (!prx.utils.isFaceTimeUrl(prx.utils.escapeHTML(action.url))) {
          if (prx.inProtoApp) {
            url = 'targetblank://about:blank';
          } else {
            url = "about:blank";
          }
        }
      }

      break;

    case "send-email":
      url += 'mailto:' + prx.utils.escapeHTML(action.email) + '?subject=' + encodeURIComponent(prx.utils.escapeHTML(action.emailSubject)) + '&body=' + encodeURIComponent(prx.utils.escapeHTML(action.emailBody));
      break;

    case "make-phone-call":
      url += 'tel:' + prx.utils.escapeHTML(action.phone);
      break;

    case "send-sms":
      url += 'sms:' + prx.utils.escapeHTML(action.phone);
      break;

    default:
      break;
  }

  $('<a href="' + url + '" target="_blank" rel="nofollow noopener" id="temp-for-external-link"></a>').appendTo('body')[0].click(); // needs [0] to trigger native click?

  $('#temp-for-external-link').remove();
  prx.actions.callback(action);
};

prx.actionsLibrary.playVideo = function (action) {
  setTimeout(function () {
    try {
      //HTML5
      if ($(action.targetId).hasClass("html5")) {
        $(action.targetId + ' video').get(0).play();
      } //Youtube
      else if ($(action.targetId).hasClass("youtube")) {
          //Youtube
          var name = (action.targetId + '-youtube').substring(1);

          try {
            prx.youtube._players[name].playVideo();
          } catch (e) {}
        } else {
          //Vimeo
          var name = (action.targetId + '-vimeo').substring(1);

          try {
            prx.vimeo._players[name].play();
          } catch (e) {}
        }
    } catch (e) {}

    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.pauseVideo = function (action) {
  setTimeout(function () {
    try {
      //HTML5
      if ($(action.targetId).hasClass("html5")) {
        $(action.targetId + ' video').get(0).pause();
      } //Youtube
      else if ($(action.targetId).hasClass("youtube")) {
          //Youtube
          var name = (action.targetId + '-youtube').substring(1);

          try {
            prx.youtube._players[name].pauseVideo();
          } catch (e) {}
        } else {
          //Vimeo
          try {
            var player2 = $f($(action.targetId).attr('id') + '-vimeo');
            player2.api("pause");
          } catch (e) {}
        }
    } catch (e) {}

    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.stopVideo = function (action) {
  setTimeout(function () {
    try {
      //HTML5
      if ($(action.targetId).hasClass("html5")) {
        $(action.targetId + ' video').get(0).pause();
        $(action.targetId + ' video').get(0).currentTime = 0;
      } //Youtube
      else if ($(action.targetId).hasClass("youtube")) {
          //Youtube
          var name = (action.targetId + '-youtube').substring(1);

          try {
            prx.youtube._players[name].seekTo(0);

            prx.youtube._players[name].pauseVideo();
          } catch (e) {}
        } else {
          //Vimeo
          try {
            var player2 = $f($(action.targetId).attr('id') + '-vimeo');
            player2.api("unload");
          } catch (e) {}
        }
    } catch (e) {}

    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.playAudio = function (action) {
  if (action.actionId == 'play-audio' && action.sourceId == 'library') {
    setTimeout(function () {
      try {
        var audio = $('#quick-audios').find('#' + action.sound.name.replace(/\s+/g, '-'));

        if (audio.length > 0) {
          audio.get(0).pause();
          audio.get(0).currentTime = 0;
          audio.get(0).play();
        }

        prx.actions.callback(action);
      } catch (e) {}
    }, action.delay);
  } else {
    setTimeout(function () {
      try {
        $(action.targetId + ' audio').get(0).play();
        prx.actions.callback(action);
      } catch (e) {}
    }, action.delay);
  }
};

prx.actionsLibrary.volumeAudio = function (action) {
  var newvolume = action.newvalue;
  var audio = $(action.targetId).find('audio').get(0);
  if (newvolume < 0) newvolume = 0;else if (newvolume > 100) newvolume = 100;
  if (typeof audio != 'undefined' && typeof audio['volume'] != 'undefined') audio.volume = parseFloat(newvolume / 100);
};

prx.actionsLibrary.volumeVideo = function (action) {
  var newvolume = action.newvalue;
  if (newvolume < 0) newvolume = 0;else if (newvolume > 100) newvolume = 100;
  setTimeout(function () {
    try {
      //HTML5
      if ($(action.targetId).hasClass("html5")) {
        var video = $(action.targetId).find('video').get(0);
        video.volume = parseFloat(newvolume / 100);
      } //Youtube
      else if ($(action.targetId).hasClass("youtube")) {
          //Youtube
          var name = (action.targetId + '-youtube').substring(1);

          try {
            prx.youtube._players[name].setVolume(newvolume);
          } catch (e) {}
        } else {
          //Vimeo
          try {
            var player2 = $f($(action.targetId).attr('id') + '-vimeo');
            player2.api("setVolume", parseFloat(newvolume / 100));
          } catch (e) {}
        }
    } catch (e) {}

    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.getComponentItemTypeFromDom = function (actionTargetId) {
  if (typeof actionTargetId != 'undefined') {
    return $(actionTargetId).attr('data-component-type');
  }

  return;
};

prx.actionsLibrary.playVectorAnimation = function (action) {
  setTimeout(function () {
    try {
      var animeElement = $(action.targetId).find('.bodymovin-player');
      var animeName = animeElement.attr('data-name');
      var animeAutoplay = animeElement.attr('data-autoplay');
      var animeLoop = animeElement.attr('data-loop');
      var animeSpeed = animeElement.attr('data-speed');
      prx.bodymovinAnimation.playbackConsole({
        playbackType: 'play',
        target: {
          search: false,
          dataName: animeName
        },
        loop: animeLoop,
        autoplay: animeAutoplay,
        rewindIfLastFrame: true,
        speed: animeSpeed,
        onCompleteEvent: function onCompleteEvent() {
          $(action.targetId).trigger('vectoranimationend');
        }
      });
    } catch (e) {}

    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.pauseVectorAnimation = function (action) {
  setTimeout(function () {
    try {
      var animeElement = $(action.targetId).find('.bodymovin-player');
      var animeName = animeElement.attr('data-name');
      var animeAutoplay = animeElement.attr('data-autoplay');
      var animeLoop = animeElement.attr('data-loop');
      prx.bodymovinAnimation.playbackConsole({
        playbackType: 'pause',
        target: {
          search: false,
          dataName: animeName
        },
        loop: animeLoop,
        autoplay: animeAutoplay
      });
    } catch (e) {}

    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.stopVectorAnimation = function (action) {
  setTimeout(function () {
    try {
      var animeElement = $(action.targetId).find('.bodymovin-player');
      var animeName = animeElement.attr('data-name');
      var animeAutoplay = animeElement.attr('data-autoplay');
      var animeLoop = animeElement.attr('data-loop');
      prx.bodymovinAnimation.playbackConsole({
        playbackType: 'stop',
        target: {
          search: false,
          dataName: animeName
        },
        loop: animeLoop,
        autoplay: animeAutoplay
      });
    } catch (e) {}

    prx.actions.callback(action);
  }, action.delay);
};

prx.actionsLibrary.changeCursor = function (action) {
  var cursor;
  $('#custom-cursor-css').remove();

  if (action.cursor === 'auto') {
    $('body').removeClass('custom-cursor');
  } else {
    if (action.cursor !== 'custom-cursor') {
      cursor = action.cursor;
    } else {
      cursor = "url(".concat(prx.componentsHelper.getProp(action.customCursor, 'asset'), "), default");
    }

    var css = "<style id=\"custom-cursor-css\">body.custom-cursor, body.custom-cursor * { cursor: ".concat(cursor, "!important; }</style>");
    $('head').append(css);
    $('body').addClass('custom-cursor');
  }

  prx.actions.callback(action);
}; // GS - this does not cover all conditions but a regex was preferred over DOMParser for performance reasons
// example fail: <strong>Words are </strong> normal in the middle <strong>but end bold</strong> will make everything bold
// example fail: <span style="font-weight: 700">Words start bold</span> <span style="font-style: italic"> but end regular italic</span> will make everything bold


prx.actionsLibrary.replaceTextValue = function (oldValue, newValue) {
  var result = newValue;
  var searchString = oldValue;
  var match;
  var possibleTagNames = [];
  var possibleStartTags = [];
  var possibleEndTags = [];
  var matchedStartTags = [];
  var matchedEndTags = []; // find all tags in the beginning of the old value

  while ((match = /^(<[^\/>][^>]*>)/g.exec(searchString)) !== null) {
    possibleStartTags.push(match[0]);
    var nameMatch = match[0].match(/^<([a-z]+)/gi);
    possibleTagNames.push(nameMatch[0].slice(1));
    searchString = searchString.slice(match[0].length);
  } // find all ending tags of the old value


  searchString = oldValue;

  while ((match = /(<\/[^>]+>)$/g.exec(searchString)) !== null) {
    possibleEndTags.push(match[0]);
    searchString = searchString.slice(0, -match[0].length);
  } // match start and end tags


  for (var i = 0; i < possibleStartTags.length; i++) {
    if (possibleEndTags[i] && possibleEndTags[i].toLowerCase() === '</' + possibleTagNames[i].toLowerCase() + '>') {
      matchedStartTags.push(possibleStartTags[i]);
      matchedEndTags.push(possibleEndTags[i]);
    }
  } // maintain matched tags in new value


  matchedStartTags = matchedStartTags.reverse();

  for (var i = 0; i < matchedStartTags.length; i++) {
    result = matchedStartTags[i] + result + matchedEndTags[i];
  }

  return result;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_actions.js":
/*!******************************************************!*\
  !*** ./sass/player-engine/js/components/_actions.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.actions = {};
prx.actions._actionTypes = ['actions', 'actionbarUpCaretActions', 'actionbarActionOverflowActions', 'flipswitchActionsOnActive', 'flipswitchActionsOnDeactive', 'checkboxActionsOnActive', 'checkboxActionsOnDeactive', 'ios7NavbarActionsTitle', 'ios7NavbarActionsLeftBtn', 'ios7NavbarActionsRightBtn', 'actions1', 'actions2', 'actions3'];
prx.actions._actions = {};
prx.actions._isRunning = {};
prx.actions._loopCounter = {};
prx.actions._hammerDirToString = [];
prx.actions._hammerDirToString[1] = "none";
prx.actions._hammerDirToString[2] = "left";
prx.actions._hammerDirToString[4] = "right";
prx.actions._hammerDirToString[8] = "up";
prx.actions._hammerDirToString[16] = "down";
prx.actions.scrolltos = [];
prx.actions.justtapped = false;
prx.actions.ACTION_RUNNING = 1;
prx.actions.ACTION_NOT_RUNNING = 0;
prx.actions.ACTION_INTERRUPTED = -1;

prx.actions.build = function (action, clicktotap, bindevents) {
  if (typeof action.enabled != "undefined" && !action.enabled) {
    return false;
  }

  if (typeof bindevents == "undefined") {
    bindevents = true;
  }

  if (typeof action.live == "undefined" || action.clb_disabled !== undefined && action.clb_disabled === true) {
    action.live = false;
  }

  if (typeof action.delay == "undefined") {
    action.delay = 0;
  }

  if (action.type == 'inputkeyup' && typeof action.charCode == 'undefined') {
    action.charCode = '-1';
  }

  if (action.charCode !== undefined && typeof action.charCode === "string") {
    action.charCode = action.charCode.split(',');
  }

  if (action.type == "containerpageenter" && typeof action.namespace == "undefined") {
    action.namespace = ".page" + action.eventItemIndex[0] + '-' + action.eventItemIndex[1];
  }

  if (action.type == "containerscrollto") {
    action.namespace = ".scrollto" + action.scrolltodirection + '-' + action.scrolltovalue;
    var length = prx.actions.scrolltos.filter(function (item) {
      return item.dir == action.scrolltodirection && item.val == action.scrolltovalue && item.namespace == action.namespace && item.item == action.bindTo;
    });

    if (length.length == 0) {
      prx.actions.scrolltos.push({
        dir: action.scrolltodirection,
        val: action.scrolltovalue,
        namespace: action.namespace,
        item: action.bindTo
      });
    }
  }

  if (typeof action.namespace == "undefined") {
    action.namespace = "";
  } //v5, to be able to unbind
  // v5.2.8 not used anymore because im binding to specific actions eg protoio-actions , proto.io-actionbarUpCaretActions etc
  //action.namespace += '.protoio';


  if (typeof action.guid == "undefined") {
    action.guid = prx.utils.getGuid();
  }

  if (typeof action.callback == "undefined") {
    action.callback = false;
  } //if (typeof(clicktotap)=='undefined') {
  // v5.0.13 always changing click to tap because we removed jquery mobile vclick event (further down, on('vclick') stop propagation
  // and click did not work on mobile devices
  // vr pattern it used to be that clicktotap was always true, now we are reverting back to optional so that we can use click in vr
  // clicktotap = true;
  //}


  if (typeof action.targetId == "undefined") {
    if (typeof action.pageId != "undefined") {
      action.targetId = '#p-' + action.pageId + '-' + action.itemId;
    } else {
      // v4.2.1 for targetting current container
      // action.targetId = '#'+action.containerid+'-'+action.itemId;
      action.targetId = action.itemId == -1 ? '#' + action.containerid : '#' + action.containerid + '-' + action.itemId;

      if (action.itemId == -1) {
        var split = action.containerid.split('-');
        action.itemId = 'box-' + split[split.length - 1];
      }
    }
  }

  if (typeof action.pageId != "undefined") {
    if (action.pageId == -1) {
      //action.guid = action.containerid + '-' + action.guid;
      // ANNAM v3.0.5 when in current template, "t1" exists in both the containerid and item id. i need to remove it from one of them.
      //if(typeof(action.itemId) != "undefined" && action.itemId.split('-').shift() == action.containerid.split('-').pop()) {
      //AP FIX ON 2013/10/04 POST v5
      if (typeof action.itemId != "undefined" && action.itemId != null && typeof action.containerid != "undefined" && action.containerid != null && action.itemId.split('-').shift() == action.containerid.split('-').pop()) {
        action.targetId = '#' + action.containerid + '-' + action.itemId.split('-').slice(1).join('-');
      } else {
        // v4.2.1 for targetting current container
        // action.targetId = '#'+action.containerid+'-'+action.itemId
        action.targetId = action.itemId == -1 ? '#' + action.containerid : '#' + action.containerid + '-' + action.itemId;
        /*
         annam v5.10.2. im removing this because if the action is then reparsed due to changeproperty:action and targetid recreated, the wrong targetid will be recreated due to itemid not being -1 anymore.
         i'm doing this and praying to god that it won't affect anything else.
         since the itemid is created only if both pageid and itemid is -1, i'm assuming that there's already functionality in place, where needed, to substitude -1 with the actual item id, in cases that pageid is defined but item id is not.?
         im sure this will come back introducing other issues :(
         v5.10.4 turns out this was caused by caching prx.states._changes in getChangesBetweenStates.
         */

        if (action.itemId == -1) {
          var split = action.containerid.split('-');
          action.itemId = 'box-' + split[split.length - 1];
        }
      } //action.pageId = action.containerid.split('-')[1]; ****** REMOVED BY AP AND ANNA ON 11Sep2013 to fix currentcontainer

    } else if (action.pageId == -2) {
      /**/
      //annam v5.10.2.1 same as above. if i change pageid here then the targetid will not be recalculated the next time buildaction is called, keeping the old target id (eg another page). moving this to movewholescreen.
      // v5.10.4 turns out this was caused by caching prx.states._changes in getChangesBetweenStates.
      // at the moment only for move screen
      // current page in targetid
      var split = action.targetId.split(/[-\[]/);
      action.targetId = '#p-' + split[1];
      action.pageId = split[1]; //action.guid = action.containerid + '-' + action.guid;

      /**/
    } else {
      if (typeof action.allowOverwriteTargetId == "undefined" || action.allowOverwriteTargetId) {
        if (typeof action.itemId != "undefined") {
          action.targetId = '#p-' + action.pageId + '-' + action.itemId;
        } else {
          action.targetId = '#p-' + action.pageId;
        }
      }
    }
  } else {} // actions that don't allow pageId are very specific:
  // go to snap carousel page, scroll scrollable container, stop event propagation, unload overlayed screen, and alert.
  // if called from inside a container, there is a chance that they are duplicates. changing action guid to ensure uniqueness
  // JIRA PROTOIO-9
  //action.guid = action.containerid + '-' + action.guid;
  // v4.2.4.1 fix for guids - always append containerid if in container ?
  //if(action.containerid != '') {
  // v5 fix because if multiple containers in same page, same guid when using conatinerid
  //action.guid = action.containerid + '-' + action.guid;
  // v5.7.5 fix becausse if two same targets - ie action within container targetting a component outside the container, and container attached twice
  // caused problems in callbacks. so now im adding everything on the guid :P
  //v5.10.4 i dont think its really needed just making sure the string doesnt get appended every time
  //action.guid = action.bindTo + '-target-' + action.targetId + '-guid-' + action.guid;


  var guidsplit = action.guid.split('-guid-');
  action.guid = action.bindTo + '-target-' + action.targetId + '-guid-' + guidsplit[guidsplit.length - 1];
  prx.actions.addHighlight(action); //}

  if (action.animation == "") {
    action.animation = 'none';
  }
  /* FIX FOR SCROLLER CLICK ACTION */


  if (clicktotap === undefined) clicktotap = true;

  if (clicktotap) {
    if (action.type == 'click') {
      action.type = 'tap';
    }
  } // Mappings for Hammer


  if (action.type == 'taphold' || action.type == 'forcetouch') {
    action.type = 'press';
  }

  var actiontype = action.type;

  if (action.type == 'statekeydown') {
    actiontype = 'keydown';
  }

  if (bindevents) {
    var runEvent = function runEvent(event, a) {
      // annam v6.0.32
      // warning!! hammer now triggers each action twice due to default domEvents: true (we set domEvents: true via a patenta in jquery.hammer)
      // the only thing that prevents actins from actually triggering is this prx.actions._isRunning which is true the second time the event is triggered,
      // which seems to work even if action duration is 0.
      // to prevent this we can set domEvents: false however this will stop stopPropagation from working
      // annam 6.0.36 i am removing both propagating and domEvents: true because of problems caused by events triggering twice (on listeners in components' afterDisplay, where _isRunning
      // precaution does not fix problem. this no longer applies.
      if (prx.actions._isRunning[action.guid] == prx.actions.ACTION_RUNNING) {
        return false;
      }

      _activePage = prx.navigation._activepage; //if click/tap, check that we are not scrolling a container

      if (action.type == "click" || action.type == "tap") {
        var target = event.target;

        while (target != null && target.nodeType == 1) {
          if (typeof prx.scrollable._scrollables[target.id] != "undefined") {
            if (prx.scrollable._scrollables[target.id].moved) {
              return false;
            } else {
              break;
            }
          }

          target = target.parentNode;
        }
      } //Editor-318


      if (action.type == 'statekeydown') {
        var activeStateIds = [];
        $('#' + _activePage + ', #' + _activePage + ' [data-state-id]').not(".ghost-component").each(function () {
          activeStateIds.push($(this).attr('id') + '-' + $(this).attr('data-state-id'));
        });
      } //if keydown, check charcode, page and that we are not typing in an input/textarea


      if (action.type != 'keydown' && action.type != 'inputkeyup' && action.type != 'statekeydown' || action.type == 'keydown' && (action.charCode.indexOf(event.which + '') > -1 || action.charCode.indexOf(event.which) > -1) && _activePage == action.bindPageId && !/textarea|select|input/i.test(event.target.nodeName) || action.type == 'statekeydown' && (action.charCode.indexOf(event.which + '') > -1 || action.charCode.indexOf(event.which) > -1) && _activePage == action.bindPageId && activeStateIds.indexOf(action.containerid + '-' + action.bindStateId) > -1 && !/textarea|select|input/i.test(event.target.nodeName) || action.type == 'inputkeyup' && (action.charCode.indexOf(event.which + '') > -1 || action.charCode.indexOf(event.which) > -1 || action.charCode.indexOf('-1') > -1)) {
        prx.actions._actions[action.guid].call(this, event, a);

        if (action.type == 'keydown' || action.type == 'contextmenu' || action.type == 'statekeydown') {
          return false;
        }
      }
    };

    if (action.live) {
      $('body').off(actiontype + action.namespace + '.' + action.guid.replace(/-/g, '').replace('#', ''), action.bindTo);
      $('body').hammer().on(actiontype + action.namespace + '.' + action.guid.replace(/-/g, '').replace('#', '') + '.' + action.bindTo.replace(/\W/g, ''), action.bindTo, runEvent);
      prx.actions.hammer('body', action.type);
    } else {
      // patenda for gaze interactions (vr) because a-frame has a bug and does not recognise mouse-leave and mouse-enter when they are applied to the element
      // with jquery,
      if (actiontype == "gazemouseenter" || actiontype == "gazemouseleave" || actiontype == "gazeclick") {
        actiontype = actiontype.replace("gaze", "");
        var $el = $(action.bindTo).addClass('interaction-' + actiontype);
        $el[0].addEventListener(actiontype, runEvent); // do not apply namespace a-frame also doesn't like this for mouse-leave and mouse-enter
      } else {
        $(action.bindTo).hammer().addClass('interaction-' + actiontype).on(actiontype + action.namespace, runEvent);
        prx.actions.hammer(action.bindTo, action.type, action.namespace);
      }
    }
  }

  prx.actions._isRunning[action.guid] = prx.actions.ACTION_NOT_RUNNING;
  prx.actions.generate(action);

  if (action.callback) {
    if (action.loop) {
      action.callbackAction.loop = action.loop;

      if (typeof action.loopGUID != "undefined") {
        action.callbackAction.loopGUID = action.loopGUID;
      } else {
        action.callbackAction.loopGUID = action.guid;
      }
    } // when we end the action, i need to end all previous callbacked actions


    if (typeof action.previousActions == "undefined") {
      action.previousActions = [];
    }

    if (typeof action.containerid != "undefined") {
      action.callbackAction.containerid = action.containerid;
    } // annam v5.7.3 we use this in build action and perhaps other places


    if (typeof action.targetId != "undefined") {// annam v5.7.8 added recursivelyAddActionInfo so we are now sending the CORRECT targetId for each action.
      // action.callbackAction.targetId = action.targetId;
    }

    if (typeof action.bindTo != "undefined") {
      action.callbackAction.bindTo = action.bindTo;
    } // needed for set variable - triggerdata in callbacks


    if (typeof action.type != "undefined") {
      action.callbackAction.type = action.type;
    }

    action.callbackAction.previousActions = action.previousActions;
    action.callbackAction.previousActions.push(action.guid); //needed for set variable from callback event
    //action.callbackAction.bindTo = action.bindTo;
    //action.callbackAction.type = action.type;

    prx.actions.build(action.callbackAction, undefined, false);
  }

  return true;
};

prx.actions.generate = function (action) {
  prx.actions._actions[action.guid] = function (event, a) {
    if (typeof event != "undefined") {
      //check if one of its parent or itself is a ghost
      var isGhost = function isGhost(eventTarget) {
        if ($(eventTarget).hasClass('ghost-component')) {
          return true;
        }

        return $(eventTarget).parents('.ghost-component').length > 0;
      };

      if (isGhost(event.target)) {
        //dont want to run actions on ghosts
        return false;
      }

      ; // live events :( stop propagation doesn't work
      // eg if stateenter on container, stateenter will also trigger on parent page
      // chrome only

      if (event.type == 'stateenter' || event.type == 'stateleave' || event.type == 'statetransitionstart' || event.type == 'statetransitionend') {
        if (event.target != event.currentTarget) {
          return false;
        } else if (event.type == 'statetransitionstart' || event.type == 'statetransitionend') {
          // only trigger statetransitionstart/end for if specific statetransition
          if (action.states !== undefined && action.states.indexOf($(event.target).attr('data-previous-state-id') + ':') == -1) {
            return false;
          }
        }
      } // containers can be nested. we need to check that events are only triggered on their initial target


      if (['containerpageenter', 'containerpagechange', 'containerscroll', 'containerscrollto', 'containerscrollend'].indexOf(event.type) > -1 && event.target != event.currentTarget) return false; // in case you are trying to fix this, it doesnt work.
      // mouseout events are triggered for nested dom elements. eg if i have a container with a rectangle inside and a "mouseout" event on the container, if i mouseout on the rectangle inside, the event will be triggered.
      // the same will happen for a non-nested component with complex dom that doesnt cover the whole component area - as soon as i mouseout a nested dom element, the mouseout event will be triggered on the parent.
      // with the implementation below, the above problem is fixed. BUT. if i have a container with a rectangle and a mouseout on the container, and the rectangle is fullwidth on the container, this will prevent
      // the event from triggering on the container completely, because when we detect the wanted mouseout event, the target of the event is the rectangle, not the container :(
      // GS - added this chunk to handle nested dom elements firing mouseover and mouseout events

      if (['mouseover', 'mouseout'].indexOf(event.type) > -1) {
        var targetElement = event.relatedTarget;

        if (targetElement == this) {
          return;
        } else if (targetElement) {
          var parentNode = targetElement.parentNode;

          while (parentNode) {
            if (parentNode == this) {
              return;
            }

            parentNode = parentNode.parentNode;
          }
        }
      } // if(['mouseover', 'mouseout'].indexOf(event.type) > -1) {
      // 	   if($(event.target).parents('.box').first().add(event.target).first().attr('id') != $(event.currentTarget).parents('.box').add(event.currentTarget).first().attr('id'))
      //         return false;
      // }

    } // i am just starting the function now. if it has a loop, initialize iterations
    // action.loopIterations is only defined in the top-level action.
    // also if already running, i dont want to reset the loop iterations.


    if (prx.actions._isRunning[action.guid] === prx.actions.ACTION_NOT_RUNNING && action.loop && typeof action.loopIterations != "undefined") {
      prx.actions._loopCounter[action.guid] = action.loopIterations - 1;
    }

    prx.actions._isRunning[action.guid] = prx.actions.ACTION_RUNNING;

    if (typeof event != "undefined") {
      // for flashActions change to stopImmediatePropagation
      // if we remove this i will have an issue with components that have one interaction on outer .box and one inside eg crouton
      //event.preventDefault();
      //event.stopImmediatePropagation();
      if (action.type !== 'change') {
        //dont stop propagation on change since there might be an event on activation or deactivation as well
        // stop propagation never worked with hammer. I can't use stop propagation anyway because we have events on components in containers, that when tapped (or whatever), i want to trigger actions (eg tap) on the parent container as well.
        // event.stopPropagation();
        // instead, for cases that i want to stop propagation (nested actions on items, eg on material chips which have an interaction on whole item and then on a div inside), i do the following:
        // if I get an interaction triggered on the parent box (the namespace of my action doesnt have protoio-actionsX, but I detect that the action has originated from a nested actions div, i return, and dont trigger.
        if ($(event.target).parents().andSelf().filter('.actions-actions1, .actions-actions2').length > 0) {
          if (!/\.protoio-actions[1-2]/.test(action.namespace)) {
            prx.actions.setNotRunning(action);
            return false;
          }
        }
      } // fix for "tap" on ios propagation v3.2.10
      // it needs to call "preventDefault()", which also prevents labels for being clicked in tabbars, list items etc
      // i am assuming that when clicked, the action is always to make the element active.
      // it is very fortunate that in the case of checkbox and onoff components, the action is binded on "change" and so this is not called, as the action may be either on or off.
      // v5.0.18 for checkboxes its fortunate, but for checkboxlist this is an issue!
      // im leaving it as is for now because the actionIsRunning prevents the second run of the function for most functions so this
      // shouldnt occur in many instances, at the moment only known issue with alert;
      // http://stackoverflow.com/questions/24998194/hammer-js-click-triggered-on-dom-elements-behind-tapped-after-tap-action


      if (action.type == "tap") {
        if (typeof event.gesture != "undefined" && typeof event.gesture.srcEvent != "undefined" && typeof event.gesture.srcEvent.preventDefault != "undefined") {
          if ($(event.gesture.srcEvent.target).prop('tagName').toLowerCase() != "input" && $(event.gesture.srcEvent.target).prop('tagName').toLowerCase() != "textarea") {
            // if we prevent default on an input the mobile keyboard doesnt open
            event.gesture.srcEvent.preventDefault();
            prx.helper.blurInputs();
          } // needed for flashActions
          //event.gesture.srcEvent.stopImmediatePropagation()
          //for some reason this is only needed on mobiles now?
          //WTF? This is COMPLETELY wrong!!!! If there are two interactions on the same tap event , the checkbox will be toggled on and off again!!!!
          //WTF? I don't know if this is used anymore since we changed the action.type for checkboxes to be "changed" and not on tap (if tap)
          //It could still be  used for list items checkboxes


          if (event.gesture.srcEvent.type == "touchend") {
            $(this).find('input[type=radio]').not(':visible').not(':disabled').prop('checked', true).trigger('change.custom-change-event');
            $(this).find('input[type=checkbox]').not(':visible').not(':disabled').each(function () {
              if ($(this).is(':checked')) {
                $(this).prop('checked', false).trigger('change.custom-change-event');
              } else {
                $(this).prop('checked', true).trigger('change.custom-change-event');
              }
            });
          }
        } // v5.6.3 https://protoio.atlassian.net/browse/EDITOR-128


        $(this).parents('.type-symbol').children().each(function () {
          if (typeof prx.scrollable._scrollables[this.id] != "undefined") {
            prx.scrollable._scrollables[this.id]._end({
              type: 'touchend',
              target: this,
              preventDefault: function preventDefault() {}
            });
          }
        });
      }

      if (["pan", "panleft", "panright", "panup", "pandown", "panend"].indexOf(event.type) > -1 && typeof event.gesture != "undefined") {
        if (typeof prx.variables._triggerData[action.bindTo] == "undefined") {
          prx.variables._triggerData[action.bindTo] = {};
        }

        if (typeof prx.variables._triggerData[action.bindTo][event.type] == "undefined") {
          prx.variables._triggerData[action.bindTo][event.type] = {};
        }

        prx.variables._triggerData[action.bindTo][event.type].distancex = event.gesture.deltaX;
        prx.variables._triggerData[action.bindTo][event.type].distancey = event.gesture.deltaY;
        prx.variables._triggerData[action.bindTo][event.type].direction = prx.actions._hammerDirToString[event.gesture.direction];
      }

      if (["pinch", "pinchin", "pinchout"].indexOf(event.type) > -1 && typeof event.gesture != "undefined") {
        if (typeof prx.variables._triggerData[action.bindTo] == "undefined") {
          prx.variables._triggerData[action.bindTo] = {};
        }

        if (typeof prx.variables._triggerData[action.bindTo][event.type] == "undefined") {
          prx.variables._triggerData[action.bindTo][event.type] = {};
        }

        prx.variables._triggerData[action.bindTo][event.type].scale = event.gesture.scale;
      }
    }

    switch (action.actionId) {
      case "alert":
        alert(action.bindTo);
        prx.actions.callback(action);
        break;

      case "alert-variable":
        alert(prx.variables.read(action.variable));
        prx.actions.callback(action);
        break;

      case "stoppropagation":
        prx.actions.callback(action);
        break;

      case "go-to-page":
        prx.actionsLibrary.goToPage(action);
        break;

      case "load-page":
        prx.actionsLibrary.loadPage(action);
        break;

      case "unload-page":
        prx.actionsLibrary.unloadPage(action);
        break;

      case "hide-item":
        prx.actionsLibrary.hideItem(action); // event.stopPropagation was commented out here - i dont know why :/

        break;

      case "show-item":
        prx.actionsLibrary.showItem(action);
        break;

      case "show-hide-item":
        prx.actionsLibrary.showHide(action);
        break;

      case "toggle-item":
        prx.actionsLibrary.toggleItem(action);
        break;

      case "restart-gif":
        prx.actionsLibrary.restartGif(action);
        break;

      case "bring-front":
        setTimeout(function () {
          action.targetId = action.targetId.replace('-group-', ' .group-');
          var stateId = $(action.targetId).parents('[data-state-id]').first().attr('data-state-id');
          $(action.targetId).appendTo($(action.targetId).parent());

          if (typeof stateId != 'undefined') {
            prx.items.helper.refreshHtmlComponent(action.itemId, action.containerid, stateId);
          }

          prx.groups.redrawGroupActionDiv(action.targetId);
          prx.actions.callback(action);
        }, action.delay);
        break;

      case "send-back":
        setTimeout(function () {
          action.targetId = action.targetId.replace('-group-', ' .group-');
          var stateId = $(action.targetId).parents('[data-state-id]').first().attr('data-state-id');
          $(action.targetId).prependTo($(action.targetId).parent());

          if (typeof stateId != 'undefined') {
            prx.items.helper.refreshHtmlComponent(action.itemId, action.containerid, stateId);
          }

          prx.groups.redrawGroupActionDiv(action.targetId);
          prx.actions.callback(action);
        }, action.delay);
        break;

      case "highlight-navbar-item":
        setTimeout(function () {
          if (action.itemIndex == "-1") {
            $(action.targetId + ' input[type=radio]').prop('checked', false).trigger('change.custom-change-event');
          } else {
            var _itemid = action.targetId + '-radio-' + action.itemIndex;

            $('[id=' + _itemid.substr(1) + ']').prop('checked', true).trigger('change.custom-change-event');
          }

          prx.actions.callback(action);
        }, action.delay);
        break;

      case "highlight-list-item":
        setTimeout(function () {
          if (action.itemIndex.toString() === "-1") {
            $(action.targetId + ' input[type=radio], ' + action.targetId + ' input[type=checkbox]').prop('checked', false).trigger('change.custom-change-event');
          } else {
            $(action.targetId + ' input[type=radio], ' + action.targetId + ' input[type=checkbox]').each(function (index, elem) {
              var isChecked = Array.isArray(action.itemIndex) && action.itemIndex.indexOf(index) > -1 || action.itemIndex.toString() === index.toString();
              $(elem).prop('checked', isChecked).trigger('change.custom-change-event');
            });
          }

          prx.actions.callback(action);
        }, action.delay);
        break;

      case "highlight-pagecontroller-item":
        setTimeout(function () {
          if (action.itemIndex == "-1") {
            $(action.targetId + ' input[type=radio]').prop('checked', false).trigger('change.custom-change-event');
          } else {
            $(action.targetId + ' input').eq(parseInt(action.itemIndex)).prop("checked", true).trigger('change.custom-change-event');
          }

          prx.actions.callback(action);
        }, action.delay);
        break;

      case "play-audio":
        prx.actionsLibrary.playAudio(action);
        break;

      case "pause-audio":
        setTimeout(function () {
          if ($(action.targetId + ' audio').length) {
            $(action.targetId + ' audio').get(0).pause();
          }

          prx.actions.callback(action);
        }, action.delay);
        break;

      case "stop-audio":
        setTimeout(function () {
          if ($(action.targetId + ' audio').length) {
            $(action.targetId + ' audio').get(0).pause();

            if ($(action.targetId + ' audio').get(0).readyState != 0) {
              $(action.targetId + ' audio').get(0).currentTime = 0;
            }
          }

          prx.actions.callback(action);
        }, action.delay);
        break;

      case "volume-audio":
        prx.actionsLibrary.volumeAudio(action);
        prx.actions.callback(action);
        break;

      case "play-video":
        prx.actionsLibrary.playVideo(action);
        break;

      case "pause-video":
        prx.actionsLibrary.pauseVideo(action);
        break;

      case "stop-video":
        prx.actionsLibrary.stopVideo(action);
        break;

      case "volume-video":
        prx.actionsLibrary.volumeVideo(action);
        break;

      case "go-to-carousel-page":
        prx.actionsLibrary.goToCarouselPage(action);
        break;

      case "scroll-scrollable-container":
        prx.actionsLibrary.scrollScrollableContainer(action);
        break;

      case "sync-pagecontroller-item":
        var _page = 0;

        if (typeof a != 'undefined') {
          if ($(action.bindTo).hasClass('scroll-vertical')) {
            _page = a.currentPage.pageY;
          } else {
            _page = a.currentPage.pageX;
          }
        }

        setTimeout(function () {
          $(action.targetId + ' input:eq(' + _page + ')').prop("checked", true).trigger('change.custom-change-event');
          prx.actions.callback(action);
        }, action.delay);
        break;

      case "fire-item-event":
        prx.actionsLibrary.fireItemsEvent(action);
        break;

      case "animate-item":
        prx.actionsLibrary.animateItem(action);
        break;

      case "end-loop":
        setTimeout(function () {
          /*
           var actionGuid = action.actionGuid;
           if(typeof(prx.actions._actions[actionGuid]) == "undefined") {
           //not found, actionGuid has containerid
           actionGuid = action.containerid + '-' + action.actionGuid;
           action.bindTo + '-target-' + action.targetId + '-' + action.guid;
           }*/
          for (var guid in prx.actions._loopCounter) {
            if (prx.actions._loopCounter.hasOwnProperty(guid)) {
              if (guid.indexOf(action.actionGuid) > -1) {
                var pageid = action.pageId;

                if (pageid == -1) {
                  pageid = action.containerid;
                } else {
                  pageid = 'p-' + pageid;
                }

                if (guid.indexOf('#' + pageid + '-') == 0 || guid.indexOf('#' + pageid + '[') == 0) {
                  prx.actions._loopCounter[guid] = 0;
                }
              }
            }
          } //prx.actions._loopCounter[actionGuid] = 0;


          prx.actions.callback(action);
        }, action.delay);
        break;

      case "change-property":
        prx.actionsLibrary.changeProperty(action);
        break;

      case "set-variable":
        prx.actionsLibrary.setVariable(action);
        break;

      case "move-screen":
        prx.actionsLibrary.moveScreen(action);
        break;

      case "change-screen-state":
        setTimeout(function () {
          prx.actionsLibrary.changeState(action, 'pages');
        }, action.delay);
        break;

      case "change-template-state":
        setTimeout(function () {
          prx.actionsLibrary.changeState(action, 'templates');
        }, action.delay);
        break;

      case "go-to-container-state": // remove after v5 launch

      case "change-container-state":
        setTimeout(function () {
          prx.actionsLibrary.changeState(action, 'symbols');
        }, action.delay);
        break;

      case "stop-state-transition":
        setTimeout(function () {
          prx.actionsLibrary.stopStateTransition(action);
        }, action.delay);
        break;

      case "open-external-url":
      case "send-email":
      case "make-phone-call":
      case "send-sms":
        setTimeout(function () {
          prx.actionsLibrary.externalLink(action);
        }, action.delay);
        break;

      case "focus-input-field":
        /**/
        setTimeout(function () {
          $(action.targetId + ' input, ' + action.targetId + ' textarea').trigger('click.fakefocus');
          prx["interface"].triggeriOSAppEvent('forceInputFocus', action.targetId.substr(1));
          prx.actions.callback(action);
        }, action.delay);
        /**/
        //
        // $(action.targetId + ' input, ' + action.targetId +  ' textarea').trigger('focus');

        break;

      case "play-vectoranimation":
        prx.actionsLibrary.playVectorAnimation(action);
        break;

      case "pause-vectoranimation":
        prx.actionsLibrary.pauseVectorAnimation(action);
        break;

      case "stop-vectoranimation":
        prx.actionsLibrary.stopVectorAnimation(action);
        break;

      case "change-cursor":
        prx.actionsLibrary.changeCursor(action);
        break;

      default:
        break;
    }
  };
};

prx.actions.callback = function (action) {
  if (action.callback) {
    if (action.callbackAction.clb_disabled !== undefined && action.callbackAction.clb_disabled === true) {
      //check for disabled interaction. In such case go to the next one
      prx.actions.callback(action.callbackAction);
    } else {
      prx.actions._actions[action.callbackAction.guid].call(this);
    }
  } else if (typeof action.loop != "undefined" && action.loop) {
    var loopGuid = typeof action.loopGUID != "undefined" ? action.loopGUID : action.guid;

    if (prx.actions._loopCounter[loopGuid] > 0) {
      prx.actions._loopCounter[loopGuid]--;

      prx.actions._actions[loopGuid].call();
    } else {
      prx.actions._isRunning[loopGuid] = prx.actions.ACTION_NOT_RUNNING;
    }
  } else {
    prx.actions.setNotRunning(action);
  }
};

prx.actions.setNotRunning = function (action) {
  if (typeof action.guid != "undefined") {
    prx.actions._isRunning[action.guid] = prx.actions.ACTION_NOT_RUNNING;

    if (typeof action.previousActions != "undefined") {
      for (var i = 0; i < action.previousActions.length; i++) {
        prx.actions._isRunning[action.previousActions[i]] = prx.actions.ACTION_NOT_RUNNING;
      }
    }
  }
};

prx.actions.setInterrupted = function (action) {
  if (typeof action.guid != "undefined") {
    prx.actions._isRunning[action.guid] = prx.actions.ACTION_INTERRUPTED;

    if (typeof action.previousActions != "undefined") {
      for (var i = 0; i < action.previousActions.length; i++) {
        prx.actions._isRunning[action.previousActions[i]] = prx.actions.ACTION_INTERRUPTED;
      }
    }
  }
};

prx.actions.hammer = function (bindTo, trigger) {
  // annam v6.0.32
  // warning!! hammer now triggers each action twice due to default domEvents: true (we set domEvents: true via a patenta in jquery.hammer)
  // the only thing that prevents actins from actually triggering is this prx.actions._isRunning which is true the second time the event is triggered,
  // which seems to work even if action duration is 0.
  // to prevent this we can set domEvents: false however this will stop stopPropagation from working
  // annam 6.0.36 i am removing both propagating and domEvents: true because of problems caused by events triggering twice (on listeners in components' afterDisplay, where _isRunning
  // precaution does not fix problem. this no longer applies.
  $(bindTo).each(function () {
    var hammer = $(this).data("hammer");

    if (typeof hammer == "undefined") {
      return false;
    } // if we dont use this there are all sorts of problems with input fields not focusing, labels not toggling etc
    // but if we use it swipe doesn't work on older mobiles
    //hammer.options.touchAction = 'auto';
    // generic2 fixes


    hammer.get('swipe').set({
      direction: Hammer.DIRECTION_ALL,
      velocity: -1,
      threshold: 20
    }); // by default only up down

    hammer.get('pan').set({
      direction: Hammer.DIRECTION_ALL
    }); // by default only up down

    hammer.get('tap').set({
      time: 500,
      threshold: 10
    }); // sometimes on "harder" tap (more time on mouse down) tap did not trigger. also some minimum movement should be allowed

    hammer.get('doubletap').set({
      posThreshold: 60,
      threshold: 2
    }); // allow slight movement between taps

    hammer.get('press').set({
      time: 500,
      threshold: 5
    }); // hammer update keep same setting as before
    // fix swipe to test for offsetdirection instead of direction
    // this solves the issue where if you pan but then keep your finger on screen at the same position for some time before releasing,
    // swipe is not triggered because direction (calculated every few ms) is NONE

    /*
     hammer.get('swipe').attrTest = function(input) {
     var direction = this.options.direction;
     var offsetdirection = input.offsetDirection;
     var velocity;
         //fix offsetdirection
     switch(offsetdirection) {
     case Hammer.DIRECTION_LEFT:
     offsetdirection = Hammer.DIRECTION_RIGHT;
     break;
     case Hammer.DIRECTION_RIGHT:
     offsetdirection = Hammer.DIRECTION_LEFT;
     break;
     case Hammer.DIRECTION_UP:
     offsetdirection = Hammer.DIRECTION_DOWN;
     break;
     case Hammer.DIRECTION_DOWN:
     offsetdirection = Hammer.DIRECTION_UP;
     break;
       }
       if (direction & (Hammer.DIRECTION_HORIZONTAL | Hammer.DIRECTION_VERTICAL)) {
     velocity = input.velocity;
     } else if (direction & Hammer.DIRECTION_HORIZONTAL) {
     velocity = input.velocityX;
     } else if (direction & Hammer.DIRECTION_VERTICAL) {
     velocity = input.velocityY;
     }
       return this._super.attrTest.call(this, input) &&
     direction & offsetdirection &&
     input.maxPointers == this.options.pointers && // annam patenta diki mou, also patentarismeno hammer.js to return this property :(
     input.distance > this.options.threshold && // to take threshold into account
     Math.abs(velocity) > this.options.velocity && input.eventType & Hammer.INPUT_END;
     };
       hammer.get('swipe').emit = function(input) {
     var offsetdirection = input.offsetDirection;
       //fix offsetdirection
     switch(offsetdirection) {
     case Hammer.DIRECTION_LEFT:
     offsetdirection = Hammer.DIRECTION_RIGHT;
     break;
     case Hammer.DIRECTION_RIGHT:
     offsetdirection = Hammer.DIRECTION_LEFT;
     break;
     case Hammer.DIRECTION_UP:
     offsetdirection = Hammer.DIRECTION_DOWN;
     break;
     case Hammer.DIRECTION_DOWN:
     offsetdirection = Hammer.DIRECTION_UP;
     break;
       }
       var direction = prx.actions._hammerDirToString[offsetdirection];
       if (direction != "none") {
     this.manager.emit(this.options.event + direction, input);
     }
       this.manager.emit(this.options.event, input);
     }
     /**/
    // much easier way to listen for touch

    if (trigger == 'touch' || trigger == 'release' || trigger == 'delayedtap') {
      // $(this).off("hammer.input").on("hammer.input", function(ev) {
      //
      //     debugger
      //
      //     if(ev.gesture.pointers.length == 1 && ev.gesture.isFirst) {
      //         $(this).trigger('touch')
      //     }
      // });
      // Touch recognizer
      var TouchRecognizer = function TouchRecognizer() {
        Hammer.AttrRecognizer.apply(this, arguments);
      };

      Hammer.inherit(TouchRecognizer, Hammer.AttrRecognizer, {
        defaults: {
          event: 'touch',
          pointers: 1
        },
        getTouchAction: function getTouchAction() {
          return [Hammer.TOUCH_ACTION_AUTO];
        },
        attrTest: function attrTest(input) {
          return input.isFirst && this._super.attrTest.call(this, input);
        },
        process: function process(input) {
          var isValid = this.attrTest(input);
          if (isValid) return Hammer.STATE_RECOGNIZED;
          return Hammer.STATE_FAILED;
        }
      });
      hammer.add(new TouchRecognizer()).recognizeWith([hammer.get('tap'), hammer.get('press'), hammer.get('swipe'), hammer.get('pan')]);
      prx.actions.disableFlashActionOnItemTouch(bindTo);
    } // release recognizer


    if (trigger == 'release' || trigger == 'delayedtap') {
      // delayed tap patenta because i need release to be defined in delayed tap to allow recogniseWith
      var ReleaseRecognizer = function ReleaseRecognizer() {
        Hammer.AttrRecognizer.apply(this, arguments);
      };

      Hammer.inherit(ReleaseRecognizer, Hammer.AttrRecognizer, {
        defaults: {
          event: 'release',
          pointers: 1
        },
        getTouchAction: function getTouchAction() {
          return [Hammer.TOUCH_ACTION_AUTO];
        },
        attrTest: function attrTest(input) {
          return this._super.attrTest.call(this, input) && input.isFinal;
        }
      });
      hammer.add(new ReleaseRecognizer()).recognizeWith([hammer.get('tap'), hammer.get('press'), hammer.get('swipe'), hammer.get('pan'), hammer.get('touch')]); //.recognizeWith(hammer.get('touch'));
    } // delayed tap
    // only add if it exists because it delays doubletap


    if (trigger == 'delayedtap') {
      hammer.add(new Hammer.Tap({
        event: 'delayedtap',
        time: 500,
        threshold: 10
      }) // sometimes on "harder" tap (more time on mouse down) tap did not trigger
      .recognizeWith(hammer.get('tap')).requireFailure(hammer.get('doubletap')));
      hammer.get('release').recognizeWith(hammer.get('delayedtap'));
      hammer.get('touch').recognizeWith(hammer.get('delayedtap'));
    } // pinch
    // only enable if it exists because it is blocking (something to do with scroll?)
    // using pinch enables touch-action: none and makes input fields non focusable and labels not toggling


    if (["pinch", "pinchin", "pinchout"].indexOf(trigger) > -1) {
      hammer.get('pinch').set({
        enable: true
      });
    } // custom tap which is also recognised with doubletap so that it is also triggered on doubletap.


    if (bindTo != "body" && trigger == "tap") {
      prx.actions.disableFlashActionOnItemTap(bindTo);
    }
  });
};

prx.actions.addHighlight = function (action) {
  // if is a callback, highlight has already definitely been added. also don't want to add the actionicon for callbacks because title shows undefined.
  if (action.previousActions !== undefined) return;
  var $highlight = $(action.highlightTarget).children('.action-highlight');
  var namespaceClass = action.namespace ? 'highlight-' + action.namespace.replace('.', '') : '';

  if ($highlight.length == 0) {
    $highlight = $('<div class="action-highlight ' + namespaceClass + '"></div>').appendTo(action.highlightTarget);
  } else {
    if (namespaceClass && !$highlight.hasClass(namespaceClass)) {
      $highlight.addClass(namespaceClass);
    }
  }

  $highlight.append('<span class="actionicon action-' + action.type + ' ' + namespaceClass + '" title="' + action.type + ': ' + prx.utils.escapeHTML(action.title) + '"></span>');
};

prx.actions.recursivelyAddInfo = function (action, bindTo, containerid, _target, highlightTarget) {
  var namespace = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;

  if (typeof namespace == "undefined") {
    namespace = '.protoio-actions';
  }

  action.namespace = (typeof action.namespace == "undefined" ? '' : action.namespace) + namespace;
  action.bindTo = bindTo;
  action.targetId = action.itemId == -1 ? '#' + _target.slice(0, -1) : '#' + _target + action.itemId;
  action.containerid = containerid;
  action.highlightTarget = highlightTarget;

  if (typeof action.delay == "undefined" || action.delay == 0) {
    action.delay = 10;
  }

  if (typeof action.callbackAction != "undefined") {
    action.callbackAction = prx.actions.recursivelyAddInfo(action.callbackAction, bindTo, containerid, _target, highlightTarget, namespace);
  }

  return action;
};

prx.actions.loadScreenActions = function (pageid) {
  //log('*** LOAD PAGE EVENTS');
  var _pageid = '';
  $.each(prxy.pages, function (i, page) {
    if (page.id == pageid) {
      _pageid = page.id;
      $('#p-' + pageid).unbind('pagebeforeshow').bind('pagebeforeshow', function (event, ui) {
        $(this).find('.type-applewatch-notification .notification-container.notificationType-long').each(function () {
          $(this).removeClass('notificationType-long').addClass('notificationType-short');
        });

        if (prx.allowstatusbar && prx.canvas._statusbars[page.id].statusbar == "1") {
          try {
            if (prx.export2html != '1') {
              //$('#statusbar').css('background-image', 'url('+prx.url['static']+'/images/player/'+prx.device+'/'+prx.canvas._statusbars[page.id].orientation+'/statusbar_'+prx.devices[prx.device][prx.canvas._statusbars[page.id].orientation][0]+'.png)');
              $('#statusbar').css({
                'background-image': prx.statusNavBar.buildStatusbar(prx.canvas._statusbars[page.id].orientation)
              });
            } else {
              prx.statusNavBar.buildStatusbarExported(prx.canvas._statusbars[page.id].orientation);
              /*if (prx.statusbarapplies=='1') {
               $('#statusbar').css('background-image', 'url(./images/statusbar_'+orientation+'.png)')
               } else {
               $('#statusbar').css('background-image', 'none');
               }
               */
            }

            $('#statusbar').css('height', prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[page.id].orientation] + 'px');
          } catch (err) {}

          ;
          $('#p-' + page.id).css('top', prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[page.id].orientation] + 'px');
        } else {
          // annam v5.0.22 why is this check necessary???
          //if (page.background == "none") {$('#statusbar').css('height','0px')}
          $('#statusbar').css('height', '0px'); // annam v5.8 removing jquery - removing this because it caused flicker on screen transitions - also it should be ok by default.
          //$('#p-'+page.id).css('top', '0px');
        } //if (prx.canvas._navigationbars[page.id].navigationbar == 'undefined') {prx.canvas._navigationbars[page.id].navigationbar="0"}


        if (prx.allownavigationbar && prx.canvas._navigationbars[page.id].navigationbar == "1") {
          try {
            if (prx.export2html != '1') {
              //$('#navigationbar').css('background-image', 'url('+prx.url['static']+'/images/player/'+prx.device+'/'+prx.canvas._navigationbars[page.id].orientation+'/navigationbar_'+prx.devices[prx.device][prx.canvas._navigationbars[page.id].orientation][0]+'.png)');
              $("#navigationbar").css({
                'background-image': prx.statusNavBar.buildNavbar(prx.canvas._navigationbars[page.id].orientation)
              });
            } else {
              prx.statusNavBar.buildNavbarExported(prx.canvas._navigationbars[page.id].orientation);
            }

            $('#navigationbar').css('height', prx.devices[prx.device]['navigationbarheight' + prx.canvas._navigationbars[page.id].orientation] + 'px');
            $('#navigationbar').css('top', prx.devices[prx.device][prx.canvas._navigationbars[page.id].orientation][1] - prx.devices[prx.device]['navigationbarheight' + prx.canvas._navigationbars[page.id].orientation] + 'px');
          } catch (err) {}

          ;
        } else {
          $('#navigationbar').css('height', '0px');
        }
      });
      $('#p-' + pageid).bind('pagebeforehide', function (event, ui) {
        // everything below has to do with overlay which is already rendered (this would occur if you tried a go to screen while another go to screen is already running);
        if ($('#p-' + pageid).hasClass('prx-page-transitioning')) {
          return false;
        }

        prx.overlay.render('#p-' + pageid); // fix move whole screen items with overlay (have been repositioned to appear that they have stayed in the same position

        var pageoffsetleft = $('#p-' + pageid).offset().left;
        var pageoffsettop = $('#p-' + pageid).offset().top;
        var statusbarspace = 0;

        if (prx.allowstatusbar && prx.canvas._statusbars[page.id].statusbar == "1") {
          pageoffsettop -= prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[page.id].orientation];
          statusbarspace = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[page.id].orientation];
        }

        if (pageoffsetleft != 0 || pageoffsettop != 0) {
          var moveditems = [];
          $('#p-' + pageid).find('[data-mpoverlay="1"]').each(function () {
            moveditems[this.id] = {
              y: $(this).offset().top - ($(this).parent().offset().top - $(this).parents('.prx-page').offset().top) - statusbarspace,
              x: $(this).offset().left - ($(this).parent().offset().left - $(this).parents('.prx-page').offset().left)
            };
          });
          $('#p-' + pageid).one('pagehide', function (event, ui) {
            $(this).find('[data-mpoverlay="1"]').each(function () {
              new TimelineMax().to('#' + this.id, 0, moveditems[this.id]);
            });
          });
        }
      });
      $('#p-' + pageid).bind('pagehide', function (event, ui) {
        $(this).find('.type-list input, .type-list-retina input, .type-android-listbasic input').not('.listitem-type-checkbox input').prop('checked', false);
        $('#overlay').empty().hide();
        $('#underlay').empty().hide();
        prx.vr.disable('#' + $(this).attr('id'));
      });
      $('#p-' + pageid).bind('pageshow', function (event, ui) {
        $('#p-' + page.id + ' .type-image .gif img').each(function () {
          var $this = $(this);
          $this.attr('src', $this.attr('src'));
        });
        $('#p-' + page.id + ' .box [data-linked-screen="' + page.id + '"]').find('input').prop('checked', true).trigger('change.custom-change-event');
      });
      prx.actions.parseScreenAction(i);

      for (var j = 0; j < page.states.length; j++) {
        prx.actions.parseScreenStateAction(i, j);
      }

      prx.actions.loadItemActions(page.states[0], 'page', pageid, '');
    }
  });
};

prx.actions.loadTemplateActions = function (template, pageid, containerid) {
  var index = prx.stc.templates.getIndexFromId(template.id);
  var stateindex = prx.stc.templates.getStateIndexFromId(template.stateid, index);

  if (index == -1 || stateindex == -1) {
    return false;
  }

  for (var j = 0; j < prx.templates[index].states.length; j++) {
    prx.actions.parseTemplateStateAction(index, j, pageid, containerid);
  }

  if (index > -1 && stateindex > -1) {
    prx.actions.loadItemActions(prx.templates[index].states[stateindex], 'template', pageid, template.id, containerid);
  }

  ;
};

prx.actions.loadContainerActions = function (symbolid, pageid, templateid, containerid) {
  //log('*** LOAD SYMBOL EVENTS');
  var _symbolid = '';
  $.each(prxy.symbols, function (i, symbol) {
    if (symbol.id == symbolid) {
      //_symbol= symbol.id;
      prx.actions.loadItemActions(symbol.states[0], 'symbol', pageid, templateid, containerid);
    }
  });
  return false;
};

prx.actions.loadItemActions = function (data, type, pageid, templateid, containerid) {
  //if (prx.save != "true") {
  //log('*** LOAD ITEM EVENTS');
  var _data = '';
  var _prefix = '';

  if (type == "page") {
    _data = JSON.parse(data.data);
    _prefix = 'p-' + pageid;
  }

  if (type == "template") {
    _data = JSON.parse(data.data);
    _prefix = 'p-' + pageid;

    if (typeof containerid != "undefined" && containerid != '') {
      _prefix += '-' + containerid;
    }
  }

  if (type == "symbol") {
    _data = JSON.parse(data.data); //_data = prx.stc.containers.getAllItems(data);

    _prefix = 'p-' + pageid + '-' + containerid + '-';
  }

  prx.actions.loadGroupActions(data, type, pageid, containerid);
  $.each(_data, function (i, item) {
    prx.actions.parseItemAction(item, _prefix, pageid, templateid);
  }); //}
};

prx.actions.reloadGroupActions = function (type, index, stateid, pageid, containerid) {
  containerid = containerid.replace('#', '');
  var typemapping = {
    pages: 'page',
    templates: 'template',
    symbols: 'symbol'
  };
  var jCanvas = prxy[type][index];

  for (var i = 0; i < jCanvas.states.length; i++) {
    if (jCanvas.states[i].id == stateid) {
      prx.actions.loadGroupActions(jCanvas.states[i], typemapping[type], pageid, containerid);
    }
  }
};

prx.actions.loadGroupActions = function (data, type, pageid, containerid) {
  var _data = '';
  var _prefix = '';
  var _groups = {};

  if (type == "page") {
    _prefix = 'p-' + pageid;
    _groups = data.groups;
  }

  if (type == "template") {
    _prefix = 'p-' + pageid;

    if (typeof containerid != "undefined" && containerid != '') {
      _prefix += '-' + containerid;
    }

    _groups = data.groups;
  }

  if (type == "symbol") {
    _prefix = containerid;
    _groups = data.groups;
  } // unbind all group actions here..
  // even though its not visible in the editor, when comparing changes between states the algorithm will detect differences in group actions
  // because we propagate group actions to the children on load. so no need to unbind here.


  $('#' + _prefix + ' > .group-action-prediv, #' + _prefix + '-scroll > .group-action-prediv').remove();

  for (var group in _groups) {
    if (_groups.hasOwnProperty(group)) {
      prx.actions.parseGroupAction(_groups[group], _prefix);
    }
  }
};

prx.actions.parseGroupAction = function (group, _prefix) {
  if (group.actions === undefined || group.actions.length == 0) return;
  var bindTo = _prefix + '-group-' + group.id + '-actions';
  var classes = group.parentgroups === undefined ? '' : group.parentgroups.map(function (gid) {
    return 'group-' + gid;
  }).join(' ');
  if (prx.visibility.get('#' + bindTo.replace('-group', ' .group').replace('-actions', ''), 'visible') === false) classes += ' hidden';
  var actiondiv = $('<div id="' + bindTo + '" class="group-action-prediv group-' + group.id + ' ' + classes + '"></div>');
  new TimelineMax().to(actiondiv, 0, {
    x: group.left,
    y: group.top,
    width: group.width,
    height: group.height,
    rotation: group.rotation
  });
  $('#' + _prefix + ' .group-' + group.id).first().before(actiondiv);
  group.actions.sort(function (a, b) {
    return a.sort - b.sort;
  });
  group.actions.forEach(function (action) {
    action = JSON.parse(JSON.stringify(action));
    action = prx.actions.recursivelyAddInfo(action, '#' + bindTo, _prefix, _prefix, '#' + bindTo, '.protoio-group-actions'); // not really bothering with targetid (passing prefix instead) because its recrated in build action

    prx.actions.build(action);
  });
};

prx.actions.parseItemAction = function (item, containerid, pageid, templateid, clicktotap) {
  var _target = ''; // no need to attach actions - on a "gotostate" interaction, we will need to rebind actions.

  if (typeof item._fromstateid != "undefined") {
    return true;
  }

  if (typeof containerid != 'undefined') {
    if (typeof templateid != "undefined" && templateid != '') {
      containerid = containerid + '-' + 't' + templateid;
    }

    _id = containerid + '-' + item.id;
    _target = containerid + '-';
  } else {
    _id = item.id;
    _target = '';
  }
  /* FIX FOR SCROLLER TAP ACTION */


  if (typeof item.actions != "undefined") {
    if (item.actions.length > 0) {
      item.actions.sort(function (a, b) {
        return a.sort - b.sort;
      });
    }
  }

  var removeHighlights = function removeHighlights(actionNamespace, highlightTarget) {
    var highlightNamespace = 'highlight-' + actionNamespace;
    var $highlight = $(highlightTarget + ' > .action-highlight');
    var othersExist = false;

    if ($highlight.length) {
      var classList = $highlight.attr('class').split(/\s+/);
      $.each(classList, function (index, className) {
        if (className !== 'action-highlight' && className !== highlightNamespace) {
          othersExist = true;
          return false;
        }
      });
    }

    if (othersExist) {
      $('.actionicon.' + highlightNamespace, $highlight).last().remove();
      $highlight.removeClass(highlightNamespace);
    } else {
      $highlight.remove();
    }
  };

  var bindActions = function bindActions(actions, clicktotap, bindTo, containerid, _target, highlightTarget, actionNamespace) {
    var clickTapToChange = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
    var isActionLive = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
    actions.sort(function (a, b) {
      return a.sort - b.sort;
    });
    $.each(actions, function (j, action) {
      if (clickTapToChange) {
        // tap/hold natively changed checkbox state without triggering the interaction. we needed to bind the event on the global change
        if (action.type == 'click' || action.type == 'tap') {
          action.type = 'change';
        }
      }

      action = prx.actions.recursivelyAddInfo(action, bindTo, containerid, _target, highlightTarget, '.' + actionNamespace);

      if (isActionLive) {
        action.live = true;
      }

      prx.actions.build(action, clicktotap);
    });
  };

  var processActionsList = function processActionsList(actions, clicktotap, bindTo, containerid, _target, highlightTarget, actionNamespace) {
    var bindOffReplace = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
    var clickTapToChange = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
    var isActionLive = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
    removeHighlights(actionNamespace, highlightTarget);

    if (bindOffReplace) {
      $('body').off('.' + bindTo.replace(/\W/g, ''));
    } else {
      $(bindTo).off('.' + actionNamespace).off('.flashactiontap');
    }

    if (actions.length > 0) {
      bindActions(actions, clicktotap, bindTo, containerid, _target, highlightTarget, actionNamespace, clickTapToChange, isActionLive);
    }
  };

  switch (item.type) {
    case 'basic_checkbox_list':
    case 'basic_checkbox_list_horizontal':
    case 'basic_checkbox_list_vertical':
    case 'ios7_listcheckbox':
      // ios7 lists have "listitems" in their item class name
      // basic chckbox lists have "buttons" in their item class names
      var listitem_class = 'listitems';

      if (item.type.indexOf('basic_checkbox_list') === 0) {
        listitem_class = 'buttons';
      }

      if (typeof item.listitems == "undefined") {
        item.listitems = [];
      }

      $.each(item.listitems, function (i, listitem) {
        if (typeof listitem == "undefined") {
          return true;
        }

        var highlightTarget = '#' + _id + '-' + listitem_class + '-' + i;

        if (typeof listitem.actions != "undefined") {
          var bindTo = '#' + _id + '-checkbox-' + i;
          var actionNamespace = 'protoio-actions';
          processActionsList(listitem.actions, clicktotap, bindTo, containerid, _target, highlightTarget, actionNamespace, false, true, false);
        }

        if (typeof listitem.actions1 != "undefined") {
          var _bindTo = '#' + _id + '-checkbox-' + i + ':checked';

          var _actionNamespace = 'protoio-actions-actions1';
          processActionsList(listitem.actions1, clicktotap, _bindTo, containerid, _target, highlightTarget, _actionNamespace, true, true, true);
        }

        if (typeof listitem.actions2 != "undefined") {
          var _bindTo2 = '#' + _id + '-checkbox-' + i + ':not(:checked)';

          var _actionNamespace2 = 'protoio-actions-actions2';
          processActionsList(listitem.actions2, clicktotap, _bindTo2, containerid, _target, highlightTarget, _actionNamespace2, true, true, true);
        }
      });
      break;

    case "flipswitch":
    case "flipswitch_retina":
    case "flipswitch_ios5":
    case "flipswitch_ios5_retina":
    case "android_onoffswitch":
    case "android_onoffswitch_kitkat":
    case "metro_onoff":
    case "ios7_switch":
    case "material_onoffswitch":
    case "basic_switch":
    case "basic_switch2":
      if (typeof item.flipswitchActionsOnActive == "undefined" && typeof item.actionsOnActive != "undefined") {
        item.flipswitchActionsOnActive = item.actionsOnActive;
      }

      if (typeof item.flipswitchActionsOnDeactive == "undefined" && typeof item.actionsOnDeactive != "undefined") {
        item.flipswitchActionsOnDeactive = item.actionsOnDeactive;
      }

      var highlightTarget = '#' + _id;

      if (typeof item.flipswitchActionsOnActive != "undefined") {
        var bindTo = '#' + _id + '-flipswitch:checked';
        var actionNamespace = 'protoio-flipswitchActionsOnActive';
        processActionsList(item.flipswitchActionsOnActive, clicktotap, bindTo, containerid, _target, highlightTarget, actionNamespace, true, true, true);
      }

      if (typeof item.flipswitchActionsOnDeactive != "undefined") {
        var _bindTo3 = '#' + _id + '-flipswitch:not(:checked)';

        var _actionNamespace3 = 'protoio-flipswitchActionsOnDeactive';
        processActionsList(item.flipswitchActionsOnDeactive, clicktotap, _bindTo3, containerid, _target, highlightTarget, _actionNamespace3, true, true, true);
      }

      if (typeof item.actions != "undefined") {
        var _bindTo4 = '#' + _id;

        var _actionNamespace4 = 'protoio-actions';
        processActionsList(item.actions, clicktotap, _bindTo4, containerid, _target, highlightTarget, _actionNamespace4, false, true, false);
      }

      break;
    // checkbox double actions

    case "checkbox":
    case "checkbox_retina":
    case "radiobutton":
    case "basic_checkbox":
    case "basic_radiobutton":
    case "radiobutton_retina":
    case "android_checkbox":
    case "android_radiobutton":
    case "metro_checkbox":
    case "metro_radiobutton":
    case "ios7_checkbox":
    case "material_checkbox":
    case "material_radiobutton":
    case "material_morphing_lines":
      if (typeof item.checkboxActionsOnActive != "undefined") {
        var _bindTo5 = '#' + _id + '-checkbox:checked';

        var _highlightTarget = '#' + _id;

        var _actionNamespace5 = 'protoio-checkboxActionsOnActive';
        processActionsList(item.checkboxActionsOnActive, clicktotap, _bindTo5, containerid, _target, _highlightTarget, _actionNamespace5, true, true, true);
      }

      if (typeof item.checkboxActionsOnDeactive != "undefined") {
        var _bindTo6 = '#' + _id + '-checkbox:not(:checked)';

        var _highlightTarget2 = '#' + _id;

        var _actionNamespace6 = 'protoio-checkboxActionsOnDeactive';
        processActionsList(item.checkboxActionsOnDeactive, clicktotap, _bindTo6, containerid, _target, _highlightTarget2, _actionNamespace6, true, true, true);
      }

      if (typeof item.actions != "undefined") {
        var _bindTo7 = '#' + _id;

        var _highlightTarget3 = _bindTo7;
        var _actionNamespace7 = 'protoio-actions';
        processActionsList(item.actions, clicktotap, _bindTo7, containerid, _target, _highlightTarget3, _actionNamespace7, false, true, false);
      }

      break;
    // android bar double action

    case "android_actionbar":
    case 'android_actionbar_contextual':
      if (typeof item.actionbarActionOverflowActions == "undefined" && typeof item.actions != "undefined") {
        item.actionbarActionOverflowActions = item.actions;
      }

      if (typeof item.actionbarActionOverflowActions != "undefined") {
        var _bindTo8 = '#' + _id + ' .actionOverflow';

        var _highlightTarget4 = _bindTo8;
        var _actionNamespace8 = 'protoio-actionbarActionOverflowActions';
        processActionsList(item.actionbarActionOverflowActions, clicktotap, _bindTo8, containerid, _target, _highlightTarget4, _actionNamespace8, false, false, false);
      }

      if (typeof item.actionbarUpCaretActions != "undefined") {
        var _bindTo9 = '#' + _id + ' .left-icon';

        var _highlightTarget5 = _bindTo9;
        var _actionNamespace9 = 'protoio-actionbarUpCaretActions';
        processActionsList(item.actionbarUpCaretActions, clicktotap, _bindTo9, containerid, _target, _highlightTarget5, _actionNamespace9, false, false, false);
      }

      break;
    // ios7 navbar

    case "ios7_navbar_buttons":
      if (typeof item.ios7NavbarActionsTitle != "undefined") {
        var _bindTo10 = '#' + _id + ' .ios7-navbar-title';

        var _highlightTarget6 = _bindTo10;
        var _actionNamespace10 = 'protoio-ios7NavbarActionsTitle';
        processActionsList(item.ios7NavbarActionsTitle, clicktotap, _bindTo10, containerid, _target, _highlightTarget6, _actionNamespace10, false, false, false);
      }

      if (typeof item.ios7NavbarActionsLeftBtn != "undefined") {
        var _bindTo11 = '#' + _id + ' .ios7-navbar-button-left';

        var _highlightTarget7 = _bindTo11;
        var _actionNamespace11 = 'protoio-ios7NavbarActionsLeftBtn';
        processActionsList(item.ios7NavbarActionsLeftBtn, clicktotap, _bindTo11, containerid, _target, _highlightTarget7, _actionNamespace11, false, false, false);
      }

      if (typeof item.ios7NavbarActionsRightBtn != "undefined") {
        var _bindTo12 = '#' + _id + ' .ios7-navbar-button-right';

        var _highlightTarget8 = _bindTo12;
        var _actionNamespace12 = 'protoio-ios7NavbarActionsRightBtn';
        processActionsList(item.ios7NavbarActionsRightBtn, clicktotap, _bindTo12, containerid, _target, _highlightTarget8, _actionNamespace12, false, false, false);
      }

      break;

    case "material_snackbar_action":
      if (typeof item.actions1 != "undefined") {
        var _bindTo13 = '#' + _id + ' .actions-actions1';

        var _highlightTarget9 = _bindTo13;
        var _actionNamespace13 = 'protoio-actions1';
        processActionsList(item.actions1, clicktotap, _bindTo13, containerid, _target, _highlightTarget9, _actionNamespace13, false, false, false);
      }

      if (typeof item.actions2 != "undefined") {
        var _bindTo14 = '#' + _id + ' .actions-actions2';

        var _highlightTarget10 = _bindTo14;
        var _actionNamespace14 = 'protoio-actions2';
        processActionsList(item.actions2, clicktotap, _bindTo14, containerid, _target, _highlightTarget10, _actionNamespace14, false, false, false);
      }

      break;

    default:
      var postfix = '';

      for (var i = 0; i < 999; i++) {
        if (i > 0) {
          postfix = i;
        }

        if (typeof item["actions" + postfix] != "undefined") {
          var _bindTo15 = '#' + _id;

          if (i > 0) {
            _bindTo15 += ' .actions-actions' + i;
          }

          var _highlightTarget11 = _bindTo15;

          var _actionNamespace15 = 'protoio-actions' + postfix;

          processActionsList(item["actions" + postfix], clicktotap, _bindTo15, containerid, _target, _highlightTarget11, _actionNamespace15, false, false, false);
        } else {
          break;
        }
      }

      prx.utils.dynamic_properties.forEach(function (dynPropKey) {
        if (Array.isArray(item[dynPropKey])) {
          $.each(item[dynPropKey], function (index, dynProp) {
            if (!dynProp) {
              dynProp = {};
            }

            postfix = '';

            for (var _i = 0; _i < 999; _i++) {
              if (_i > 0) {
                postfix = _i;
              }

              if (typeof dynProp["actions" + postfix] != "undefined") {
                var _bindTo16 = '#' + _id + '-' + dynPropKey + '-' + index;

                var _highlightTarget12 = _bindTo16;

                var _actionNamespace16 = 'protoio-actions' + postfix;

                processActionsList(dynProp["actions" + postfix], clicktotap, _bindTo16, containerid, _target, _highlightTarget12, _actionNamespace16, false, false, false);
              } else {
                break;
              }
            }
          });
        }
      });
      break;
  }
};

prx.actions.parseScreenAction = function (index) {
  var _page = prxy.pages[index];

  if (typeof _page.actions != 'undefined') {
    $.each(_page.actions, function (i, action) {
      action.bindTo = '#p-' + _page.id;
      action.containerid = 'p-' + _page.id;
      action.targetId = action.bindTo + '-' + action.itemId; //log('^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^')
      //log(action);

      if (action.type == "keydown") {
        // annam v5.9.5 was causing errors when trying to $.toJSON(prxy.pages) to iniPlayerReady. also change in triggerkeydownaction()
        //action.bindTo = document;
        action.bindTo = 'body';
        action.bindPageId = 'p-' + _page.id;
      }

      prx.actions.build(action);
    });
  }
};

prx.actions.parseScreenStateAction = function (index, stateindex) {
  if (stateindex == -1) {
    return false;
  }

  var _page = prxy.pages[index];
  var _state = _page.states[stateindex];

  if (typeof _state.actions != 'undefined') {
    _state.actions.sort(function (a, b) {
      return a.sort - b.sort;
    });

    $.each(_state.actions, function (i, action) {
      action.bindTo = '#p-' + _page.id + '[data-state-id=' + _state.id + ']'; // this would be a better way to only trigger the correct statetransition interactions but this multiselector is slow on ios
      // so i handle it in actions.generate()
      //if (['statetransitionstart', 'statetransitionend'].indexOf(action.type) !== -1 && typeof  action.states !== 'undefined'){
      //    action.bindTo += '[data-previous-state-id=' + action.states.split(':')[0] + ']';
      //}

      action.containerid = 'p-' + _page.id;
      action.targetId = action.bindTo + '-' + action.itemId;

      if (action.type == "statekeydown") {
        //action.bindTo = document;
        action.bindTo = '';
        action.bindPageId = 'p-' + _page.id;
        action.bindStateId = _state.id;
      }

      action.live = true;
      prx.actions.build(action);
    });
  }
};

prx.actions.parseTemplateStateAction = function (index, stateindex, pageid, containerid) {
  if (stateindex == -1) {
    return false;
  }

  var _prefix = 'p-' + pageid;

  if (typeof containerid != "undefined" && containerid != '') {
    _prefix += '-' + containerid;
  }

  var _template = prx.templates[index];
  var _state = _template.states[stateindex];

  if (typeof _state.actions != 'undefined') {
    _state.actions.sort(function (a, b) {
      return a.sort - b.sort;
    });

    $.each(_state.actions, function (i, action) {
      action.bindTo = '#' + _prefix + '-t' + prx.templates[index].id + '[data-state-id=' + _state.id + ']';
      action.containerid = _prefix;
      action.targetId = action.bindTo + '-' + action.itemId;

      if (action.type == "statekeydown") {
        //action.bindTo = document;
        action.bindTo = 'body';
        action.bindPageId = 'p-' + _pageid;
        action.bindStateId = _state.id;
      }

      action.live = true;
      prx.actions.build(action);
    });
  }
};

prx.actions.parseContainerStateAction = function (index, stateindex, pageid, containerid, itemid) {
  if (stateindex == -1) {
    return false;
  }

  var _symbol = prxy.symbols[index];
  var _state = _symbol.states[stateindex];

  if (typeof _state.actions != 'undefined') {
    _state.actions.sort(function (a, b) {
      return a.sort - b.sort;
    });

    $.each(_state.actions, function (i, action) {
      action = JSON.parse(JSON.stringify(action)); // because im editing action, it overwrites for all symbol instances
      //action.bindTo = '#'+containerid + itemid+'[data-state-id='+_state.id+']';

      action.bindTo = '#' + containerid + '[data-state-id=' + _state.id + ']'; // this would be a better way to only trigger the correct statetransition interactions but this multiselector is slow on ios
      // so i handle it in actions.generate()
      //if (['statetransitionstart', 'statetransitionend'].indexOf(action.type) !== -1 && typeof  action.states !== 'undefined') {
      //    action.bindTo += '[data-previous-state-id=' + action.states.split(':')[0] + ']';
      //}

      /*
         if(action.pageId == -1) {
       action.pageId = pageid
       }
         if(action.itemId == -1) {
       action.itemId = itemid;
       }
       */

      action.containerid = containerid; // v5.5.16 we used to always target the current container :S if pageid != -1 then i just allow targetId to be built in buildAction

      if (action.pageId == -1) {
        action.pageId = pageid;
        action.targetId = '#' + containerid + (action.itemId != -1 ? '-' + action.itemId : '');
        action.allowOverwriteTargetId = false;
      }

      if (action.type == "statekeydown") {
        action.bindTo = '';
        action.bindPageId = 'p-' + pageid;
        action.bindStateId = _state.id;
      }

      action.live = true;
      prx.actions.build(action);
    });
  }
};

prx.actions.disableFlashActionOnItemTap = function (bindTo, namespace) {
  $(bindTo).each(function () {
    var hammer = $(this).data("hammer");

    if (typeof hammer == "undefined") {
      return false;
    }

    hammer.add(new Hammer.Tap({
      event: 'flashactiontap',
      time: 500,
      threshold: 10
    }).recognizeWith(hammer.get('tap')).recognizeWith(hammer.get('doubletap')));

    if (typeof namespace == "undefined") {
      namespace = '.flashactiontap';
    }

    $(this).off('flashactiontap' + namespace).on('flashactiontap' + namespace, function (e) {
      prx.actions.justtapped = true;
    });
  });
};

prx.actions.disableFlashActionOnItemTouch = function (bindTo, namespace) {
  if (typeof namespace == "undefined") {
    namespace = '.flashactiontap';
  }

  $(bindTo).off('touch' + namespace).on('touch' + namespace, function (e) {
    prx.actions.justtapped = true;
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_analytics.js":
/*!********************************************************!*\
  !*** ./sass/player-engine/js/components/_analytics.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.analytics = {};
prx.analytics.hasanalytics = false;
prx.analytics.trackingcode = '';
prx.analytics.version = '';

prx.analytics.ini = function () {
  if (prx.spaces) return;
  prx.analytics.trackingcode = prx.projectsettings.gatrackingcode;
  prx.analytics.hasanalytics = prx.analytics.trackingcode.length > 0;
  prx.analytics.version = prx.projectsettings.v != 0 && prx.projectsettings.v != '0' && prx.projectsettings.v != 'latest' ? 'v' + prx.projectsettings.v : 'live';
  if (!prx.analytics.hasanalytics) return;

  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments);
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

  ga('create', prx.analytics.trackingcode, prx.url.siteurl);

  if (prx.export2html) {
    ga('set', 'checkProtocolTask', null); // Disable file protocol checking.

    ga('set', 'checkStorageTask', null); // Disable cookie storage checking.

    ga('set', 'historyImportTask', null); // Disable history checking (requires reading from cookies).
  }

  $(window).bind('hashchange', function () {
    if (location.hash.length) {
      prx.analytics.trackPage(window.location.hash.replace('#', ''));
    }
  });
};

prx.analytics.trackPage = function (pageid) {
  if (prx.analytics.hasanalytics) {
    var title = prxy.pages[prx.stc.screens.getIndexFromId(pageid)].title;
    ga('send', 'pageview', {
      'page': '#p-' + pageid,
      'title': prx.analytics.version + ': ' + title
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_canvas.js":
/*!*****************************************************!*\
  !*** ./sass/player-engine/js/components/_canvas.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.canvas = {};
prx.canvas._statusbars = {};
prx.canvas._navigationbars = {};

prx.canvas.loadAll = function () {
  $.each(prxy.pages, function (i, page) {
    prx.stc.screens.load(page);
  });
};

prx.canvas.clear = function () {
  // not used?
  $("#dragarea").html("");
};

prx.canvas.ini = function () {
  prx.canvas.loadAll(); // v5.7.4 checking again because of a bug in android app where when checking through index.cfm the webview is not yet initialised so the values are incorrect.

  prx.orientation._orientation = prx.orientation.get();
  prx.orientation.changeBody(prx.orientation._orientation);

  if (typeof prx.project.background != "undefined") {
    if (typeof prx.project.background === "string") {
      prx.project.background = prx.gradients.stringToPrxData(prx.project.background);
    }

    $('body').css('background-color', prx.gradients.prxToCss(prx.project.background));
  }

  $(window).bind('pagebeforechange', function (event, obj) {
    var _currentpage = '#' + prx.navigation._activepage; // remember scroll position


    var _pgId = _currentpage.substr(1);

    $.each(prx.scrollable._scrollables, function (i, elm) {
      if (i.indexOf(_pgId + '-') == 0) {
        // only save scroll position if in currently displayed page, otherwise it messes scroll position
        prx.scrollable._scrollPositions[i] = [elm.x, elm.y];
      }
    });
  });
  $(window).bind('pagechange', function (event, obj) {
    // Scroll to last scrolled position (for back button)
    if (typeof prx.scrollable._scrollables != "undefined") {
      // annam removing jquery
      var _pgId = prx.navigation._activepage;
      $.each(prx.scrollable._scrollables, function (i, elm) {
        if (i.indexOf(_pgId + '-') == 0) {
          if (typeof prx.scrollable._scrollPositions[i] != "undefined") {
            elm.scrollTo(prx.scrollable._scrollPositions[i][0], prx.scrollable._scrollPositions[i][1], 0);
          }
        }
      });
    }
  });

  if (!prx.inProtoApp) {
    $(window).bind('orientationchange', function (event) {
      prx.orientation._orientation = prx.orientation.get(); // don't trigger if in iframe (preview page), because i may not want to.
      // i am triggering prx.orientation.change() manually from the preview where needed.
      // 5.7.12 removing from proto apps, AO and Angelos trigger prx.orientation.change() themselves.

      if (parent == window) {
        prx.orientation.change();
      }

      return true;
    });
  }

  $(window).resize(function () {
    prx.orientation.check();
    $('#dragarea').width($(window).width());
    $('#dragarea').height($(window).height());
  });
  /* GS - No longer needed after removing width=device-width from the viewport
  $(document).on('focusout',':input', function() {
      if (prx.inProtoIOsApp || prx.iosmobilebrowser) { // only for ios
          setTimeout(function () {
              if (!$("input, textarea").is(":focus")) {
                  // window.scrollTo(0,0);
              }
          }, 100);
      }
  });
    $(document).on('focusin',':input', function(e) {
      function repos(target) {
          setTimeout(function () {
              if ($(window).scrollLeft() !== 0) {
                  // $(window).scrollLeft(0);
              }
          }, 500);
      }
      repos(e.currentTarget);
  });
  */

  /* GS - Removing width=device-width throws android devices out in that they now allow body to scroll, so put it in meta only if we are in android */

  if (prx.inProtoAndroidApp) {
    var $metaSelector = $('head meta[name=viewport]');
    var metaViewportContent = $metaSelector.attr('content');
    $metaSelector.attr('content', 'width=device-width, ' + metaViewportContent);
  }

  if (prx.helper.oniphone()) {
    var isIphoneXXS = window.screen.height == '812' && window.screen.width == '375' || window.screen.height == '375' && window.screen.width == '812';
    var isIphoneXR = window.screen.height == '828' && window.screen.width == '1792' || window.screen.height == '1792' && window.screen.width == '828';
    var isIphoneXSMAX = window.screen.height == '414' && window.screen.width == '896' || window.screen.height == '896' && window.screen.width == '414';

    if (isIphoneXXS || isIphoneXR || isIphoneXSMAX) {
      var _$metaSelector = $('head meta[name=viewport]');

      var _metaViewportContent = _$metaSelector.attr('content');

      _$metaSelector.attr('content', 'viewport-fit=cover, ' + _metaViewportContent);

      $(document).on('focusout', ':input', function () {
        setTimeout(function () {
          if (!$("input, textarea").is(":focus")) {
            window.scrollTo(0, 0);
          }
        }, 100);
      });
    }
  } // make sure letterbox mobile safari issue is reflowed after input edit


  $(document).on('blur', 'input,textarea', function () {
    if (prx.iosmobilebrowser) {
      prx.crossmsg.send({
        action: 'inputblur',
        data: {}
      });
    }
  });
  $(window).bind('hashchange', function () {
    // this will always be triggered on changepage
    // but allowSamePageTransition: false should prevent this from looping
    // so it will only do something if triggered by back button
    // so no need to use the following
    // if(window.location.hash != '#' + prx.navigation._activepage.replace('p-', '')) {
    if (window.location.hash != '' && window.location.hash != '#' + prx.navigation._activepage.replace('p-', '')) {
      prx.navigation.changePage($('#p-' + window.location.hash.replace('#', '')), {
        changeHash: false,
        allowSamePageTransition: false
      });
    } else if (window.location.hash == '') {
      prx.loading.hideLoader();
      prx.loading.iniStartScreen();
    }
  }); // for "focus input component" interaction

  $(document).on('click.fakefocus', ':input', function () {
    if (!$(this).is(':focus')) {
      $(this).focus();
    }
  });
  $(window).on('mouseleave', function (e) {
    if (e.originalEvent.toElement == null && e.originalEvent.relatedTarget == null) {
      prx.scrollable.endTransitions();
    }
  });
  $('body').on('contextmenu', function () {
    return false;
  });
  $(document).on('click touchstart', function () {
    // on ios only, clicking outside to hide keyboard does not work by default.
    if (prx.iosmobilebrowser) {
      prx.helper.blurInputs();
    }

    $('.box.type-material-dropdown-menu').trigger('dummy.close');
    $('.box.type-basic-select').trigger('dummy.close');
    $('.box.type-basic-dropdown').trigger('dummy.close');
  }); // on ios only, clicking outside to hide keyboard does not work by default.

  if (prx.iosmobilebrowser) {
    $(document).on('click touchstart', 'input,textarea', function (e) {
      // WKWebView problem with misplaced screen on input focus fix
      //document.body.scrollLeft = 0;
      e.stopPropagation();
    }); // WKWebView problem with misplaced screen on input focus fix
    // $('input,textarea').on('focus', function(){
    //     document.body.scrollLeft = 0;
    // });
  }
  /**/


  if ($.browser.chrome && !prx.helper.onmobile()) {
    $('body').addClass('do-chrome-fix');
  }
  /**/

};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_click-effect.js":
/*!***********************************************************!*\
  !*** ./sass/player-engine/js/components/_click-effect.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.clickEffect = {};
prx.clickEffect.scaleRatio = 1;

prx.clickEffect.ini = function () {
  if (!prx.helper.onmobile()) {
    var clickEffectCookie = prx.kvs.get("clickEffect_" + prx.projectsettings.id);

    if (clickEffectCookie == false || clickEffectCookie == null) {
      prx.clickEffect.hide();
    } else {
      prx.clickEffect.show();
    }
  }
};

prx.clickEffect.scale = function (zoom) {
  if (zoom == "undefined") {
    zoom = 1;
  }

  prx.clickEffect.scaleRatio = parseFloat(1 / zoom).toFixed(2);
};

prx.clickEffect.show = function () {
  if (!parent != window) {
    try {
      prx.crossmsg.send({
        action: 'show-click-effect'
      });
    } catch (err) {}

    ;
  } //$(window).bind('click',function(event,obj) {


  $('body').on("mousedown.clickeffect", function (e, obj) {
    var $parent = $('body').find('.prx-page-active');

    if ($('body').hasClass('device-cursor-touch')) {
      $parent.append('<span class="cbutton cbutton--effect-sanja"></span>');
    } else {
      $parent.append('<span class="cbutton cbutton--effect-jelena"></span>');
    } //cbutton--effect-sanja


    var elem = $parent.find('.cbutton');
    elem.css({
      height: 54 + 'px',
      width: 54 + 'px'
    });
    var x = e.pageX - 54 / 2 - 0;
    var y = e.pageY - 54 / 2 - 3;
    elem.css({
      '-moz-transform': 'scale(' + prx.clickEffect.scaleRatio + ')',
      '-webkit-transform': 'scale(' + prx.clickEffect.scaleRatio + ')',
      'transform': 'scale(' + prx.clickEffect.scaleRatio + ')',
      '-webkit-perspective': 1000
    });
    elem.css({
      top: y + 'px',
      left: x + 'px',
      position: 'absolute'
    }).addClass("cbutton--click"); ///elem.removeClass("cbutton--click");

    setTimeout(function () {
      elem.remove();
    }, 250);
  });
};

prx.clickEffect.hide = function () {
  if (!parent != window) {
    try {
      prx.crossmsg.send({
        action: 'hide-click-effect'
      });
    } catch (err) {}

    ;
  }

  $('body').off("mousedown.clickeffect");
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_cross-msg.js":
/*!********************************************************!*\
  !*** ./sass/player-engine/js/components/_cross-msg.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.crossmsg = prx.crossmsg || {};

prx.crossmsg.gettargetframe = function () {
  return parent;
};

prx.crossmsg.onmsg = function (msg) {
  switch (msg.action) {
    case 'zoom-level-changed':
      prx.clickEffect.scale(msg.data.zoom);
      break;

    case 'change-page':
      prx["interface"].goToPage(msg.data.pageid);
      break;

    case 'keydown':
      prx["interface"].triggerKeydownAction(msg.data.key);
      break;

    case 'change-orientation':
      prx["interface"].triggerOrientationChange();
      break;

    case 'change-body-orientation':
      prx["interface"].triggerBodyOrientationChange();
      break;

    case 'show-click-effect':
      prx["interface"].clickEffect.show();
      break;

    case 'hide-click-effect':
      prx["interface"].clickEffect.hide();
      break;

    case 'show-show-actions':
      prx["interface"].showActions.on();
      break;

    case 'hide-show-actions':
      prx["interface"].showActions.off();
      break;

    case 'enable-flash-actions':
      prx["interface"].showActions.flash.enable();
      break;

    case 'disable-flash-actions':
      prx["interface"].showActions.flash.disable();
      break;

    case 'show-loader':
      prx["interface"].startShowLoader();
      break;

    case 'hide-loader':
      prx["interface"].startHideLoader();
      break;

    case 'go-to-previous-screen':
      prx.goToPreviousScreen();
      break;

    case 'go-to-next-screen':
      prx.goToNextScreen();
      break;

    default:
      break;
  }
};

/***/ }),

/***/ "./sass/player-engine/js/components/_debug.js":
/*!****************************************************!*\
  !*** ./sass/player-engine/js/components/_debug.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.debug = {};
prx.debug.fps;
prx.debug._time = {};

prx.debug.ini = function () {
  prx.debug.performance();
  prx.debug.inilog();
  prx.debug.iniLogErrors();
};

prx.debug.performance = function () {
  return;

  if (typeof window.requestAnimationFrame == "undefined") {
    return;
  }

  prx.debug.fps = $('<div id="fps" />').appendTo('body').get(0);
  var frame = 0;
  var startTime = Date.now();

  function tick() {
    var time = Date.now();
    frame++;

    if (time - startTime > 1000) {
      prx.debug.fps.innerHTML = (frame / ((time - startTime) / 1000)).toFixed(1);
      startTime = time;
      frame = 0;
    }

    window.requestAnimationFrame(tick);
  }

  tick();
};

prx.debug.inilog = function () {
  $('<div id="log" />').appendTo('body');
};

prx.debug.log = function (text) {
  $('#log').append(text + '<br>');
};

prx.debug.clearlog = function () {
  $('#log').html('');
};

prx.debug.starttime = function (id) {
  prx.debug._time[id] = Date.now();
};

prx.debug.endtime = function (id) {
  return prx.debug._time[id] === undefined ? 0 : Date.now() - prx.debug._time[id];
};

prx.debug.time = function (id) {
  prx.debug.starttime(id);
};

prx.debug.timeEnd = function (id) {
  prx.debug.log(id + ': ' + prx.debug.endtime(id) + 'ms');
};

prx.debug.iniLogErrors = function () {
  window.onerror = function (msg, url, line, col, error) {
    prx.debug.log(msg + ' - Line: ' + line);
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_draggable.js":
/*!********************************************************!*\
  !*** ./sass/player-engine/js/components/_draggable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.draggable = {};
prx.draggable._draggables = {};

prx.draggable.ini = function (item, pageid, containerid) {
  if (typeof item.draggable != 'undefined' && item.draggable !== null && item.draggable.isdraggable) {
    _bounds = '';

    if (item.draggable.isdraggable) {
      if (typeof containerid == 'undefined' || containerid.length == 0) {
        containerid = 'p-' + pageid;
      }

      var _targetid = '#' + containerid + '-' + item.id;

      item.draggable.targetitem = $(_targetid);

      if (item.draggable.bounds == "auto") {
        item.draggable.container = item.draggable.targetitem.parent();
      } else {
        item.draggable.container = {
          left: parseInt(item.draggable.boundsprops.left),
          top: parseInt(item.draggable.boundsprops.top),
          width: item.draggable.boundsprops.width,
          height: item.draggable.boundsprops.height
        };
      }

      item.draggable.container = item.draggable.targetitem.parent();

      if (typeof item.draggable.handle != "undefined" && item.draggable.handle != "" && $(_targetid + '-' + item.draggable.handle).length > 0) {
        item.draggable.handleid = _targetid + '-' + item.draggable.handle;
      }

      $(_targetid).addClass('draggable');
      var handle = item.draggable.handle == '' ? _targetid : _targetid + '-' + item.draggable.handle;
      $(handle).addClass('move');

      if (typeof item.draggable.front == "undefined") {
        item.draggable.front = false;
      }

      if (typeof item.draggable.livesnap == "undefined") {
        item.draggable.livesnap = false;
      }

      if (typeof item.draggable.lockaxis == "undefined") {
        item.draggable.lockaxis = false;
      }

      var _maxDuration;

      if (item.draggable.kinetic) {
        _maxDuration = 2;
      } else {
        _maxDuration = 0.0001;
      }

      if (item.draggable.axis == "rotation" && item.draggable.rotationbounds == "none") {
        _bounds = {
          minRotation: -99999,
          maxRotation: 99999
        };
      } else if (item.draggable.axis == "rotation") {
        _bounds = {
          minRotation: parseInt(item.draggable.boundsprops.mindegrees),
          maxRotation: parseInt(item.draggable.boundsprops.maxdegrees)
        };
      }

      if (item.draggable.targetitem.length == 0) return false; // if i dont position items using greensock before i initialize draggable, draggable resets the initial position of the item to 0,0
      // this happens because on draggable.create, screens are display: none

      prx.items.updatePosition(item, containerid, pageid);
      prx.draggable._draggables[_targetid.substr(1)] = Draggable.create(item.draggable.targetitem, {
        type: item.draggable.axis,
        edgeResistance: 0.95,
        throwProps: true,
        bounds: _bounds,
        trigger: typeof item.draggable.handleid != "undefined" ? item.draggable.handleid : '',
        zIndexBoost: item.draggable.front,
        dragResistance: 0,
        minDuration: 0.0001,
        maxDuration: _maxDuration
      });

      prx.draggable._draggables[_targetid.substr(1)][0].vars.onDragStart = function () {
        $(this.target).parents('.box').each(function () {
          // all symbols
          if (typeof prx.scrollable._scrollables[this.id + '-inner'] != "undefined") {
            prx.scrollable._scrollables[this.id + '-inner'].disable();
          }
        });
      };

      prx.draggable._draggables[_targetid.substr(1)][0].vars.onDragEnd = function () {
        $(this.target).parents('.box').each(function () {
          // all symbols
          if (typeof prx.scrollable._scrollables[this.id + '-inner'] != "undefined") {
            prx.scrollable._scrollables[this.id + '-inner'].enable();
          }
        });
      };
    }
  }
};

prx.draggable.refresh = function (targetid) {
  $(targetid + '.box.draggable, ' + targetid + ' .box.draggable').each(function () {
    if (typeof prx.draggable._draggables[this.id] == "undefined") return false;
    var split = this.id.split('box-');
    var id = 'box-' + split[split.length - 1];
    var stateid = $(this).parents('[data-state-id]').first().attr('data-state-id');

    if (typeof prx.allItems[id] != "undefined" && typeof prx.allItems[id].states != "undefined" && typeof prx.allItems[id].states[stateid] != "undefined") {
      var data = JSON.parse(prxy[prx.allItems[id].containertype][prx.allItems[id].containerindex].states[prx.allItems[id].states[stateid].stateindex].data);
      var item = data[prx.allItems[id].states[stateid].itemindex];

      if (typeof item.draggable != 'undefined' && item.draggable.isdraggable) {
        item.draggable.targetitem = $('#' + this.id);

        if (item.draggable.axis != "rotation") {
          if (item.draggable.bounds != "auto") {
            var _parentPosition = {
              left: 0,
              top: 0
            };
            var container = {
              left: parseInt(item.draggable.boundsprops.left) + _parentPosition.left,
              top: parseInt(item.draggable.boundsprops.top) + _parentPosition.top,
              width: item.draggable.boundsprops.width,
              height: item.draggable.boundsprops.height
            };
            prx.draggable._draggables[this.id][0].vars.bounds = container;
          } else if (item.draggable.bounds == "auto") {
            prx.draggable._draggables[this.id][0].vars.bounds = $('#' + this.id).parent();
          }
        }

        var gridWidth = 0,
            gridHeight = 0,
            gridRows = 0,
            gridColumns = 0,
            _snap = {};

        if (item.draggable.snap) {
          gridRows = item.draggable.snapprops.rows;
          gridColumns = item.draggable.snapprops.columns;
        }

        if (item.draggable.bounds == "auto") {
          item.draggable.container = item.draggable.targetitem.parent();

          if (item.draggable.snap) {
            gridWidth = item.draggable.container.width() / gridColumns;
            gridHeight = item.draggable.container.height() / gridRows;
          }

          if (item.width < gridWidth) {
            gridWidth = (item.draggable.container.width() - item.width) / gridColumns;
          }

          if (item.height < gridHeight) {
            gridHeight = (item.draggable.container.height() - item.height) / gridRows;
          }
        } else {
          item.draggable.container = {
            left: parseInt(item.draggable.boundsprops.left),
            top: parseInt(item.draggable.boundsprops.top),
            width: item.draggable.boundsprops.width,
            height: item.draggable.boundsprops.height
          };

          if (item.draggable.snap) {
            gridWidth = item.draggable.boundsprops.width / gridColumns;
            gridHeight = item.draggable.boundsprops.height / gridRows;
          }
        }

        if (item.draggable.snap) {
          if (item.draggable.axis != "rotation") {
            _snap = {
              x: function x(endValue) {
                if (item.draggable.snap) {
                  return Math.max(this.minX, Math.min(this.maxX, Math.round((endValue - item.draggable.boundsprops.left) / gridWidth) * gridWidth + parseInt(item.draggable.boundsprops.left)));
                } else {
                  return endValue;
                }
              },
              y: function y(endValue) {
                if (item.draggable.snap) {
                  return Math.max(this.minY, Math.min(this.maxY, Math.round((endValue - item.draggable.boundsprops.top) / gridHeight) * gridHeight + parseInt(item.draggable.boundsprops.top)));
                } else {
                  return endValue;
                }
              }
            };
          } else {
            _snap = function _snap(endValue) {
              var _rotationSnap = item.draggable.rotationsnap; // * Math.PI / 180;

              if (_rotationSnap == 0 || _rotationSnap == "") _rotationSnap = 360;
              return Math.round(endValue / _rotationSnap) * _rotationSnap;
            };
          }
        }

        prx.draggable._draggables[this.id][0].vars.snap = _snap;
        prx.draggable._draggables[this.id][0].vars.liveSnap = item.draggable.snap && item.draggable.livesnap;
        prx.draggable._draggables[this.id][0].vars.lockAxis = item.draggable.lockaxis;
        prx.draggable._draggables[this.id][0].lockAxis = item.draggable.lockaxis;
        var _ondragstartinteraction = false;
        var _ondraginteraction = false;
        var _ondragendinteraction = false;
        var _onthrowupdateinteraction = false;
        var _onthrowcompleteinteraction = false;

        for (var i = 0; i < prx.actions._actionTypes.length; i++) {
          if (typeof item[prx.actions._actionTypes[i]] != "undefined") {
            for (var j = 0; j < item[prx.actions._actionTypes[i]].length; j++) {
              switch (item[prx.actions._actionTypes[i]][j].type) {
                case "ondragstart":
                case "onrotatestart":
                  _ondragstartinteraction = true;
                  break;

                case "ondrag":
                case "onrotate":
                  _ondraginteraction = true;
                  break;

                case "ondragend":
                case "onrotateend":
                  _ondragendinteraction = true;
                  break;

                case "onthrowupdate":
                case "onrotatethrowupdate":
                  _onthrowupdateinteraction = true;
                  break;

                case "onthrowcomplete":
                case "onrotatethrowcomplete":
                  _onthrowcompleteinteraction = true;
                  break;

                default:
                  break;
              }

              if (item[prx.actions._actionTypes[i]][j].originaltarget !== undefined) {
                // originating from a group interaction so need to recreate group action divs, need callbacks
                _ondragendinteraction = true;
                _onthrowcompleteinteraction = true;
              }
            }
          }
        }

        var _targetid = '#' + this.id,
            _tempRotated = 0;

        if (_ondragstartinteraction || _ondraginteraction || _ondragendinteraction || _onthrowupdateinteraction || _onthrowcompleteinteraction) {
          var dims = prx.items.getRealDimsAndPosFromDom(_targetid);

          if (typeof prx.variables._triggerData[_targetid] == "undefined") {
            prx.variables._triggerData[_targetid] = {
              original: {}
            };
          }

          prx.variables._triggerData[_targetid]['original'].x = dims.left;
          prx.variables._triggerData[_targetid]['original'].y = dims.top;
        }

        if (_ondragstartinteraction) {
          prx.draggable._draggables[_targetid.substr(1)][0].vars.onDragStart = function () {
            var _r = {};
            $(this.target).parents('.box').each(function () {
              // all symbols
              if (typeof prx.scrollable._scrollables[this.id + '-inner'] != "undefined") {
                prx.scrollable._scrollables[this.id + '-inner'].disable();
              }
            });

            if (typeof prx.variables._triggerData[_targetid] == "undefined") {
              prx.variables._triggerData[_targetid] = {};
            }

            if (item.draggable.axis != "rotation") {
              _r.row = 0;
              _r.column = 0;
              _r.x = 0; // relative position to boundaries

              _r.y = 0;
              _r.movex = 0;
              _r.movey = 0;
              _r.left = 0; // absolute position to canvas

              _r.top = 0;
              _r.position = {
                'left': item.left,
                'top': item.top
              };

              if (item.draggable.snap) {
                switch (item.draggable.axis) {
                  case "x":
                    _r.row = 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  case "y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = 1;
                    break;

                  case "x,y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  default:
                    break;
                }
              }

              var off = $(this.target).offset();
              _r.x = Math.round(this.x - this.minX);
              _r.y = Math.round(this.y - this.minY);
              _r.movex = Math.round(this.x - prx.variables._triggerData[_targetid]['original'].x);
              _r.movey = Math.round(this.y - prx.variables._triggerData[_targetid]['original'].y);
              _r.left = Math.round(off.left);
              _r.top = Math.round(off.top);
              prx.variables._triggerData[_targetid]['ondragstart'] = _r;
              $(_targetid).trigger('ondragstart', this);
            } else {
              var degs = Math.round(this.rotation % 360);
              _r.degrees = degs > 0 ? degs : 360 + degs;
              _r.rotationposition = this.rotation;

              if (isNaN(_r.degrees)) {
                _r.degrees = 0;
              }

              _tempRotated = this.rotation;
              _r.rotated = 0;
              prx.variables._triggerData[_targetid]['onrotatestart'] = _r;
              $(_targetid).trigger('onrotatestart', this);
            }
          };
        }

        if (_ondraginteraction) {
          prx.draggable._draggables[_targetid.substr(1)][0].vars.onDrag = function () {
            var _r = {}; // v5.9.5 strange bug where if rotation and tapping on component to change screen, on other screen but in same position, dragstart is not being triggered
            // i think caused by a more generic2 bug where tap events are propagated to next page.
            // v5.9.8 found really issue (was tap propagating) and fix it.
            // v5.10 now adding it on all interactions because i don't call dragstart unless its needed.

            if (typeof prx.variables._triggerData[_targetid] == "undefined") {
              prx.variables._triggerData[_targetid] = {};
            }

            if (item.draggable.axis != "rotation") {
              _r.row = 0;
              _r.column = 0;
              _r.x = 0; // relative position to boundaries

              _r.y = 0;
              _r.movex = 0;
              _r.movey = 0;
              _r.left = 0; // absolute position to canvas

              _r.top = 0;

              if (item.draggable.snap) {
                switch (item.draggable.axis) {
                  case "x":
                    _r.row = 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  case "y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = 1;
                    break;

                  case "x,y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  default:
                    break;
                }
              }

              var off = $(this.target).offset();
              _r.x = Math.round(this.x - this.minX);
              _r.y = Math.round(this.y - this.minY);
              _r.movex = Math.round(this.x - prx.variables._triggerData[_targetid]['original'].x);
              _r.movey = Math.round(this.y - prx.variables._triggerData[_targetid]['original'].y);
              _r.left = Math.round(off.left);
              _r.top = Math.round(off.top);
              prx.variables._triggerData[_targetid]['ondrag'] = _r;
              $(_targetid).trigger('ondrag', this);
            } else {
              var degs = Math.round(this.rotation % 360);
              _r.degrees = degs > 0 ? degs : 360 + degs;
              _r.rotationposition = this.rotation;
              _r.rotated = this.rotation - _tempRotated;
              _r.rotated = Math.round(_r.rotated);
              prx.variables._triggerData[_targetid]['onrotate'] = _r;
              $(_targetid).trigger('onrotate', this);
            }
          };
        }

        if (_ondragendinteraction) {
          prx.draggable._draggables[_targetid.substr(1)][0].vars.onDragEnd = function () {
            var _r = {};

            if (typeof prx.variables._triggerData[_targetid] == "undefined") {
              prx.variables._triggerData[_targetid] = {};
            }

            $(this.target).parents('.box').each(function () {
              // all symbols
              if (typeof prx.scrollable._scrollables[this.id + '-inner'] != "undefined") {
                prx.scrollable._scrollables[this.id + '-inner'].enable();
              }
            }); //this.tween.seek(this.tween.duration());

            if (item.draggable.axis != "rotation") {
              _r.row = 0;
              _r.column = 0;
              _r.x = 0; // relative position to boundaries

              _r.y = 0;
              _r.movex = 0;
              _r.movey = 0;
              _r.left = 0; // absolute position to canvas

              _r.top = 0;

              if (item.draggable.snap) {
                switch (item.draggable.axis) {
                  case "x":
                    _r.row = 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  case "y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = 1;
                    break;

                  case "x,y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  default:
                    break;
                }
              }

              var off = $(this.target).offset();
              _r.x = Math.round(this.x - this.minX);
              _r.y = Math.round(this.y - this.minY);
              _r.movex = Math.round(this.x - prx.variables._triggerData[_targetid]['original'].x);
              _r.movey = Math.round(this.y - prx.variables._triggerData[_targetid]['original'].y);
              _r.left = Math.round(off.left);
              _r.top = Math.round(off.top);
              prx.variables._triggerData[_targetid]['ondragend'] = _r;
              $(_targetid).trigger('ondragend', this);
            } else {
              var degs = Math.round(this.rotation % 360);
              _r.degrees = degs > 0 ? degs : 360 + degs;
              _r.rotationposition = this.rotation;
              _r.rotated = this.rotation - _tempRotated;
              _r.rotated = Math.round(_r.rotated);
              prx.variables._triggerData[_targetid]['onrotateend'] = _r;
              $(_targetid).trigger('onrotateend', this);
            }

            prx.groups.redrawGroupActionDiv(_targetid);
          };
        }

        if (_onthrowupdateinteraction) {
          prx.draggable._draggables[_targetid.substr(1)][0].vars.onThrowUpdate = function () {
            var _r = {};

            if (typeof prx.variables._triggerData[_targetid] == "undefined") {
              prx.variables._triggerData[_targetid] = {};
            }

            if (item.draggable.axis != "rotation") {
              _r.row = 0;
              _r.column = 0;
              _r.x = 0;
              _r.y = 0;
              _r.movex = 0;
              _r.movey = 0;

              if (item.draggable.snap) {
                switch (item.draggable.axis) {
                  case "x":
                    _r.row = 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  case "y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = 1;
                    break;

                  case "x,y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  default:
                    break;
                }
              }

              var off = $(this.target).offset();
              _r.x = Math.round(this.x - this.minX);
              _r.y = Math.round(this.y - this.minY);
              _r.movex = Math.round(this.x - prx.variables._triggerData[_targetid]['original'].x);
              _r.movey = Math.round(this.y - prx.variables._triggerData[_targetid]['original'].y);
              _r.left = Math.round(off.left);
              _r.top = Math.round(off.top);
              prx.variables._triggerData[_targetid]['onthrowupdate'] = _r;
              $(_targetid).trigger('onthrowupdate', this);
            } else {
              var degs = Math.round(this.rotation % 360);
              _r.degrees = degs > 0 ? degs : 360 + degs;
              _r.rotationposition = this.rotation; //_r.rotated = this.endX - _tempRotated;

              _r.rotated = Math.round(_r.rotated);
              prx.variables._triggerData[_targetid]['onrotatethrowupdate'] = _r;
              $(_targetid).trigger('onrotatethrowupdate', this);
            }
          };
        }

        if (_onthrowcompleteinteraction) {
          prx.draggable._draggables[_targetid.substr(1)][0].vars.onThrowComplete = function () {
            var _r = {};

            if (typeof prx.variables._triggerData[_targetid] == "undefined") {
              prx.variables._triggerData[_targetid] = {};
            }

            if (item.draggable.axis != "rotation") {
              _r.row = 0;
              _r.column = 0;
              _r.x = 0;
              _r.y = 0;
              _r.movex = 0;
              _r.movey = 0;

              if (item.draggable.snap) {
                switch (item.draggable.axis) {
                  case "x":
                    _r.row = 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  case "y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = 1;
                    break;

                  case "x,y":
                    _r.row = Math.round((this.y - this.minY) / gridHeight) + 1;
                    _r.column = Math.round((this.x - this.minX) / gridWidth) + 1;
                    break;

                  default:
                    break;
                }
              }

              var off = $(this.target).offset();
              _r.x = Math.round(this.x - this.minX);
              _r.y = Math.round(this.y - this.minY);
              _r.movex = Math.round(this.x - prx.variables._triggerData[_targetid]['original'].x);
              _r.movey = Math.round(this.y - prx.variables._triggerData[_targetid]['original'].y);
              _r.left = Math.round(off.left);
              _r.top = Math.round(off.top);
              prx.variables._triggerData[_targetid]['onthrowcomplete'] = _r;
              $(_targetid).trigger('onthrowcomplete', this);
            } else {
              var degs = Math.round(this.rotation % 360);
              _r.degrees = degs > 0 ? degs : 360 + degs;
              _r.rotationposition = this.rotation;
              _r.rotated = this.rotation - _tempRotated;
              _r.rotated = Math.round(_r.rotated);
              [_targetid]['onrotatethrowcomplete'] = _r;
              $(_targetid).trigger('onrotatethrowcomplete', this);
            }

            prx.groups.redrawGroupActionDiv(_targetid);
          };
        }
      }
    }
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_easing.js":
/*!*****************************************************!*\
  !*** ./sass/player-engine/js/components/_easing.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.easing = prx.easing || {};

prx.easing.replaceUserPreset = function (json) {
  var easingTypes = ["animationEasing", "easing"];
  var easingTypesLength = easingTypes.length;

  for (var i = 0; i < easingTypesLength; i++) {
    if (typeof json[easingTypes[i]] !== "undefined" && prx.utils.isSpringrk4(json[easingTypes[i]])) {
      json.duration = prx.springrk4.getDuration(json[easingTypes[i]]) * 1000;
    }

    if (typeof json[easingTypes[i]] !== "undefined" && prx.utils.isGuid(json[easingTypes[i]])) {
      if (prx.easing._customEasings[json[easingTypes[i]]] !== undefined) {
        json.userpresetuuid = json[easingTypes[i]];
        json.duration = prx.easing._customEasings[json[easingTypes[i]]].duration;
        json[easingTypes[i]] = prx.easing._customEasings[json[easingTypes[i]]].easing;
      } else {
        // if for some reason easing was deleted but not replaced
        json.userpresetuuid = json[easingTypes[i]];
        json.duration = 0;
        json[easingTypes[i]] = 'linear';
      }
    }
  }

  if (typeof json.callbackAction !== "undefined") {
    json.callbackAction = prx.easing.replaceUserPreset(json.callbackAction);
  }

  return json;
};

prx.easing.searchItem = function (item) {
  $.each(prx.actions._actionTypes, function (i, actionType) {
    if (actionType in item) {
      $.each(item[actionType], function (i, action) {
        prx.easing.replaceUserPreset(action);
      });
    }
  }); // data dynamic properties

  $.each(prx.dynamicprops, function (i, dynpropType) {
    if (dynpropType in item && typeof item[dynpropType] !== "string") {
      $.each(item[dynpropType], function (i, dynprop) {
        $.each(prx.actions._actionTypes, function (i, actionType) {
          if (actionType in dynprop) {
            $.each(dynprop[actionType], function (i, action) {
              prx.easing.replaceUserPreset(action);
            });
          }
        });
      });
    }
  });
};

prx.easing.checkToOverwriteCustomEasingDuration = function (userpresetuuid, originalduration) {
  if (userpresetuuid === undefined) return originalduration;
  if (prx.utils.isValidUserPreset(userpresetuuid)) return prx.easing._customEasings[userpresetuuid]["duration"];
  return originalduration;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_fonts.js":
/*!****************************************************!*\
  !*** ./sass/player-engine/js/components/_fonts.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.fonts = {};
prx.fonts._fonts = [];

prx.fonts.loadProjectFonts = function () {
  var gFamilies = [];
  var kitsIds = {};
  var fontFaces = [];
  var cFamilies = [];
  var fakeTextStyles = [];

  var missedFonts = function missedFonts() {
    if (missedFonts.done) return;
    prx.crossmsg.send({
      action: 'missed-fonts'
    }); // prx.interface.triggerAppEvent('showToaster', [prx.lang.get("apps.toaster.missingFontTitle"), prx.lang.get("apps.toaster.missingFontText")]);

    prx["interface"].triggerAppEvent('showToaster', ['Missing Fonts', 'Some fonts used in this project are not available. A default font is displayed instead.']);
    missedFonts.done = true;
  };

  if ($('#custom-font-faces').length < 1) {
    $('html > head').append('<style id="custom-font-faces"></style>');
  }

  prx.fonts._fonts.forEach(function (font) {
    if (font.kitId && (font.project === prx.project.projectid || prx.spaces)) {
      kitsIds[font.kitId] = true;
    } else if (font.kitId && font.project !== prx.project.projectid) {
      missedFonts();
    } else if (font.type === 'googlefonts') {
      gFamilies.push("".concat(font.value, ":").concat(font.variants.toString()));
    } else if (font.type === 'uploadedfonts') {
      font.variants.forEach(function (variant, index) {
        if (!font.fonts || !font.fonts[index]) return;
        var fontGuid = font.fonts[index].guid;
        var weight = (variant.match(/[0-9]{3}/) || 400).toString();
        var style = (variant.match(/[^0-9]+/) || 'normal').toString();
        var url = prx.componentsHelper.getAssetUrl({
          assetType: 'project',
          fileId: fontGuid,
          isFont: true,
          extension: font.fonts[index].ext || 'woff',
          familyId: font.familyGuid
        });
        fontFaces.push("\n                    @font-face {\n                        font-family: \"".concat(font.value, "\";\n                        font-weight: ").concat(weight, ";\n                        font-style: ").concat(style, ";\n                        src: url('").concat(url, "') format('woff');\n                    }"));
        fakeTextStyles.push("font-family:".concat(font.value, ";font-weight:").concat(weight, ";font-style:").concat(style));
      });
      cFamilies.push(font.value);
    }
  });

  $('#custom-font-faces').html(fontFaces.join('')); // add fake elements with all custom fonts so they are all loaded on page load,
  // otherwise the browser will download them when they are used (e.g another screen), and cause FOUT

  $('body').append("\n        <div style=\"opacity: 0\">\n            ".concat(fakeTextStyles.map(function (style) {
    return "<span style=\"".concat(style, "\"></span>");
  }), "\n        </div>"));

  if (gFamilies.length > 0) {
    WebFont.load({
      classes: false,
      events: true,
      timeout: 15000,
      google: {
        families: gFamilies
      },
      inactive: function inactive() {//missedFonts();
      },
      fontinactive: function fontinactive() {//missedFonts();
      }
    });
  }

  var kitsIdsArray = Object.keys(kitsIds);
  kitsIdsArray.forEach(function (kitid) {
    WebFont.load({
      classes: false,
      events: true,
      timeout: 15000,
      typekit: {
        id: kitid
      },
      inactive: function inactive() {
        missedFonts();
      },
      fontinactive: function fontinactive() {
        missedFonts();
      }
    });
  });

  if (cFamilies.length > 0) {
    WebFont.load({
      classes: false,
      events: true,
      custom: {
        families: cFamilies
      },
      inactive: function inactive() {
        missedFonts();
      },
      fontinactive: function fontinactive() {
        missedFonts();
      }
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_groups.js":
/*!*****************************************************!*\
  !*** ./sass/player-engine/js/components/_groups.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.groups = function () {
  function multiplyActionsToNestedGroups(groups) {
    for (var group in groups) {
      if (groups.hasOwnProperty(group)) {
        if (groups[group].actions === undefined) groups[group].actions = [];
        var parents = getGroupParentGroups(group, groups);
        parents.forEach(function (parent) {
          if (groups[group].parentgroups === undefined) groups[group].parentgroups = [];
          groups[group].parentgroups.push(parent.id);

          if (parent.actions !== undefined) {
            parent.actions.forEach(function (action) {
              action.originaltarget = parent.id;
              groups[group].actions.push(JSON.parse(JSON.stringify(action)));
            });
          }
        });
      }
    }

    return groups;
  }

  function addDimPosToGroups(jState, cCanvasType, iCanvasIndex, iStateIndex) {
    for (var gid in jState.groups) {
      if (jState.groups.hasOwnProperty(gid)) {
        var items = getGroupItems(gid, jState);
        var box = prx.toolbox.calculateBox(items.map(function (item) {
          return prx.toolbox.itemDimensions(item, cCanvasType, iCanvasIndex, iStateIndex);
        }), jState.groups[gid].rotation || 0, cCanvasType, iCanvasIndex, iStateIndex);
        jState.groups[gid].width = box.width;
        jState.groups[gid].height = box.height;
        jState.groups[gid].top = box.top;
        jState.groups[gid].left = box.left;
        jState.groups[gid].rotation = box.rotation;
      }
    }

    return jState.groups;
  }

  function movePropsToChildren(jItem, jGroups) {
    if (typeof jGroups === 'undefined') return Object.assign(jItem, {
      parentgroups: []
    });

    function multiplyProps() {
      var props = [, 'saturate', 'brightness', 'contrast'];
      if (typeof jItem.group == 'undefined') return;
      var parents = getParentGroups(jItem.group, jGroups);
      props.forEach(function (prop) {
        var i = 0,
            val = typeof jItem[prop] !== 'undefined' ? jItem[prop] : 1;

        while (i < parents.length) {
          var g = parents[i++];
          val = typeof g[prop] !== 'undefined' ? val * g[prop] : val;
        }

        if (val !== 1) jItem[prop] = val;
      });
    }

    multiplyProps();
    if (typeof jItem.group == 'undefined') return;
    if (jItem.actions === undefined) jItem.actions = [];
    var parents = getParentGroups(jItem.group, jGroups);

    for (var i = 0; i < parents.length; i++) {
      if (typeof parents[i].actions === 'undefined') parents[i].actions = [];
      parents[i].actions.forEach(function (action) {
        action.originaltarget = parents[i].id;
        jItem.actions.push(JSON.parse(JSON.stringify(action)));
      });
    }

    jItem.parentgroups = parents.map(function (p) {
      return p.id;
    });
    return jItem;
  }

  function getGroupItems(gid, jState) {
    var data = JSON.parse(jState.data);
    var groups = jState.groups;

    function getAllItemIndexes(groupid) {
      var indexes = [],
          groupskv = getGroupKeyValues(groups);
      data.forEach(function (item, index) {
        if (item.group === groupid) indexes.push(index);
      });

      for (var gid in groupskv) {
        if (groupskv[gid] === groupid) indexes = indexes.concat(getAllItemIndexes(gid));
      }

      return indexes.unique().sort(function (a, b) {
        return a - b;
      });
    }

    return getAllItemIndexes(gid).map(function (index) {
      return data[index];
    });
  }

  function getGroupKeyValues(groups) {
    var groupskv = {};

    for (var gid in groups) {
      groupskv[gid] = groups[gid].parent;
    }

    return groupskv;
  } // gets parent groups of item, by passing the direct parent, so this includes the group whose id was passed as an argument


  function getParentGroups(gid, groups) {
    if (gid === 'root' || typeof groups[gid] === 'undefined') {
      return [];
    } else {
      return [groups[gid]].concat(getParentGroups(groups[gid].parent, groups));
    }
  }

  function getGroupParentGroups(gid, groups) {
    if (typeof groups[gid] === 'undefined' || groups[gid].parent == "root") {
      return [];
    } else {
      return [groups[groups[gid].parent]].concat(getGroupParentGroups(groups[gid].parent, groups));
    }
  }

  var getGroupData = function getGroupData(targetid) {
    var d = {};
    d.parent = $(targetid).parents('[data-state-id]').first();
    if (!d.parent.length) return false;
    d.targetid = targetid;
    d.parenttype = d.parent.hasClass('box') ? 'symbols' : 'pages';
    d.parentid = d.parenttype == "pages" ? d.parent.attr('data-id') : d.parent.attr('data-symbol-id');
    d.stateid = d.parent.attr('data-state-id');
    d.groupid = targetid.split('group-').pop();

    for (var parentindex = 0; parentindex < prxy[d.parenttype].length; parentindex++) {
      if (prxy[d.parenttype][parentindex].id == d.parentid) break;
    }

    for (var stateindex = 0; stateindex < prxy[d.parenttype][parentindex].states.length; stateindex++) {
      if (prxy[d.parenttype][parentindex].states[stateindex].id == d.stateid) break;
    }

    d.group = prxy[d.parenttype][parentindex].states[stateindex].groups[d.groupid];
    d.parentindex = parentindex;
    d.stateindex = stateindex;
    d.targetids = $(targetid).not('.group-action-prediv').map(function (index, item) {
      return '#' + item.id;
    }).toArray();
    return d;
  };

  var getItemDimentions = function getItemDimentions(groupData, scaled) {
    return groupData.targetids.map(function (id) {
      var dims = prx.items.getRealDimsAndPosFromDom(id);

      if (scaled === true) {
        var scalex = prx.scale.get(groupData.targetid, 'scalex');
        var scaley = prx.scale.get(groupData.targetid, 'scaley');
        var scaledWidth = dims.width * scalex;
        var scaledHeight = dims.height * scaley;
        var widthDiff = scaledWidth - dims.width;
        var heightDiff = scaledHeight - dims.height;
        var topDiff = heightDiff / 2;
        var leftDiff = widthDiff / 2;
        dims.width = scaledWidth;
        dims.height = scaledHeight;
        dims.left -= leftDiff;
        dims.top -= topDiff;
      }

      return prx.toolbox.itemDimensions(dims, groupData.parenttype, groupData.parentindex, groupData.stateindex);
    });
  };

  function redrawGroupActionDiv(targetid) {
    var target = $(targetid);
    if (target.length == 0) return;
    var groups = [];
    target.each(function () {
      var t = $(this).attr('class').split(' ').filter(function (s) {
        return s.indexOf('group') != -1;
      });
      groups = groups.concat(t);
    });
    var base = targetid.split('-box-');
    base.pop();
    base = base.join('-box-');
    groups.forEach(function (groupid) {
      var target = base + ' .' + groupid;
      var groupdata = getGroupData(target);
      var $actiondiv = $(target).siblings('.group-action-prediv[id*=' + groupdata.groupid + ']');
      if ($actiondiv.length == 0) return;
      var visibilities = $actiondiv[0].className.split(' ').filter(function (group) {
        return group.indexOf('group') !== -1 && group.indexOf('prediv') === -1;
      }).map(function (group) {
        return prx.visibility.get(base + ' .' + group, 'visible');
      });

      if (visibilities.indexOf(false) !== -1) {
        $actiondiv.addClass('hidden');
      } else {
        $actiondiv.removeClass('hidden');
      }

      var itemdimentions = getItemDimentions(groupdata);
      var groupdimentions = prx.toolbox.calculateBox(itemdimentions, groupdata.group.rotation, groupdata.parenttype, groupdata.parentindex, groupdata.stateindex);
      new TimelineMax().to($actiondiv, 0, {
        y: groupdimentions.top,
        x: groupdimentions.left,
        width: groupdimentions.width,
        height: groupdimentions.height,
        rotation: groupdimentions.rotation
      });
    });
  }

  return {
    getGroupData: getGroupData,
    getItemDimentions: getItemDimentions,
    movePropsToChildren: movePropsToChildren,
    redrawGroupActionDiv: redrawGroupActionDiv,
    getGroupItems: getGroupItems,
    multiplyActionsToNestedGroups: multiplyActionsToNestedGroups,
    addDimPosToGroups: addDimPosToGroups,
    getParentGroups: getParentGroups
  };
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_helper.js":
/*!*****************************************************!*\
  !*** ./sass/player-engine/js/components/_helper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.helper = {};

prx.helper.blurInputs = function () {
  $('input:focus, textarea:focus').blur();
};

prx.helper.rerenderActivePageWebkitIssue = function (e) {
  return; // ouffou

  var parent = $(e.gesture.target).parents('.box, .material-list-listitem, .waves-effect').first();

  if (parent.length > 0) {
    var classes = parent.attr('class').split(' ');
    var toavoid = ['type-material-morphing-lines', 'type-flipswitch', 'type-ios7-switch', 'material-list-listitem-type-withCheckbox', 'type-metro-onoff', 'type-android-onoffswitch', 'waves-effect'];

    for (var i = 0; i < classes.length; i++) {
      if (toavoid.indexOf(classes[i]) > -1) {
        return;
      }
    }
  }

  setTimeout(function () {
    if (!prx.scrollable.checkIfInTransition('.prx-page-active')) {
      // breaks animation on transition if we force rerender :(
      prx.utils.forceWebkitRerender($('.prx-page-active'));
    }
  }, 50);
};

prx.helper.onmobile = function () {
  // ANNAM THIS REGEX HAS BEEN EDITED TO INCLUDE IPADS!
  var a = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
};

prx.helper.onandroid = function () {
  return /android/i.test(navigator.userAgent.toLowerCase());
};

prx.helper.oniphone = function () {
  return /iphone/i.test(navigator.userAgent.toLowerCase());
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_ini-player.js":
/*!*********************************************************!*\
  !*** ./sass/player-engine/js/components/_ini-player.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.iniPlayer = {};

prx.iniPlayer.iniPreLoad = function () {
  if (prx.devices[prx.device]['portrait'][1] == 1136 && screen.height == 568) {
    // iPhone 4 (iPhone5/iOS6)
    document.querySelector("meta[name=viewport]").content = "width=320.1, minimum-scale=" + prx.devices[prx.device].initialscale + ", maximum-scale=" + prx.devices[prx.device].initialscale + ", initial-scale=" + prx.devices[prx.device].initialscale + ", user-scalable=no, target-densitydpi=" + prx.devices[prx.device].targetdensitydpi;
  }

  prx.iosmobilebrowser = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
  prx.orientation._orientation = prx.orientation.get();
  prx.orientation.changeBody(prx.orientation._orientation);
  if (!prx.inProtoApp) prx.inProtoApp = typeof prx.utils.getCookie('appbakerIosWrapper') != "undefined" || typeof prx.utils.getCookie('protoAppAndroidWrapper') != "undefined" || prx.mobPlayer;
  if (!prx.inProtoIOsApp) prx.inProtoIOsApp = typeof prx.utils.getCookie('appbakerIosWrapper') != "undefined";
  prx["interface"].isInProtoAndroidApp();
  if (!prx.inProtoAndroidApp) prx.inProtoAndroidApp = typeof prx.utils.getCookie('protoAppAndroidWrapper') != "undefined";

  if (typeof prx.xdata != "undefined") {
    prx.xdata = JSON.stringify(prx.xdata);
  }

  prx.youtube.ini();
};

prx.iniPlayer.iniDocumentLoad = function () {
  $('#dragarea').css('width', $(window).width() + 'px');
  $('#dragarea').css('height', $(window).height() + 'px');
  prx.statusNavBar.ini();
  prx.loading.load(prx.projectsettings.id);
  prx.showActions.iniShift();
  prx.clickEffect.ini();
  prx.showActions.flash.ini();
  prx.analytics.ini();
  prx.crossmsg.ini();
  prx.navigation.iniScreenNavigation();
  prx.variables.initSandbox();
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_interface.js":
/*!********************************************************!*\
  !*** ./sass/player-engine/js/components/_interface.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {/* HELPER FUNCTIONS FOR ACCESS FROM PREVIEW AND APPS */
prx["interface"] = {};

prx["interface"].goToPage = function (pageid) {
  _currentpage = '#' + prx.navigation._activepage;
  prx.navigation.pushToBackStack(_currentpage, 'none', 0, 'linear', 'screens');
  /*prx.navigation.changePage($('#p-'+pageid), {
      allowSamePageTransition: true
  });*/

  prx.actionsLibrary.goToPage({
    pageId: pageid,
    animation: "none",
    delay: "0"
  });
};

prx["interface"].getActivePageId = function () {
  return prx.navigation._activepage.substring(2);
};

prx["interface"].triggerKeydownAction = function (key) {
  //$(document).trigger(e);
  //$('body').trigger(e);
  var event = $.Event("keydown");
  event.which = key;
  $('body').trigger(event);
};

prx["interface"].triggerOrientationChange = function () {
  prx.orientation.change();
};

prx["interface"].triggerBodyOrientationChange = function () {
  prx.orientation.changeBody();
};

prx["interface"].changeInitialScale = function (newInitialScale) {
  var viewport = document.querySelector("meta[name=viewport]");

  if (viewport != null) {
    var settings = ['minimum-scale', 'maximum-scale', 'initial-scale'];
    var content = viewport.content.split(',');

    for (var i = 0; i < settings.length; i++) {
      for (var j = 0; j < content.length; j++) {
        if (content[j].trim().indexOf(settings[i] + '=') == 0) {
          //content.splice(j,1);
          content[j] = settings[i] + '=' + newInitialScale;
          break;
        }
      }
    }

    viewport.content = content.join(',');
  }
};

prx["interface"].changeTargetDensityDPI = function (newTD) {
  var viewport = document.querySelector("meta[name=viewport]");

  if (viewport != null) {
    var settings = ['target-densitydpi'];
    var content = viewport.content.split(',');

    for (var i = 0; i < settings.length; i++) {
      for (var j = 0; j < content.length; j++) {
        if (content[j].trim().indexOf(settings[i] + '=') == 0) {
          content[j] = settings[i] + '=' + newTD;
          break;
        }
      }
    }

    viewport.content = content.join(',');
  }
};

prx["interface"].changeViewport = function (newViewport) {
  var viewport = document.querySelector("meta[name=viewport]");

  if (viewport != null) {
    viewport.content = newViewport;
  }
};

prx["interface"].previewFrameLeave = function () {
  //alert('preview frame leave');
  prx.scrollable.endTransitions();
};

prx["interface"].previewPanEnd = function () {
  //alert('preview frame leave');
  prx.scrollable.endTransitions();
};

prx["interface"].devices = {};

prx["interface"].devices.getDeviceInfo = function () {
  return prx.devices[prx.device];
};

prx["interface"].inProtoIOsApp = function (deviceinfo) {
  /*
  {
  	versionName: '1.57',
  	versionCode, '157',
  	offline: boolean,
  	device: 'iPhone',
  	osName: 'iOS',
  	osVersion: '8.1'
  }
  */
  prx.inProtoApp = true;
  prx.inProtoIOsApp = true; //alert('ios app true!!')
}; // this function is called from old versions of the Android app
// but sometimes fails because prx has not been initialized yet


prx["interface"].inProtoAndroidApp = function () {
  /*
  {
  	versionName: '',
  	versionCode, '',
  	offline: boolean,
  	device: 'Nexus 5',
  	osName: 'Android',
  	osVersion: '4.4'
   }
  */
  prx.inProtoApp = true;
  prx.inProtoAndroidApp = true;
}; // this function is like the above but is actively called from the
// engine to the app so that prx is ready to store it


prx["interface"].isInProtoAndroidApp = function () {
  try {
    var newValue = oProtoAndroidApi.inProtoAndroidApp();
    prx.inProtoAndroidApp = newValue;
    prx.inProtoApp = true;
  } catch (e) {}
};

prx["interface"].triggerAppEvent = function (event, params) {
  prx["interface"].triggeriOSAppEvent(event, params);
  prx["interface"].triggerAndroidAppEvent(event, params);
};

prx["interface"].triggeriOSAppEvent = function (event, params) {
  //alert(prx.inProtoIOsApp)
  if (!prx.inProtoIOsApp) return;
  if (params === undefined) params = [];
  event = encodeURIComponent(event);
  params = params.map(function (el) {
    return encodeURIComponent(el);
  });
  window.location = "protojs://" + event + (params.length ? '/' + params.join('/') : ''); //alert("protojs://" + event + (params.length ? '/' + params.join('/') : ''));
};

prx["interface"].triggerAndroidAppEvent = function (event, params) {
  if (!(prx.inProtoAndroidApp || prx.helper.onandroid())) return;

  try {
    switch (event) {
      case "pageChanged":
        oProtoAndroidApi.pageChanged(params[0]);
        break;

      case "loaderShown":
        oProtoAndroidApi.loaderShown();
        break;

      case "loaderHidden":
        oProtoAndroidApi.loaderHidden();
        break;

      case "showToaster":
        oProtoAndroidApi.showToast(params[0], params[1]);
        break;

      default:
        break;
    }
  } catch (e) {}
};

prx["interface"].getAndroidAppStartScreen = function () {
  if (!(prx.inProtoAndroidApp || prx.helper.onandroid())) return prx.projectsettings.initialpageid;

  try {
    return oProtoAndroidApi.getStartScreen();
  } catch (e) {
    return prx.projectsettings.initialpageid;
  }
};

prx["interface"].forceInputFocus = function (inputid) {
  $('#' + inputid + ' input, #' + inputid + ' textarea').trigger('click.fakefocus');
}; // duplicate other used functinos under interface for maintainability.


prx["interface"].showLoader = prx.loading.showLoader;
prx["interface"].startShowLoader = prx.loading.startShowLoader;
prx["interface"].startHideLoader = prx.loading.startHideLoader;
prx["interface"].showActions = {};
prx["interface"].showActions.on = prx.showActions.on;
prx["interface"].showActions.off = prx.showActions.off;
prx["interface"].showActions.flash = {};
prx["interface"].showActions.flash.enable = prx.showActions.flash.enable;
prx["interface"].showActions.flash.disable = prx.showActions.flash.disable;
prx["interface"].stc = {};
prx["interface"].stc.screens = {};
prx["interface"].stc.screens.getIndexFromId = prx.stc.screens.getIndexFromId;
prx["interface"].getActivePageActiveStates = prx.states.getActivePageActiveStates;
prx["interface"].clickEffect = {};
prx["interface"].clickEffect.scale = prx.clickEffect.scale;
prx["interface"].clickEffect.show = prx.clickEffect.show;
prx["interface"].clickEffect.hide = prx.clickEffect.hide; // need to keep the original functions for backwards compatibility with apps

prx.goToPage = prx["interface"].goToPage;
prx.triggerKeydownAction = prx["interface"].triggerKeydownAction;
prx.changeInitialScale = prx["interface"].changeInitialScale;
prx.changeTargetDensityDPI = prx["interface"].changeTargetDensityDPI;
prx.changeViewport = prx["interface"].changeViewport;
prx.changeOrientation = prx.orientation.change;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_loading.js":
/*!******************************************************!*\
  !*** ./sass/player-engine/js/components/_loading.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

prx.loading = {};
prx.loading.imagesToPreload = [];
prx.loading.imagesToBase64 = [];
prx.loading.maskImagesToBase64 = [];
prx.loading.imagesToBodymovinAnimeData = {}; // prx.loading.bodymovinAnimData = {};

prx.loading.load = function (filename) {
  var _filename = filename;

  var _xt = new Date().getTime();

  prx.loading.handleSpecialDeviceTypes();
  prx.loading.showLoader();

  if (typeof prx.xdata == "undefined") {
    if (prx.spaces) {
      $.post("/project/livepreview/loaddata/?x=" + _xt, {
        filename: prx.projectsettings.s3b
      }, function (output) {
        prx.loading.iniData(output);
      });
    } else if (prx.prto) {
      $.post("/prto/livepreview/data/load/?x=" + _xt, {
        filename: _filename,
        short_cd: prx.projectsettings.v,
        s3b: prx.projectsettings.s3b,
        jt: prx.jt
      }, function (output) {
        prx.loading.iniData(output);
      });
    } else {
      $.post("/editor/data/loadpublished/?x=" + _xt, {
        filename: _filename,
        v: prx.projectsettings.v,
        s3b: prx.projectsettings.s3b
      }, function (output) {
        prx.loading.iniData(output);
      });
    }
  } else {
    // allow some time to render loader on apps
    setTimeout(function () {
      try {
        var dataToBeSent = JSON.parse(prx.xdata);
      } catch (e) {
        var dataToBeSent = prx.xdata;
      }

      prx.loading.iniData(dataToBeSent);
    }, 50);
  }
};

prx.loading.loadDone = function () {
  // annam isp. i need to set startscreen before i call player-ready, because player-ready needs the correct startscreen
  // but i also need to call inistartscreen after player-ready so that the preview has the data provided in player-ready to highlight page and change orientation.
  // so im breaking the startscreen function into two.
  prx.loading.setStartScreen(); // calls function in player-ui.js (when previewing in web.cfm) to build screen browser

  if (!parent != window) {
    try {
      var data = {
        pages: JSON.parse(JSON.stringify(prxy.pages)),
        symbols: JSON.parse(JSON.stringify(prxy.symbols)),
        startscreen: prx.navigation._activepage.replace('p-', ''),
        device: prx.devices[prx.device],
        csrf_token: prx.csrf_token
      };

      if (typeof prx.sort != "undefined") {
        data.sort = prx.sort.pages;
      }

      prx.crossmsg.send({
        action: 'player-ready',
        data: data
      });
    } catch (err) {}

    ;
  }

  prx.loading.iniStartScreen(); //THIS PREVENTS THE DOUBLE TRIGGER EVENT ON CLICK
  //v5.9.8.3 this doesnt seem to apply anymore?

  /*
   $(':input').on('click', function(e) {
   e.stopPropagation();
   });
   */
  // v5.9.8.3 due to hammer for some reason inputs do not get focused
  // v5.9.8.4 fixed with hammer.options.touchAction = 'auto';
  // v5.9.22 i've removed touchAction='auto', now this seems to happen when pinch interactions exist in project (causing touchAction='none') but only if input has interactions attached to it? Though a client had this issue on an input with no interactions, i wasn't able to replicate.
  // v5.9.23 now trying to force pinch to 'pan-x pan-y' touchAction so this should be ok without the focus() (which i think might be causing extra issues)

  /*
   $(document).on('touchstart', ':input', function(e) {
   $(this).focus();
   });
   */

  /* SCROLLABLE TABBARS */

  for (var i = 0; i < prx.scrollable._scrollableTabbars.length; i++) {
    prx.scrollable.iniTabbar(i);
  }
  /* /SCROLLABLE TABBARS */

};

prx.loading.iniData = function (data) {
  if (typeof inputdata === "string") var _project = JSON.parse(data);else var _project = data;
  prx.project = _project.project;
  prxy.pages = _project.pages;
  prxy.symbols = _project.symbols;
  prx.templates = _project.templates;
  prx.variables._variables = _project.variables;
  prx.variables.prepare(); // set defaults to undefined

  if (typeof _project.fonts != 'undefined') {
    prx.fonts._fonts = _project.fonts;
  }

  if (typeof _project.customEasings != 'undefined') {
    prx.easing._customEasings = _project.customEasings;
  }

  if (typeof _project.sort != 'undefined') {
    prx.sort = _project.sort;
  }

  for (var n = 0; n < prxy.pages.length; n++) {
    if (typeof prxy.pages[n].id == 'undefined') {
      // fix for Nan
      prxy.pages.splice(n, 1); // remove problematic item
    } else {
      prxy.pages[n].id = parseInt(prxy.pages[n].id);
    }
  }

  for (var n = 0; n < prxy.symbols.length; n++) {
    //prxy.symbols[n].id = parseInt(prxy.symbols[n].id);
    if (typeof prxy.symbols[n].id == 'undefined') {
      // fix for Nan
      prxy.symbols.splice(n, 1); // remove problematic item
    } else {
      prxy.symbols[n].id = parseInt(prxy.symbols[n].id);
    }

    for (var i = 0; i < prxy.symbols[n].states.length; i++) {
      prxy.symbols[n].states[i].symbolid = prxy.symbols[n].id;
    }
  }

  for (var n = 0; n < prx.templates.length; n++) {
    //prx.templates[n].id = parseInt(prx.templates[n].id);
    if (typeof prx.templates[n].id == 'undefined') {
      // fix for Nan
      prx.templates.splice(n, 1); // remove problematic item
    } else {
      prx.templates[n].id = parseInt(prx.templates[n].id);
    }
  }

  if (typeof _project.v5 != "undefined" && _project.v5) {
    prx.v5 = _project.v5;
  } else {
    prx.compatibility.v5.ini();
  }

  if (typeof _project.v5x11 != "undefined" && _project.v5x11) {
    prx.v5x11 = _project.v5x11;
  } else {
    prx.compatibility.responsiveComponents.ini();
  }

  if (typeof _project.dropboxfs != "undefined" && _project.dropboxfs) {
    prx.dropboxfs = _project.dropboxfs;
  } else {
    prx.dropboxfs = false;
  }

  if (typeof _project.richtext != "undefined" && _project.richtext) {
    prx.richtext = _project.richtext;
  }

  if (typeof _project.iscrolljs != "undefined") {
    prx.compatibility.iscrolljs = _project.iscrolljs;
  }

  if (typeof _project.scrolltotop != "undefined") {
    prx.scrolltotop = _project.scrolltotop;
  }

  if (typeof _project.dpr != "undefined") {
    prx.responsiveComponents.dpr = _project.dpr;
  }

  if (typeof _project.fontStyleCompatibility != "undefined") {
    prx.fontStyleCompatibility = _project.fontStyleCompatibility;
  } else {
    prx.compatibility.fontStyleCompatibility.ini();
  }

  if (typeof _project.transition === 'undefined') {
    prx.transition = {
      duration: 0,
      delay: 0,
      easing: 'out'
    }; // this ksimarisia is for half a day where this was live on proto 6 launch day but _project.transition was not correctly saved
  } else if (typeof _project.transition === 'undefined' && _project.stateTransitionUpgraded !== undefined) {
    prx.transition = {
      duration: 0.25,
      delay: 0,
      easing: 'out'
    };
  } else {
    prx.transition = JSON.parse(_project.transition);

    if (prx.utils.isValidUserPreset(prx.transition.easing)) {
      prx.transition.userpresetuuid = prx.transition.easing;
      prx.transition.duration = prx.easing._customEasings[prx.transition.easing].duration;
      prx.transition.easing = prx.easing._customEasings[prx.transition.easing].easing;
    }
  }

  if (typeof _project.stateTransitionToMSUpgraded != "undefined" && _project.stateTransitionToMSUpgraded) {
    prx.stateTransitionToMSUpgraded = _project.stateTransitionToMSUpgraded;
  } else {
    prx.compatibility.stateTransitionsToMs.ini();
  }

  if (typeof _project.galleryAssetsToStaticV2 != "undefined" && _project.galleryAssetsToStaticV2) {
    prx.galleryAssetsToStaticV2 = _project.galleryAssetsToStaticV2;
  } else {
    prx.compatibility.galleryAssetsToStatic.runCompatibility();
  }

  var _temporientation = prx.orientation.get();

  if (_temporientation != 'portrait') {
    if (typeof prx.project.startscreenlandscape == "undefined") {
      prx.project.startscreenlandscape = 1;
    }
  }

  prx.mpasset = {};
  prx.mpasset._imgs_version = 0;

  if (typeof _project._imgs_version != "undefined") {
    prx.mpasset._imgs_version = _project._imgs_version;
  }

  prx.fonts.loadProjectFonts();
  prx.loading.initialDataManipulation();
  _project = null; // perf+

  prx.canvas.ini();
  prx.loading.runningLoader();
};

prx.loading.handleSpecialDeviceTypes = function () {
  // iphone X notch
  var $iphoneXNotch = $('#iphoneX-notch-player');

  if (typeof prx.devices[prx.device].showiPhoneXNotch != 'undefined' && prx.devices[prx.device].showiPhoneXNotch) {
    if (!prx.helper.onmobile()) {
      prx.devices[prx.device].showiPhoneXNotch = false;
      return;
    }

    if (prx.helper.oniphone()) {
      var isIphoneXXS = window.screen.height == '812' && window.screen.width == '375' || window.screen.height == '375' && window.screen.width == '812';
      var isIphoneXR = window.screen.height == '828' && window.screen.width == '1792' || window.screen.height == '1792' && window.screen.width == '828';
      var isIphoneXSMAX = window.screen.height == '414' && window.screen.width == '896' || window.screen.height == '896' && window.screen.width == '414';

      if (isIphoneXR || isIphoneXXS || isIphoneXSMAX) {
        prx.devices[prx.device].showiPhoneXNotch = false;
        return;
      }
    }

    if ($iphoneXNotch.length > 0) {
      var data_orientation = prx.orientation.getWindowOrientationForMobileDevices(); // $('#rotation1').html(prx.orientation._orientation + '-p' + (data_orientation !== undefined && data_orientation == -90 ? '-minus90' : '') + ' / ' + data_orientation)

      $iphoneXNotch.removeClass().addClass(prx.orientation._orientation + '-p' + (data_orientation !== undefined && data_orientation == -90 ? '-minus90' : ''));

      if (prx.helper.onandroid() && typeof window != 'undefined' && $('body').length == 1) {
        //outer html in android app is the original size and the inner is the scaled. Absolute position and 50% left calculates 50% based on html.
        //The issue doesnt exist on iOS since scaling is being handled in a different way
        if (prx.orientation._orientation == 'portrait') {
          var ratio = $('body').width() / $(window).width();
          ;
          var newLeftCenter = ratio * 50;
          $iphoneXNotch.css('left', newLeftCenter + '%').css('top', 0);
        } else if (prx.orientation._orientation == 'landscape') {
          var ratio = $('body').height() / $(window).height();
          ;
          var newTopCenter = ratio * 50;
          $iphoneXNotch.css('top', newTopCenter + '%').css('left', 0);
        }
      }
    }
  }
};

prx.loading.initialDataManipulation = function () {
  var _doCanvas = function _doCanvas(jCanvas, cCanvasType, iCanvasIndex, vr) {
    // screen interactions
    if (jCanvas.actions !== undefined && jCanvas.actions.length > 0) {
      $.each(jCanvas.actions, function (i, action) {
        prx.quickaudio.recursivelySearchActionForPlayAudio(action);
        prx.easing.replaceUserPreset(action);
      });
    }

    for (var transition in jCanvas.state_transitions) {
      if (jCanvas.state_transitions.hasOwnProperty(transition)) {
        for (var item in jCanvas.state_transitions[transition]) {
          if (jCanvas.state_transitions[transition].hasOwnProperty(item)) {
            for (var prop in jCanvas.state_transitions[transition][item]) {
              if (jCanvas.state_transitions[transition][item].hasOwnProperty(prop)) {
                prx.easing.replaceUserPreset(jCanvas.state_transitions[transition][item][prop]);
              }
            }
          }
        }
      }
    }

    jCanvas.states.forEach(function (state, iStateIndex) {
      // state interactions
      if (state.actions !== undefined && state.actions.length > 0) {
        $.each(state.actions, function (i, action) {
          prx.quickaudio.recursivelySearchActionForPlayAudio(action);
          prx.easing.replaceUserPreset(action);
        });
      } // background image


      if (state.hasOwnProperty('backgroundImg')) {
        prx.loading.getAllImages({
          img: state.backgroundImg
        }, vr);
      }

      if (state.groups !== undefined) {
        for (var gid in state.groups) {
          if (state.groups.hasOwnProperty(gid)) {
            if (state.groups[gid].actions === undefined) continue;
            $.each(state.groups[gid].actions, function (i, action) {
              prx.quickaudio.recursivelySearchActionForPlayAudio(action);
              prx.easing.replaceUserPreset(action);
            });
          }
        }
      }

      var data = JSON.parse(state.data);

      if (data !== undefined && data.length > 0) {
        $.each(data, function (iItemIndex, item) {
          prx.loading.getAllImages(item, vr);
          prx.quickaudio.searchItem(item);
          prx.easing.searchItem(item);
          prx.items.addToAllItemsStruct(item, cCanvasType, iCanvasIndex, state.id, iStateIndex, iItemIndex);
          item = prx.groups.movePropsToChildren(item, state.groups);
        });
      }

      state.data = JSON.stringify(data); // needs to be after data manipulation

      state.groups = prx.groups.multiplyActionsToNestedGroups(state.groups);
      state.groups = prx.groups.addDimPosToGroups(state, cCanvasType, iCanvasIndex, iStateIndex);
    });
  }; // loop all pages, symbols and templates here.


  prxy.pages.forEach(function (page, i) {
    _doCanvas(page, 'pages', i);
  });
  prx.templates.forEach(function (template, i) {
    _doCanvas(template, 'templates', i);
  });
  prxy.symbols.forEach(function (symbol, i) {
    if (symbol.vr) {
      _doCanvas(symbol, 'symbols', i, true);
    } else {
      _doCanvas(symbol, 'symbols', i);
    }
  });
  prx.quickaudio.preload();
}; // load and convert images to base64 for idiotropous browsers


prx.loading.convertToBase64Loader = function () {
  var _noOfImgs = prx.loading.imagesToBase64.length + prx.loading.maskImagesToBase64.length + prx.loading.imagesToPreload.length + Object.keys(prx.loading.imagesToBodymovinAnimeData).length;

  var _loadedImgs = prx.loading.imagesToPreload.length + Object.keys(prx.loading.imagesToBodymovinAnimeData).length;

  if (_loadedImgs >= _noOfImgs) {
    prx.loading.loaderprogress(100, $('.progress-bar'));
    setTimeout(function () {
      prx.loading.hideLoader();
      prx.loading.loadDone();
    }, 1000);
    return;
  }

  var loadImg = function loadImg(asset, type) {
    var image = new Image();
    image.crossOrigin = 'Anonymous'; // need this from cross origin images in order to not lock the canvas

    image.addEventListener('load', function (e) {
      _loadedImgs++; // update progress bar

      var progress = Math.round(_loadedImgs / _noOfImgs * 100);
      prx.loading.loaderprogress(progress, $('.progress-bar')); // create canvas

      var canvas = document.createElement('CANVAS');
      var ctx = canvas.getContext('2d');
      var dataURL;
      canvas.height = this.naturalHeight;
      canvas.width = this.naturalWidth;
      ctx.drawImage(this, 0, 0); // get image from canvas on base64

      dataURL = canvas.toDataURL('image/png');

      if (type == 'VR') {
        prx.vr.images[asset.fileId] = dataURL;
      }

      if (type == 'maskImage') {
        prx.mask.images[asset.fileId] = dataURL;
      }

      if (_loadedImgs >= _noOfImgs) {
        setTimeout(function () {
          prx.loading.hideLoader();
          prx.loading.loadDone();
        }, 1000);
      }
    });
    image.addEventListener('error', function (e) {
      _loadedImgs++;

      if (_loadedImgs >= _noOfImgs) {
        setTimeout(function () {
          prx.loading.hideLoader();
          prx.loading.loadDone();
        }, 1000);
      }
    });
    image.src = asset.assetURL;
  };

  for (var i = 0; i < prx.loading.imagesToBase64.length; i++) {
    var asset = JSON.parse(prx.loading.imagesToBase64[i]);
    loadImg(asset, 'VR');
  }

  ;

  for (var i = 0; i < prx.loading.maskImagesToBase64.length; i++) {
    var asset = JSON.parse(prx.loading.maskImagesToBase64[i]);
    loadImg(asset, 'maskImage');
  }

  ;
  setTimeout(function () {
    if ($('#loader-wrapper').hasClass('loader-visible')) {
      prx.loading.hideLoader();
      prx.loading.loadDone();
      $('[data-role=page] img:not([src=""])').unbind("load error");
    }
  }, 10000);
};

prx.loading.runningLoader = function () {
  //var _noOfImgs = $('[data-role=page] img:not([src=""])').length;
  var _noOfImgs = prx.loading.imagesToPreload.length;
  var _loadedImgs = 0;
  var _noOfJSONanimations = Object.keys(prx.loading.imagesToBodymovinAnimeData).length;
  var _loadedJSONs = 0;

  var _totalAssets = prx.loading.imagesToPreload.length + prx.loading.imagesToBase64.length + prx.loading.maskImagesToBase64.length + _noOfJSONanimations; //console.log(prx.loading.imagesToPreload);


  if (_noOfImgs == 0 && _noOfJSONanimations === 0) {
    prx.loading.loaderprogress(100, $('.progress-bar'));
    setTimeout(function () {
      //prx.loading.hideLoader();
      prx.loading.convertToBase64Loader();
    }, 1000);
  }

  var _loop = function _loop(key) {
    $.get(JSON.parse(prx.loading.imagesToBodymovinAnimeData[key]).assetURL, function (data) {
      if (_typeof(data) == 'object') {
        prx.bodymovinAnimation.assets[key] = JSON.stringify(data);
      } else {
        prx.bodymovinAnimation.assets[key] = data;
      }

      _loadedJSONs++;
      var progress = Math.round((_loadedImgs + _loadedJSONs) / _totalAssets * 100);
      prx.loading.loaderprogress(progress, $('.progress-bar'));

      if (_loadedImgs >= _noOfImgs && _loadedJSONs >= _noOfJSONanimations) {
        setTimeout(function () {
          //prx.loading.hideLoader();
          prx.loading.convertToBase64Loader();
        }, 1000);
      } // }

    }).fail(function () {
      _loadedJSONs++;
    });
  };

  for (var key in prx.loading.imagesToBodymovinAnimeData) {
    _loop(key);
  } //$('[data-role=page] img[src]:not([src=""])').each(function () {


  for (var i = 0; i < _noOfImgs; i++) {
    // this creates a new dummy image, it first attaches the onload event and then adds the src attr to start loading the image
    // this makes sure that the onload event always triggers.
    var asset = JSON.parse(prx.loading.imagesToPreload[i]);
    var img = $('<img>').bind("load error", function () {
      _loadedImgs++;
      var progress = Math.round((_loadedImgs + _loadedJSONs) / _totalAssets * 100);
      prx.loading.loaderprogress(progress, $('.progress-bar'));

      if (_loadedImgs >= _noOfImgs && _loadedJSONs >= _noOfJSONanimations) {
        setTimeout(function () {
          //prx.loading.hideLoader();
          prx.loading.convertToBase64Loader();
        }, 1000);
      } //Remove img
      //$(this).remove();

    });
    if (asset.crossOrigin !== "") img.attr('crossOrigin', asset.crossOrigin);
    img.attr('src', asset.assetURL);
  }

  ;
  setTimeout(function () {
    if ($('#loader-wrapper').hasClass('loader-visible')) {
      // prx.loading.hideLoader();
      prx.loading.convertToBase64Loader();
      $('[data-role=page] img:not([src=""])').unbind("load error");
    }
  }, 10000);
};

prx.loading.startShowLoader = function () {
  $('body').addClass('reloading'); //$('body').addClass('fadedOut');
};

prx.loading.startHideLoader = function () {
  $('body').removeClass('reloading'); //$('body').addClass('fadedOut');
};

prx.loading.showLoader = function (reload) {
  //$('#loader-wrapper').addClass('loader-visible');
  $('#loader-wrapper').show();
  prx["interface"].triggerAppEvent('loaderShown');
};

prx.loading.hideLoader = function () {
  //$('#loader-wrapper').removeClass('loader-visible');
  // 2015-09-25:( android chrome 45 was having issues with pointer-events (probably?) so im javascript-fading instead of using css :(
  $('#loader-wrapper').fadeOut(300, function () {
    // WKWebView problem with misplaced screen when zoomed fix
    if (prx.iosmobilebrowser) {
      document.body.scrollLeft = 0;
      document.body.scrollTop = 0;
    }

    prx["interface"].triggerAppEvent('loaderHidden');
  });
};

prx.loading.loaderprogress = function (percent, $element) {
  $element.width(percent + '%');
};

prx.loading.setStartScreen = function () {
  var _activePage;

  switch (prx.orientation._orientation) {
    case "portrait":
      _activePage = 'p-' + prx.project.startscreen;

      if ($('#' + _activePage).length == 0) {
        _activePage = 'p-' + prx.project.startscreenlandscape;
      }

      break;

    case "landscape":
      _activePage = 'p-' + prx.project.startscreenlandscape;

      if ($('#' + _activePage).length == 0) {
        _activePage = 'p-' + prx.project.startscreen;
      }

      break;
  }

  prx.projectsettings.initialpageid = prx["interface"].getAndroidAppStartScreen(); // for comment emails i think

  if (prx.projectsettings.initialpageid != -1 && $('#p-' + prx.projectsettings.initialpageid).length != 0) {
    _activePage = 'p-' + prx.projectsettings.initialpageid;
  }

  if (window.location.hash != '') {
    _activePage = 'p-' + window.location.hash.replace('#', '');
  }

  if ($('#' + _activePage).length == 0) {
    _activePage = 'p-' + prxy.pages[0].id;
  }

  prx.navigation._activepage = _activePage;
  prx.navigation._initialPage = prx.navigation._activepage;
};

prx.loading.iniStartScreen = function () {
  var _activePage = typeof prx.navigation._initialPage !== 'undefined' ? prx.navigation._initialPage : prx.navigation._activepage;

  var _page = prx.stc.screens.getStructFromId(_activePage);

  var _pageorientation = prx.orientation.getPage(_page);

  prx.navigation.changePage($('#' + _activePage), {
    transition: 'none',
    changeHash: false
  }); // $('#' + _activePage).append('<div style="position:absolute;top:0;left:0;width:100%;height:200px;color:white;background:black;">show iphonex notch: ' + prx.devices[prx.device]['showiPhoneXNotch'] + '</div>');

  prx.analytics.trackPage(_page.id); // because hash doesnt change.

  if (prx.orientation._orientation != _pageorientation) {
    /* change skin orientation if on web player */
    if (!prx.embed && parent != window) {
      try {
        prx.crossmsg.send({
          action: 'switch-orientation'
        });
      } catch (err) {}

      ;
    }

    prx.orientation.change(_pageorientation);
  }

  if (prx.projectsettings.initialpageid != -1) {
    // not sure why this is needed?
    $('#' + prx.navigation._activepage).trigger('orientationchange');
  }
};
/**gy**/


prx.loading.getAllImages = function (item, vr) {
  function getImageSrcAndSave(images, item) {
    if (typeof images == 'undefined') {
      return;
    }

    var imageExtensions = ['jpg', 'jpeg', 'png', 'svg', 'gif'];
    var componentTypesContainingMaskImages = ['basic_tabbar', 'basic_tabbar_icon', 'basic_tabbar_texticon', 'tabbar_retina', 'tabbar', 'material_textfield', 'ios7_tabbar', 'material_tabbar_segmented_button', 'basic_buttongroup', 'basic_buttongroup_horizontal_text', 'basic_buttongroup_horizontal_texticon_right', 'basic_buttongroup_horizontal_texticon_top', 'basic_buttongroup_horizontal_icon', 'basic_buttongroup_vertical_text', 'basic_buttongroup_vertical_texticon', 'basic_buttongroup_vertical_icon'];
    var dataExtensions = ['json'];
    var allowedExtensions = imageExtensions.concat(dataExtensions);
    var isImage = allowedExtensions.indexOf(images.fileId.substr(images.fileId.lastIndexOf('.') + 1)) > -1 ? true : false;

    if (isImage) {
      var assetURL = prx.componentsHelper.getAssetUrl(images);
      var crossOrigin = '';

      if (vr) {
        if (!prx.export2html) {
          crossOrigin = 'anonymous';

          if (assetURL.indexOf('access_token=') === -1) {
            if (assetURL.indexOf('?') === -1) {
              assetURL += '?access_token=' + prx.assetsAccessToken;
            } else {
              assetURL += '&access_token=' + prx.assetsAccessToken;
            }
          }

          assetURL += '&VR=1';
        }
      }

      if (images.fileId.toLowerCase().indexOf(".json") > -1) {
        if (!prx.export2html) {
          if (assetURL.indexOf('access_token=') === -1) {
            if (assetURL.indexOf('?') === -1) {
              assetURL += '?access_token=' + prx.assetsAccessToken;
            } else {
              assetURL += '&access_token=' + prx.assetsAccessToken;
            }
          }
        }
      }

      var asset = JSON.stringify({
        assetURL: assetURL,
        crossOrigin: crossOrigin,
        fileId: images.fileId
      });

      if (prx.loading.imagesToPreload.indexOf(asset) == -1) {
        // safari causes issues loading images (except gifs) from cross origins in vr mode
        // for this reason non gif images that will used in vr mode are converted to base64 using canvas
        // important: gifs sould not converted to base64 because converting using canvas will capture only the first frame
        if (prx.vr.crossOriginUnsupported() && vr && images.fileId.toLowerCase().indexOf(".gif") === -1) {
          if (prx.loading.imagesToBase64.indexOf(asset) === -1) prx.loading.imagesToBase64.push(asset);
        } else if (typeof item != 'undefined' && typeof item['type'] != 'undefined' && componentTypesContainingMaskImages.indexOf(item['type']) > -1 && prx.export2html) {
          if (prx.loading.maskImagesToBase64.indexOf(asset) === -1) {
            prx.loading.maskImagesToBase64.push(asset);
          }
        } else if (images.fileId.toLowerCase().indexOf(".json") > -1) {
          if (!prx.export2html) {
            if (prx.loading.imagesToBodymovinAnimeData[images.fileId] === undefined) prx.loading.imagesToBodymovinAnimeData[images.fileId] = asset;
          }
        } else {
          if (prx.loading.imagesToPreload.indexOf(asset) === -1) prx.loading.imagesToPreload.push(asset);
        }
      }
    }

    return;
  }

  for (var key in item) {
    if (item.hasOwnProperty(key)) {
      if (_typeof(item[key]) == "object" && item[key] !== null && typeof item[key].assetType != "undefined") {
        getImageSrcAndSave(item[key], item);
      } else {
        for (var i = 0; i < prx.dynamicprops.length; i++) {
          if (typeof item[prx.dynamicprops[i]] != "undefined") {
            for (var j = 0; j < item[prx.dynamicprops[i]].length; j++) {
              for (var key in item[prx.dynamicprops[i]][j]) {
                if (item[prx.dynamicprops[i]][j].hasOwnProperty(key)) {
                  if (_typeof(item[prx.dynamicprops[i]][j][key]) == "object" && item[prx.dynamicprops[i]][j][key] !== null && typeof item[prx.dynamicprops[i]][j][key].assetType != "undefined") {
                    getImageSrcAndSave(item[prx.dynamicprops[i]][j][key], item);
                  }
                }

                if (key === 'actions') {
                  for (var k = 0; k < item[prx.dynamicprops[i]][j].actions.length; k++) {
                    for (var key2 in item[prx.dynamicprops[i]][j].actions[k]) {
                      if (item[prx.dynamicprops[i]][j].actions[k].hasOwnProperty(key2)) {
                        if (_typeof(item[prx.dynamicprops[i]][j].actions[k][key2]) == "object" && item[prx.dynamicprops[i]][j].actions[k][key2] !== null && typeof item[prx.dynamicprops[i]][j].actions[k][key2].assetType != "undefined") {
                          getImageSrcAndSave(item[prx.dynamicprops[i]][j].actions[k][key2], item);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        for (var i = 0; i < prx.actions._actionTypes.length; i++) {
          if (typeof item[prx.actions._actionTypes[i]] !== "undefined") {
            for (var j = 0; j < item[prx.actions._actionTypes[i]].length; j++) {
              for (var key in item[prx.actions._actionTypes[i]][j]) {
                if (item[prx.actions._actionTypes[i]][j].hasOwnProperty(key)) {
                  if (_typeof(item[prx.actions._actionTypes[i]][j][key]) == "object" && item[prx.actions._actionTypes[i]][j][key] !== null && typeof item[prx.actions._actionTypes[i]][j][key].assetType != "undefined") {
                    getImageSrcAndSave(item[prx.actions._actionTypes[i]][j][key], item);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_navigation.js":
/*!*********************************************************!*\
  !*** ./sass/player-engine/js/components/_navigation.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.navigation = {};
prx.navigation._pagehash = true; // history

prx.navigation._gobackstack = {
  screens: [],
  loadscreens: [],
  states: {}
}; // Go back button history stack

prx.navigation._activepage = 'p-1';

prx.navigation.changePage = function ($targetpage, opts) {
  if (opts.overlay !== 'out') {
    $targetpage.css({
      opacity: 0
    });
  }

  ;
  if (typeof opts == "undefined") opts = [];
  var options = {
    transition: 'none',
    changeHash: prx.navigation._pagehash,
    allowSamePageTransition: true,
    overlay: false,
    transitionid: prx.utils.getGuid()
  };
  $.extend(options, opts);
  var $sourcepage = $('.prx-page-active');

  if (!options.allowSamePageTransition && $sourcepage.get(0) !== undefined && $sourcepage.get(0).id == $targetpage.get(0).id) {
    // for prx.actions.callback() to be called.
    $sourcepage.trigger('pagebeforehide');
    $targetpage.trigger('pagebeforeshow');
    $(window).trigger('pagebeforechange');
    $targetpage.css({
      opacity: 1
    });
    $sourcepage.trigger('pagehide');
    $targetpage.trigger('pageshow');
    $(window).trigger('pagechange');
    return true;
  } // to close keyboard on devices


  $sourcepage.find('input:focus').trigger('blur'); // both in changepage() before transition and in pagechanged() after transition just to make sure -
  // in case a shorted "go to page" or "unload" or "load" is called and finished before this is finished.

  prx.navigation._activepage = $targetpage.get(0).id;
  if (options.overlay !== 'in') $sourcepage.trigger('pagebeforehide');
  if (options.overlay !== 'out') $targetpage.trigger('pagebeforeshow');
  $(window).trigger('pagebeforechange');
  $sourcepage.addClass('prx-page-transitioning prx-page-transitioning-out prx-page-transitioning-' + options.transitionid);
  $targetpage.addClass('prx-page-transitioning prx-page-transitioning-in prx-page-transitioning-' + options.transitionid);

  if (options.overlay != false) {
    $sourcepage.addClass(function () {
      return 'prx-page-transitioning-overlay-' + options.overlay + '-source';
    });
    $targetpage.addClass(function () {
      return 'prx-page-transitioning-overlay-' + options.overlay + '-target';
    });
  }

  switch (options.transition) {
    case "slide":
    case "slide-overlay":
      prx.screenTransitions.slide($sourcepage, $targetpage, options);
      break;

    case "slideback":
    case "slideback-overlay":
      prx.screenTransitions.slideBack($sourcepage, $targetpage, options);
      break;

    case "slideup":
    case "slideup-overlay":
      prx.screenTransitions.slideUp($sourcepage, $targetpage, options);
      break;

    case "slidedown":
    case "slidedown-overlay":
      prx.screenTransitions.slideDown($sourcepage, $targetpage, options);
      break;

    case "slide-overlay-apple-watch":
      prx.screenTransitions.slideAppleWatch($sourcepage, $targetpage, options);
      break;

    case "slideback-overlay-apple-watch":
      prx.screenTransitions.slideBackAppleWatch($sourcepage, $targetpage, options);
      break;

    case "show-modal-apple-watch":
      prx.screenTransitions.showModalAppleWatch($sourcepage, $targetpage, options);
      break;

    case "remove-modal-apple-watch":
      prx.screenTransitions.removeModalAppleWatch($sourcepage, $targetpage, options);
      break;

    case "fade":
      prx.screenTransitions.fade($sourcepage, $targetpage, options);
      break;

    case "pop":
      prx.screenTransitions.popIn($sourcepage, $targetpage, options);
      break;

    case "popout":
      prx.screenTransitions.popOut($sourcepage, $targetpage, options);
      break;

    case "flip":
      prx.screenTransitions.flip($sourcepage, $targetpage, options);
      break;

    case "turn":
      prx.screenTransitions.turnOut($sourcepage, $targetpage, options);
      break;

    case "turnin":
      prx.screenTransitions.turnIn($sourcepage, $targetpage, options);
      break;

    case "flow":
      prx.screenTransitions.flow($sourcepage, $targetpage, options);
      break;

    case "flowiOS8":
      prx.screenTransitions.flowiOS8($sourcepage, $targetpage, options);
      break;

    case "apple-watch-menuIn":
      prx.screenTransitions.menuInWatchOS($sourcepage, $targetpage, options);
      break;

    case "apple-watch-menuOut":
      prx.screenTransitions.menuOutWatchOS($sourcepage, $targetpage, options);
      break;

    case "apple-watch-notificationIn":
      prx.screenTransitions.notificationInWatchOS($sourcepage, $targetpage, options);
      break;

    default:
      $targetpage.css({
        opacity: 1
      });
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
      break;
  }
};

prx.navigation.pageChanged = function ($sourcepage, $targetpage, options) {
  $sourcepage.removeClass('prx-page-active prx-page-transitioning prx-page-transitioning-out prx-page-transitioning-overlay-in-source prx-page-transitioning-overlay-out-source prx-page-transitioning-' + options.transitionid);
  $targetpage.addClass('prx-page-active').removeClass('prx-page-transitioning prx-page-transitioning-in prx-page-transitioning-overlay-in-target prx-page-transitioning-overlay-out-target prx-page-transitioning-' + options.transitionid); // need this to fix movewholescreen inconsistency where if the screen was moved, depending on the transition it is sometimes brought back to 0 but sometimes not.
  // it also messes with my movewholescreen - position fixed on overlay fixes in pagehide.

  if (typeof $sourcepage.get(0) != "undefined" && options.overlay != "in") {
    var top = 0; // i think i also fix this later on pageshow but just to be sure

    if (prx.allowstatusbar && prx.canvas._statusbars[$sourcepage.get(0).id.replace('p-', '')].statusbar == "1") {
      top = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[$sourcepage.get(0).id.replace('p-', '')].orientation];
    }

    new TimelineMax().to($sourcepage, 0, {
      y: top,
      x: 0
    });
  } // both in changepage() before transition and in pagechanged() after transition just to make sure -
  // in case a shorted "go to page" or "unload" or "load" is called and finished before this is finished.


  prx.navigation._activepage = $targetpage.get(0).id;
  if (options.overlay !== 'in') $sourcepage.trigger('pagehide');
  if (options.overlay !== 'out') $targetpage.trigger('pageshow');

  if (options.changeHash) {
    window.location.hash = '#' + prx.navigation._activepage.replace('p-', '');
  }

  $(window).trigger('pagechange');

  if (!prx.embed && parent != window) {
    try {
      prx.crossmsg.send({
        action: 'highlight-page',
        data: {
          pageid: prx.navigation._activepage.replace('p-', '')
        }
      });
    } catch (err) {}
  }

  prx["interface"].triggerAppEvent('pageChanged', [prx.navigation._activepage.replace('p-', '')]);

  if (prx.scrolltotop) {
    try {
      prx.crossmsg.send({
        action: 'scroll-to-top'
      });
    } catch (e) {}
  }

  prx.bodymovinAnimation.loadBodymovinPageAnimations($targetpage.selector);
};

prx.navigation.iniScreenNavigation = function () {
  $(document).keydown(function (e) {
    if (e.originalEvent !== undefined && e.originalEvent.target !== undefined && e.originalEvent.target.tagName !== undefined && (e.originalEvent.target.tagName.toLowerCase() === "input" || e.originalEvent.target.tagName.toLowerCase() === "textarea")) return;

    switch (e.which) {
      case 37:
        // left
        prx.crossmsg.send({
          action: 'go-to-previous-screen'
        });
        break;

      case 39:
        // right
        prx.crossmsg.send({
          action: 'go-to-next-screen'
        });
        break;

      default:
        return;
      // exit this handler for other keys
    }

    e.preventDefault(); // prevent the default action (scroll / move caret)
  });
};

prx.navigation.pushToBackStack = function (pageid, transition, duration, easing, array) {
  prx.navigation._gobackstack[array].push({
    pageid: pageid,
    transition: transition,
    duration: duration,
    easing: easing
  });

  if (prx.navigation._gobackstack[array].length >= 50) {
    prx.navigation._gobackstack[array].shift();
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_orientation.js":
/*!**********************************************************!*\
  !*** ./sass/player-engine/js/components/_orientation.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($, jQuery) {prx.orientation = {};
prx.orientation._orientation = 'portrait';

prx.orientation.get = function () {
  // if it is defined, depend on this. using the method below, some android devices returned the wrong orientation.
  // ! parent == window : dont use this method if we are in an iframe, because the iframe could  be rotated.
  if (typeof window.orientation != "undefined" && parent == window) {
    var windowOrientation = window.orientation;
    var or = windowOrientation == 0 ? 'portrait' : 'landscape';
  } else {
    var elem = document.documentElement;
    var or = elem && elem.clientWidth / elem.clientHeight < 1.001 ? "portrait" : "landscape";
  }

  if (!prx.devices[prx.device][or + '_applies']) {
    or = or == 'portrait' ? 'landscape' : 'portrait';
  } // else {
  //     // prx.orientation.handleSpecialDevices(windowOrientation);
  // }


  return or;
};

prx.orientation.getWindowOrientationForMobileDevices = function () {
  var windowOrientation = 0; // if it is defined, depend on this. using the method below, some android devices returned the wrong orientation.
  // ! parent == window : dont use this method if we are in an iframe, because the iframe could  be rotated.

  if (typeof window.orientation != "undefined" && parent == window) {
    windowOrientation = window.orientation;
  }

  return windowOrientation;
};

prx.orientation.changeBody = function (_deviceOrientation) {
  if (typeof _deviceOrientation == "undefined") {
    _deviceOrientation = prx.orientation.get();
  }

  prx.orientation._orientation = _deviceOrientation;
  $('body').width(prx.devices[prx.device][_deviceOrientation][0]).height(prx.devices[prx.device][_deviceOrientation][1]); // show iphonex notch.

  prx.loading.handleSpecialDeviceTypes();
};

prx.orientation.change = function (orientation) {
  if (prx.vr.VRExists()) {
    return false;
  }

  if (typeof orientation != "undefined" && orientation == prx.orientation._orientation) {
    prx.loading.handleSpecialDeviceTypes(); // iphone x notch -90

    return false;
  }

  prx.orientation.changeBody(orientation); //var _deviceOrientation = ($(window).width() < $(window).height()) ? "portrait" : "landscape";
  //var _deviceOrientation = prx.orientation.get();

  try {
    //var _activePage = $.mobile.activePage.get(0).id;
    var _activePage = prx.navigation._activepage;
    /* IF NOT ORIENTATION CHANGE EVENT HAS BEEN DEFINED THEN DO AUTO RESIZE ON ORIENTATION CHANGE */
    // jquery 1.8 has removed the "official" way of retrieving the binded events :( the method we use now is for internal jquery used and may be changed in future releases

    if (typeof $._data($('#' + _activePage).get(0), "events") == "undefined" || typeof $._data($('#' + _activePage).get(0), "events") != "undefined" && typeof $._data($('#' + _activePage).get(0), "events").changeorientation == "undefined") {
      var _id = prx.items.helper.getPageIdFromId(_activePage);

      var _page = prxy.pages[prx.stc.screens.getIndexFromId(_id)];
      $('#' + _activePage).html('');
      prx.stc.screens.reloadResponsive(_page, orientation); //i want this in orientation change but can't put it in reaload responsive cause i don't want to put it in screen load cause it will start playing everywhere

      prx.bodymovinAnimation.loadBodymovinPageAnimations('#p-' + _page.id); //i want this in orientation change but can't put it in reaload responsive cause i don't want to put it in screen load cause it will start playing everywhere

      prx.bodymovinAnimation.loadBodymovinPageAnimations('#p-' + _page.id); // to trigger all necessary events
      // v5.13.2 why is this needed? the events shouldn't get triggered, eg screen leave and screen show, we are in the same screen.
      // only the orientationchange event makes sense to be triggered

      /*
         prx.navigation.changePage($('#'+_activePage), {
             changeHash: false,
             allowSamePageTransition: true
         });
         */
    } else {
      /* CALL USER DEFINED ORIENTATION CHANGE ACTION */
      //jQuery.each($('#'+_activePage).data('events'), function(i, event){
      jQuery.each($._data($('#' + _activePage).get(0), "events"), function (i, event) {
        jQuery.each(event, function (i, handler) {
          if (handler.type == 'changeorientation') {
            $('#' + _activePage).trigger("changeorientation");
          }
        });
      });
    }
  } catch (e) {}

  return true;
};

prx.orientation.getPage = function (page, stateindex) {
  if (typeof stateindex == "undefined") {
    stateindex = 0;
  }

  var _orientation = prx.devices[prx.device].defaultOrientation;

  if (typeof page.orientation == "undefined" || page.orientation == "") {
    page.orientation = prx.devices[prx.device].defaultOrientation;
  }

  _orientation = page.orientation;

  if (!prx.devices[prx.device][_orientation + '_applies']) {
    _orientation = _orientation == "portrait" ? "landscape" : "portrait";
  }

  return _orientation;
};

prx.orientation.check = function () {
  // orientationchange is triggered natively on mobile devices.
  if (!("onorientationchange" in window)) {
    var tmpOr = prx.orientation.get();

    if (tmpOr != prx.orientation._orientation) {
      $(window).trigger('orientationchange');
    }
  }
};

prx.orientation.getDims = function (parenttype, parentindex, stateindex) {
  // returns OrientationWidth, OrientationHeight
  if (parenttype == "symbols") {
    return [prxy[parenttype][parentindex].states[stateindex].dimensions[0], prxy[parenttype][parentindex].states[stateindex].dimensions[1]];
  }

  var _orientation = prxy[parenttype][parentindex].orientation;
  var _OrientationWidth = 0;
  var _statusbarHeight = 0;
  var _statusbar = 0;
  var _navigationbarHeight = 0;
  var _navigationbar = 0;

  if (prx.projectsettings.statusbarapplies && prxy[parenttype][parentindex].statusbar == "1") {
    _statusbar = 1;
    _statusbarHeight = prx.devices[prx.device]['statusbarheight' + _orientation];
  }

  if (prx.projectsettings.navigationbarapplies && prxy[parenttype][parentindex].navigationbar == "1") {
    _navigationbar = 1;
    _navigationbarHeight = prx.devices[prx.device]['navigationbarheight' + _orientation];
  }

  var _deadheight = parseInt(_statusbar) * prx.devices[prx.device]['statusbarheight' + _orientation] + parseInt(_navigationbar) * prx.devices[prx.device]['navigationbarheight' + _orientation];

  var _OrientationWidth = prx.devices[prx.device]['normal' + _orientation][0];

  var _OrientationHeight = prx.devices[prx.device]['normal' + _orientation][1] - _deadheight;

  return [parseInt(_OrientationWidth), parseInt(_OrientationHeight), parseInt(_navigationbarHeight)];
}; // prx.orientation.handleSpecialDevices = function(orientation) {
//     //this was created specifically for the iPhoneX notch. In case you have a -90 orientation u need to show the iphone notch on the other side (when on mobile device)
//     //In case you need to handle any other special cases for specific window.orientations add them here
//
//     if(typeof(orientation) == 'undefined')
//         return;
//
//     // if(orientation == -90) {
//         let $iphoneXNotch = $('#iphoneX-notch-player');
//             // console.log('length' + ' ' + $iphoneXNotch.length)
//         if ($iphoneXNotch.length > 0) {
//             $iphoneXNotch.attr('orientation', orientation);
//         }
//     // }
//
// }
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_overlay.js":
/*!******************************************************!*\
  !*** ./sass/player-engine/js/components/_overlay.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.overlay = {};

prx.overlay.render = function (pageid) {
  //return;
  //$('#overlay').show();
  //var _pageid = '#p-'+pageid;
  var _pageid = pageid;

  var _statusbar = prx.canvas._statusbars[pageid.substr(3)];

  var _top = 0;
  var _height = prx.devices[prx.device][_statusbar.orientation][1];

  if (prx.allowstatusbar && _statusbar.statusbar == "1") {
    _top = prx.devices[prx.device]['statusbarheight' + _statusbar.orientation];
    _height -= _top;
  } // need to change the id of the checkboxes, or the checked state is lost.


  $overlay = $('#overlay');
  $(_pageid).find('[data-mpoverlay="1"]') //.show()
  .each(function () {
    var _elmTop = $(this).offset().top - _top;

    var _elmLeft = $(this).offset().left; //var $overlay = $('<div class="overlay"></div>').insertAfter(this);

    $(this) //.clone(true, true) // apparently clone with events messes something up with jquery. v3.4.1.13
    .clone() //.css({'top': _elmTop + 'px', 'left': _elmLeft + 'px'})
    .find('input').attr('id', function () {
      return $(this).attr('id') + '-overlay';
    }).attr('name', function () {
      return $(this).attr('name') + '-overlay';
    }).end().find('label').attr('for', function () {
      return $(this).attr('for') + '-overlay';
    }).end().appendTo($overlay);
    new TimelineMax().to('#overlay  #' + this.id, 0, {
      x: _elmLeft,
      y: _elmTop
    });
  });
  $overlay.css('top', _top + 'px').height(_height).show(); //$(_pageid).find('[data-mpoverlay="1"]').clone(true,true).appendTo('#trash');
  //$(_pageid).find('[data-mpoverlay="1"]').remove();
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_quick-audio.js":
/*!**********************************************************!*\
  !*** ./sass/player-engine/js/components/_quick-audio.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.quickaudio = {};
prx.quickaudio.audios = {};
/*
*	loop all screens, templates and containers
*	loop all states for each screen, template and container
*	find all actions with actionId "play-audio" and sourceId "library"
*	actions to search:
*		page interactions, state interactions, item interactions, group interactions (later)
*		& their dynamic properties and callbacks
*/

prx.quickaudio.preload = function () {
  /*
  *	generate HTML for each sound in prx.quickaudio.audios with preload attr and append to $('#quick-audios')
  *	each audio element's id is the sound name (spaces removed and replaced with '-' str.replace(/\s+/g, '-'))
  */
  $.each(prx.quickaudio.audios, function (i, sound) {
    var cR = '<audio id="' + sound.name.replace(/\s+/g, '-') + '" preload="auto">';
    cR += '<source src="' + prx.componentsHelper.getAssetUrl(sound.mp3) + '" type="audio/mpeg">';
    cR += '<source src="' + prx.componentsHelper.getAssetUrl(sound.wav) + '" type="audio/x-wav">';
    cR += '<source src="' + prx.componentsHelper.getAssetUrl(sound.aac) + '" type="audio/x-aac"></audio>';
    $('#quick-audios').append(cR);
  });
};

prx.quickaudio.recursivelySearchActionForPlayAudio = function (jAction) {
  /*
   *	if action actionId is "play-audio" and action sourceId is "library" add to prx.quickaudio.audios
   */
  if (jAction.actionId == 'play-audio' && jAction.sourceId == 'library' && !$.isEmptyObject(jAction.sound)) {
    prx.quickaudio.audios[jAction.sound.name] = jAction.sound;
  }
  /*
   *	if action callbackAction is not undefined search all callbacks for play-audio
   */


  if (jAction.callbackAction !== undefined) {
    prx.quickaudio.recursivelySearchActionForPlayAudio(jAction.callbackAction);
  }
};

prx.quickaudio.searchItem = function (item) {
  $.each(prx.actions._actionTypes, function (i, actionType) {
    if (actionType in item) {
      $.each(item[actionType], function (i, action) {
        prx.quickaudio.recursivelySearchActionForPlayAudio(action);
      });
    }
  }); // data dynamic properties

  $.each(prx.dynamicprops, function (i, dynpropType) {
    if (dynpropType in item && typeof item[dynpropType] !== "string") {
      $.each(item[dynpropType], function (i, dynprop) {
        $.each(prx.actions._actionTypes, function (i, actionType) {
          if (actionType in dynprop) {
            $.each(dynprop[actionType], function (i, action) {
              prx.quickaudio.recursivelySearchActionForPlayAudio(action);
            });
          }
        });
      });
    }
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_responsive-components.js":
/*!********************************************************************!*\
  !*** ./sass/player-engine/js/components/_responsive-components.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.responsiveComponents = {};

/***/ }),

/***/ "./sass/player-engine/js/components/_scale.js":
/*!****************************************************!*\
  !*** ./sass/player-engine/js/components/_scale.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.scale = function () {
  var m = {};

  function _getGroups(target) {
    if (target.indexOf('group') !== -1) {
      return [];
    } else {
      var container = target.split('-box-');
      container.pop();
      container = container.join('-box-');
      return $(target).attr('class').split(' ').filter(function (cl) {
        return cl.indexOf('group') !== -1;
      }).map(function (cl) {
        return container + ' .' + cl;
      });
    }
  }

  function get(target, property, nomulti) {
    if (typeof m[property] === 'undefined') m[property] = {};

    if (target.indexOf('group') !== -1 || nomulti) {
      return typeof m[property][target] === "undefined" ? 1 : m[property][target];
    } else {
      var vals = _getGroups(target).map(function (grouptarget) {
        return get(grouptarget, property);
      });

      vals.push(typeof m[property][target] === "undefined" ? 1 : m[property][target]);
      return vals.reduce(function (a, b) {
        return a * b;
      }, 1);
    }
  }

  function set(target, property, value) {
    if (typeof m[property] === 'undefined') m[property] = {};
    var old = m[property][target];
    m[property][target] = value;
    return value !== old;
  }

  function same(target, property, value) {
    if (typeof m[property] === 'undefined') m[property] = {};
    return m[property][target] === value;
  }

  return {
    get: get,
    set: set,
    same: same
  };
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_screen-transitions.js":
/*!*****************************************************************!*\
  !*** ./sass/player-engine/js/components/_screen-transitions.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.screenTransitions = {};
prx.screenTransitions.reverseMapping = {
  'none': 'none',
  'slide': 'slideback',
  'slideback': 'slide',
  'slideup': 'slidedown',
  'slidedown': 'slideup',
  'slide-overlay': 'slideback-overlay',
  'slideback-overlay': 'slide-overlay',
  'slideup-overlay': 'slidedown-overlay',
  'slidedown-overlay': 'slideup-overlay',
  'slide-overlay-apple-watch': 'slideback-overlay-apple-watch',
  'slideback-overlay-apple-watch': 'slide-overlay-apple-watch',
  'show-modal-apple-watch': 'remove-modal-apple-watch',
  'remove-modal-apple-watch': 'show-modal-apple-watch',
  'pop': 'popout',
  'popout': 'pop',
  'fade': 'fade',
  'flip': 'flip',
  'turnin': 'turn',
  'turn': 'turnin',
  'flow': 'flow',
  'flowiOS8': 'flowiOS8',
  'apple-watch-menuIn': 'apple-watch-menuOut',
  'apple-watch-menuOut': 'apple-watch-menuIn',
  'apple-watch-notificationIn': 'apple-watch-notificationIn'
};

prx.screenTransitions.slide = function ($sourcepage, $targetpage, options) {
  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 600;
  }

  if (typeof easing == "undefined") {
    easing = "Expo.easeOut";
  }

  easing = prx.easing.get(easing); // i cant have both load overlayed screen (or unload) and slide-overlay transition.

  if (options.transition.indexOf("-overlay") > -1 && options.overlay != false) {
    options.transition = options.transition.replace('-overlay', '');
  }

  $targetpage.addClass('prx-page-active');

  if (options.transition.indexOf("-overlay") > -1) {
    $targetpage.addClass('prx-page-above prx-page-transition-overlay-top');
    $sourcepage.addClass('prx-page-below');
  }

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      x: $sourcepage.width() * -1 * (options.transition.indexOf("-overlay") > -1 ? 0.5 : 1),
      ease: easing
    })).call(function () {
      $targetpage.removeClass('prx-page-above prx-page-transition-overlay-top');
      $sourcepage.removeClass('prx-page-below');
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
    }).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      x: 0,
      overwrite: 0
    }));
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      x: $sourcepage.width()
    })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1
    })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      x: 0,
      ease: easing
    })).call(function () {
      if (options.overlay) {
        $targetpage.removeClass('prx-page-above prx-page-transition-overlay-top');
        $sourcepage.removeClass('prx-page-below');
        prx.navigation.pageChanged($sourcepage, $targetpage, options);
      }
    });
  }
};

prx.screenTransitions.slideBack = function ($sourcepage, $targetpage, options) {
  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 600;
  }

  if (typeof easing == "undefined") {
    easing = "Expo.easeOut";
  }

  easing = prx.easing.get(easing); // i cant have both load overlayed screen (or unload) and slid e-overlay transition.

  if (options.transition.indexOf("-overlay") > -1 && options.overlay != false) {
    options.transition = options.transition.replace('-overlay', '');
  }

  $targetpage.addClass('prx-page-active');

  if (options.transition.indexOf("-overlay") > -1) {
    $sourcepage.addClass('prx-page-above prx-page-transition-overlay-top');
    $targetpage.addClass('prx-page-below');
  }

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      x: $targetpage.width(),
      ease: easing
    })).call(function () {
      $targetpage.removeClass('prx-page-below');
      $sourcepage.removeClass('prx-page-above prx-page-transition-overlay-top');
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
    }).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      x: 0,
      overwrite: 0
    }));
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      x: $targetpage.width() * -1 * (options.transition.indexOf("-overlay") > -1 ? 0.5 : 1)
    })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1
    })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      x: 0,
      ease: easing
    })).call(function () {
      if (options.overlay) {
        $targetpage.removeClass('prx-page-below');
        $sourcepage.removeClass('prx-page-above prx-page-transition-overlay-top');
        prx.navigation.pageChanged($sourcepage, $targetpage, options);
      }
    });
  }
};

prx.screenTransitions.slideAppleWatch = function ($sourcepage, $targetpage, options) {
  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 600;
  }

  if (typeof easing == "undefined") {
    easing = "Expo.easeOut";
  }

  easing = prx.easing.get(easing);
  $targetpage.addClass('prx-page-active prx-page-below');
  $sourcepage.addClass('prx-page-above');

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      x: -$sourcepage.width(),
      ease: easing
    })).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      x: 0
    }));
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 0.1,
      scale: 0.80
    })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      scale: 1,
      opacity: 1,
      ease: easing
    })).call(function () {
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
      $targetpage.removeClass('prx-page-below prx-page-above');
      $sourcepage.removeClass('prx-page-below prx-page-above');
    });
  }
};

prx.screenTransitions.slideBackAppleWatch = function ($sourcepage, $targetpage, options) {
  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 600;
  }

  if (typeof easing == "undefined") {
    easing = "Expo.easeOut";
  }

  easing = prx.easing.get(easing);
  $targetpage.addClass('prx-page-active prx-page-above');
  $sourcepage.addClass('prx-page-below');

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 0,
      scale: 0.80,
      ease: easing
    })).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1,
      scale: 1
    }));
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      x: $targetpage.width() * -1
    })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1
    })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      x: 0,
      ease: easing
    })).call(function () {
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
      $targetpage.removeClass('prx-page-below prx-page-above');
      $sourcepage.removeClass('prx-page-below prx-page-above');
    });
  }
};

prx.screenTransitions.slideUp = function ($sourcepage, $targetpage, options) {
  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 600;
  }

  if (typeof easing == "undefined") {
    easing = "Expo.easeOut";
  }

  easing = prx.easing.get(easing); // i cant have both load overlayed screen (or unload) and slide-overlay transition.

  if (options.transition.indexOf("-overlay") > -1 && options.overlay != false) {
    options.transition = options.transition.replace('-overlay', '');
  }

  var sourcetop = 0;
  var targettop = 0;

  if (prx.allowstatusbar && prx.canvas._statusbars[$sourcepage.attr('id').replace('p-', "")].statusbar == 1) {
    sourcetop = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[$sourcepage.attr('id').replace('p-', "")].orientation];
  }

  if (prx.allowstatusbar && prx.canvas._statusbars[$targetpage.attr('id').replace('p-', "")].statusbar == 1) {
    targettop = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[$targetpage.attr('id').replace('p-', "")].orientation];
  }

  $targetpage.addClass('prx-page-active');

  if (options.transition.indexOf("-overlay") > -1) {
    $targetpage.addClass('prx-page-above prx-page-transition-overlay-top');
    $sourcepage.addClass('prx-page-below');
  }

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      y: $sourcepage.height() * -1 * (options.transition.indexOf("-overlay") > -1 ? 0.5 : 1),
      ease: easing
    })).call(function () {
      $sourcepage.removeClass('prx-page-below');
      $targetpage.removeClass('prx-page-above prx-page-transition-overlay-top');
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
    }).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      y: sourcetop,
      overwrite: 0
    }));
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      y: $sourcepage.height()
    })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1
    })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      y: targettop,
      ease: easing
    })).call(function () {
      if (options.overlay) {
        $sourcepage.removeClass('prx-page-below');
        $targetpage.removeClass('prx-page-above prx-page-transition-overlay-top');
        prx.navigation.pageChanged($sourcepage, $targetpage, options);
      }
    });
  }
};

prx.screenTransitions.slideDown = function ($sourcepage, $targetpage, options) {
  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 600;
  }

  if (typeof easing == "undefined") {
    easing = "Expo.easeOut";
  }

  easing = prx.easing.get(easing); // i cant have both load overlayed screen (or unload) and slide-overlay transition.

  if (options.transition.indexOf("-overlay") > -1 && options.overlay != false) {
    options.transition = options.transition.replace('-overlay', '');
  }

  var sourcetop = 0;
  var targettop = 0;

  if (prx.allowstatusbar && prx.canvas._statusbars[$sourcepage.attr('id').replace('p-', "")].statusbar == 1) {
    sourcetop = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[$sourcepage.attr('id').replace('p-', "")].orientation];
  }

  if (prx.allowstatusbar && prx.canvas._statusbars[$targetpage.attr('id').replace('p-', "")].statusbar == 1) {
    targettop = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[$targetpage.attr('id').replace('p-', "")].orientation];
  }

  $targetpage.addClass('prx-page-active');

  if (options.transition.indexOf("-overlay") > -1) {
    $sourcepage.addClass('prx-page-above prx-page-transition-overlay-top');
    $targetpage.addClass('prx-page-below');
  }

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      y: $targetpage.height(),
      ease: easing
    })).call(function () {
      $targetpage.removeClass('prx-page-below');
      $sourcepage.removeClass('prx-page-above prx-page-transition-overlay-top');
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
    }).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      y: sourcetop,
      overwrite: 0
    }));
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      y: $targetpage.height() * -1 * (options.transition.indexOf("-overlay") > -1 ? 0.5 : 1)
    })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1
    })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      y: targettop,
      ease: easing
    })).call(function () {
      if (options.overlay) {
        $targetpage.removeClass('prx-page-below');
        $sourcepage.removeClass('prx-page-above prx-page-transition-overlay-top');
        prx.navigation.pageChanged($sourcepage, $targetpage, options);
      }
    });
  }
};

prx.screenTransitions.showModalAppleWatch = function ($sourcepage, $targetpage, options) {
  $targetpage.css({
    opacity: 1
  });
  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 600;
  }

  if (typeof easing == "undefined") {
    easing = "Expo.easeOut";
  }

  easing = prx.easing.get(easing);
  var sourcetop = 0;
  var targettop = 0;
  var $appleWatchStatusBar = $sourcepage.find('div[class*="box pos type-applewatch-statusbar"]:not(.hidden)'); //var $appleWatchStatusBar = $sourcepage.find('div[class*="box pos type-applewatch-statusbar"]');

  var appleWatchStatusBarFound = [];

  for (var i = 0; i < $appleWatchStatusBar.length; i++) {
    $('#' + $appleWatchStatusBar[i].id).attr("data-opacity", $('#' + $appleWatchStatusBar[i].id).css('opacity'));
    appleWatchStatusBarFound.push($('#' + $appleWatchStatusBar[i].id));
  }

  if (prx.allowstatusbar && prx.canvas._statusbars[$sourcepage.attr('id').replace('p-', "")].statusbar == 1) {
    sourcetop = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[$sourcepage.attr('id').replace('p-', "")].orientation];
  }

  if (prx.allowstatusbar && prx.canvas._statusbars[$targetpage.attr('id').replace('p-', "")].statusbar == 1) {
    targettop = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[$targetpage.attr('id').replace('p-', "")].orientation];
  }

  $targetpage.addClass('prx-page-active');

  if (options.overlay != 'in') {
    $targetpage.addClass('prx-page-above prx-page-transition-overlay-top');
    $sourcepage.addClass('prx-page-below');
    new TimelineMax().to(appleWatchStatusBarFound, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 0,
      ease: easing
    })).call(function () {
      $sourcepage.removeClass('prx-page-below');
      $targetpage.removeClass('prx-page-above prx-page-transition-overlay-top');
      prx.navigation.pageChanged($sourcepage, $targetpage, options);

      for (var i = 0; i < $appleWatchStatusBar.length; i++) {
        $('#' + $appleWatchStatusBar[i].id).css('opacity', $('#' + $appleWatchStatusBar[i].id).attr("data-opacity"));
      }
    });
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      y: $sourcepage.height()
    })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      y: targettop,
      ease: easing
    }));
  }
};

prx.screenTransitions.removeModalAppleWatch = function ($sourcepage, $targetpage, options) {
  $targetpage.css({
    opacity: 1
  });
  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 600;
  }

  if (typeof easing == "undefined") {
    easing = "Expo.easeOut";
  }

  easing = prx.easing.get(easing);
  var sourcetop = 0;
  var targettop = 0;

  if (prx.allowstatusbar && prx.canvas._statusbars[$sourcepage.attr('id').replace('p-', "")].statusbar == 1) {
    sourcetop = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[$sourcepage.attr('id').replace('p-', "")].orientation];
  }

  if (prx.allowstatusbar && prx.canvas._statusbars[$targetpage.attr('id').replace('p-', "")].statusbar == 1) {
    targettop = prx.devices[prx.device]['statusbarheight' + prx.canvas._statusbars[$targetpage.attr('id').replace('p-', "")].orientation];
  }

  $targetpage.addClass('prx-page-active');
  prx.underlay.render('#' + $('#' + $targetpage.get(0).id).attr('id'));

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      y: $targetpage.height() * 1,
      ease: easing
    })).call(function () {
      $targetpage.removeClass('prx-page-below');
      $sourcepage.removeClass('prx-page-above prx-page-transition-overlay-top');
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
    });
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      y: $targetpage.height() * -0.5,
      ease: easing,
      opacity: 0
    })).to('#' + $targetpage.get(0).id, duration / 1000 * 0.9, Object.assign({}, prx.basicGreensockOptions, {
      y: targettop,
      ease: easing,
      opacity: 1
    })).call(function () {
      prx.underlay.changeVisibility('#' + $('#' + $targetpage.get(0).id).attr('id'));
    });
  }
};

prx.screenTransitions.popIn = function ($sourcepage, $targetpage, options) {
  if (options.overlay == 'out') {
    prx.screenTransitions.popOut($sourcepage, $targetpage, options);
    return;
  }

  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 300;
  }

  if (typeof easing == "undefined") {
    easing = "in-out";
  }

  easing = prx.easing.get(easing);
  $targetpage.addClass('prx-page-active prx-page-above');
  $sourcepage.addClass('prx-page-below');
  new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
    scale: 0.8,
    opacity: 0.8
  })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
    scale: 1,
    opacity: 1,
    ease: easing
  })).call(function () {
    prx.navigation.pageChanged($sourcepage, $targetpage, options);
    $sourcepage.removeClass('prx-page-below');
    $targetpage.removeClass('prx-page-above');
  });
};

prx.screenTransitions.popOut = function ($sourcepage, $targetpage, options, size) {
  $targetpage.css({
    opacity: 1
  });

  if (options.overlay == 'in') {
    prx.screenTransitions.popIn($sourcepage, $targetpage, options);
    return;
  }

  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 300;
  }

  if (typeof easing == "undefined") {
    easing = "in-out";
  } // provision for popout-large and popout-small which i dont have at the moment. small would be 0.8.


  if (typeof size == "undefined") {
    size = 1.8;
  }

  easing = prx.easing.get(easing);
  $targetpage.addClass('prx-page-active prx-page-below');
  $sourcepage.addClass('prx-page-above');
  new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
    scale: size,
    opacity: 0.2,
    ease: easing
  })).call(function () {
    prx.navigation.pageChanged($sourcepage, $targetpage, options);
    $sourcepage.removeClass('prx-page-above');
    $targetpage.removeClass('prx-page-below');
  }).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
    scale: 1,
    opacity: 1,
    overwrite: 0
  }));
};

prx.screenTransitions.fade = function ($sourcepage, $targetpage, options) {
  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 300;
  }

  if (typeof easing == "undefined") {
    easing = "in-out";
  }

  easing = prx.easing.get(easing);

  if (options.overlay != 'out') {
    // safari images flicker issue - it seems that safari has time to show the page before i fade it out below
    // moving this into the timeline after fading the targetpage out doesnt work :(
    $targetpage.addClass('prx-page-active prx-page-above');
    $sourcepage.addClass('prx-page-below');
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 0
    })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1,
      ease: easing
    })).call(function () {
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
      $sourcepage.removeClass('prx-page-below');
      $targetpage.removeClass('prx-page-above');
    });
  } else {
    $targetpage.addClass('prx-page-active prx-page-below');
    $sourcepage.addClass('prx-page-above');
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 0,
      ease: easing
    })).call(function () {
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
      $sourcepage.removeClass('prx-page-above');
      $targetpage.removeClass('prx-page-below');
    }).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1,
      overwrite: 0
    }));
  }
};

prx.screenTransitions.flip = function ($sourcepage, $targetpage, options) {
  // dont allow easing in flip because im splitting interaction in 2!
  var duration = options.duration;
  var easing = "linear";

  if (typeof duration == "undefined") {
    duration = 500;
  }

  easing = prx.easing.get(easing);

  if (options.overlay == 'out') {
    $targetpage.addClass('prx-page-active prx-page-below prx-page-transition-flip');
    $sourcepage.addClass('prx-page-above prx-page-transition-flip');
  } else {
    $targetpage.addClass('prx-page-active prx-page-above prx-page-transition-flip');
    $sourcepage.addClass('prx-page-below prx-page-transition-flip');
  } // if(opts.overlay !== 'out') {
  //     $targetpage.css({opacity: 0 })
  // };
  // boxes that have their own transform are not visibility-hidden :(
  // of course this doesnt fix it :(
  //prx.scrollable.disable('#' + $sourcepage.attr('id'));
  //prx.scrollable.disable('#' + $targetpage.attr('id'));


  $('body').addClass('dont-do-chrome-fix');

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      rotationY: -180,
      ease: easing
    })).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 0
    }), duration / 2000).call(function () {
      if (options.overlay) {
        prx.navigation.pageChanged($sourcepage, $targetpage, options);
        $sourcepage.removeClass('prx-page-below prx-page-above prx-page-transition-flip');
        $targetpage.removeClass('prx-page-below prx-page-above prx-page-transition-flip');
        $('body').removeClass('dont-do-chrome-fix');
      }
    }).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      rotationY: 0,
      overwrite: 0,
      opacity: 1
    }));
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000 / 2, Object.assign({}, prx.basicGreensockOptions, {
      scale: 0.9,
      ease: easing
    })).to('#' + $sourcepage.get(0).id, duration / 1000 / 2, Object.assign({}, prx.basicGreensockOptions, {
      scale: 1,
      ease: easing
    }));
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      rotationY: 180
    })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
      rotationY: 0,
      ease: easing
    })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1
    }), duration / 2000).call(function () {
      //prx.scrollable.enable('#' + $sourcepage.attr('id'));
      //prx.scrollable.enable('#' + $targetpage.attr('id'));
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
      $sourcepage.removeClass('prx-page-below prx-page-above prx-page-transition-flip');
      $targetpage.removeClass('prx-page-below prx-page-above prx-page-transition-flip');
      $('body').removeClass('dont-do-chrome-fix');
    });
    new TimelineMax().to('#' + $targetpage.get(0).id, duration / 1000 / 2, Object.assign({}, prx.basicGreensockOptions, {
      scale: 0.9,
      ease: easing
    })).to('#' + $targetpage.get(0).id, duration / 1000 / 2, Object.assign({}, prx.basicGreensockOptions, {
      scale: 1,
      ease: easing
    }));
  }
};

prx.screenTransitions.turnOut = function ($sourcepage, $targetpage, options) {
  if (options.overlay == 'in') {
    prx.screenTransitions.turnIn($sourcepage, $targetpage, options);
    return;
  }

  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 400;
  }

  if (typeof easing == "undefined") {
    easing = "in-out";
  }

  easing = prx.easing.get(easing);
  $targetpage.addClass('prx-page-active prx-page-below');
  $sourcepage.addClass('prx-page-above prx-page-transition-turn');
  $('body').addClass('dont-do-chrome-fix');
  new TimelineMax().to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
    transformPerspective: 1000 // need to call it first otherwise it doesn't have time to run before the animation starts, and it flickers.

  })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
    opacity: 1
  })).to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
    rotationY: -90,
    ease: easing
  })).call(function () {
    prx.navigation.pageChanged($sourcepage, $targetpage, options);
    $sourcepage.removeClass('prx-page-above prx-page-transition-turn');
    $targetpage.removeClass('prx-page-below');
    $('body').removeClass('dont-do-chrome-fix');
  }).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
    rotationY: 0,
    overwrite: 0
  }));
};

prx.screenTransitions.turnIn = function ($sourcepage, $targetpage, options) {
  if (options.overlay == 'out') {
    prx.screenTransitions.turnOut($sourcepage, $targetpage, options);
    return;
  }

  var duration = options.duration;
  var easing = options.easing;

  if (typeof duration == "undefined") {
    duration = 400;
  }

  if (typeof easing == "undefined") {
    easing = "in-out";
  }

  easing = prx.easing.get(easing);
  $targetpage.addClass('prx-page-active prx-page-above prx-page-transition-turn');
  $sourcepage.addClass('prx-page-below');
  $('body').addClass('dont-do-chrome-fix');
  new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
    transformPerspective: 1000,
    // need to call it first otherwise it doesn't have time to run before the animation starts, and it flickers.
    rotationY: -90
  })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
    opacity: 1
  })).to('#' + $targetpage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
    rotationY: 0,
    ease: easing
  })).call(function () {
    prx.navigation.pageChanged($sourcepage, $targetpage, options);
    $sourcepage.removeClass('prx-page-below');
    $targetpage.removeClass('prx-page-above prx-page-transition-turn');
    $('body').removeClass('dont-do-chrome-fix');
  });
}; //Flow Transition iOS8


prx.screenTransitions.flowiOS8 = function ($sourcepage, $targetpage, options) {
  var duration = options.duration;
  var easing = "linear";

  if (typeof duration == "undefined") {
    duration = 500;
  }

  easing = prx.easing.get(easing);

  if (options.overlay != 'in') {
    $targetpage.addClass('prx-page-active prx-page-below prx-page-transition-flowiOS8');
    $sourcepage.addClass('prx-page-above prx-page-transition-flowiOS8');
  } else {
    $targetpage.addClass('prx-page-active prx-page-above prx-page-transition-flowiOS8');
    $sourcepage.addClass('prx-page-below prx-page-transition-flowiOS8');
  }

  if (options.overlay) {
    $targetpage.addClass('prx-page-transition-flowiOS8-overlay');
    $sourcepage.addClass('prx-page-transition-flowiOS8-overlay');
  }

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000 * 0.15, Object.assign({}, prx.basicGreensockOptions, {
      scale: 0.98,
      x: $sourcepage.width() / 20,
      ease: easing
    })).to('#' + $sourcepage.get(0).id, duration / 1000 * 0.45, Object.assign({}, prx.basicGreensockOptions, {
      scale: 0.93,
      x: $sourcepage.width() / 3,
      ease: easing
    })).to('#' + $sourcepage.get(0).id, duration / 1000 * 0.4, Object.assign({}, prx.basicGreensockOptions, {
      scale: 1,
      x: $sourcepage.width(),
      ease: easing
    })).call(function () {
      if (options.overlay) {
        prx.navigation.pageChanged($sourcepage, $targetpage, options);
        $sourcepage.removeClass('prx-page-below prx-page-above prx-page-transition-flow');
        $targetpage.removeClass('prx-page-below prx-page-above prx-page-transition-flow');
      }
    });
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      scale: 0.98,
      x: -$sourcepage.width()
    })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1
    })).to('#' + $targetpage.get(0).id, duration / 1000 * 0.45, Object.assign({}, prx.basicGreensockOptions, {
      scale: 0.93,
      x: -$sourcepage.width() + $sourcepage.width() / 3,
      ease: easing,
      delay: duration / 1000 * 0.15
    })).to('#' + $targetpage.get(0).id, duration / 1000 * 0.42, Object.assign({}, prx.basicGreensockOptions, {
      scale: 1,
      x: 0,
      ease: easing
    })).call(function () {
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
      $sourcepage.removeClass('prx-page-below prx-page-above prx-page-transition-flowiOS8');
      $targetpage.removeClass('prx-page-below prx-page-above prx-page-transition-flowiOS8');
    });
  }
};

prx.screenTransitions.flow = function ($sourcepage, $targetpage, options) {
  var duration = options.duration;
  var easing = "linear";

  if (typeof duration == "undefined") {
    duration = 500;
  }

  easing = prx.easing.get(easing);

  if (options.overlay != 'in') {
    $targetpage.addClass('prx-page-active prx-page-below prx-page-transition-flow');
    $sourcepage.addClass('prx-page-above prx-page-transition-flow');
  } else {
    $targetpage.addClass('prx-page-active prx-page-above prx-page-transition-flow');
    $sourcepage.addClass('prx-page-below prx-page-transition-flow');
  }

  if (options.overlay) {
    $targetpage.addClass('prx-page-transition-flow-overlay');
    $sourcepage.addClass('prx-page-transition-flow-overlay');
  }

  if (options.overlay != 'in') {
    new TimelineMax().to('#' + $sourcepage.get(0).id, duration / 1000 * 0.25, Object.assign({}, prx.basicGreensockOptions, {
      scale: 0.7,
      ease: easing
    })).to('#' + $sourcepage.get(0).id, duration / 1000 * 0.2, Object.assign({}, prx.basicGreensockOptions, {
      x: -$sourcepage.width(),
      ease: easing,
      delay: duration / 1000 * 0.15
    })).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      delay: duration / 1000 * 0.4
    })).call(function () {
      if (options.overlay) {
        prx.navigation.pageChanged($sourcepage, $targetpage, options);
        $sourcepage.removeClass('prx-page-below prx-page-above prx-page-transition-flow');
        $targetpage.removeClass('prx-page-below prx-page-above prx-page-transition-flow');
      }
    }).to('#' + $sourcepage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      x: 0,
      scale: 1,
      overwrite: 0
    }));
  }

  if (options.overlay != 'out') {
    new TimelineMax().to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      x: $sourcepage.width(),
      scale: 0.7
    })).to('#' + $targetpage.get(0).id, 0, Object.assign({}, prx.basicGreensockOptions, {
      opacity: 1
    })).to('#' + $targetpage.get(0).id, duration / 1000 * 0.2, Object.assign({}, prx.basicGreensockOptions, {
      x: 0,
      //$sourcepage.width()*0.15,
      ease: easing,
      delay: duration / 1000 * 0.4
    })).to('#' + $targetpage.get(0).id, duration / 1000 * 0.25, Object.assign({}, prx.basicGreensockOptions, {
      x: 0,
      scale: 1,
      ease: easing,
      delay: duration / 1000 * 0.15
    })).call(function () {
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
      $sourcepage.removeClass('prx-page-below prx-page-above prx-page-transition-flow');
      $targetpage.removeClass('prx-page-below prx-page-above prx-page-transition-flow');
    });
  }
}; // WatchOS Menu transitions


prx.screenTransitions.menuInWatchOS = function ($sourcepage, $targetpage, options) {
  $targetpage.css({
    opacity: 1
  });
  var duration = 300;
  var easing = "ease-out";
  easing = prx.easing.get(easing);
  $targetpage.addClass('prx-page-active prx-page-above');
  $sourcepage.addClass('prx-page-below');
  var targetTimeline = new TimelineMax();
  var targetItemsTimeline = new TimelineMax();
  var sourceTimeline = new TimelineMax();
  var sourceBlurTimeline = new TimelineMax();
  var menuItemNum = $targetpage.find('.menu-container .menu-listitem').length;

  switch (menuItemNum) {
    case 2:
      $targetpage.find('.menu-container .menu-listitem[data-dynamic-property-index=0]').addClass('menu-up');
      $targetpage.find('.menu-container .menu-listitem[data-dynamic-property-index=1]').addClass('menu-down');
      break;

    case 3:
      $targetpage.find('.menu-container .menu-listitem[data-dynamic-property-index=0]').addClass('menu-diag-up-left');
      $targetpage.find('.menu-container .menu-listitem[data-dynamic-property-index=1]').addClass('menu-diag-up-right');
      $targetpage.find('.menu-container .menu-listitem[data-dynamic-property-index=2]').addClass('menu-down');
      break;

    case 4:
      $targetpage.find('.menu-container .menu-listitem[data-dynamic-property-index=0]').addClass('menu-diag-up-left');
      $targetpage.find('.menu-container .menu-listitem[data-dynamic-property-index=1]').addClass('menu-diag-up-right');
      $targetpage.find('.menu-container .menu-listitem[data-dynamic-property-index=2]').addClass('menu-diag-down-left');
      $targetpage.find('.menu-container .menu-listitem[data-dynamic-property-index=3]').addClass('menu-diag-down-right');
      break;

    case 1:
    default:
      break;
  }

  sourceTimeline.to('#' + $sourcepage.get(0).id, duration / 1000, Object.assign({}, prx.basicGreensockOptions, {
    scale: 0.6,
    ease: easing
  }));
  targetTimeline.set('#' + $targetpage.get(0).id, {
    scale: 2,
    opacity: 0
  }).set('#' + $targetpage.get(0).id, {
    opacity: 1,
    onStart: function onStart() {
      $sourcepage.addClass('menu-in');
      $targetpage.find('.menu-container .menu-listitem').removeClass('menu-up menu-down menu-diag-up-left menu-diag-up-right menu-diag-down-left menu-diag-down-right');
    }
  }, '+=' + duration / 1000 * 0.4).to('#' + $targetpage.get(0).id, duration / 1000 * 0.6, Object.assign({}, prx.basicGreensockOptions, {
    scale: 1,
    ease: easing
  })).call(function () {
    prx.navigation.pageChanged($sourcepage, $targetpage, options);
    $sourcepage.removeClass('prx-page-below prx-page-above');
    $targetpage.removeClass('prx-page-below prx-page-above');
  });
};

prx.screenTransitions.menuOutWatchOS = function ($sourcepage, $targetpage, options) {
  $targetpage.css({
    opacity: 1
  });
  var duration = 250;
  var easing = "ease-out";
  easing = prx.easing.get(easing);
  $targetpage.removeClass('menu-in');
  $targetpage.addClass('prx-page-active prx-page-below');
  $sourcepage.addClass('prx-page-above');
  var sourceTimeline = new TimelineMax();
  var targetTimeline = new TimelineMax();
  var targetBlurTimeline = new TimelineMax();
  var menuItemNum = $sourcepage.find('.menu-container .menu-listitem').length;

  switch (menuItemNum) {
    case 2:
      $sourcepage.find('.menu-container .menu-listitem[data-dynamic-property-index=0]').addClass('menu-up');
      $sourcepage.find('.menu-container .menu-listitem[data-dynamic-property-index=1]').addClass('menu-down');
      break;

    case 3:
      $sourcepage.find('.menu-container .menu-listitem[data-dynamic-property-index=0]').addClass('menu-diag-up-left');
      $sourcepage.find('.menu-container .menu-listitem[data-dynamic-property-index=1]').addClass('menu-diag-up-right');
      $sourcepage.find('.menu-container .menu-listitem[data-dynamic-property-index=2]').addClass('menu-down');
      break;

    case 4:
      $sourcepage.find('.menu-container .menu-listitem[data-dynamic-property-index=0]').addClass('menu-diag-up-left');
      $sourcepage.find('.menu-container .menu-listitem[data-dynamic-property-index=1]').addClass('menu-diag-up-right');
      $sourcepage.find('.menu-container .menu-listitem[data-dynamic-property-index=2]').addClass('menu-diag-down-left');
      $sourcepage.find('.menu-container .menu-listitem[data-dynamic-property-index=3]').addClass('menu-diag-down-right');
      break;

    case 1:
    default:
      break;
  }

  targetTimeline.to('#' + $targetpage.get(0).id, duration / 1000 * 0.8, Object.assign({}, prx.basicGreensockOptions, {
    scale: 1,
    ease: easing,
    onStart: function onStart() {
      $sourcepage.addClass('menu-out');
    }
  }), '+=' + duration / 1000 * 0.2).call(function () {
    prx.navigation.pageChanged($sourcepage, $targetpage, options);
    $sourcepage.removeClass('prx-page-below prx-page-above menu-out');
    $targetpage.removeClass('prx-page-below prx-page-above');
    $sourcepage.find('.menu-container .menu-listitem').removeClass('menu-up menu-down menu-diag-up-left menu-diag-up-right menu-diag-down-left menu-diag-down-right');
  });
}; //WatchOS Notification transition


prx.screenTransitions.notificationInWatchOS = function ($sourcepage, $targetpage, options) {
  $targetpage.css({
    opacity: 1
  });
  var duration = 500;
  var easing = "ease-out";
  $targetpage.addClass('prx-page-active prx-page-above prx-page-transition-notificationInWatchOS prx-page-transition-notificationInWatchOS-notification-in');
  $sourcepage.addClass('prx-page-below prx-page-transition-notificationInWatchOS'); //setTimeout(function() {

  $targetpage.find('.notification-container').addClass('notification-in notification-load'); //}, duration*0.1);

  setTimeout(function () {
    $targetpage.removeClass('prx-page-transition-notificationInWatchOS-notification-in').find('.notification-container').removeClass('notification-in');
    setTimeout(function () {
      prx.navigation.pageChanged($sourcepage, $targetpage, options);
      $sourcepage.removeClass('prx-page-below prx-page-above');
      $targetpage.removeClass('prx-page-below prx-page-above');
      $targetpage.find('.notification-container').removeClass('notification-load');
    }, duration * 0.9);
  }, duration * 0.1);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_scrollable.js":
/*!*********************************************************!*\
  !*** ./sass/player-engine/js/components/_scrollable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.scrollable = {};
prx.scrollable._scrollables = {};
prx.scrollable._scrollableTabbars = [];
prx.scrollable._materialScrollableTabbars = [];
prx.scrollable._materialScrollableTabbarContainers = [];
prx.scrollable._scrollPositions = {};
prx.scrollable.scrolls = {};

prx.scrollable.refresh = function (targetid) {
  $(targetid + ', ' + targetid + ' .box').each(function () {
    if (typeof prx.scrollable._scrollables[this.id + '-inner'] != 'undefined') {
      if ($('#' + this.id + '-inner').is(':visible')) {
        // because if not visible it looses its scroll position
        prx.scrollable._scrollables[this.id + '-inner'].refresh(); // handling click option of iScroll here now instead of initialisation


        if (prx.helper.onmobile()) {
          prx.scrollable._scrollables[this.id + '-inner'].options.click = prx.scrollable.getNumOfScrollableParents(this.id) == 0;
        }

        ;

        if ($(this).hasClass('type-material-tabbar-scrollable')) {
          prx.scrollable.materialFocusTab(this.id, $(this).find('.material-tabbar-scrollable-list-item-input:checked').val(), 0);
          prx.scrollable.materialSetActiveTabIndicator(this.id);
        } else {
          if (prx.scrollable._materialScrollableTabbarContainers[this.id] !== undefined) {
            var $linkedtabbar = $('#' + prx.scrollable._materialScrollableTabbarContainers[this.id]);

            if ($linkedtabbar.length > 0) {
              prx.scrollable.materialFocusContainerPage(this.id, $linkedtabbar.find('.material-tabbar-scrollable-list-item-input:checked').val(), 0);
            }
          }
        }

        var itemid = 'box-' + this.id.split('box-').last();
        var originalPropType = prx.scrollable._scrollables[this.id + '-inner'].options.probeType;
        var updateProbType = false;
        var stateid = $('#' + this.id).parents('[data-state-id]').first().attr('data-state-id');

        var _item = prx.items.getFromAllItemStruct(itemid, stateid);

        if (originalPropType !== 3 && _item && typeof _item.actions != "undefined") {
          for (var i = 0; i < _item.actions.length; i++) {
            if (_item.actions[i].type == "containerscroll" || _item.actions[i].type == "containerscrollto") {
              updateProbType = true;
              break;
            }
          }
        }

        if (originalPropType !== 3 && !updateProbType) {
          for (var i = 0; i < prx.scrollable._scrollableTabbars.length; i++) {
            var _linked = prx.scrollable._scrollableTabbars[i].container + '-' + prx.scrollable._scrollableTabbars[i].linked + '-inner';

            if (_linked == this.id + '-inner') {
              updateProbType = true;
            }
          }
        }

        if (prx.scrollable._materialScrollableTabbarContainers[this.id + '-inner'] !== undefined) {
          if (originalPropType !== 3) {
            updateProbType = true;
          }

          prx.scrollable._scrollables[this.id + '-inner'].options.momentum = false;
          prx.scrollable._scrollables[this.id + '-inner'].options.bounce = false;
        }

        if (originalPropType !== 3 && updateProbType) {
          prx.scrollable._scrollables[this.id + '-inner'].options.probeType = 3;
          prx.scrollable.setOnScrollEventForProbType3(this.id, _item);
        }
      }
    }
  });
  /*
   $.each($('#p-'+pageid+ ' .type-picker, #p-'+pageid+ ' .type-picker-retina, #p-'+pageid+ ' .type-android-scrollable-tabbar, #p-'+pageid+ ' .type-ios7-picker'), function(i, elm){
   if (typeof(prx.scrollable._scrollables[elm.id + '-inner'])!='undefined') {
   prx.scrollable._scrollables[elm.id + '-inner'].refresh();
   }
   });
   */
};

prx.scrollable.enable = function (targetid) {
  $(targetid + ', ' + targetid + ' .box').each(function () {
    if (typeof prx.scrollable._scrollables[this.id + '-inner'] != 'undefined') {
      //if($('#' + this.id + '-inner').is(':visible')) { // because if not visible it looses its scroll position
      prx.scrollable._scrollables[this.id + '-inner'].enable(); //}

    }
  });
};

prx.scrollable.disable = function (targetid) {
  $(targetid + ', ' + targetid + ' .box').each(function () {
    if (typeof prx.scrollable._scrollables[this.id + '-inner'] != 'undefined') {
      //if($('#' + this.id + '-inner').is(':visible')) { // because if not visible it looses its scroll position
      prx.scrollable._scrollables[this.id + '-inner'].disable(); //}

    }
  });
}; // this only seems to be on if the scrollable is currently in momentum (or called through "scroll to"), not while its scrolling via drag


prx.scrollable.checkIfInTransition = function (targetid) {
  var foundintransition = false;
  $(targetid + ', ' + targetid + ' .box').each(function () {
    if (typeof prx.scrollable._scrollables[this.id + '-inner'] != 'undefined') {
      if (prx.scrollable._scrollables[this.id + '-inner'].isInTransition) {
        foundintransition = true;
      }
    }
  });
  return foundintransition;
};

prx.scrollable.endTransitions = function (targetid, event) {
  if (typeof targetid == "undefined") {
    targetid = '#' + prx.navigation._activepage;
  }

  if (prx.helper.onmobile()) {
    var event = $.Event("touchend");
  } else {
    var event = $.Event("mouseup");
  }

  event.target = $('body').get(0);
  $(targetid + ', ' + targetid + ' .box').each(function () {
    if (typeof prx.scrollable._scrollables[this.id + '-inner'] != 'undefined') {
      if (prx.scrollable._scrollables[this.id + '-inner'].initiated) {
        prx.scrollable._scrollables[this.id + '-inner']._end(event);
      }
    }
  });
};

prx.scrollable.iniContainer = function (item, _containerid) {
  if ($('#' + _containerid + '-inner').length == 0) {
    return;
  } //var isAppleWatch = ( (typeof(prx.devices[prx.device]) != "undefined" && prx.devices[prx.device].deviceType == "applewatch") || (typeof(prx.deviceExtraParams)!="undefined" && prx.deviceExtraParams.deviceType == "applewatch")) ? true : false;


  var isAppleWatchCrown = typeof prx.devices[prx.device] != "undefined" && prx.devices[prx.device].scrollType == "crown" || typeof prx.deviceExtraParams != "undefined" && prx.deviceExtraParams.scrollType == "crown" ? true : false;

  if (typeof prx.scrollable._scrollables[_containerid + '-inner'] != 'undefined') {
    prx.scrollable._scrollables[_containerid + '-inner'].destroy();

    prx.scrollable._scrollables[_containerid + '-inner'] = null;
    delete prx.scrollable._scrollables[_containerid + '-inner'];
  }

  if (typeof item.scroll != 'undefined') {
    if (item.scroll != '' && item.scroll != 'none') {
      var _scrollX = false;
      var _scrollY = false;
      var _scrollbars = false;

      var _snap = eval(item.scrollsnap);

      item.scrollToX = item.scrollToX || 0;
      item.scrollToY = item.scrollToY || 0;

      switch (item.scroll) {
        case "omni":
          _scrollX = true;
          _scrollY = true;
          _scrollbars = typeof item.scrollbars == "undefined" ? eval(item.hscrollbar) || eval(item.vscrollbar) : eval(item.scrollbars);
          break;

        case "horizontal":
          _scrollX = true;
          _scrollbars = typeof item.scrollbars == "undefined" ? eval(item.hscrollbar) : eval(item.scrollbars);
          break;

        case "vertical":
          _scrollY = true;
          _scrollbars = typeof item.scrollbars == "undefined" ? eval(item.vscrollbar) : eval(item.scrollbars);
          break;

        default:
          break;
      }

      var _probeType = 0; // default in iscroll is 0.0006. For web we set it to 0.0008 and mobile to 0.0006
      // var _deceleration = (prx.inProtoIOsApp || prx.inProtoAndroidApp) ? 0.0008 : 0.0008;

      var _deceleration = 0.001;

      if (typeof item.actions != "undefined") {
        for (var i = 0; i < item.actions.length; i++) {
          if (item.actions[i].type == "containerscroll" || item.actions[i].type == "containerscrollto") {
            _probeType = 3;
          }
        }
      }

      for (var i = 0; i < prx.scrollable._scrollableTabbars.length; i++) {
        var _linked = prx.scrollable._scrollableTabbars[i].container + '-' + prx.scrollable._scrollableTabbars[i].linked + '-inner';

        if (_linked == _containerid + '-inner') {
          _probeType = 3;
        }
      }

      if (prx.scrollable._materialScrollableTabbarContainers[_containerid] !== undefined) {
        _probeType = 3;
        item.momentum = false;
        item.bounce = false;
      }
      /* TO MAKE CONTAINERS REDEFINED WHEN CHANGE ORIENTATION */


      if ($.isArray(_snap)) {
        _snap = true;
      }

      if (typeof prx.scrollable._scrollables[_containerid + '-inner'] == 'undefined') {
        // even though im not sure how direction lock would affect twowayscroll
        if (typeof item.lockdirection == "undefined" || item.scroll != "omni") {
          item.lockdirection = true;
        }

        if (typeof item.bounce == "undefined") {
          item.bounce = true;
        } //OsWatch styled Scrollbars with fade


        if (isAppleWatchCrown == true && typeof item.watchOSscrollbars !== 'undefined' && item.watchOSscrollbars == true && typeof item.scroll !== 'undefined' && item.scroll == 'vertical') {
          var resizeScrollbarsVal = false;
          var fadeScrollbarsVal = true;
        } else {
          var resizeScrollbarsVal = true;
          var fadeScrollbarsVal = true; //July 6h, Proto.io v6 changed to always FADE
        } //if(typeof(prx.scrollable._scrollables[_containerid + '-inner']) != "undefined") {delete prx.scrollable._scrollables[_containerid + '-inner']};

        /*
         * GS - 3751 inputs and text areas cause browser to scroll along with scrollable containers so we need to preventDefault
         * The line below solves the issue BUT causes a bug when the input/textarea also has an interaction for pan/swipe etc
         */


        $('#' + _containerid + '-inner').off('touchmove.debug', 'input, textarea').on('touchmove.debug', 'input, textarea', function (e) {
          e.preventDefault();
        });
        prx.scrollable._scrollables[_containerid + '-inner'] = new IScroll('#' + _containerid + '-inner', {
          startX: item.scroll == 'omni' || item.scroll == 'horizontal' ? 0 - parseInt(item.scrollToX) : 0,
          startY: item.scroll == 'omni' || item.scroll == 'vertical' ? 0 - parseInt(item.scrollToY) : 0,
          scrollX: _scrollX,
          scrollY: _scrollY,
          snap: _snap,
          useTransition: true,
          resizeScrollbars: resizeScrollbarsVal,
          fadeScrollbars: fadeScrollbarsVal,
          // ANNAM v5.0.18 - causing checkbox labels to click twice and so turn on and off again on desktop
          // All issues caused by click: true (or the absence of it) are because of incompatible behaviour
          // between browser and mobile. so triggering click accordingly
          // annam v5.8 after removing jquery mobile this seems to make no difference on my checboxes, either on or off, but im leaving it as is anyway.
          // annam v5.16.4 we came across this issue of double clicking on checkboxes in export.html when click was set to true (was using prx.mobilebrowser which was true for export)
          // most likely this should be set to false - i dont know if this still makes a difference on mobile so i'm leaving it as it was.
          // click: true,
          // click: prx.mobilebrowser,
          // AH v6.0.32.3 - checkboxes not working properly in scrollable containers
          // we cannot call prx.scrollable.getNumOfScrollableParents here because prx.scrollable._scrollables doesn't
          // exist yet, we are now handling this in prx.scrollable.refresh
          click: false,
          // prx.helper.onmobile() && prx.scrollable.getNumOfScrollableParents(_containerid) == 0,
          //preventDefault: false,
          //tap: true,
          zoom: eval(item.pinchzoom),
          momentum: eval(item.momentum),
          bounce: item.bounce,
          bounceLock: true //,lockDirection: eval(item.lockdirection) // not used in iscroll5, use freeScroll instead
          ,
          freeScroll: !eval(item.lockdirection),
          directionLockThreshold: 0 // for better lockdirection
          ,
          scrollbars: _scrollbars,
          mouseWheel: true,
          probeType: _probeType //,keyBindings: true
          ,
          snapThreshold: 0.25 // for less tolerant change page. original 0.334.
          ,
          deceleration: _deceleration // original 0.0006
          // this is a setting that is used by iscroll so that if you have nested iscrolls, eg one horizontal and one vertical, and you scroll one,
          // it locks scrolling in the other direction. this is why it needs to be off for omni.
          ,
          twoWayScroll: item.scroll == "omni" ? false : true,
          interactiveScrollbars: true,
          disablePointer: true // pointerevents which was enabled on chrome 55 dont work correctly on android phones
          //,disableTouch: !prx.helper.onmobile()
          //,disableMouse: prx.helper.onmobile()

        }); // I have no idea how this behaves on iScroll 5 (AP)

        /*
         prx.scrollable._scrollables[_containerid + '-inner'].on('beforeScrollStart', function() {
         var target = e.target;
         while (target.nodeType != 1)
         target = target.parentNode;
         if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA') {
         e.preventDefault();
         }
         });
         */

        /*
         prx.scrollable._scrollables[_containerid + '-inner'].on('move', function() {
           });
         */

        $('#' + _containerid + '-inner').on('click', function (event) {
          if ($(event.target).prop('tagName').toLowerCase() != "input" && $(event.target).prop('tagName').toLowerCase() != "textarea") prx.helper.blurInputs();
        });

        if (_probeType == 3) {
          prx.scrollable.setOnScrollEventForProbType3(_containerid, item);
        }

        prx.scrollable._scrollables[_containerid + '-inner'].on('scrollStart', function () {
          var _targetid = _containerid + '-inner';

          var _triggerId = '#' + _containerid;

          var _r = {};

          if (typeof prx.variables._triggerData[_triggerId] == "undefined") {
            prx.variables._triggerData[_triggerId] = {};
          }

          $(_triggerId).parents('.box').each(function () {
            // all symbols
            if (typeof prx.scrollable._scrollables[this.id + '-inner'] != "undefined") {
              prx.scrollable._scrollables[this.id + '-inner'].disable();
            }
          });
        });

        prx.scrollable._scrollables[_containerid + '-inner'].on('scrollEnd', function () {
          // TODO for some reason if we have nested containers and we scroll inner, the next time we touch to start scrolling any of the two, the outer container scrollend is triggered
          var _targetid = _containerid + '-inner';

          var _triggerId = '#' + _containerid;

          var _r = {};

          if (typeof prx.variables._triggerData[_triggerId] == "undefined") {
            prx.variables._triggerData[_triggerId] = {};
          }

          $(_triggerId).parents('.box').each(function () {
            // all symbols
            if (typeof prx.scrollable._scrollables[this.id + '-inner'] != "undefined") {
              prx.scrollable._scrollables[this.id + '-inner'].enable();
            }
          });

          if (eval(item.scrollsnap)) {
            if (prx.compatibility.iscrolljs) {
              _r.x = this.x * -1;
              _r.y = this.y * -1;
            } else {
              _r.x = this.x;
              _r.y = this.y;
            }

            _r.currentpagex = this.currentPage.pageX + 1;
            _r.currentpagey = this.currentPage.pageY + 1;
            _r.currentpagexindex = this.currentPage.pageX;
            _r.currentpageyindex = this.currentPage.pageY;
            prx.variables._triggerData[_triggerId]['containerpagechange'] = _r;
            prx.variables._triggerData[_triggerId]['containerpageenter'] = _r;
            prx.variables._triggerData[_triggerId]['containerscrollend'] = _r;
            $('#' + _containerid).trigger('containerpagechange', this);
            $('#' + _containerid).trigger('containerpageenter.page' + this.currentPage.pageX + '-' + this.currentPage.pageY, this);
            $('#' + _containerid).trigger('containerscrollend', this);
          } else {
            if (prx.compatibility.iscrolljs) {
              _r.x = this.x * -1;
              _r.y = this.y * -1;
            } else {
              _r.x = this.x;
              _r.y = this.y;
            }

            _r.currentpagex = 1;
            _r.currentpagey = 1;
            _r.currentpagexindex = 0;
            _r.currentpageyindex = 0;
            prx.variables._triggerData[_triggerId]['containerscrollend'] = _r;
            $('#' + _containerid).trigger('containerscrollend', this);
          }

          if (prx.scrollable._materialScrollableTabbarContainers[_containerid] !== undefined) {
            prx.scrollable.materialFocusTab(prx.scrollable._materialScrollableTabbarContainers[_containerid], this.currentPage.pageX);
          } // ANNAM v5.10.8
          // prevents scrollend to be triggered again on next tap event. unfortunately only if snap = false
          //this.moved = false;
          //this.initiated = false;

        }); // if scroll is on but the container is not really scrollable, scroll start is triggered but the code ends up going to scroll cancel


        prx.scrollable._scrollables[_containerid + '-inner'].on('scrollCancel', function () {
          var _targetid = _containerid + '-inner';

          var _triggerId = '#' + _containerid;

          $(_triggerId).parents('.box').each(function () {
            // all symbols
            if (typeof prx.scrollable._scrollables[this.id + '-inner'] != "undefined") {
              prx.scrollable._scrollables[this.id + '-inner'].enable();
            }
          });
        }); // iScroll5 does not support this
        //var RESIZE_EV = 'onorientationchange' in window ? 'orientationchange' : 'resize';
        //prx.scrollable._scrollables[_containerid + '-inner']._unbind(RESIZE_EV, window);


        for (var i = 0; i < prx.scrollable._scrollableTabbars.length; i++) {
          var _linked = prx.scrollable._scrollableTabbars[i].container + '-' + prx.scrollable._scrollableTabbars[i].linked + '-inner';

          if (_linked == _containerid + '-inner') {
            /* WARNING! THIS IS ALSO COPIED IN ANDROID COMPONENTS.JS! */
            var _tabbar = prx.scrollable._scrollableTabbars[i].container + '-' + prx.scrollable._scrollableTabbars[i].id + '-inner';

            prx.scrollable._scrollables[_linked].options.linkedTabbar = _tabbar;

            prx.scrollable._scrollables[_linked].goToPage(Number(prx.scrollable._scrollableTabbars[i].start), 0, 0);

            if (typeof prx.scrollable._scrollables[_tabbar] != "undefined") {
              // for some reason this needs to be here when the tabbar is not in the startscreen. XL :o
              prx.scrollable._scrollables[_tabbar].goToPage(Number(prx.scrollable._scrollableTabbars[i].start), 0, 0);
            }

            prx.scrollable._scrollables[_linked].on('scroll', function () {
              var x = this.x;

              prx.scrollable._scrollables[this.options.linkedTabbar].scrollTo(x / 2, 0, 0, false);
            });

            $(prx.scrollable._scrollables[_linked].wrapper).on('mouseup touchend', function () {
              prx.scrollable._scrollables[prx.scrollable._scrollables[this.id].options.linkedTabbar].scrollTo(prx.scrollable._scrollables[prx.scrollable._scrollables[this.id].options.linkedTabbar].pages[prx.scrollable._scrollables[this.id].currentPage.pageX][0].x, 0, 200, false);
            });
            break;
          }
        } //} catch(err){};

      }
    }
  }
};

prx.scrollable.iniTabbar = function (i) {
  var _tabbar = prx.scrollable._scrollableTabbars[i].container + '-' + prx.scrollable._scrollableTabbars[i].id + '-inner';

  var _linked = prx.scrollable._scrollableTabbars[i].container + '-' + prx.scrollable._scrollableTabbars[i].linked + '-inner';

  var _bLinked = false;

  if (typeof prx.scrollable._scrollables[_tabbar] != "undefined") {
    prx.scrollable._scrollables[_tabbar].destroy();

    prx.scrollable._scrollables[_tabbar] = null;
  }

  prx.scrollable._scrollables[_tabbar] = new IScroll('#' + _tabbar, {
    scrollX: true,
    scrollY: false,
    probeType: 3,
    //hScrollbar: false,
    //vScrollbar: false,
    scrollbars: false,
    useTransition: true,
    momentum: false,
    snap: 'li',
    linkedContainer: _linked,
    twoWayScroll: true
  });
  $(prx.scrollable._scrollables[_tabbar].wrapper).on('mouseup touchend', function () {
    if (typeof prx.scrollable._scrollables[prx.scrollable._scrollables[_tabbar].options.linkedContainer] != 'undefined') {
      prx.scrollable._scrollables[prx.scrollable._scrollables[this.id].options.linkedContainer].goToPage(prx.scrollable._scrollables[this.id].currentPage.pageX, 0, 200);
    }
  });

  prx.scrollable._scrollables[_tabbar].on('scroll', function () {
    if (typeof prx.scrollable._scrollables[this.options.linkedContainer] != 'undefined') {
      var x = this.x;

      prx.scrollable._scrollables[this.options.linkedContainer].scrollTo(x * 2, 0, 0, false);
    }
  });

  prx.scrollable._scrollables[_tabbar].goToPage(Number(prx.scrollable._scrollableTabbars[i].start), 0, 0);

  $('#' + _tabbar).hammer();
  prx.actions.hammer('#' + _tabbar, 'tap');
};

prx.scrollable.materialIniTabbar = function (item, containerid) {
  var _id = !containerid ? item.id : containerid + '-' + item.id; //var dims = prx.componentsHelper.getRealDims(item);


  if (prx.allItems[item.linkedContainer] === undefined) {
    return;
  }

  prx.scrollable._materialScrollableTabbars[item.id] = {
    container: containerid,
    linked: item.linkedContainer,
    start: item.selected
  };

  var _tabbar = _id + '-inner';

  prx.scrollable._materialScrollableTabbarContainers[containerid + '-' + item.linkedContainer] = containerid + '-' + item.id;
  var stateid = $('#' + _id).parents('[data-state-id]').first().attr('data-state-id');
  var containeritem = prx.items.getFromAllItemStruct(item.linkedContainer, stateid);

  if (containeritem == false) {
    return false;
  }

  var activewidth = $('#' + _id).find('.material-tabbar-scrollable-list-item-input:checked').parents('li').width();
  prx.scrollable.iniContainer(containeritem, containerid + '-' + containeritem.id); // need to reinitialize item to make sure that it knows it is part of a scrollable.

  if (typeof prx.scrollable._scrollables[_tabbar] != "undefined") {
    prx.scrollable._scrollables[_tabbar].destroy();

    prx.scrollable._scrollables[_tabbar] = null;
  }

  prx.scrollable._scrollables[_tabbar] = new IScroll('#' + _tabbar, {
    scrollX: true,
    scrollY: false,
    probeType: 3,
    scrollbars: false,
    useTransition: true,
    momentum: true,
    twoWayScroll: true,
    bounce: false,
    linked: item.linkedContainer
  });

  prx.scrollable._scrollables[_tabbar].on('scrollStart', function (a) {
    $(this.scroller).addClass('scrolling');
  });

  prx.scrollable._scrollables[_tabbar].on('scrollEnd', function (a) {
    $(this.scroller).removeClass('scrolling');
  });

  prx.scrollable._scrollables[_tabbar].on('scroll', function (a) {
    prx.scrollable.materialSetActiveTabIndicator(_id);
  });

  $('#' + _id + ' .material-tabbar-scrollable-list-item-label').hammer().on('tap', function () {
    $('#' + _id + ' .material-tabbar-scrollable-list-item-input[id=' + $(this).attr('for') + ']').prop('checked', true);
    var val = $('#' + _id).find('.material-tabbar-scrollable-list-item-input:checked').val();
    prx.scrollable.materialFocusTab(_id, val);
    prx.scrollable.materialFocusContainerPage(containerid + '-' + item.linkedContainer, val);
  });
  prx.actions.hammer('#' + _id + ' .material-tabbar-scrollable-list-item-label', 'tap');
  $('#' + _id + ' .material-tabbar-scrollable-list-item-input').on('change', function () {
    var val = $(this).val();
    prx.scrollable.materialFocusTab(_id, val);
    prx.scrollable.materialFocusContainerPage(containerid + '-' + item.linkedContainer, val);
  });
  prx.scrollable.materialFocusTab(_id, item.selected);
  prx.scrollable.materialFocusContainerPage(containerid + '-' + item.linkedContainer, item.selected, 0);
};

prx.scrollable.materialIntermittentMoveTab = function (id, currentindex, percent) {
  currentindex = parseInt(currentindex);
  var targetindex = percent > 0 ? currentindex + 1 : currentindex - 1;
  var $selected = $('#' + id + ' li').eq(currentindex);
  var $target = $('#' + id + ' li').eq(targetindex);

  if ($target.length == 0) {
    return;
  }

  var activewidth = $selected.width();
  var targetwidth = $target.width();
  var activeleft = prx.scrollable.materialGetTabLeft(id, currentindex);
  var targetleft = prx.scrollable.materialGetTabLeft(id, targetindex);
  var activeleftreal = prx.scrollable.materialGetRealTabLeft(id, currentindex);
  var targetleftreal = prx.scrollable.materialGetRealTabLeft(id, targetindex);
  var offset = $selected.position().left;
  var target = activeleft - targetleft * percent;
  var toscroll = -(offset - target);
  toscroll = prx.scrollable.materialCheckBounds(id, toscroll);
  $('#' + id + ' .material-tabbar-scrollable-indicator').css({
    width: activewidth + (targetwidth - activewidth) * Math.abs(percent) + 'px',
    left: activeleftreal + (targetleftreal - activeleftreal) * Math.abs(percent) + 'px'
  });

  prx.scrollable._scrollables[id + '-inner'].scrollBy(toscroll, 0, 0);
};

prx.scrollable.materialGetTabLeft = function (id, index) {
  var $selected = $('#' + id + ' li').eq(index);
  var width = $selected.width();
  var outerwidth = $('#' + id).width();
  var target = (outerwidth - width) / 2;
  return target;
};

prx.scrollable.materialGetRealTabLeft = function (id, index) {
  var $selected = $('#' + id + ' li').eq(index);
  var width = $selected.width();
  var outerwidth = $('#' + id).width();
  var target = (outerwidth - width) / 2;
  var fullwidth = $('#' + id + ' ul').width();

  var pos = $selected.offset().left - prx.scrollable._scrollables[id + '-inner'].x;

  if (pos < target) {
    return pos;
  }

  if (fullwidth - pos < outerwidth - (outerwidth - width) / 2) {
    return $selected.offset().left;
  }

  return target;
};

prx.scrollable.materialCheckBounds = function (id, toscroll) {
  if (prx.scrollable._scrollables[id + '-inner'] === undefined) {
    return false;
  }

  if (prx.scrollable._scrollables[id + '-inner'].x + toscroll > 0) {
    toscroll = -prx.scrollable._scrollables[id + '-inner'].x;
  }

  if (prx.scrollable._scrollables[id + '-inner'].x + toscroll < prx.scrollable._scrollables[id + '-inner'].maxScrollX) {
    toscroll = prx.scrollable._scrollables[id + '-inner'].maxScrollX - prx.scrollable._scrollables[id + '-inner'].x;
  }

  return toscroll;
};

prx.scrollable.materialFocusTab = function (id, index, timing) {
  if (timing === undefined) {
    timing = 400;
  }

  if (prx.scrollable._scrollables[id + '-inner'] === undefined) {
    return false;
  }

  var $selected = $('#' + id + ' li').eq(index);
  $selected.find('input').prop('checked', true); // this returns the current position in the visible area, as if it was positioned absolutely there, not the position inside the parent.

  var offset = $selected.position().left;
  var target = prx.scrollable.materialGetTabLeft(id, index);
  var toscroll = -(offset - target);
  toscroll = prx.scrollable.materialCheckBounds(id, toscroll);

  prx.scrollable._scrollables[id + '-inner'].scrollBy(toscroll, 0, timing);
}; // only triggering this on page load to make sure that is correct, otherwise the indicator is set because of teh moveintermittent function
// also using for on tabbar scroll


prx.scrollable.materialSetActiveTabIndicator = function (id, index) {
  if (index === undefined) {
    index = $('#' + id).find('.material-tabbar-scrollable-list-item-input:checked').val();
  }

  var $selected = $('#' + id + ' li').eq(index);
  var offset = $selected.position().left;
  $('#' + id + ' .material-tabbar-scrollable-indicator').css({
    width: $selected.width() + 'px',
    left: offset + 'px'
  });
};

prx.scrollable.materialFocusContainerPage = function (id, index, timing) {
  if (timing === undefined) {
    timing = 400;
  }

  if (prx.scrollable._scrollables[id + '-inner'] !== undefined) {
    prx.scrollable._scrollables[id + '-inner'].goToPage(index, 0, timing);
  }
};

prx.scrollable.getNumOfScrollableParents = function (_containerid) {
  var _substr = _containerid,
      _count = 0; // while we don't reach the pageid in the string

  while (/^p-\d+$/.test(_substr) == false) {
    // first, so that on first run we remove child scrollable from id string first
    _substr = _substr.substring(0, _substr.lastIndexOf('box') - 1);

    if (prx.scrollable._scrollables[_substr + '-inner'] !== undefined) {
      _count++;
    }
  }

  return _count;
};

prx.scrollable.setOnScrollEventForProbType3 = function (_containerid, _item) {
  prx.scrollable._scrollables[_containerid + '-inner'].off('scroll');

  prx.scrollable._scrollables[_containerid + '-inner'].on('scroll', function () {
    var _targetid = _containerid + '-inner';

    var _triggerId = '#' + _containerid;

    var _r = {};

    if (prx.actions.scrolltos.length !== 0) {
      var x = this.x * -1;
      var y = this.y * -1;

      if (prx.scrollable.scrolls[_containerid] !== undefined) {
        var _getScrolls = function _getScrolls(dir, min, max, itemid) {
          var _s = prx.actions.scrolltos.filter(function (item) {
            return item.dir === dir && item.val >= min && item.val <= max && item.item == itemid;
          });

          return _s;
        };

        var _triggerActions = function _triggerActions(scrolls) {
          scrolls.forEach(function (item) {
            $('#' + _containerid).trigger('containerscrollto' + item.namespace, this);
          });
        };

        var diffX = x - prx.scrollable.scrolls[_containerid].x;
        var diffY = y - prx.scrollable.scrolls[_containerid].y;

        if (diffX > 0) {
          var max = x,
              min = x - diffX;

          var scrolls = _getScrolls('horizontali', min, max, '#' + _containerid);

          _triggerActions(scrolls);
        } else {
          var max = x - diffX,
              min = x;

          var scrolls = _getScrolls('horizontald', min, max, '#' + _containerid);

          _triggerActions(scrolls);
        }

        if (diffY > 0) {
          var max = y,
              min = y - diffY;

          var scrolls = _getScrolls('verticali', min, max, '#' + _containerid);

          _triggerActions(scrolls);
        } else {
          var max = y - diffY,
              min = y;

          var scrolls = _getScrolls('verticald', min, max, '#' + _containerid);

          _triggerActions(scrolls);
        }
      } else {
        prx.scrollable.scrolls[_containerid] = {};
      }

      prx.scrollable.scrolls[_containerid].x = x;
      prx.scrollable.scrolls[_containerid].y = y;
    }

    if (typeof prx.variables._triggerData[_triggerId] == "undefined") {
      prx.variables._triggerData[_triggerId] = {};
    }

    if (eval(_item.scrollsnap)) {
      if (prx.compatibility.iscrolljs) {
        _r.x = this.x * -1;
        _r.y = this.y * -1;
      } else {
        _r.x = this.x;
        _r.y = this.y;
      }

      _r.currentpagex = this.currentPage.pageX + 1;
      _r.currentpagey = this.currentPage.pageY + 1;
      _r.currentpagexindex = this.currentPage.pageX;
      _r.currentpageyindex = this.currentPage.pageY;
      prx.variables._triggerData[_triggerId]['containerscroll'] = _r;
      $('#' + _containerid).trigger('containerscroll', this);
    } else {
      if (prx.compatibility.iscrolljs) {
        _r.x = this.x * -1;
        _r.y = this.y * -1;
      } else {
        _r.x = this.x;
        _r.y = this.y;
      }

      _r.currentpagex = 1;
      _r.currentpagey = 1;
      _r.currentpagexindex = 0;
      _r.currentpageyindex = 0;
      prx.variables._triggerData[_triggerId]['containerscroll'] = _r;
      $('#' + _containerid).trigger('containerscroll', this);
    }

    if (eval(_item.scrollsnap) && prx.scrollable._materialScrollableTabbarContainers[_containerid] !== undefined) {
      var x = this.x;
      prx.scrollable.materialIntermittentMoveTab(prx.scrollable._materialScrollableTabbarContainers[_containerid], this.currentPage.pageX, (this.currentPage.x - x) / this.wrapperWidth);
    }
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_show-actions.js":
/*!***********************************************************!*\
  !*** ./sass/player-engine/js/components/_show-actions.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.showActions = {};
prx.showActions._shiftShowingActions = false;
prx.showActions._flashActions = true;
prx.showActions._shiftKeyDown = false;

prx.showActions.on = function (simple) {
  // check if there isn't a current screen or state action that listens for shift. if there is that will be triggered and so we should disable our native shift.
  var activeScreenIndex = prx.stc.screens.getIndexFromId(prx.navigation._activepage.replace('p-', ''));
  var activeStateIds = prx.states.getActivePageActiveStates();
  var screenShiftDownActions = (prxy.pages[activeScreenIndex].actions || []).filter(function (action) {
    return action.type === "keydown" && ($.isArray(action.charCode) && action.charCode[0] == 16 || !$.isArray(action.charCode) && action.charCode == 16);
  }).length;
  var screensStateShiftDownActions = (prxy.pages[activeScreenIndex].states[prx.stc.helper.getStateIndexFromId(activeStateIds.pages, "pages", activeScreenIndex)].actions || []).filter(function (action) {
    return action.type === "statekeydown" && ($.isArray(action.charCode) && action.charCode[0] == 16 || !$.isArray(action.charCode) && action.charCode == 16);
  }).length; // get all containers that are in screen, and sum up ther "shift keydown" state actions

  var containersStateShiftDownActions = prxy.symbols.filter(function (symbol) {
    return activeStateIds.symbols.hasOwnProperty(symbol.id);
  }).map(function (symbol) {
    // get the sum of "shift keydown" interactions of all active states of each container on screen
    return symbol.states.filter(function (state) {
      return activeStateIds.symbols[symbol.id].indexOf(state.id) > -1;
    }).map(function (state) {
      return (state.actions || []).filter(function (action) {
        return action.type === "statekeydown" && ($.isArray(action.charCode) && action.charCode[0] == 16 || !$.isArray(action.charCode) && action.charCode == 16);
      }).length;
    }).reduce(function (a, b) {
      return a + b;
    }, 0);
  }).reduce(function (a, b) {
    return a + b;
  }, 0);
  if (screenShiftDownActions || screensStateShiftDownActions || containersStateShiftDownActions) return;
  prx.showActions.show(simple);
  prx.showActions._shiftShowingActions = true;
  prx.crossmsg.send({
    action: 'show-actions',
    data: {
      activeStateIds: prx.states.getActivePageActiveStates()
    }
  });
};

prx.showActions.off = function (simple) {
  prx.showActions.hide();
  prx.showActions._shiftShowingActions = false;
  prx.crossmsg.send({
    action: 'hide-actions'
  });
};

prx.showActions.show = function (simple) {
  if (typeof simple == "undefined") {
    simple = false;
  }

  var ahClass = simple ? 'action-highlight-simple-visible' : 'action-highlight-visible';
  $('.action-highlight').addClass(ahClass);
};

prx.showActions.hide = function () {
  $('.action-highlight').removeClass('action-highlight-visible action-highlight-simple-visible');
};

prx.showActions.iniShift = function () {
  // in two places, also in web.cfm
  if (!prx.export2html && !prx.embed && !prx.helper.onmobile() && parent != window) {
    var keys = {};
    $(document).keydown(function (e) {
      if (e.which == 16 || e.metaKey) {
        keys[e.which] = true;

        if (keys[16] && navigator.appVersion.indexOf("Mac") != -1 && e.metaKey && !$("input,textarea").is(":focus")) {
          try {
            prx.showActions.off();
          } catch (e) {}
        } else if (keys[16] && !$("input,textarea").is(":focus")) {
          try {
            prx.showActions.on();
          } catch (e) {}
        }
      }
    }).keyup(function (e) {
      if (e.which == 16) {
        keys = {};

        try {
          prx.showActions.off();
        } catch (e) {}
      }
    });
  }
};

prx.showActions.flash = {};

prx.showActions.flash.ini = function () {
  prx.showActions._flashActions = prx.projectsettings.flashactions;

  if (prx.export2html != "1" && !prx.embed) {
    var flashactions = prx.kvs.get(prx.showActions.flash.getKVSName());

    if (flashactions !== null) {
      prx.showActions._flashActions = eval(flashactions);
    }
  }

  if (prx.showActions._flashActions) {
    prx.showActions.flash.enable(false);
  }
};

prx.showActions.flash.enable = function (setcookie) {
  if (setcookie === undefined) {
    setcookie = true;
  }

  prx.showActions._flashActions = true; // used for share links due to cross browsing

  if (setcookie && prx.export2html != "1" && !prx.embed && prx.prto) {
    prx.kvs.set(prx.showActions.flash.getKVSName(), prx.showActions._flashActions);
  }

  $('body').hammer().on('tap.flashactions', function (e) {
    if ($(e.target).attr('id') === 'mbd') setTimeout(prx.showActions.flash.flash, 20);
  });
};

prx.showActions.flash.disable = function () {
  prx.showActions._flashActions = false; // used for share links due to cross browsing

  if (prx.export2html != "1" && !prx.embed && prx.prto) {
    prx.kvs.set(prx.showActions.flash.getKVSName(), prx.showActions._flashActions);
  }

  $('body').off('tap.flashactions');
};

prx.showActions.flash.flash = function () {
  if (prx.showActions._flashActions && !prx.actions.justtapped && !prx.showActions._shiftShowingActions) {
    prx.showActions.show(true);
    setTimeout(function () {
      prx.showActions.hide();
    }, 350);
  }

  prx.actions.justtapped = false;
};

prx.showActions.flash.getKVSName = function () {
  if (prx.spaces) {
    return 'flashactions_spaces';
  }

  if (prx.prto) {
    return 'flashactions_' + prx.projectsettings.v;
  }

  return 'flashactions_' + prx.projectsettings.id;
}; // NOT BEING USED found a fix for inputs :D hammer wrapper div, not input.
// cant hammer() input elements :(
// and justtapped might not be removed automatically if eg we focus input on screen show
// it would turn on justtapped but not back off


prx.showActions.addRemoveJustTapped = function () {
  prx.actions.justtapped = true;
  setTimeout(function () {
    prx.actions.justtapped = false;
  }, 50);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_states.js":
/*!*****************************************************!*\
  !*** ./sass/player-engine/js/components/_states.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.states = {};
prx.states._timelines = {};
prx.states._changes = {};

prx.states.getChangesBetweenStates = function (fromstateid, tostateid, type, index) {
  if (typeof type == "undefined") type = prx.getPageTemplateSymbolType();
  if (typeof index == "undefined") index = prx.getPageTemplateSymbolIndex();

  if (typeof prx.states._changes[fromstateid + ":" + tostateid] != "undefined") {
    return JSON.parse(JSON.stringify(prx.states._changes[fromstateid + ":" + tostateid]));
  } // var changes = {};


  var changes = [];
  var fromstateindex = prx.stc.helper.getStateIndexFromId(fromstateid, type, index);
  var tostateindex = prx.stc.helper.getStateIndexFromId(tostateid, type, index);

  if (fromstateindex == -1 || tostateindex == -1) {
    return false;
  }

  switch (type) {
    case "pages":
    case "templates":
      if (prx.gradients.prxToCss(prxy[type][index].states[fromstateindex].background) !== prx.gradients.prxToCss(prxy[type][index].states[tostateindex].background) || prxy[type][index].states[fromstateindex].template.stateid != prxy[type][index].states[tostateindex].template.stateid) {
        var containerChanges = type == 'pages' ? {
          type: 'page-properties',
          id: 'current-page',
          changes: {}
        } : {
          type: 'template-properties',
          id: 'current-page-template',
          changes: {}
        }; //if(typeof(changes.containerProperties) == "undefined") { changes.containerProperties = {}; }

        if (prx.gradients.prxToCss(prxy[type][index].states[fromstateindex].background) !== prx.gradients.prxToCss(prxy[type][index].states[tostateindex].background)) {
          containerChanges.changes.background = [prxy[type][index].states[fromstateindex].background, prxy[type][index].states[tostateindex].background];
        }

        if (prxy[type][index].states[fromstateindex].template.stateid != prxy[type][index].states[tostateindex].template.stateid) {
          containerChanges.changes.templatestateid = [prxy[type][index].states[fromstateindex].template.stateid, prxy[type][index].states[tostateindex].template.stateid];
        }

        containerChanges.changes_order = Object.keys(containerChanges.changes).sort(prx.states.sortChanges);
        changes.push(containerChanges);
      }

      break;

    case "symbols":
      if (prxy[type][index].states[fromstateindex].dimensions[0] != prxy[type][index].states[tostateindex].dimensions[0] || prxy[type][index].states[fromstateindex].dimensions[1] != prxy[type][index].states[tostateindex].dimensions[1] || prx.gradients.prxToCss(prxy[type][index].states[fromstateindex].background) !== prx.gradients.prxToCss(prxy[type][index].states[tostateindex].background)) {
        var containerChanges = {
          type: 'container-properties',
          id: 'current-container',
          changes: {}
        };

        if (prxy[type][index].states[fromstateindex].dimensions[0] != prxy[type][index].states[tostateindex].dimensions[0]) {
          containerChanges.changes.width = [prxy[type][index].states[fromstateindex].dimensions[0], prxy[type][index].states[tostateindex].dimensions[0]];
        }

        if (prxy[type][index].states[fromstateindex].dimensions[1] != prxy[type][index].states[tostateindex].dimensions[1]) {
          containerChanges.changes.height = [prxy[type][index].states[fromstateindex].dimensions[1], prxy[type][index].states[tostateindex].dimensions[1]];
        }

        if (prx.gradients.prxToCss(prxy[type][index].states[fromstateindex].background) !== prx.gradients.prxToCss(prxy[type][index].states[tostateindex].background)) {
          //if(typeof(changes.containerProperties) == "undefined") { changes.containerProperties = {}; }
          containerChanges.changes.background = [prxy[type][index].states[fromstateindex].background, prxy[type][index].states[tostateindex].background];
        }

        containerChanges.changes_order = Object.keys(containerChanges.changes).sort(prx.states.sortChanges);
        changes.push(containerChanges);
      }

      break;
  }

  var changedGroups = {
    opacity: [],
    visible: []
  }; // groups

  if (JSON.stringify(prxy[type][index].states[fromstateindex].groups) != JSON.stringify(prxy[type][index].states[tostateindex].groups)) {
    for (var group in prxy[type][index].states[tostateindex].groups) {
      if (prxy[type][index].states[fromstateindex].groups[group] === undefined) {
        changes.push({
          type: 'new-group',
          id: 'group-' + group,
          group: prxy[type][index].states[tostateindex].groups[group],
          opacity: [0, prxy[type][index].states[tostateindex].groups[group].opacity],
          visible: [0, prxy[type][index].states[tostateindex].groups[group].visible]
        });
        changedGroups.opacity.push(group);
        changedGroups.visible.push(group);
      } else {
        if (prxy[type][index].states[fromstateindex].groups[group].opacity != prxy[type][index].states[tostateindex].groups[group].opacity || prxy[type][index].states[fromstateindex].groups[group].visible != prxy[type][index].states[tostateindex].groups[group].visible) {
          var comp_changes = {};

          if (prxy[type][index].states[fromstateindex].groups[group].opacity != prxy[type][index].states[tostateindex].groups[group].opacity) {
            comp_changes.opacity = [prxy[type][index].states[fromstateindex].groups[group].opacity, prxy[type][index].states[tostateindex].groups[group].opacity];
            changedGroups.opacity.push(group);
          }

          if (prxy[type][index].states[fromstateindex].groups[group].visible != prxy[type][index].states[tostateindex].groups[group].visible) {
            comp_changes.visible = [prxy[type][index].states[fromstateindex].groups[group].opacity, prxy[type][index].states[tostateindex].groups[group].visible];
            changedGroups.visible.push(group);
          }

          changes.push(Object.assign({
            type: 'changed-group',
            id: 'group-' + group,
            group: prxy[type][index].states[tostateindex].groups[group]
          }, comp_changes));
        }
      }
    }

    for (var group in prxy[type][index].states[fromstateindex].groups) {
      if (prxy[type][index].states[tostateindex].groups[group] === undefined) {
        changes.push({
          type: 'removed-group',
          id: 'group-' + group,
          group: prxy[type][index].states[fromstateindex].groups[group],
          opacity: [prxy[type][index].states[fromstateindex].groups[group].opacity, 0],
          visible: [prxy[type][index].states[fromstateindex].groups[group].visible, 0]
        });
        changedGroups.opacity.push(group);
        changedGroups.visible.push(group);
      }
    }
  }

  var fromstate = prxy[type][index].states[fromstateindex].data;
  var tostate = prxy[type][index].states[tostateindex].data; // first check if same
  // this could be still affected by external changes:
  // container dimensions or groups

  /*
   if (fromstate == tostate) {
   prx.states._changes[fromstateid + ":" + tostateid] = changes;
   return JSON.parse(JSON.stringify(changes));
   }
   */

  fromstate = JSON.parse(fromstate);
  tostate = JSON.parse(tostate); // check if components the same

  var fromlist = [];
  var tolist = [];

  for (var i = 0; i < fromstate.length; i++) {
    fromlist.push(fromstate[i].id);
  }

  for (i = 0; i < tostate.length; i++) {
    tolist.push(tostate[i].id);
  } // different objects, or different order


  if (fromlist.toString() != tolist.toString()) {
    // different order
    // v5.2.9 always reordering to take care of new components that were originally added at the end of the array
    // v5.10 moving this in if statement - why should i reorder if the order is the same? expensive dom manipulation. for new components this should be ok.
    changes.push({
      type: 'reordered-components',
      new_order: tolist.toString(),
      old_order: fromlist.toString()
    }); // different objects

    if (fromlist.slice(0).sort().toString() != tolist.slice(0).sort().toString()) {
      // slice(0) is a hack for cloning arrays
      // removed components
      for (i = 0; i < fromlist.length; i++) {
        if (tolist.indexOf(fromlist[i]) == -1) {
          //if(typeof(changes.removedComponents) == "undefined") { changes.removedComponents = [] }
          //changes.removedComponents.push(fromlist[i]);
          var comp_changes = {};
          comp_changes.opacity = [fromlist[i].opacity, 0];
          var changes_order = Object.keys(comp_changes).sort(prx.states.sortChanges);
          changes.push({
            type: 'removed-component',
            id: fromlist[i],
            item: fromstate[i],
            componentType: fromstate[i].type,
            changes: comp_changes,
            changes_order: changes_order
          });
          fromlist.splice(i, 1);
          i--;
        }
      } // new components


      for (i = 0; i < tolist.length; i++) {
        if (fromlist.indexOf(tolist[i]) == -1) {
          //if(typeof(changes.newComponents) == "undefined") { changes.newComponents = [] }
          //changes.newComponents.push(tolist[i])
          for (j = 0; j < tostate.length; j++) {
            if (tostate[j].id == tolist[i]) {
              var comp_changes = {};
              comp_changes.opacity = [0, tostate[j].opacity];
              var changes_order = Object.keys(comp_changes).sort(prx.states.sortChanges);
              var item = tostate[j];
              item.opacity = 0;
              changes.push({
                type: 'new-component',
                id: tolist[i],
                componentType: tostate[j].type,
                item: item,
                changes: comp_changes,
                changes_order: changes_order
              });
              tolist.splice(i, 1);
              i--;
              break;
            }
          }
        }
      }
    } // now two arrays contain the same items, possibly in different order. only contain the items that are common?
    // different order
    // v5.2.9 removing if statement and moving above detection of new/removed components

    /*
     if(fromlist.toString() != tolist.toString()) {
     changes.push({
     type: 'reordered-components',
     new_order: tolist.toString(),
     old_order: fromlist.toString()
     })
       }
     */
    // delete to avoid coming up on diff compare


    for (i = 0; i < fromstate.length; i++) {
      if (typeof fromstate[i].zindex != "undefined") {
        delete fromstate[i].zindex;
      }
    }

    for (i = 0; i < tostate.length; i++) {
      if (typeof tostate[i].zindex != "undefined") {
        delete tostate[i].zindex;
      }
    }
  }

  for (var i = 0; i < changes.length; i++) {
    if (Array.isArray(changes[i].opacity) === true && typeof changes[i].opacity[1] == 'undefined') changes[i].opacity[1] = 1;
    if (Array.isArray(changes[i].visible) === true && typeof changes[i].visible[1] == 'undefined') changes[i].visible[1] = true;
  } //changes.changedComponents = []
  // compare common components


  for (i = 0; i < fromstate.length; i++) {
    for (var j = 0; j < tostate.length; j++) {
      if (tostate[j].id == fromstate[i].id) {
        var diffs = jsondiffpatch.diff(fromstate[i], tostate[j]); // v5.16.2 even if no diffs, if the two container states dont have the same diffs, go through code to check if dims variable

        var checkParentGroups = function checkParentGroups(groups, item) {
          for (var i = 0; i < item.parentgroups.length; i++) {
            if (groups.indexOf(item.parentgroups[i]) !== -1) return true;
          }

          return false;
        };

        if (typeof diffs != "undefined" || type == "symbols" && JSON.stringify(prxy[type][index].states[fromstateindex].dimensions) != JSON.stringify(prxy[type][index].states[tostateindex].dimensions) || checkParentGroups(changedGroups.opacity, tostate[j]) || checkParentGroups(changedGroups.visible, tostate[j])) {
          if (diffs == undefined) diffs = {}; // loop diffs. if array, simple before, after.
          // if json (meaning array comparison, eg actions), convert to array

          $.each(diffs, function (key, value) {
            // v5.0.14 doing it for all diffs to make sure that they are all setup fine
            // because in some cases where in fromstate value is undefined and in to state value is array
            // the returned diff[key] was [tostate[j][key], and it was later on used as the from value instead of as the to value
            // v5.0.19 moving this on top of the width height visible etc checks so that the overrides below are not overwritten
            //if(!$.isArray(value)) {
            diffs[key] = [fromstate[i][key], tostate[j][key]]; //}
          });

          for (var diff in diffs) {
            if (diffs.hasOwnProperty(diff)) {
              if ($.isArray(diffs[diff])) {
                // check if diff is just num == string
                if (typeof diffs[diff][0] == "string" && typeof diffs[diff][1] == "number" && parseFloat(diffs[diff][0]) == diffs[diff][1] || typeof diffs[diff][1] == "string" && typeof diffs[diff][0] == "number" && parseFloat(diffs[diff][1]) == diffs[diff][0]) {
                  delete diffs[diff];
                } // v5.0.19 will not be applicable anymore because the $.each above makes sure that diffs[diff].length == 2.

                /*
                 if(diff == "draggable" && diffs[diff].length == 1) {
                 if(!diffs[diff][0].isdraggable) {
                 // from undefined to draggable false
                 delete diffs[diff];
                 } else {
                 // from undefined to draggable true
                 if(typeof(tostate[j].draggable) != "undefined" && tostate[j].draggable.isdraggable) {
                 diffs[diff] = [fromstate[i].draggable, tostate[j].draggable]
                 }
                 }
                 }
                 */

              }
            }
          } // variable position and size
          //if(typeof(diffs.width) != "undefined" || typeof(diffs.wtype) != "undefined" || typeof(diffs.height) != "undefined" || typeof(diffs.htype) != "undefined"
          //  || typeof(diffs.left) != "undefined" || typeof(diffs.hpos) != "undefined" || typeof(diffs.top) != "undefined" || typeof(diffs.vpos) != "undefined") {


          var realDimsFrom = prx.items.getRealDimsAndPos(fromstate[i], type, index, fromstateindex); // real [width,height,left,top]

          var realDimsTo = prx.items.getRealDimsAndPos(tostate[j], type, index, tostateindex); // real [width,height,left,top]

          if (typeof diffs.wtype != "undefined") {
            delete diffs.wtype;
          }

          if (realDimsFrom[0] != realDimsTo[0]) {
            diffs.width = [realDimsFrom[0], realDimsTo[0]];
          } else if (typeof diffs.width != "undefined") {
            delete diffs.width;
          }

          if (typeof diffs.htype != "undefined") {
            delete diffs.htype;
          }

          if (realDimsFrom[1] != realDimsTo[1]) {
            diffs.height = [realDimsFrom[1], realDimsTo[1]];
          } else if (typeof diffs.height != "undefined") {
            delete diffs.height;
          }

          if (typeof diffs.hpos != "undefined") {
            delete diffs.hpos;
          }

          if (realDimsFrom[2] != realDimsTo[2]) {
            diffs.left = [realDimsFrom[2], realDimsTo[2]];
          } else if (typeof diffs.left != "undefined") {
            delete diffs.left;
          }

          if (typeof diffs.vpos != "undefined") {
            delete diffs.vpos;
          }

          if (realDimsFrom[3] != realDimsTo[3]) {
            diffs.top = [realDimsFrom[3], realDimsTo[3]];
          } else if (typeof diffs.top != "undefined") {
            delete diffs.top;
          } //}
          // it would no longer needed because we can get the true opacity
          // however im removing opacity transition if we have both visibility and opacity so i need visibility to also set opacity.


          if (typeof diffs.visible != "undefined") {
            if (diffs.visible[1] == false) {
              // target visibility
              diffs.visible = [fromstate[i].opacity, 0];
            } else {
              diffs.visible = [0, tostate[j].opacity];
            }
          }

          if (fromstate[i].group != tostate[j].group || checkParentGroups(changedGroups.opacity, tostate[j]) || checkParentGroups(changedGroups.visible, tostate[j])) {
            // if changed groups, i only animate visibility because in that process, we also set opacity.
            // if both run, I had an issue with tweens being overwritten and transition failing
            // http://greensock.com/forums/topic/13449-seek-causes-timeline-to-jump-on-transition-when-two-similar-tweens-are-found/?view=getnewpost
            if (fromstate[i].group != tostate[j].group || checkParentGroups(changedGroups.visible, tostate[j])) {
              if (tostate[j].visible == false) {
                // target visibility
                diffs.visible = [fromstate[i].opacity, 0];
              } else {
                diffs.visible = [0, tostate[j].opacity];
              }
            }

            if (checkParentGroups(changedGroups.opacity, tostate[j])) {
              diffs.opacity = [fromstate[i].opacity, tostate[j].opacity];
            }
          } // dynamic properties.


          if (typeof prx.types[fromstate[i].type] != "undefined" && typeof prx.types[fromstate[i].type].dynamicProperties != "undefined") {
            var dynprop = prx.types[fromstate[i].type].dynamicProperties.data;

            if (typeof diffs[dynprop] != "undefined") {
              // delete and rename for easier identification
              delete diffs[dynprop]; // if something has been added/removed, then rerender all -
              // because how will i know which one was added/removed

              if (fromstate[i][dynprop].length != tostate[j][dynprop].length) {
                diffs.dynamicProperties = {
                  type: ''
                };
              } else {
                // if they are equal length, I assume that only changes have been made.
                // i cant know if they've been reordered

                /*
                 diffs.dynamicProperties = [];
                 for(var k=0;k<fromstate[i][dynprop].length;k++) {
                 diffs.dynamicProperties.push(jsondiffpatch.diff(fromstate[i][dynprop][k], tostate[j][dynprop][k]))
                 }
                 */
                // different than editor
                for (var k = 0; k < fromstate[i][dynprop].length; k++) {
                  var dyndiffs = jsondiffpatch.diff(fromstate[i][dynprop][k], tostate[j][dynprop][k]);

                  if (typeof dyndiffs != "undefined") {
                    for (var dyndiff in dyndiffs) {
                      if (dyndiffs.hasOwnProperty(dyndiff)) {
                        if ($.isArray(dyndiffs[dyndiff])) {
                          // property has been deleted, does not exist, should be undefined
                          if (dyndiffs[dyndiff].length == 3 && dyndiffs[dyndiff][1] == 0 && dyndiffs[dyndiff][2] == 0) {
                            dyndiffs[dyndiff][1] = undefined;
                            delete dyndiffs[dyndiff][2];
                          }

                          diffs['dynamicProperties-' + k + '-' + dyndiff] = dyndiffs[dyndiff];
                        } else {
                          diffs['dynamicProperties-' + k + '-' + dyndiff] = [fromstate[i][dynprop][k][dyndiff], tostate[j][dynprop][k][dyndiff]];
                        }
                      }
                    }
                  }
                }
              }
            }
          } // because visibility and opacity both animate opacity, i have an issue with overwritting tweens
          // http://greensock.com/forums/topic/13449-seek-causes-timeline-to-jump-on-transition-when-two-similar-tweens-are-found


          if (diffs.opacity !== undefined || diffs.visible !== undefined) {
            diffs.visible = {
              opacity: [fromstate[i].opacity, typeof tostate[j].opacity === 'undefined' ? 1 : tostate[j].opacity],
              visible: [fromstate[i].visible === false ? false : true, tostate[j].visible === false ? false : true]
            };
            delete diffs.opacity;
          }

          if (Object.keys(diffs).length > 0) {
            var change = {
              type: 'changed-component',
              id: fromstate[i].id,
              componentType: fromstate[i].type,
              changes: diffs
            };

            if (typeof diffs.width != "undefined" || typeof diffs.height != "undefined") {
              change.item = tostate[j];
            } //  i need this for state preview so that i dont have to look for it


            if (diffs.symbolstateid !== undefined) change.symbolid = fromstate[i].symbolid; // if the only difference between the actions is the guid, then i dont need to unbind and rebind them
            // but only if all the actions in the actions array are the same - because during unbinding, all actions are unbinded, they are not unbinded individually

            if (change.hasOwnProperty("changes") && change.changes.hasOwnProperty("actions")) {
              var clonedDiffs0 = prx.componentsHelper.cloneobject(change['changes']['actions'][0]);
              var clonedDiffs1 = prx.componentsHelper.cloneobject(change['changes']['actions'][1]);
              var identicalActionsFound = 0;

              for (var z = 0; z < clonedDiffs0.length; z++) {
                if (typeof clonedDiffs0[z] != 'undefined' && typeof clonedDiffs1[z] != 'undefined') {
                  if (typeof clonedDiffs0[z].guid != 'undefined' && typeof clonedDiffs1[z].guid != 'undefined') {
                    delete clonedDiffs0[z].guid;
                    delete clonedDiffs1[z].guid;

                    if (JSON.stringify(clonedDiffs0[z]) == JSON.stringify(clonedDiffs1[z])) {
                      identicalActionsFound++;
                    }
                  }
                }
              }

              if (identicalActionsFound == change['changes']['actions'][0].length && identicalActionsFound == change['changes']['actions'][1].length) {
                delete change['changes']['actions'];
                change.changes_order = Object.keys(diffs).sort(prx.states.sortChanges);
              }
            }

            if (change.hasOwnProperty("changes") && change.changes.hasOwnProperty("mask")) {
              var firstNotMasked = false,
                  secondNotMasked = false;

              if (change.changes.mask[0] === undefined || change.changes.mask[0].isMasked == false) {
                firstNotMasked = true;
                change.changes.mask[0] = {
                  inner_height: fromstate[0].height,
                  inner_width: fromstate[0].width,
                  x: 0,
                  y: 0,
                  borderWidth: 0,
                  borderColor: "#000000",
                  borderRadius: 0,
                  borderStyle: 'solid',
                  borderPos: 'inside'
                };
              }

              if (change.changes.mask[1] === undefined || change.changes.mask[1].isMasked == false) {
                secondNotMasked = true;
                if (!firstNotMasked) change.changes.mask[1] = {
                  inner_height: tostate[0].height,
                  inner_width: tostate[0].width,
                  x: 0,
                  y: 0,
                  borderWidth: 0,
                  borderColor: "#000000",
                  borderRadius: 0,
                  borderStyle: 'solid',
                  borderPos: 'inside'
                };
              }

              if (!(firstNotMasked && secondNotMasked)) {
                if (firstNotMasked) change.changes.mask_missing = [true, false];else if (secondNotMasked) change.changes.mask_missing = [false, true];
                if (change.changes.mask[0].inner_height != change.changes.mask[1].inner_height) change.changes.mask_inner_height = [change.changes.mask[0].inner_height, change.changes.mask[1].inner_height];
                if (change.changes.mask[0].inner_width != change.changes.mask[1].inner_width) change.changes.mask_inner_width = [change.changes.mask[0].inner_width, change.changes.mask[1].inner_width];
                if (change.changes.mask[0].x != change.changes.mask[1].x) change.changes.mask_x = [change.changes.mask[0].x, change.changes.mask[1].x];
                if (change.changes.mask[0].y != change.changes.mask[1].y) change.changes.mask_y = [change.changes.mask[0].y, change.changes.mask[1].y];
                if (change.changes.mask[0].borderWidth != change.changes.mask[1].borderWidth) change.changes.mask_border_width = [change.changes.mask[0].borderWidth, change.changes.mask[1].borderWidth];
                if (change.changes.mask[0].borderPos != change.changes.mask[1].borderPos) change.changes.mask_border_pos = [change.changes.mask[0].borderPos, change.changes.mask[1].borderPos];
                if (change.changes.mask[0].borderStyle != change.changes.mask[1].borderStyle) change.changes.mask_border_style = [change.changes.mask[0].borderStyle, change.changes.mask[1].borderStyle];
                if (change.changes.mask[0].borderColor != change.changes.mask[1].borderColor) change.changes.mask_border_color = [change.changes.mask[0].borderColor, change.changes.mask[1].borderColor];
                if (JSON.stringify(change.changes.mask[0].borderRadius) != JSON.stringify(change.changes.mask[1].borderRadius)) change.changes.mask_border_radius = [change.changes.mask[0].borderRadius, change.changes.mask[1].borderRadius];
              }

              delete change.changes.mask;
            }

            change.changes_order = Object.keys(diffs).sort(prx.states.sortChanges);
            changes.push(change);
          }
        }
      }
    }
  }

  prx.states._changes[fromstateid + ":" + tostateid] = changes;
  return JSON.parse(JSON.stringify(changes));
};

prx.states.sortChanges = function (a, b) {
  // create an changes_order array because i need some changes to run before others.
  // visible and opacity must be after everything else and parentgroups must be first
  // mask_missing should be executing before with and height events - to add/remove the mask elements
  // symbolstateid must be first so that if there is any rerendering change later, rerender must know the correct state.
  if (a == 'parentgroups' && b == 'symbolstateid') return -1;
  if (a == 'symbolstateid' && b == 'parentgroups') return 1;
  if (a == 'visible' || a == 'opacity' || b == 'symbolstateid' || b == 'parentgroups' || b == 'mask_missing') return 1;
  if (b == 'visible' || b == 'opacity' || a == 'symbolstateid' || a == 'parentgroups' || a == 'mask_missing') return -1;
  return 0;
};

prx.states.getActivePageActiveStates = function () {
  var _currentpage = '#' + prx.navigation._activepage;

  var activeStateIds = {};
  activeStateIds.symbols = {};
  activeStateIds.pages = {}; //get active state

  $(_currentpage + ', ' + _currentpage + ' [data-state-id]:not(.ghost-component)').each(function () {
    //get active page  active state
    if ($(this).hasClass('prx-page')) {
      activeStateIds['pages'] = $(this).attr('data-state-id');
    } //get active page container(s)
    else if ($(this).hasClass('type-symbol')) {
        if (activeStateIds['symbols'][$(this).attr('data-symbol-id')] === undefined) {
          activeStateIds['symbols'][$(this).attr('data-symbol-id')] = [$(this).attr('data-state-id')];
        } else if (activeStateIds['symbols'][$(this).attr('data-symbol-id')].indexOf($(this).attr('data-state-id')) === -1) {
          activeStateIds['symbols'][$(this).attr('data-symbol-id')].push($(this).attr('data-state-id'));
        }
      }
  }); //activeStateIds['symbols']['3']=["asdsadsa"]

  return activeStateIds;
};

prx.states.preCacheChanges = function () {
  console.time('precaching');

  for (var i = 0; i < prxy.pages.length; i++) {
    for (var j = 0; j < prxy.pages[i].states.length; j++) {
      for (var k = 0; k < prxy.pages[i].states.length; k++) {
        if (j != k) {
          prx.states.getChangesBetweenStates(prxy.pages[i].states[j].id, prxy.pages[i].states[k].id, 'pages', i);
        }
      }
    }
  }

  for (var i = 0; i < prxy.symbols.length; i++) {
    for (var j = 0; j < prxy.symbols[i].states.length; j++) {
      for (var k = 0; k < prxy.symbols[i].states.length; k++) {
        if (j != k) {
          prx.states.getChangesBetweenStates(prxy.symbols[i].states[j].id, prxy.symbols[i].states[k].id, 'symbols', i);
        }
      }
    }
  }

  console.timeEnd('precaching');
};

prx.states.isReverse = function (canvas, index, fromstateid, tostateid) {
  return typeof prxy[canvas][index].state_transitions_reverse != "undefined" && typeof prxy[canvas][index].state_transitions_reverse[fromstateid + ':' + tostateid] != "undefined" && prxy[canvas][index].state_transitions_reverse[fromstateid + ':' + tostateid] == true;
};

prx.states.getChangesTransitionInfo = function (changes, fromstateid, tostateid, _canvastype, _index) {
  if (_index == -1) {
    return {
      allchanges: [],
      common: [],
      maxendtotal: 0,
      minstart: 0
    };
  }
  /* start copy from editor */


  var duration,
      delay,
      easing,
      commonduration,
      commondelay,
      commoneasing,
      isuserpreset = false,
      userpresetuuid;
  var common = {};
  var allchanges = {};
  var maxendtotal = 0;
  var reverse = prx.states.isReverse(_canvastype, _index, fromstateid, tostateid);

  if (reverse) {
    if (typeof prxy[_canvastype][_index].state_transitions != "undefined" && typeof prxy[_canvastype][_index].state_transitions[tostateid + ':' + fromstateid] != "undefined") {
      var state_transitions = prxy[_canvastype][_index].state_transitions[tostateid + ':' + fromstateid];
    }
  } else {
    if (typeof prxy[_canvastype][_index].state_transitions != "undefined" && typeof prxy[_canvastype][_index].state_transitions[fromstateid + ':' + tostateid] != "undefined") {
      var state_transitions = prxy[_canvastype][_index].state_transitions[fromstateid + ':' + tostateid];
    }
  }

  for (var i = 0; i < changes.length; i++) {
    if (typeof state_transitions !== "undefined") {
      commonduration = prx.transition.duration;
      commondelay = prx.transition.delay;
      commoneasing = prx.transition.easing;
      isuserpreset = prx.transition.userpresetuuid !== undefined;
      userpresetuuid = isuserpreset ? prx.transition.userpresetuuid : void 0;
    } else {
      commonduration = 0;
      commondelay = 0;
      commoneasing = prx.utils.getDefaultDefaultTransition().easing;
    }

    var minstart = 9999999;
    var maxend = 0;

    if (typeof state_transitions != "undefined" && typeof state_transitions[changes[i].id] != "undefined") {
      if (typeof state_transitions[changes[i].id].common != "undefined") {
        if (typeof state_transitions[changes[i].id].common.delay != "undefined") {
          commondelay = state_transitions[changes[i].id].common.delay;
        }

        if (typeof state_transitions[changes[i].id].common.duration != "undefined") {
          commonduration = state_transitions[changes[i].id].common.duration;
        }

        if (typeof state_transitions[changes[i].id].common.easing != "undefined") {
          commoneasing = state_transitions[changes[i].id].common.easing;
          isuserpreset = state_transitions[changes[i].id].common.userpresetuuid !== undefined;
          userpresetuuid = isuserpreset ? state_transitions[changes[i].id].common.userpresetuuid : void 0;
        } // needs to be done outside of if - even if easing was not defined, its possible that duration was defined, but default easing above (common) was a preset and so duration needs to be overwritten


        commonduration = prx.easing.checkToOverwriteCustomEasingDuration(userpresetuuid, commonduration);
        minstart = commondelay;
        maxend = commondelay + commonduration;
      }
    }

    if (typeof changes[i].changes != "undefined") {
      for (var key in changes[i].changes) {
        if (changes[i].changes.hasOwnProperty(key)) {
          var elm = changes[i].changes[key];
          var itemType = changes[i].componentType;
          var transitionable = true; // for left, top, width, height, opacity etc?

          var rerender = false;
          var found = false;
          var rotationDirection;
          delay = commondelay;
          duration = commonduration;
          easing = commoneasing;

          if (typeof state_transitions != "undefined" && typeof state_transitions[changes[i].id] != "undefined") {
            if (typeof state_transitions[changes[i].id][key] != "undefined") {
              if (typeof state_transitions[changes[i].id][key].delay != "undefined") {
                delay = state_transitions[changes[i].id][key].delay;
              }

              if (typeof state_transitions[changes[i].id][key].duration != "undefined") {
                duration = state_transitions[changes[i].id][key].duration;
              }

              if (typeof state_transitions[changes[i].id][key].easing != "undefined") {
                easing = state_transitions[changes[i].id][key].easing;
                isuserpreset = state_transitions[changes[i].id][key].userpresetuuid !== undefined;
                userpresetuuid = isuserpreset ? state_transitions[changes[i].id][key].userpresetuuid : void 0;
              }

              duration = prx.easing.checkToOverwriteCustomEasingDuration(userpresetuuid, duration);

              if (typeof state_transitions[changes[i].id][key].rotationDirection != "undefined") {
                rotationDirection = state_transitions[changes[i].id][key].rotationDirection;
              }
            }
          }

          if (changes[i].type == "new-component" || changes[i].type == "removed-component") {
            if (key == "opacity") {
              allchanges[changes[i].id + '-' + key] = {
                duration: duration,
                delay: parseFloat(delay) + 1,
                // to allow rerender first
                //delay: delay,
                easing: easing,
                transitionable: true,
                rerender: false
              };
            }

            continue;
          }

          if (changes[i].id == 'current-page' || changes[i].id == 'current-page-template' || changes[i].id == 'current-container') {
            // at the moment dimensions, background color, all transitionable.
            // will probably need to change for template change.
            allchanges[changes[i].id + '-' + key] = {
              duration: duration,
              delay: delay,
              easing: easing,
              transitionable: true,
              rerender: false
            };
            continue;
          } // changed-dynamic-properties


          if (key == 'dynamicProperties' || key == 'draggable' || key == 'mask_border_pos' || key == 'mask_border_width') {
            allchanges[changes[i].id + '-' + key] = {
              duration: 0,
              delay: false,
              easing: easing,
              transitionable: false,
              rerender: true
            };
            continue;
          }

          if (key == 'visible') {
            if (typeof state_transitions != "undefined" && typeof state_transitions[changes[i].id] != "undefined" && typeof state_transitions[changes[i].id][key] == "undefined" && typeof state_transitions[changes[i].id]['opacity'] != "undefined") {
              if (typeof state_transitions[changes[i].id]['opacity'].delay != "undefined") {
                delay = state_transitions[changes[i].id]['opacity'].delay;
              }

              if (typeof state_transitions[changes[i].id]['opacity'].duration != "undefined") {
                duration = state_transitions[changes[i].id]['opacity'].duration;
              }

              if (typeof state_transitions[changes[i].id]['opacity'].easing != "undefined") {
                easing = state_transitions[changes[i].id]['opacity'].easing;
                isuserpreset = state_transitions[changes[i].id]['opacity'].userpresetuuid !== undefined;
                userpresetuuid = isuserpreset ? state_transitions[changes[i].id]['opacity'].userpresetuuid : void 0;
              }

              duration = prx.easing.checkToOverwriteCustomEasingDuration(userpresetuuid, duration);
            }

            allchanges[changes[i].id + '-' + key] = {
              duration: duration,
              delay: delay,
              easing: easing,
              transitionable: true,
              rerender: false
            };
            continue;
          }

          if (key == "parentgroups") {
            allchanges[changes[i].id + '-' + key] = {
              duration: 0,
              delay: 0,
              easing: easing,
              transitionable: false,
              rerender: false
            };
          }

          if (key.indexOf('dynamicProperties-') > -1) {
            var tosearch = prx.types[itemType].dynamicProperties;
            var split = key.split('-');
            var keytosearch = split[split.length - 1];
          } else {
            var tosearch = prx.types[itemType];
            var keytosearch = key;
          } // find property


          if (typeof tosearch.editableProperties != "undefined") {
            for (var j = 0; j < tosearch.editableProperties.length; j++) {
              if (tosearch.editableProperties[j].name == keytosearch) {
                if (typeof tosearch.editableProperties[j].changeProperty != "undefined") {
                  if (typeof tosearch.editableProperties[j].changeProperty.transitionable != "undefined") {
                    transitionable = tosearch.editableProperties[j].changeProperty.transitionable;
                  }

                  if (typeof tosearch.editableProperties[j].changeProperty.rerender != "undefined") {
                    rerender = tosearch.editableProperties[j].changeProperty.rerender;
                  }

                  found = true;
                  break;
                }
              }
            }
          }

          if (!found) {
            if (typeof tosearch.interactions != "undefined") {
              for (var j = 0; j < tosearch.interactions.length; j++) {
                if (tosearch.interactions[j].name == keytosearch) {
                  if (typeof tosearch.interactions[j].changeProperty != "undefined") {
                    //caption = tosearch.interactions[j].changeProperty.caption;
                    if (typeof tosearch.interactions[j].changeProperty.transitionable != "undefined") {
                      transitionable = tosearch.interactions[j].changeProperty.transitionable;
                    }

                    if (typeof tosearch.interactions[j].changeProperty.rerender != "undefined") {
                      rerender = tosearch.interactions[j].changeProperty.rerender;
                    }

                    found = true;
                    break;
                  }
                }
              }
            }
          }

          if (!found) {
            if (typeof tosearch.propertyGroups != "undefined") {
              for (var j = 0; j < tosearch.propertyGroups.length; j++) {
                for (var k = 0; k < tosearch.propertyGroups[j].properties.length; k++) {
                  for (var l = 0; l < tosearch.propertyGroups[j].properties[k].length; l++) {
                    if (tosearch.propertyGroups[j].properties[k][l].name == keytosearch) {
                      if (typeof tosearch.propertyGroups[j].properties[k][l].changeProperty != "undefined") {
                        if (typeof tosearch.propertyGroups[j].properties[k][l].changeProperty.transitionable != "undefined") {
                          transitionable = tosearch.propertyGroups[j].properties[k][l].changeProperty.transitionable;
                        }

                        if (typeof tosearch.propertyGroups[j].properties[k][l].changeProperty.rerender != "undefined") {
                          rerender = tosearch.propertyGroups[j].properties[k][l].changeProperty.rerender;
                        }

                        found = true;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }

          if (!transitionable) {
            duration = 0;
          } // special case. is transitionable false (because we cant resize) but it can have duration


          if (keytosearch === 'symbolstateid') {
            duration = prx.states.getChangesTransitionInfo(prx.states.getChangesBetweenStates(changes[i].changes.symbolstateid[0], changes[i].changes.symbolstateid[1], 'symbols', prx.stc.containers.getIndexFromId(changes[i].symbolid)), changes[i].changes.symbolstateid[0], changes[i].changes.symbolstateid[1], 'symbols', prx.stc.containers.getIndexFromId(changes[i].symbolid)).maxendtotal;
          }

          if (rerender) {
            duration = 0; // i don't know the common delay yet. the changes loop needs to end to know the final common delay
            // so im setting this to false, and looping everything later to change :(
            // delay = common['changed-' + changes[i].id].duration + common['changed-' + changes[i].id].delay;

            delay = false;
          }

          if (key == "mask_missing") {
            //check if destination mask is missing
            if (changes[i].changes[key][1] == true) {
              //if the target state has no mask then then we want to remove the mask at the end of the animation
              //by setting the delay to false later on will compute the
              delay = false;
            }
          }

          allchanges[changes[i].id + '-' + key] = {
            duration: duration,
            delay: delay,
            easing: easing,
            transitionable: transitionable,
            rerender: rerender
          };

          if (typeof rotationDirection != "undefined") {
            if (reverse) {
              if (rotationDirection == 'cw') {
                rotationDirection = 'ccw';
              } else if (rotationDirection == 'ccw') {
                rotationDirection = 'cw';
              }
            } //rotationDirection = (reverse) ? ((rotationDirection == 'cw') ? 'ccw' : 'cw') : rotationDirection;


            allchanges[changes[i].id + '-' + key].rotationDirection = rotationDirection;
          }

          minstart = delay < minstart && delay !== false ? delay : minstart;
          maxend = delay + duration > maxend ? delay + duration : maxend;
        }
      }
    }

    if (minstart === 9999999 && maxend === 0 && typeof prxy[_canvastype][_index].state_transitions !== "undefined" && typeof prxy[_canvastype][_index].state_transitions[fromstateid + ':' + tostateid] !== "undefined") {
      minstart = 0;
      commonduration = prx.transition.duration;
      commondelay = prx.transition.delay;
    } else {
      minstart = minstart === 9999999 ? 0 : minstart; // until now this was the .common { delay: .., duration: .. } definition
      // now it represents the minimum delay, maximum duration of all items

      commonduration = maxend - minstart;
      commondelay = minstart;
    }

    common['changed-' + changes[i].id] = {
      duration: commonduration,
      delay: commondelay,
      easing: commoneasing
    };

    if (commonduration + commondelay > maxendtotal) {
      maxendtotal = commonduration + commondelay;
    }
  } // if reverse, reverse timeline!
  // basically change delay to be the end delay


  if (reverse) {
    for (var key in allchanges) {
      if (allchanges.hasOwnProperty(key)) {
        if (allchanges[key].delay !== false) {
          allchanges[key].delay = maxendtotal - (allchanges[key].delay + allchanges[key].duration);
        } // annam inextgen - decided with AP to stop reversing easing on reverse
        // allchanges[key].easing = prx.easing.getReverse(allchanges[key].easing);

      }
    }

    for (var key in common) {
      if (common.hasOwnProperty(key)) {
        common[key].delay = maxendtotal - (common[key].delay + common[key].duration); // common[key].easing = prx.easing.getReverse(common[key].easing);
      }
    }
  } // loop all changes, find delay = false and correct delay value


  for (var key in allchanges) {
    if (allchanges.hasOwnProperty(key)) {
      if (allchanges[key].delay === false) {
        var commonkey = 'changed-' + key.split('-')[0] + '-' + key.split('-')[1];
        allchanges[key].delay = common[commonkey].duration + common[commonkey].delay;
      }
    }
  }

  return {
    allchanges: allchanges,
    common: common,
    maxendtotal: maxendtotal,
    minstart: minstart
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_status-nav-bar.js":
/*!*************************************************************!*\
  !*** ./sass/player-engine/js/components/_status-nav-bar.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.statusNavBar = {};

prx.statusNavBar.ini = function () {
  prx.allowstatusbar = prx.projectsettings.statusbarapplies == true;
  prx.allownavigationbar = prx.projectsettings.navigationbarapplies == true;
  if (!prx.helper.onmobile()) return;

  if (!prx.inProtoApp && prx.allowstatusbar) {
    // CHECK STATUSBAR ON IOS
    var _agents = navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad)/g); // iOS


    if (_agents) {
      // if in safari, false, if in add to home, true
      var _standalone = window.navigator.standalone ? true : false;

      if (_standalone) {
        // ANNAM 5.2.3 for ios7 translucent statusbars
        // if standalone ios, always allow statusbar
        //prx.allowstatusbar = false;
        prx.allowstatusbar = true; // ANNAM 5.14.16
        // after letterboxing, statusbar doesn't always appear on top of the project - it might be bigger if the project is zoomed out
        // changed statusbars to black-not translucent in letterbox and leaving statusbar as is, resulting in double statusbars but that's ok
        //prx.devices[prx.device].statusbar_skin = 'default';
        //$('body').prepend("<style>.type-ios7-statusbar .ios7-statusbar-inner * { display: none; }</style>");
      } else {
        /*
         var _agent = _agents[0];
         if(_agent == "ipod") { _agent = "iphone"; }
        		 <cfif qGetProject.device eq "iphone">
         if(_agent == "ipad") { _agent = "iphone"; }
         </cfif>
         */
        // if not fullscreen then disable statusbar
        if (!($(window).width() == prx.devices[prx.device][prx.orientation._orientation][0] && $(window).height() == prx.devices[prx.device][prx.orientation._orientation][1])) {
          prx.allowstatusbar = false;
        }
      }
    } // CHECK STATUSBAR ON ANDROID
    // v5.2.24 moved .ui-page { position fixed; } for not android because it was causing issue #4544 and problems for angelos's native app


    try {
      _agents = navigator.userAgent.toLowerCase().match(/(android)/g); // Android

      if (_agents) {
        // if not fullscreen then disable statusbar
        if (!($(window).width() == prx.devices[prx.device][prx.orientation._orientation][0] && $(window).height() == prx.devices[prx.device][prx.orientation._orientation][1])) {
          prx.allowstatusbar = false;
        }
      }
    } catch (err) {
      alert(err);
    }
  }

  var _agents = navigator.userAgent.toLowerCase().match(/(android)/g);

  if (_agents) {
    try {
      if (!($(window).width() == prx.devices[prx.device][prx.orientation._orientation][0] && $(window).height() == prx.devices[prx.device][prx.orientation._orientation][1])) {
        prx.allownavigationbar = false;
      }
    } catch (err) {
      alert(err);
    }

    $('body').prepend("<style>.prx-page { position: absolute!important; }</style>");
  }
};

prx.statusNavBar.buildStatusbarExported = function (orientation) {
  if (prx.projectsettings.statusbarapplies == '1') {
    if (prx.devices[prx.device].statusbar_skin == 'default') {
      $('#statusbar').css({
        'background-image': 'none',
        'background-color': 'black'
      });
    } else {
      //custom skin
      $('#statusbar').css({
        'background-image': 'url(./images/statusbar_' + orientation + '.png)',
        'background-color': 'transparent'
      });
    }
  } else {
    $('#statusbar').css({
      'background-image': 'none',
      'background-color': 'transparent'
    });
  }
};

prx.statusNavBar.buildStatusbar = function (orientation) {
  if (prx.projectsettings.statusbarapplies == '1') {
    if (prx.devices[prx.device].statusbar_skin == 'default') {
      return 'url(' + prx.utils.getAssetsServer() + '/device/default/statusbar_' + orientation + '.png?ac=' + prx.projectsettings.account + ')';
    } else if (prx.devices[prx.device].statusbar_skin == 'shared') {
      return 'url(' + prx.utils.getAssetsServer() + '/device/shared/' + prx.devices[prx.device].device_s3bucket + '/statusbar_' + orientation + '.png?ac=' + prx.projectsettings.account + ')';
    } else {
      //custom skin
      return 'url(' + prx.utils.getAssetsServer() + '/device/' + prx.devices[prx.device].device_s3bucket + '/statusbar_' + orientation + '.png?ac=' + prx.projectsettings.account + ')';
    }
  } else {
    return 'none';
  }
};

prx.statusNavBar.buildNavbar = function (orientation) {
  if (prx.projectsettings.navigationbarapplies == '1') {
    if (prx.devices[prx.device].navigationbar_skin == 'default') {
      return 'url(' + prx.utils.getAssetsServer() + '/device/default/navigationbar_' + orientation + '.png?ac=' + prx.projectsettings.account + ')';
    } else if (prx.devices[prx.device].navigationbar_skin == 'shared') {
      return 'url(' + prx.utils.getAssetsServer() + '/device/shared/' + prx.devices[prx.device].device_s3bucket + '/navigationbar_' + orientation + '.png?ac=' + prx.projectsettings.account + ')';
    } else {
      //custom skin
      return 'url(' + prx.utils.getAssetsServer() + '/device/' + prx.devices[prx.device].device_s3bucket + '/navigationbar_' + orientation + '.png?ac=' + prx.projectsettings.account + ')';
    }
  } else {
    return 'none';
  }
};

prx.statusNavBar.buildNavbarExported = function (orientation) {
  if (prx.projectsettings.navigationbarapplies == '1') {
    $('#navigationbar').css('background-image', 'url(./images/navigationbar_' + orientation + '.png)');
  } else {
    $('#navigationbar').css('background-image', 'none');
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_underlay.js":
/*!*******************************************************!*\
  !*** ./sass/player-engine/js/components/_underlay.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {/**
 * Created by GeorgeYiannakas on 14/07/15.
 */
prx.underlay = {};

prx.underlay.render = function (pageid) {
  //var _pageid = '#p-'+pageid;
  var _pageid = pageid;

  var _statusbar = prx.canvas._statusbars[pageid.substr(3)];

  var _top = 0;
  var _height = prx.devices[prx.device][_statusbar.orientation][1];

  if (prx.allowstatusbar && _statusbar.statusbar == "1") {
    _top = prx.devices[prx.device]['statusbarheight' + _statusbar.orientation];
    _height -= _top;
  }

  var $underlay = $('#underlay');
  $(_pageid).find('div[class*="box pos type-applewatch-statusbar"]:not(.hidden)') //.show()
  .each(function () {
    var _elmTop = $(this).offset().top - _top;

    var _elmLeft = $(this).offset().left;
    $(this) //.clone(true, true) // apparently clone with events messes something up with jquery. v3.4.1.13
    .clone() //.css({'top': _elmTop + 'px', 'left': _elmLeft + 'px'})

    /* .find('input')
     .attr('id', function(){return $(this).attr('id') + '-overlay' })
     .attr('name', function(){return $(this).attr('name') + '-overlay' })
     .end()
     .find('label')
     .attr('for', function(){return $(this).attr('for') + '-overlay' })
     .end()*/
    .appendTo($underlay);
    new TimelineMax().to('#underlay  #' + this.id, 0, {
      x: _elmLeft,
      y: _elmTop
    });
    $(this).attr('data-opacity', $(this).css('opacity')).css({
      'opacity': '0'
    });
  });
  $underlay.css('top', _top + 'px').height(_height).show();
};

prx.underlay.changeVisibility = function (pageid) {
  var _pageid = pageid;
  $(_pageid).find('div[class*="box pos type-applewatch-statusbar"]:not(.hidden)') //.show()
  .each(function () {
    $(this).css({
      'opacity': '' + $(this).attr('data-opacity') + ''
    });
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_utils.js":
/*!****************************************************!*\
  !*** ./sass/player-engine/js/components/_utils.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.utils = window.prx.utils || {};

/***/ }),

/***/ "./sass/player-engine/js/components/_variables.js":
/*!********************************************************!*\
  !*** ./sass/player-engine/js/components/_variables.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.variables = {};
prx.variables._regEx = new RegExp('{[a-z][-a-z0-9\._]*}', 'gi');
prx.variables._triggerData = {}; //init variables evaluation sandbox

prx.variables.initSandbox = function () {
  if (prx.export2html) // for this case we handle the sandbox differently due to cross-side blocking of browsers on local html file
    return;
  prx.variables.evalIframe = document.createElement('iframe');
  if (!prx.spaces) prx.variables.evalIframe.src = "evaluation/";else prx.variables.evalIframe.src = "/project/livepreview/evaluation/";
  prx.variables.evalIframe.id = "eval-iframe";
  document.body.appendChild(prx.variables.evalIframe);
};

prx.variables.eValSandBox = function (value) {
  if (prx.export2html) {
    var result;

    try {
      result = eval("'use strict'; var document={}; var prx = {}; var window = {}; var localStorage = {}; var $ = {}; var jQuery = {}; ''; " + value);
    } catch (err) {
      result = value;
    }

    return result;
  } else return prx.variables.evalIframe.contentWindow.evaluate(value);
}; // VARIABLES FUNCTIONS


prx.variables.prepare = function () {
  for (var key in prx.variables._variables) {
    if (prx.variables._variables.hasOwnProperty(key)) {
      if (typeof prx.variables._variables[key].type == "undefined") {
        prx.variables._variables[key].type = "text";
      }

      if (typeof prx.variables._variables[key].value == "undefined") {
        prx.variables._variables[key].value = "";
      }

      if (typeof prx.variables._variables[key].evaluate == "undefined") {
        prx.variables._variables[key].evaluate = true;
      }
    }
  }
};

prx.variables.paramsExist = function (value) {
  try {
    if (value.search(prx.variables._regEx) > -1) {
      return true;
    } else {
      return false;
    }
  } catch (err) {
    return false;
  }
};

prx.variables.removeFirstLast = function (text) {
  return text.substring(1, text.length - 1);
};

prx.variables.read = function (key) {
  if (typeof prx.variables._variables[key] != "undefined") {
    if (typeof prx.variables._variables[key].parsed == "undefined") {
      prx.variables.recursivelyEvaluate(prx.variables._variables[key].value, key);
    }

    return prx.variables._variables[key].parsed;
  } else {
    return false;
  }
};

prx.variables.recursivelyEvaluate = function (value, key, update) {
  if (update) {
    if (key.length > 0) {
      if (typeof prx.variables._variables[key] != "undefined") {
        if (typeof prx.variables._variables[key].parsed != "undefined") {
          delete prx.variables._variables[key].parsed;
        }
      }
    }
  } else {
    update = false;

    if (key.length > 0) {
      if (typeof prx.variables._variables[key] != "undefined") {
        if (typeof prx.variables._variables[key].parsed != "undefined") {
          return prx.variables._variables[key].parsed;
        }
      }
    }
  }

  if (prx.variables.paramsExist(value)) {
    var _matches = value.match(prx.variables._regEx);

    if (_matches != null) {
      for (var i = 0; i < _matches.length; i++) {
        var _toReplace = _matches[i];

        var _key = prx.variables.removeFirstLast(_matches[i]).toLowerCase();

        if (!(key == _key && prx.variables._variables[key].value == key)) {
          // avoid endless loop of self call
          try {
            value = value.replace(_toReplace, prx.variables.recursivelyEvaluate(prx.variables._variables[_key].value, _key, update));
          } catch (err) {
            value = value.replace(_toReplace, ""); // just replace faulty param with empty string
          }
        } else {
          //value = prx.variables._variables[key].parsed;
          value = value.replace(_toReplace, ""); // just replace faulty param with empty string
        }
        /*
         if (key != _key) { // avoid endless loop of self call
         try {
         value = value.replace(_toReplace, prx.variables.recursivelyEvaluate(prx.variables._variables[_key].value, _key, update));
         } catch(err) {
         value = value.replace(_toReplace, ""); // just replace faulty param with empty string
         }
         } else {
         //value = prx.variables._variables[key].parsed;
         value = value.replace(_toReplace, ""); // just replace faulty param with empty string
         }
         */

      }
    }
  } else {
    if (typeof key != "undefined") {
      if (typeof prx.variables._variables[key] != "undefined") {
        /*
         switch (prx.variables._variables[key].type) {
         case "numeric":
         try {
         value = eval(value);
         } catch(err){} // in case evaluate string then return string
         break;
         default:
         }
         */
        if (prx.variables._variables[key].evaluate) {
          try {
            //value = eval(value);
            value = prx.variables.eValSandBox(value);
          } catch (e) {}

          ;
        }
      }
    }
  }

  if (typeof _key != "undefined") {
    if (typeof prx.variables._variables[key] != "undefined") {
      /*
       switch (prx.variables._variables[key].type) {
       case "numeric":
       try {
       value = eval(value);
       } catch(err){} // in case evaluate string then return string
       break;
       default:
       }
       */
      if (prx.variables._variables[key].evaluate) {
        try {
          //value = eval(value);
          value = prx.variables.eValSandBox(value);
        } catch (e) {}

        ;
      }
    }
  }

  if (key.length > 0) {
    if (typeof prx.variables._variables[key] != "undefined") {
      prx.variables._variables[key].parsed = value;
    }
  }

  if (key.length > 0) {
    if (typeof prx.variables._variables[key] != "undefined") {
      switch (prx.variables._variables[key].type) {
        case "text":
          //value = value.toString();
          break;

        case "numeric":
          value = parseFloat(value);
          break;

        case "boolean":
          value = value ? true : false;
          break;
      }
    }
  }

  return value;
};

/***/ }),

/***/ "./sass/player-engine/js/components/_vimeo.js":
/*!****************************************************!*\
  !*** ./sass/player-engine/js/components/_vimeo.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.vimeo = {};
prx.vimeo._players = {};

prx.vimeo.createVideo = function (targetId) {
  prx.vimeo._players[targetId + '-vimeo'] = $f(targetId + '-vimeo');
  /* !!! Do not try to add listeners or call functions before receiving ready event */

  prx.vimeo._players[targetId + '-vimeo'].addEvent('ready', function () {
    prx.vimeo._players[targetId + '-vimeo'].addEvent('play', onPlay);

    prx.vimeo._players[targetId + '-vimeo'].addEvent('pause', onPause);

    prx.vimeo._players[targetId + '-vimeo'].addEvent('finish', onFinish);
  });

  function onPlay(targetId) {
    $('#' + targetId).trigger('videoplay');
  }

  function onPause(targetId) {
    $('#' + targetId).trigger('videopause');
  }

  function onFinish(targetId) {
    $('#' + targetId).trigger('videoend');
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_visibility.js":
/*!*********************************************************!*\
  !*** ./sass/player-engine/js/components/_visibility.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.visibility = function () {
  var m = {};

  function _getGroups(target, stateid) {
    if (target.indexOf('group') !== -1) {
      return [];
    } else {
      var container = target.split('-box-');
      var itemid = 'box-' + container.pop();
      container = container.join('-box-'); // annam 6.2.5, 5/1/2018
      // it used to be that if the item was rendered on the canvas, we read its groups from the dom classes,
      // and we only used the code below, and getting the groups from the item struct, if it was the first time that the item was being rendered
      // however this was problematic if the item was being rerendered during a state transition where the groups would be changed between states.
      // so now im reading the state from the dom (already changed to the target state) and getting the groups from the item struct

      if (prx.allItems[itemid] === undefined) return [];
      stateid = stateid || ($(target).length ? $(target).parents('[data-state-id]').first().attr('data-state-id') : Object.keys(prx.allItems[itemid].states)[0]);
      var item = prx.items.getFromAllItemStruct(itemid, stateid); // due to corrupted data with some projects having items with duplicated ids this might return false

      if (item === false) item = prx.items.getFromAllItemStruct(itemid, Object.keys(prx.allItems[itemid].states)[0]);
      return item.parentgroups.map(function (cl) {
        return container + ' .group-' + cl;
      });
    }
  }

  function get(target, property, exclude, stateid) {
    if (typeof m.opacity === 'undefined') m.opacity = {};
    if (typeof m.visible === 'undefined') m.visible = {};

    if (target.indexOf('group') !== -1) {
      if (property === 'visible') {
        return m.visible[target] === false ? false : typeof m.opacity[target] === "undefined" ? 1 : m.opacity[target];
      } else {
        return typeof m.opacity[target] === "undefined" ? 1 : m.opacity[target];
      }
    } else {
      var vals = _getGroups(target, stateid).filter(function (test) {
        if (typeof exclude === 'string') return exclude !== test;
        if (Array.isArray(exclude)) return exclude.indexOf(test) === -1;
        return true;
      }).map(function (grouptarget) {
        return get(grouptarget, 'visible');
      });

      vals.push(typeof m.opacity[target] === "undefined" ? 1 : m.opacity[target]);

      if (property === 'visible-all') {
        for (var i = 0; i < vals.length; i++) {
          if (vals[i] === false) return false;
        }

        if (m.visible[target] === false) return false;
        return vals.filter(function (v) {
          return v !== false;
        }).reduce(function (a, b) {
          return a * b;
        }, 1);
      }

      if (property === 'visible-rest') {
        for (var i = 0; i < vals.length; i++) {
          if (vals[i] === false) return false;
        }

        return vals.filter(function (v) {
          return v !== false;
        }).reduce(function (a, b) {
          return a * b;
        }, 1);
      }

      if (property === 'visible') {
        return m.visible[target] === false ? false : typeof m.opacity[target] === "undefined" ? 1 : m.opacity[target];
      } // i just want to check if the item is display: none or block, and dont care about opacity.
      // i do care however about parent containers' display
      // if i also returned opacity the results would be peculiar because we would need to multiple visibility
      // but not opacity, as for opacity each container applies its own on the dom and it's multiplied by the browser's nested tree
      // in this case only, i also want to check for the general visibility of the item on the dom - is the screen visible?


      if (property === 'visible-in-dom') {
        for (var i = 0; i < vals.length; i++) {
          if (vals[i] === false) return false;
        }

        if (m.visible[target] === false) return false;
        var regexmatch = target.match(/(.+)(-box-[\d]+|-group-[a-fA-F0-9\-]+)$/);
        var screenregex = target.match(/#(p-[\d]+)(.+)$/);
        if (regexmatch === null || screenregex === null) return true;
        if (screenregex[1] !== prx.navigation._activepage) return false;
        var parent = regexmatch[1]; // in theory the parent here is the screen. i have already checked if the screen i am in is the current screen, and if it is not, returned false,
        // so im returning true if i have checked all my other parents (if the parent is the screen) and the screen is the current screen.

        if (parent.indexOf('box-') === -1) return true;
        var parentvisibility = get(parent, 'visible-in-dom', exclude, stateid);
        if (parentvisibility === false) return false;
        return true;
      }

      return vals.filter(function (v) {
        return v !== false;
      }).reduce(function (a, b) {
        return a * b;
      }, 1);
    }
  }

  function set(target, property, value) {
    if (typeof m[property] === 'undefined') m[property] = {};
    var old = m[property][target];
    m[property][target] = value;
    return value !== old;
  }

  function setd(target, property, value) {
    if (typeof m[property] === 'undefined') m[property] = {};
    if (typeof m[property][target] !== 'undefined') return;
    var old = m[property][target];
    m[property][target] = value;
    return value !== old;
  }

  return {
    get: get,
    set: set,
    setd: setd
  };
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_vr.js":
/*!*************************************************!*\
  !*** ./sass/player-engine/js/components/_vr.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.vr = {};
prx.vr.allowedTypes = ['vrimage', 'vractionarea', 'vrrectangle'];
prx.vr.RADIUS_MIN = 10;
prx.vr.RADIUS_STEP = 1;

if (!prx.vr.images) {
  prx.vr.images = {};
}

prx.vr.ini = function (item, containerid) {
  var _id = !containerid ? item.id : containerid + '-' + item.id;

  $('a-scene#' + _id + '-scene').on("enter-vr", function () {
    // the following class is added to work properly on the mobile apps
    $('body').addClass('fullscreen-vr');
    $(this).parents('.type-vrsymbol, .type-symbol').addClass('fullscreen');
    prx.crossmsg.send({
      action: 'player-engine-enter-fullscreen'
    });
  }); // before exit is a custom event added by us on the custom aframe script, removing the fullscreen class on exit-vr event wasnt working we needed to remove it before exit process

  $('a-scene#' + _id + '-scene').on("before-exit-vr", function () {
    $('body').removeClass('fullscreen-vr');
    $(this).parents('.type-vrsymbol, .type-symbol').removeClass('fullscreen');
    prx.crossmsg.send({
      action: 'player-engine-exit-fullscreen'
    });
  });
  $('a-scene#' + _id + '-scene').find('a-assets').on("loaded", function () {});
};

prx.vr.VRExists = function (checkFullscreen) {
  if (!checkFullscreen) checkFullscreen = false;else checkFullscreen = true;
  var page = prx.navigation._activepage;
  var $vr = $('#' + page + ' .type-vrsymbol');

  if ($vr.length > 0) {
    if (!checkFullscreen) return true;else {
      if ($vr.hasClass('fullscreen')) {
        return true;
      } else {
        return false;
      }
    }
  }

  return false;
};

prx.vr.render = function (item, containerid, stateindex, symbolIndex) {
  var _id = !containerid ? item.id : containerid + '-' + item.id;

  var symbol = prxy.symbols[symbolIndex];
  var data = JSON.parse(symbol.states[stateindex].data);
  var backgroundColor = '#FFF';
  var images = prx.vr.getImages(symbol);
  var sky = images.skies[stateindex];
  var src = '';
  var cR = '';

  if (sky === 'none') {
    backgroundColor = prx.utils.getColor(symbol.states[stateindex].background);
  } else {
    src = '#' + sky;
  }

  var classes = '';
  if (prx.devices[prx.device].deviceType === 'iphonex') classes += 'round-corners-device';

  if ($('#' + _id).parents('.prx-page-active').length > 0) {
    cR += '<a-scene id="' + _id + '-scene"  class="' + classes + '" canvas="" keyboard-shortcuts="" vr-mode-ui="enabled: true;" embedded>';
    cR += '<a-assets timeout="1000">';
    cR += images.cR;
    cR += '</a-assets>';
    cR += '<a-sky src="' + src + '" rotation="0 90 0" material="color:' + backgroundColor + ';"></a-sky>';
    cR += '<a-entity id="light" position="0 0 0" light="intensity: 0.95; type: ambient"></a-entity>';
    cR += '<a-entity id="camera" position="0 0 0" camera="active:true;userHeight:0;near:0.01" rotation="0 180 0" look-controls="" aframe-injected="" data-aframe-inspector="default-camera">';
    cR += '<a-entity id="indicator"' + '                position="0 0 -1"' + '                geometry="primitive: ring; radiusInner: 0.00001; radiusOuter: 0.0055; thetaLength: 360; thetaStart: 0"' + '                cursor="fuse: true; fuseTimeout: 1000"\n' + '                raycaster="far: 20; interval: 250; objects: .vr-interactive"' + '                material="color: black; shader: flat">' + '            <a-animation begin="vrtimeranimation" easing="linear" attribute="geometry.radiusInner"' + '                         from="0.00001" to="0.02" dur="1000" fill="none" end="mouseleave"></a-animation>' + '            <a-animation begin="vrtimeranimation" easing="linear" attribute="geometry.radiusOuter"' + '                         from="0.0055" to="0.025" dur="1000" fill="none" end="mouseleave"></a-animation>' + '            <a-animation begin="vrclickanimation" easing="ease-in-out" attribute="scale" direction="alternate"' + '                         from="1 1 1" to="1.5 1.5 1.5" dur="125" delay="0" repeat="1"></a-animation>' + '            <a-animation begin="vrclickanimation" easing="linear" attribute="geometry.radiusInner"' + '                         to="0.00001" dur="0" delay="250"></a-animation>' + '            <a-animation begin="vrclickanimation" easing="linear" attribute="geometry.radiusOuter"' + '                         to="0.0055" dur="0" delay="250"></a-animation>' + '            <a-animation begin="mouseleave" easing="linear" attribute="geometry.radiusInner"' + '                         to="0.00001" dur="0" delay="0"></a-animation>' + '            <a-animation begin="mouseleave" easing="linear" attribute="geometry.radiusOuter"' + '                         to="0.0055" dur="0" delay="0"></a-animation>' + '        </a-entity>' + '        <a-entity' + '                  position="0 0 -1"' + '                  rotation="0 0 0"' + '                  geometry="primitive: ring; radiusOuter: 0.025; radiusInner: 0.02; thetaStart: 0; thetaLength: 360"' + '                  material="side: double;color: black; shader: flat; opacity: 0.25">' + '        </a-entity>';
    cR += '</a-entity>';
    cR += '<a-entity id="spheres">';
    cR += prx.vr.interactionAreas(symbol, _id, stateindex);
    cR += '</a-entity>';
    cR += '</a-scene>';
  }

  return cR;
};

prx.vr.interactionAreas = function (symbol, containerid, stateindex) {
  var vrWidth = symbol.states[stateindex].dimensions[0];
  var vrHeight = symbol.states[stateindex].dimensions[1];
  var data = JSON.parse(symbol.states[stateindex].data);
  var cR = '';
  var groups = symbol.states[stateindex].groups || {};
  var nextRadius = prx.vr.RADIUS_MIN + (data.length + Object.keys(groups).length) * prx.vr.RADIUS_STEP;

  for (var i = 0; i < data.length; i++) {
    var item = data[i]; // set group radius

    for (var j = item.parentgroups.length - 1; j >= 0; j--) {
      if (groups[item.parentgroups[j]].radius === undefined) {
        groups[item.parentgroups[j]].radius = nextRadius;
        nextRadius -= prx.vr.RADIUS_STEP;
      }
    }

    cR += prx.vr.getComponent(item, nextRadius, containerid, vrWidth, vrHeight);
    nextRadius -= prx.vr.RADIUS_STEP;
  }

  for (var key in groups) {
    var group = groups[key];

    if (group.actions.length > 0) {
      cR += prx.vr.getGroup(group, containerid, vrWidth, vrHeight);
    }

    delete group.radius; // need to delete it for the next time that the screen will be rendered
  }

  return cR;
};

prx.vr.debugGroupsAndInteractionAreas = false;

prx.vr.getGroup = function (group, containerid, vrW, vrH) {
  var groupId = 'group-' + group.id;

  var _id = !containerid ? groupId : containerid + '-' + groupId;

  var phi = prx.vr.getPhi(group, vrW);
  var theta = prx.vr.getTheta(group, vrH);
  if (!prx.vr.debugGroupsAndInteractionAreas) return '<a-sphere item-type="vrgroup" id="' + _id + '" class="vr-interactive ' + groupId + '" rotation="0 270 0" material="side:double;visible:false;transparent:true;color:#FFF" src="" geometry="mergeTo:null;primitive:sphere;radius:' + group.radius + ';phiLength:' + phi.length + ';phiStart:' + phi.start + ';thetaLength:' + theta.length + ';thetaStart:' + theta.start + '"></a-sphere>';else return '<a-sphere item-type="vrgroup" id="' + _id + '" class="vr-interactive ' + groupId + '" rotation="0 270 0" material="side:double;visible:true;transparent:true;color:' + getRandomColor() + '" src="" geometry="mergeTo:null;primitive:sphere;radius:' + group.radius + ';phiLength:' + phi.length + ';phiStart:' + phi.start + ';thetaLength:' + theta.length + ';thetaStart:' + theta.start + '"></a-sphere>';
};

function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';

  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }

  return color;
}

prx.vr.getComponent = function (item, radius, containerDomId, vrW, vrH) {
  var _id = !containerDomId ? item.id : containerDomId + '-' + item.id;

  var phi = prx.vr.getPhi(item, vrW);
  var theta = prx.vr.getTheta(item, vrH);
  var visible = 'true';
  var color = '';
  var cR = '',
      objectClass;
  if (!radius) radius = 0;

  if (item.type === 'vrrectangle') {
    color = prx.utils.getColor(item.backgroundColor);
  }

  if (item.type === 'vractionarea') {
    if (!prx.vr.debugGroupsAndInteractionAreas) visible = 'false';else visible = 'true';
  }

  if (typeof item.actions !== 'undefined') {
    if (item.actions.length > 0) {
      objectClass = 'vr-interactive';
    } else {
      objectClass = '';
    }
  }

  if (prx.vr.allowedTypes.indexOf(item.type) > -1) {
    if (item.type === 'vrimage') {
      var fileId = item.imgSrc.fileId.split(".")[0]; // set correct shader, for gif images we should use shader:gif

      var shader = "";

      if (item.imgSrc.fileId.toLowerCase().indexOf(".png") > -1 || item.imgSrc.fileId.toLowerCase().indexOf(".gif") > -1) {
        shader = "shader:gif;";
      }

      cR += '<a-sphere item-type="' + item.type + '" id="' + _id + '" class="' + objectClass + '" rotation="0 270 0" material= "' + shader + 'side:double;transparent:true;color:' + color + '" src="#vr-' + fileId + '" geometry="mergeTo:null;primitive:sphere;radius:' + radius + ' ;phiLength:' + phi.length + ';phiStart:' + phi.start + ';thetaLength:' + theta.length + ';thetaStart:' + theta.start + '"></a-sphere>';
    } else {
      cR += '<a-sphere item-type="' + item.type + '" id="' + _id + '" class="' + objectClass + '" rotation="0 270 0" material="side:double;visible:' + visible + ';transparent:true;color:' + color + '" src="" geometry="mergeTo:null;primitive:sphere;radius:' + radius + ';phiLength:' + phi.length + ';phiStart:' + phi.start + ';thetaLength:' + theta.length + ';thetaStart:' + theta.start + '"></a-sphere>';
    }
  }

  return cR;
};

prx.vr.changeState = function (containerDomId, symbolId, stateId, changes) {
  var index = prx.stc.helper.getIndexFromId(symbolId, 'symbols');
  var stateindex = prx.stc.helper.getStateIndexFromId(stateId, 'symbols', index);
  var symbol = prxy.symbols[index];
  var state = symbol.states[stateindex];
  var data = JSON.parse(state.data);
  var groups = state.groups;
  var pageId = containerDomId.split('-')[1];
  var skyComponent = $('#' + containerDomId + ' a-sky');
  var vrWidth = state.dimensions[0];
  var vrHeight = state.dimensions[1]; // update sky

  var skyId = '';
  var backgroundColor = '#FFF';
  var src = '';

  if (state.backgroundImg !== undefined && state.backgroundImg.fileId !== '') {
    skyId = state.backgroundImg.fileId.split(".")[0];
    src = '#sky-' + skyId;
  } else {
    backgroundColor = prx.utils.getColor(symbol.states[stateindex].background);
  } // update sky element


  skyComponent[0].setAttribute('src', src);
  skyComponent[0].setAttribute('material', 'color', backgroundColor);
  var nextRadius = prx.vr.RADIUS_MIN + (data.length + Object.keys(groups).length) * prx.vr.RADIUS_STEP;
  var reorder = false;
  var items = {}; // find the radius of each item and group

  for (var i = 0; i < data.length; i++) {
    // set group radius
    for (var j = data[i].parentgroups.length - 1; j >= 0; j--) {
      if (groups[data[i].parentgroups[j]].update_radius === undefined) {
        groups[data[i].parentgroups[j]].update_radius = nextRadius;
        nextRadius -= prx.vr.RADIUS_STEP;
      }
    }

    data[i].update_radius = nextRadius;
    items[data[i].id] = data[i];
    nextRadius -= prx.vr.RADIUS_STEP;
  } // loop all changes


  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    switch (change.type) {
      case 'changed-component':
        if (items.hasOwnProperty(change.id)) {
          change.item = items[change.id];
        } else continue;

        if (change.changes.hasOwnProperty('actions')) {
          prx.vr.removeComponent(change, containerDomId);
          prx.vr.addComponent(change.item, pageId, containerDomId, vrWidth, vrHeight);
        } else if (change.changes.hasOwnProperty('left') || change.changes.hasOwnProperty('top')) {
          prx.vr.updateComponent(change.item, change.changes, containerDomId, vrWidth, vrHeight);
        }

        break;

      case 'new-component':
        reorder = true;
        if (items.hasOwnProperty(change.id)) prx.vr.addComponent(items[change.id], pageId, containerDomId, vrWidth, vrHeight);
        break;

      case 'removed-component':
        prx.vr.removeComponent(change, containerDomId);
        reorder = true;
        break;
      // case 'changed-group':
      //     // remove it and add it again
      //     debugger;
      //     prx.vr.removeComponent(change, containerDomId);
      //     prx.vr.addGroup(change.group, containerDomId, vrWidth, vrHeight);
      //     break;

      case 'new-group':
        reorder = true;
        break;

      case 'removed-group':
        prx.vr.removeGroup(change.group, containerDomId);
        reorder = true;
        break;

      case 'reordered-components':
        reorder = true;
        break;
    }
  } // do reorder if needed


  if (reorder) {
    // update radius on items that have not been updated already
    for (var i = 0; i < data.length; i++) {
      if (data[i].hasOwnProperty('update_radius')) {
        prx.vr.updateComponent(data[i], {}, containerDomId);
      }
    }
  } // update groups


  for (var key in groups) {
    if (groups.hasOwnProperty(key)) {
      var group = groups[key]; // remove the dom element

      prx.vr.removeGroup(group, containerDomId); // add it again if there are actions on it

      if (group.actions.length > 0) {
        prx.vr.addGroup(group, containerDomId, vrWidth, vrHeight);
      }
    }
  }

  document.getElementById("indicator").components.raycaster.refreshObjects();
  $('#' + containerDomId).attr('data-state-id', stateId);
  prx.vr.setEventListenersForFusingAnimations();
}; // add component


prx.vr.addComponent = function (item, pageId, containerDomId, vrW, vrH) {
  var html = prx.vr.getComponent(item, item.update_radius, containerDomId, vrW, vrH);
  delete item.update_radius;
  var $spheres = $('#' + containerDomId).find('#spheres');
  $spheres.append(html);
  prx.actions.parseItemAction(item, containerDomId, pageId, undefined, false);
};

prx.vr.addGroup = function (group, containerDomId, vrW, vrH) {
  if (group.hasOwnProperty('update_radius')) {
    group.radius = group.update_radius;
    delete group.update_radius;
  }

  var html = prx.vr.getGroup(group, containerDomId, vrW, vrH);
  var $spheres = $('#' + containerDomId).find('#spheres');
  $spheres.append(html);
  prx.vr.parseGroupAction(group, containerDomId);
};

prx.vr.removeComponent = function (change, containerDomId) {
  var _id = '#' + (!containerDomId ? change.id : containerDomId + '-' + change.id);

  $(_id).remove();
};

prx.vr.removeGroup = function (group, containerDomId) {
  var _id = '#' + (!containerDomId ? group.id : containerDomId + '-group-' + group.id);

  $(_id).remove();
}; // update component for change state


prx.vr.updateComponent = function (item, changes, containerDomId, vrW, vrH) {
  var _id = !containerDomId ? item.id : containerDomId + '-' + item.id;

  var el = document.getElementById(_id);
  if (!el) return; // check and update geometry changes

  if (changes.hasOwnProperty('left') || changes.hasOwnProperty('top') || changes.hasOwnProperty('height') || changes.hasOwnProperty('width')) {
    var phi = prx.vr.getPhi(item, vrW);
    var theta = prx.vr.getTheta(item, vrH);
    var geometry = {
      phiLength: phi.length,
      phiStart: phi.start,
      thetaLength: theta.length,
      thetaStart: theta.start
    };

    if (item.hasOwnProperty('update_radius')) {
      geometry.radius = item.radius;
      delete item.update_radius;
    }

    el.setAttribute('geometry', geometry);
  } else if (item.hasOwnProperty('update_radius')) {
    // update only radius in needed
    el.setAttribute('geometry', {
      radius: item.update_radius
    });
    delete item.update_radius;
  } // check and update material changes


  if (changes.hasOwnProperty('backgroundColor') || changes.hasOwnProperty('imgSrc')) {
    var shader = 'flat';
    var color = '#FFFFFF';

    if (item.type == 'vrimage') {
      if (item.imgSrc.fileId.toLowerCase().indexOf('.gif') > -1) shader = 'gif';
    }

    if (item.type == 'vrrectangle') {
      color = prx.utils.getColor(item.backgroundColor);
    }

    el.setAttribute('material', {
      color: prx.utils.getColor(color),
      transparent: true,
      side: 'double',
      shader: shader
    });
  } // src changes


  if (changes.hasOwnProperty('imgSrc')) {
    var src = "";
    if (item.type == 'vrimage') src = item.imgSrc.fileId.split(".")[0];
    el.setAttribute('src', '#vr-' + src);
  }
}; // // remove or add items, of the specified type, on dom based on the diff number
// prx.vr.addRemoveItems = function(itemId, diff, type){
//
//     // remove
//     if (diff > 0) {
//
//         var $items = $('#' + itemId + ' a-sphere');
//         var removed = 0; // number of items have been removed
//
//         for (var j = 0; j < $items.length; j++){
//             if ($items[j].attributes['item-type'] != undefined) {
//                 if ($items[j].attributes['item-type'].value == type && removed < diff) {
//                     $($items[j]).remove();
//                     removed++;
//
//                     if(removed == diff)
//                         break;
//                 }
//             }
//         }
// 	}
// 	else if (diff < 0) { // add
//
//         var $spheres = $('#'+itemId).find('#spheres')[0];
//         for (var i = 0; i < (diff * (-1)); i++){
//             var el = '<a-sphere item-type="'+type+'" id="sphere-' + type + '-' + i + '" class="" rotation="0 270 0"></a-sphere>';
//             $spheres.insertAdjacentHTML('beforeend', el);
//         }
//
// 	}
// };
//
// // get all vr items from dom in object sorted by type
// prx.vr.getCurrentItemsFromDom = function(itemId){
//
//     var $items = $('#'+itemId+' a-sphere');
//
//     var itemsObj = prx.vr.getEmptyItemsObj();
//
//     for (var i = 0; i < $items.length; i++){
//         if ($items[i].attributes['item-type'] != undefined) {
//             var itemType = $items[i].attributes['item-type'].value.toString();
//             itemsObj[itemType].push($items[i]);
//         }
//     }
//
//     return itemsObj;
// };
//
// // for each item in the state get the properties
// prx.vr.getStateItemsProperties = function(stateindex, index){
//
//     var symbol = prxy.symbols[index];
//     var data = JSON.parse(symbol.states[stateindex].data);
//     var vrWidth = prxy.symbols[index].states[stateindex].dimensions[0];
//     var vrHeight = prxy.symbols[index].states[stateindex].dimensions[1];
//     var items = prx.vr.getEmptyItemsObj();
//
//     for (var i = 0; i < data.length; i++) {
//
//         var item = data[i];
//
//         if (prx.vr.allowedTypes.indexOf(item.type) > -1) {
//
//             var id = item.id;
//             var phi = prx.vr.getPhi(item, vrWidth);
//             var theta = prx.vr.getTheta(item, vrHeight);
//             var color = '#FFFFFF';
//             var src = "";
//             var objectClass = '';
//             var shader = 'flat';
//             var radius = 10 + (data.length - i) * 1;
//
//             if (item.type == 'vrrectangle') {
//                 color = prx.utils.getColor(item.backgroundColor);
//             }
//
//             if (item.type == 'vrimage') {
//                 src = item.imgSrc.fileId.split(".")[0];
//
//                 if(item.imgSrc.fileId.toLowerCase().indexOf('.gif') > -1)
//                     shader = 'gif';
//             }
//
//             if (item.actions.length > 0) {
//                 objectClass = 'clickable';
//             }
//
//             items[item.type].push({phi: phi, theta: theta, src: src, id: id, objectClass: objectClass, color: color, shader: shader, radius: radius});
//         }
//     }
//     return items;
// };
//
// prx.vr.getEmptyItemsObj = function(){
//     return {'vrimage': [], 'vractionarea': [], 'vrrectangle': [], 'vrgroup': []};
// };
//
// prx.vr.updateVrItems = function(domElements, newProperties, parentId){
//
//
//     for (var i = 0; i < prx.vr.allowedTypes .length; i++){
//
//         var type = prx.vr.allowedTypes [i];
//
//     	if (newProperties[type].length > 0) {
//
//     	    for (var j = 0; j < newProperties[type].length; j++) {
//
//     	        var item = newProperties[type][j];
//
//                 domElements[type][j].id = parentId.concat('-'+item.id);
//
//                 domElements[type][j].setAttribute('geometry', {
//                 	radius: item.radius,
//                     phiLength: item.phi.length,
//                     phiStart: item.phi.start,
//                     thetaLength: item.theta.length,
//                     thetaStart: item.theta.start
//                 });
//
//
//                 domElements[type][j].setAttribute('material', {
//                     color: prx.utils.getColor(item.color),
//                     transparent: true,
//                     side: 'double',
//                     shader: item.shader
//                 });
//
//                 if (type == 'vrimage') {
//                     domElements[type][j].setAttribute('src', '#vr-'+item.src);
//                 }
//
//                 domElements[type][j].setAttribute('class', item.objectClass);
//             }
//         }
//     }
// };


prx.vr.getPhi = function (item, vrWidth) {
  var xInitial = item.left + item.width;
  var xFinal = item.left;
  var phi = {};
  phi.start = (vrWidth - xFinal) * 360 / vrWidth;
  phi.end = (vrWidth - xInitial) * 360 / vrWidth;
  phi.length = phi.end - phi.start;
  return phi;
};

prx.vr.getTheta = function (item, vrHeight) {
  var yInitial = item.top;
  var yFinal = item.top + item.height;
  var theta = {};
  theta.start = yInitial * 180 / vrHeight;
  theta.end = yFinal * 180 / vrHeight;
  theta.length = theta.end - theta.start;
  return theta;
};

prx.vr.refresh = function (targetid, maintainVisiblity) {
  if (!maintainVisiblity) false;
  var length = $(targetid + '.type-vrsymbol' + ',' + targetid + ' .type-vrsymbol').length;
  var index = 0;
  if (!length) return;

  function rerenderOne() {
    if (index >= length) return;
    $(targetid + '.type-vrsymbol' + ',' + targetid + ' .type-vrsymbol').eq(index).each(function (i) {
      index++;
      var id = this.id;
      var item = id.split("box-");
      var itemId = "box-".concat(item[item.length - 1]);
      var pageid = $(this).parents(".prx-page").attr('data-id');
      var pageid = $(this).parents(".prx-page").attr('data-id');
      var stateid = $(this).parents('[data-state-id]').first().attr('data-state-id');
      var data = prx.items.getFromAllItemStruct(itemId, stateid);

      if (maintainVisiblity) {
        if ($(this).hasClass('hidden')) {
          data.visible = false;
        } else {
          data.visible = true;
        }
      }

      var containerid = id.substring(0, id.length - (itemId.length + 1));
      var symbolid = $(this).attr("data-symbol-id");
      var symbolstateid = $(this).attr("data-state-id");
      data.symbolstateid = symbolstateid;
      prx.items.rerender(data, containerid, pageid);
      prx.vr.bindItemActions(symbolid, symbolstateid, id, pageid);
      var scene = $('#' + id + ' a-scene')[0];

      if (scene.hasLoaded) {
        rerenderOne();
      } else {
        scene.addEventListener('loaded', rerenderOne);
      }

      prx.vr.setEventListenersForFusingAnimations();
      setTimeout(function () {
        prx.vr.setUpScroll(id);
      }, 100);
    });
  }

  rerenderOne(0);
};

prx.vr.disable = function (targetid) {
  $('.prx-page-active').find('a-scene').each(function () {
    this.exitVR();
  });
  $(targetid + ' .type-vrsymbol,' + targetid + '.type-vrsymbol').each(function () {
    $(this).empty();
  });
}; // not used


prx.vr.setInitialPosition = function (item, backgroundPic) {
  var maxW = backgroundPic.width;
  var maxH = backgroundPic.height;
  var vCenter = parseFloat(item.scrollToY) + item.height / 2;
  var hCenter = parseFloat(item.scrollToX) + item.width / 2;
  var initPos = {};
  initPos.vAngle = (maxH / 2 - vCenter) * 180 / maxH;
  initPos.hAngle = 0 - hCenter * 360 / maxW;
  var camera = $('a-camera'); // item id needed

  camera.setAttribute('rotation', {
    x: initPos.vAngle,
    y: initPos.hAngle,
    z: 0
  });
};

prx.vr.bindItemActions = function (symbolid, stateid, containerid, pageid) {
  var index = prx.stc.helper.getIndexFromId(symbolid, 'symbols');
  var symbol = prxy.symbols[index];
  var state = prx.stc.containers.getStateIndexFromId(stateid, index);
  var data = JSON.parse(symbol.states[state].data);

  for (var i = 0; i < data.length; i++) {
    var item = data[i]; // rectangles, interaction areas, images only, so we can assume that we can find
    // all actions under item.action
    // if(item.actions !== undefined) {
    //    for (var j = 0; j < item.actions.length; j++) {
    //     item.actions[j].type = 'click';
    //    }
    // }

    prx.actions.parseItemAction(item, containerid, pageid, undefined, false);
  }

  for (var key in symbol.states[state].groups) {
    var group = symbol.states[state].groups[key];
    prx.vr.parseGroupAction(group, containerid);
  }
};

prx.vr.parseGroupAction = function (group, _prefix) {
  if (group.actions === undefined || group.actions.length == 0) return;
  var bindTo = _prefix + '-group-' + group.id;
  group.actions.sort(function (a, b) {
    return a.sort - b.sort;
  });
  group.actions.forEach(function (action) {
    action = JSON.parse(JSON.stringify(action));
    action = prx.actions.recursivelyAddInfo(action, '#' + bindTo, _prefix, _prefix, '#' + bindTo, '.protoio-group-actions'); // not really bothering with targetid (passing prefix instead) because its recrated in build action

    prx.actions.build(action);
  });
};

prx.vr.setUpScroll = function (targetId) {
  var scrollableEl = $('#' + targetId).parents('.type-symbol').attr('id');
  var canvasEl = $('#' + targetId).find('canvas')[0];

  if (typeof scrollableEl !== 'undefined' && typeof canvasEl !== 'undefined') {
    if (!prx.helper.onmobile()) {
      canvasEl.addEventListener('mousedown', function () {
        prx.scrollable.disable('#' + scrollableEl);
      });
      canvasEl.addEventListener('mouseup', function () {
        prx.scrollable.enable('#' + scrollableEl);
      });
    } else {
      canvasEl.addEventListener('touchstart', function () {
        prx.scrollable.disable('#' + scrollableEl);
      });
      canvasEl.addEventListener('touchend', function () {
        prx.scrollable.enable('#' + scrollableEl);
      });
    }
  }
};

prx.vr.getImages = function (symbol) {
  var cR = '';
  var assets = [];
  var skies = [];

  for (var i = 0; i < symbol.states.length; i++) {
    var bgImg = symbol.states[i].backgroundImg;

    if (bgImg !== undefined && bgImg.fileId != '') {
      var fileId = bgImg.fileId.split(".")[0];
      var src = getSrc(prx.componentsHelper.getProp(bgImg, 'asset'), bgImg.fileId);

      if (skies.indexOf('sky-' + fileId) === -1) {
        skies.push('sky-' + fileId);
        cR += '<img id="sky-' + fileId + '" src="' + src + '" crossorigin="anonymous">';
      } else {
        skies.push('sky-' + fileId);
      }
    } else {
      skies.push('none');
    }

    var data = JSON.parse(symbol.states[i].data);

    for (var j = 0; j < data.length; j++) {
      if (data[j].type === 'vrimage') {
        if (typeof data[j].imgSrc !== 'undefined') {
          fileId = data[j].imgSrc.fileId;
          src = getSrc(prx.componentsHelper.getProp(data[j].imgSrc, 'asset'), fileId);
          fileId = fileId.split(".")[0];

          if (assets.indexOf(data[j].imgSrc.fileId) === -1) {
            assets.push(data[j].imgSrc.fileId);
            cR += '<img id="vr-' + fileId + '" src="' + src + '" crossorigin="anonymous">';
          }
        }
      }
    }
  }

  function getSrc(src, fileId) {
    if (!prx.export2html && (!prx.vr.crossOriginUnsupported() || fileId.toLowerCase().indexOf(".gif") > -1)) {
      if (src.indexOf('access_token=') === -1) {
        if (src.indexOf('?') === -1) {
          src += '?access_token=' + prx.assetsAccessToken;
        } else {
          src += '&access_token=' + prx.assetsAccessToken;
        }
      }

      src += '&VR=1';
    } else {
      if (prx.vr.images.hasOwnProperty(fileId)) {
        src = prx.vr.images[fileId];
      } else {
        src = "";
      }
    }

    return src;
  }

  return {
    cR: cR,
    skies: skies
  };
}; // this function returns true in the cases that the browser cases cross origin issues for images


prx.vr.crossOriginUnsupported = function () {
  return !prx.export2html && $.browser.safari;
};

prx.vr.setEventListenersForFusingAnimations = function () {
  $('.vr-interactive.interaction-click').on('fusing', function (e) {
    document.getElementById("indicator").dispatchEvent(new Event('vrtimeranimation'));
  }).on('click', function (e) {
    document.getElementById("indicator").dispatchEvent(new Event('vrclickanimation'));
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/_youtube.js":
/*!******************************************************!*\
  !*** ./sass/player-engine/js/components/_youtube.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.youtube = {};
prx.youtube._players = {};
prx.youtube._playersPending = [];

prx.youtube.createVideo = function (targetId) {
  try {
    prx.youtube._players[targetId + '-youtube'] = new YT.Player(targetId + '-youtube', {
      events: {
        'onStateChange': onPlayerStateChange
        /*'onReady':function(){player.playVideo()}
        onError: function(a){
        	alert(a);
        	alert(a.data);
        }*/

      }
    });
  } catch (e) {
    prx.youtube._playersPending.push(targetId + '-youtube');
  }

  function onPlayerStateChange(event) {
    if (event.data == YT.PlayerState.PLAYING) {
      $('#' + targetId).trigger('videoplay');
    } else if (event.data == YT.PlayerState.PAUSED) {
      $('#' + targetId).trigger('videopause');
    } else if (event.data == YT.PlayerState.ENDED) {
      $('#' + targetId).trigger('videoend');
    }
  }
};

prx.youtube.createPendingVideos = function () {
  for (var i = 0; i < prx.youtube._playersPending.length; i++) {
    prx.youtube.createVideo(prx.youtube._playersPending[i]);
  }
};

prx.youtube.ini = function () {
  onYouTubeIframeAPIReady = function onYouTubeIframeAPIReady() {
    prx.youtube.createPendingVideos();
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/compatibility/_galleryAssetsToStatic.js":
/*!**********************************************************************************!*\
  !*** ./sass/player-engine/js/components/compatibility/_galleryAssetsToStatic.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Created by kyriakos on 23/05/17.
 */
prx.compatibility.galleryAssetsToStatic = {};

prx.compatibility.galleryAssetsToStatic.runCompatibility = function () {
  if (prx.hasOwnProperty("sGalleryAssetsToStatic")) {
    prx.compatibility.galleryAssetsToStatic.mapping = prx.sGalleryAssetsToStatic;
    prx.sGalleryAssetsToStatic = {};
    prx.compatibility.galleryAssetsToStatic.updateProject();
  }
};

prx.compatibility.galleryAssetsToStatic.updateProject = function () {
  var i, j, k, l, group; // loop over pages

  for (i = 0; i < prxy.pages.length; i++) {
    // loop page actions
    for (j = 0; j < prxy.pages[i].actions.length; j++) {
      prxy.pages[i].actions[j] = prx.compatibility.galleryAssetsToStatic.updateAction(prxy.pages[i].actions[j]);
    } // loop over page's states


    for (j = 0; j < prxy.pages[i].states.length; j++) {
      //loop groups for actions
      if (typeof prxy.pages[i].states[j].groups !== "undefined") {
        for (group in prxy.pages[i].states[j].groups) {
          if (prxy.pages[i].states[j].groups.hasOwnProperty(group) && typeof prxy.pages[i].states[j].groups[group].actions !== "undefined") {
            for (l = 0; l < prxy.pages[i].states[j].groups[group].actions.length; l++) {
              prxy.pages[i].states[j].groups[group].actions[l] = prx.compatibility.galleryAssetsToStatic.updateAction(prxy.pages[i].states[j].groups[group].actions[l]);
            }
          }
        }
      }

      if (typeof prxy.pages[i].states[j].actions !== "undefined") {
        for (k = 0; k < prxy.pages[i].states[j].actions.length; k++) {
          prxy.pages[i].states[j].actions[k] = prx.compatibility.galleryAssetsToStatic.updateAction(prxy.pages[i].states[j].actions[k]);
        }
      }

      var data = JSON.parse(prxy.pages[i].states[j].data);

      for (k = 0; k < data.length; k++) {
        data[k] = prx.compatibility.galleryAssetsToStatic.updateItem(data[k]);
      }

      prxy.pages[i].states[j].data = JSON.stringify(data);
    }
  }

  for (i = 0; i < prxy.symbols.length; i++) {
    for (j = 0; j < prxy.symbols[i].states.length; j++) {
      if (typeof prxy.symbols[i].states[j].groups !== "undefined") {
        for (group in prxy.symbols[i].states[j].groups) {
          if (prxy.symbols[i].states[j].groups.hasOwnProperty(group) && typeof prxy.symbols[i].states[j].groups[group].actions !== "undefined") {
            for (l = 0; l < prxy.symbols[i].states[j].groups[group].actions.length; l++) {
              prxy.symbols[i].states[j].groups[group].actions[l] = prx.compatibility.galleryAssetsToStatic.updateAction(prxy.symbols[i].states[j].groups[group].actions[l]);
            }
          }
        }
      }

      if (typeof prxy.symbols[i].states[j].actions !== "undefined") {
        for (k = 0; k < prxy.symbols[i].states[j].actions.length; k++) {
          prxy.symbols[i].states[j].actions[k] = prx.compatibility.galleryAssetsToStatic.updateAction(prxy.symbols[i].states[j].actions[k]);
        }
      }

      var data = JSON.parse(prxy.symbols[i].states[j].data);

      for (k = 0; k < data.length; k++) {
        data[k] = prx.compatibility.galleryAssetsToStatic.updateItem(data[k]);
      }

      prxy.symbols[i].states[j].data = JSON.stringify(data);
    }
  }

  prx.compatibility.galleryAssetsToStatic.mapping = {}; // optimisation;
}; // check item if contain any gallery asset from main bucket


prx.compatibility.galleryAssetsToStatic.updateItem = function (item) {
  var key, i, j, k;

  for (key in item) {
    if (item.hasOwnProperty(key)) {
      if (_typeof(item[key]) == "object" && item[key] !== null && typeof item[key].assetType != "undefined" && item[key].assetType == "gallery" && item[key].bucketsource && item[key].bucketsource == "main") {
        item[key] = prx.compatibility.galleryAssetsToStatic.updateAsset(item[key]);
      }
    }
  }

  for (i = 0; i < prx.actions._actionTypes.length; i++) {
    if (typeof item[prx.actions._actionTypes[i]] !== "undefined") {
      for (j = 0; j < item[prx.actions._actionTypes[i]].length; j++) {
        item[prx.actions._actionTypes[i]][j] = prx.compatibility.galleryAssetsToStatic.updateAction(item[prx.actions._actionTypes[i]][j]);
      }
    }
  }

  for (i = 0; i < prx.utils.dynamic_properties.length; i++) {
    if (typeof item[prx.utils.dynamic_properties[i]] !== "undefined") {
      for (j = 0; j < item[prx.utils.dynamic_properties[i]].length; j++) {
        if (typeof item[prx.utils.dynamic_properties[i]][j].actions !== "undefined") {
          for (k = 0; k < item[prx.utils.dynamic_properties[i]][j].actions.length; k++) {
            item[prx.utils.dynamic_properties[i]][j].actions[k] = prx.compatibility.galleryAssetsToStatic.updateAction(item[prx.utils.dynamic_properties[i]][j].actions[k]);
          }
        }

        for (key in item[prx.utils.dynamic_properties[i]][j]) {
          if (item[prx.utils.dynamic_properties[i]][j].hasOwnProperty(key)) {
            if (_typeof(item[prx.utils.dynamic_properties[i]][j][key]) === "object" && item[prx.utils.dynamic_properties[i]][j][key] !== null && typeof item[prx.utils.dynamic_properties[i]][j][key].assetType !== "undefined" && item[prx.utils.dynamic_properties[i]][j][key].assetType === "gallery" && item[prx.utils.dynamic_properties[i]][j][key].bucketsource && item[prx.utils.dynamic_properties[i]][j][key].bucketsource === "main") {
              item[prx.utils.dynamic_properties[i]][j][key] = prx.compatibility.galleryAssetsToStatic.updateAsset(item[prx.utils.dynamic_properties[i]][j][key]);
            }
          }
        }
      }
    }
  }

  return item;
}; // update an action


prx.compatibility.galleryAssetsToStatic.updateAction = function (action) {
  if (action === null) {
    return action;
  } // check if action is change property and the new value is a gallery asset to convert it to static


  if (action.actionId === 'change-property' && _typeof(action.newvalue) === "object" && action.newvalue !== null && typeof action.newvalue.assetType !== "undefined" && action.newvalue.assetType === "gallery" && action.newvalue.bucketsource && action.newvalue.bucketsource === "main") {
    action.newvalue = prx.compatibility.galleryAssetsToStatic.updateAsset(action.newvalue);
  } else if (action.actionId === 'play-audio' && action.hasOwnProperty("sourceId") && action.sourceId === "library" && action.hasOwnProperty("sound")) {
    if (action.sound.hasOwnProperty("aac") && action.sound.aac.hasOwnProperty("fileId") && !action.sound.aac.hasOwnProperty("url")) {
      action.sound.aac = prx.compatibility.galleryAssetsToStatic.updateAsset(action.sound.aac);
    }

    if (action.sound.hasOwnProperty("mp3") && action.sound.mp3.hasOwnProperty("fileId") && !action.sound.mp3.hasOwnProperty("url")) {
      action.sound.mp3 = prx.compatibility.galleryAssetsToStatic.updateAsset(action.sound.mp3);
    }

    if (action.sound.hasOwnProperty("wav") && action.sound.wav.hasOwnProperty("fileId") && !action.sound.wav.hasOwnProperty("url")) {
      action.sound.wav = prx.compatibility.galleryAssetsToStatic.updateAsset(action.sound.wav);
    }
  }

  if (typeof action.callbackAction !== "undefined") {
    action.callbackAction = prx.compatibility.galleryAssetsToStatic.updateAction(action.callbackAction);
  }

  return action;
};

prx.compatibility.galleryAssetsToStatic.updateAsset = function (asset) {
  var id = asset.fileId;

  if ((!prx.hasOwnProperty("dropboxfs") || !prx.dropboxfs) && asset.hasOwnProperty("url")) {
    id = asset.url;
  }

  if (prx.compatibility.galleryAssetsToStatic.mapping.hasOwnProperty(id)) {
    asset.bucketsource = "static";
    asset.url = prx.compatibility.galleryAssetsToStatic.mapping[id];
  }

  return asset;
};

/***/ }),

/***/ "./sass/player-engine/js/components/compatibility/_responsive-components.js":
/*!**********************************************************************************!*\
  !*** ./sass/player-engine/js/components/compatibility/_responsive-components.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.compatibility.responsiveComponents = {};

prx.compatibility.responsiveComponents.compatibleData = function (data) {
  for (var i = 0; i < data.length; i++) {
    if (data[i].lib == "iphone_retina") {
      data[i].lib = "iphone";
      data[i].type = data[i].type.replace('_retina', '');
      data[i].name = data[i].name.replace('_retina', '');
      data[i].rscale = 2;
    }

    if (data[i].lib == "ios7") {
      data[i].rscale = 2;
    }
  }

  return data;
};

prx.compatibility.responsiveComponents.compatibleAllData = function () {
  for (var i = 0; i < prxy.pages.length; i++) {
    for (var j = 0; j < prxy.pages[i].states.length; j++) {
      var data = JSON.parse(prxy.pages[i].states[j].data);
      data = prx.compatibility.responsiveComponents.compatibleData(data);
      prxy.pages[i].states[j].data = JSON.stringify(data);
    }
  }

  for (var i = 0; i < prx.templates.length; i++) {
    for (var j = 0; j < prx.templates[i].states.length; j++) {
      var data = JSON.parse(prx.templates[i].states[j].data);
      data = prx.compatibility.responsiveComponents.compatibleData(data);
      prx.templates[i].states[j].data = JSON.stringify(data);
    }
  }

  for (var i = 0; i < prxy.symbols.length; i++) {
    for (var j = 0; j < prxy.symbols[i].states.length; j++) {
      var data = JSON.parse(prxy.symbols[i].states[j].data);
      data = prx.compatibility.responsiveComponents.compatibleData(data);
      prxy.symbols[i].states[j].data = JSON.stringify(data);
    }
  }
};

prx.compatibility.responsiveComponents.ini = function () {
  prx.v5x11 = false;
  prx.compatibility.responsiveComponents.compatibleAllData();
};

/***/ }),

/***/ "./sass/player-engine/js/components/compatibility/_v5.js":
/*!***************************************************************!*\
  !*** ./sass/player-engine/js/components/compatibility/_v5.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.compatibility.v5 = {};

prx.compatibility.v5.ini = function () {
  // stateful objects
  // templates first because i need to find template state id when converting pages.
  prx.compatibility.v5.convertToStatefulTemplates();
  prx.compatibility.v5.convertToStatefulPages(); // TODO V5 remove if

  if (!(prxy.symbols.length > 0 && typeof prxy.symbols[0].states != "undefined")) {
    prx.compatibility.v5.convertToStatefulSymbols();
  }

  prx.v5 = true;
};

prx.compatibility.v5.convertToStatefulPages = function (index) {
  for (var index = 0; index < prxy.pages.length; index++) {
    prxy.pages[index].states = [];
    var data = JSON.parse(prxy.pages[index].data);

    if (prx.stc.templates.getIndexFromId(data.templateid) > -1) {
      var template = {
        id: data.templateid,
        stateid: prx.templates[prx.stc.templates.getIndexFromId(data.templateid)].states[0].id
      };
    } else {
      var template = {
        id: ''
      };
    }

    var defaultstate = {
      data: JSON.stringify(data.items),
      template: template,
      title: 'Default State',
      history: prxy.pages[index].history,
      background: prxy.pages[index].background,
      id: prx.utils.getGuid()
    };
    defaultstate = JSON.stringify(defaultstate);
    defaultstate = JSON.parse(defaultstate);
    delete prxy.pages[index].data;
    delete prxy.pages[index].history;
    delete prxy.pages[index].background;
    prxy.pages[index].states.push(defaultstate);
  }

  return true;
};

prx.compatibility.v5.convertToStatefulTemplates = function () {
  for (var index = 0; index < prx.templates.length; index++) {
    prx.templates[index].states = [];
    var data = JSON.parse(prx.templates[index].data);
    var defaultstate = {
      data: JSON.stringify(data.items),
      template: {
        id: data.templateid,
        stateid: ''
      },
      title: 'Default State',
      history: prx.templates[index].history,
      background: prx.templates[index].background,
      id: prx.utils.getGuid()
    };
    defaultstate = JSON.stringify(defaultstate);
    defaultstate = JSON.parse(defaultstate);
    delete prx.templates[index].data;
    delete prx.templates[index].history;
    delete prx.templates[index].background;
    prx.templates[index].states.push(defaultstate);
  } // recheck now that they all have state ids and set state ids where templateid neq ''


  for (var index = 0; index < prx.templates.length; index++) {
    if (prx.templates[index].states[0].template.id != '' && prx.stc.templates.getIndexFromId(prx.templates[index].states[0].template.id) > -1) {
      prx.templates[index].states[0].template.stateid = prx.templates[prx.stc.templates.getIndexFromId(prx.templates[index].states[0].template.id)].states[0].id;
    }
  }

  return true;
};

prx.compatibility.v5.convertToStatefulSymbols = function () {
  for (var index = 0; index < prxy.symbols.length; index++) {
    prxy.symbols[index].states = [];
    var defaultstate = {
      data: prxy.symbols[index].data,
      dimensions: prxy.symbols[index].dimensions,
      title: 'Default State',
      history: prxy.symbols[index].history,
      background: prxy.symbols[index].background,
      id: prx.utils.getGuid()
    };
    defaultstate = JSON.stringify(defaultstate);
    defaultstate = JSON.parse(defaultstate);
    delete prxy.symbols[index].data;
    delete prxy.symbols[index].dimensions;
    delete prxy.symbols[index].history;
    delete prxy.symbols[index].background;
    prxy.symbols[index].states.push(defaultstate);
  }

  return true;
};

/***/ }),

/***/ "./sass/player-engine/js/components/compatibility/compatibility.js":
/*!*************************************************************************!*\
  !*** ./sass/player-engine/js/components/compatibility/compatibility.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.compatibility = {};
prx.compatibility.iscrolljs = false;

/***/ }),

/***/ "./sass/player-engine/js/components/items/_helper.js":
/*!***********************************************************!*\
  !*** ./sass/player-engine/js/components/items/_helper.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.items.helper = {};

prx.items.helper.getAllItems = function (type, index, stateindex) {
  if (typeof stateindex == "undefined") {
    stateindex = 0;
  }

  if (index == -1) {
    return [];
  }

  var data = JSON.parse(prxy[type][index].states[stateindex].data);

  if (prxy[type][index].states.length == 1) {
    return data;
  }

  var itemlist = [];
  var tempdata;

  for (var i = 0; i < data.length; i++) {
    itemlist.push(data[i].id);
  }

  for (i = 0; i < prxy[type][index].states.length; i++) {
    if (i != stateindex) {
      tempdata = JSON.parse(prxy[type][index].states[i].data);

      for (var j = 0; j < tempdata.length; j++) {
        if (itemlist.indexOf(tempdata[j].id) == -1) {
          itemlist.push(tempdata[j].id);
          tempdata[j]._fromstateid = prxy[type][index].states[i].id;
          data.push(tempdata[j]);
        }
      }
    }
  }

  return data;
};

prx.items.helper.refreshHtmlComponent = function (itemid, containerid, stateid) {
  if ($('#' + containerid + '-' + itemid).hasClass('type-html')) {
    if (typeof prx.allItems[itemid].states != "undefined" && typeof prx.allItems[itemid].states[stateid] != "undefined") {
      var data = JSON.parse(prxy[prx.allItems[itemid].containertype][prx.allItems[itemid].containerindex].states[prx.allItems[itemid].states[stateid].stateindex].data);
      var item = data[prx.allItems[itemid].states[stateid].itemindex];
      $('#' + containerid + '-' + item.id + ' iframe').remove();
      prx.types[item.type].afterDisplay(item, containerid);
    }
  } else {
    $('#' + containerid + '-' + itemid + ' .box').each(function () {
      if ($(this).hasClass('type-html')) {
        var split = $(this).attr('id').split('box-');
        var itemid = 'box-' + split[split.length - 1];
        var containerid = $(this).attr('id').split('-' + itemid)[0];
        var stateid = $(this).parents('.type-symbol').attr('data-state-id');

        if (typeof prx.allItems[itemid].states != "undefined" && typeof prx.allItems[itemid].states[stateid] != "undefined") {
          var data = JSON.parse(prxy[prx.allItems[itemid].containertype][prx.allItems[itemid].containerindex].states[prx.allItems[itemid].states[stateid].stateindex].data);
          var item = data[prx.allItems[itemid].states[stateid].itemindex];
          $('iframe', this).remove();
          prx.types[item.type].afterDisplay(item, containerid);
        }
      }
    });
  }
};

prx.items.helper.getPageIdFromId = function (id) {
  if (id.substring(0, 1) == '#') {
    return id.substring(3);
  } else {
    return id.substring(2);
  }
};

prx.items.helper.getBoxIdFromId = function (id) {
  var split = id.split('-box-');
  return 'box-' + split[split.length - 1];
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/items/_items.js":
/*!**********************************************************!*\
  !*** ./sass/player-engine/js/components/items/_items.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.items.filters = {}; // dropShadowX, dropShadowY, dropShadowColor, and dropShadowBlur should be at the end of the array

prx.items.filters.props = ['grayscale', 'sepia', 'saturate', 'hueRotate', 'invert', 'brightness', 'contrast', 'blur', 'dropShadowX', 'dropShadowY', 'dropShadowColor', 'dropShadowBlur'];

prx.items.getComponentBaseStyle = function (item, containerid, symbol) {
  var id = !containerid ? item.id : containerid + '-' + item.id;
  var groups = prx.items.getGroups(item, containerid, symbol === undefined ? void 0 : symbol.symbolid, symbol === undefined ? void 0 : symbol.id); // i need to call groups so that groups visibility is updated?

  var visibilityDets = prx.visibility.get('#' + id, 'visible-all', void 0, symbol === undefined ? void 0 : symbol.id);

  if (containerid.indexOf('box') == -1) {
    var pageid = containerid.match(/p-(\d+)/)[1];
    var pageindex = prx.stc.screens.getIndexFromId(pageid);
    var dims = prx.items.getRealDimsAndPos(item, 'pages', pageindex, 0);
  } else {
    var dims = prx.items.getRealDimsAndPos(item, 'symbols', void 0, void 0, symbol);
  }

  prx.items.getFilter(item, containerid);
  var filters = prx.items.buildFilter('#' + id);
  if (item._fromstateid !== undefined) visibilityDets = 0; // force opacity 0 if not in state

  if (typeof item.rotation == "undefined") {
    item.rotation = 0;
  }

  var cR = '';
  cR += '#' + id + ' {'; //cR += 'top: ' + dims[3] + 'px; left: ' + dims[2] + 'px; ';

  cR += 'transform: translate3d(' + dims[2] + 'px, ' + dims[3] + 'px, 0px) rotate(' + item.rotation + 'deg);';
  cR += 'width: ' + dims[0] + 'px; height: ' + dims[1] + 'px; ';
  cR += 'opacity: ' + (visibilityDets === false ? 0 : visibilityDets) + '; ';
  cR += '-webkit-filter: ' + filters + '; filter: ' + filters + ';';
  cR += '}';
  return cR;
};

prx.items.getComponentBaseClasses = function (item, containerid, symbol) {
  var id = !containerid ? item.id : containerid + '-' + item.id;
  var classes = '';
  var groups = prx.items.getGroups(item, containerid, symbol === undefined ? void 0 : symbol.symbolid, symbol === undefined ? void 0 : symbol.id);
  var visibilityDets = prx.visibility.get('#' + id, 'visible-all', void 0, symbol === undefined ? void 0 : symbol.id);
  var scale = prx.items.getScale(item);
  groups.forEach(function (el) {
    classes += ' group-' + el;
  });
  if (visibilityDets === false) classes += ' hidden';
  classes += ' ' + scale;
  if (item._fromstateid !== undefined) classes += ' ghost-component';
  return classes;
};

prx.items.getComponentPrependDivs = function (item, containerid, symbol) {
  var cR = '';

  if (prx.mask.isActive(item)) {
    delete item.maskImage;

    if (typeof containerid != 'undefined') {
      var itemid = containerid + '-' + item.id;
    } else {
      var itemid = item.id;
    } //MASK-WRAPPER


    var style = prx.mask.getBorderCss(item) + prx.mask.getBorderRadiusCss(item);
    style += prx.mask.marginOnBorderOutside(item, false);
    var classes = "mask-wrapper";
    if (item.mask.borderPos == "inside") classes += " borderPos-inside";else classes += " borderPos-outside";
    cR += '<div id="' + itemid + '-mask" class = "' + classes + '" style = "' + style + '">'; //MASK-INNER

    style = "width: " + item.mask.inner_width + "px; height: " + item.mask.inner_height + "px;";
    style += prx.mask.marginOnBorderOutside(item, true);
    cR += '<div id="' + itemid + '-mask-inner" class = "mask-inner" style = "' + style + '" >';
  }

  return cR;
};

prx.items.getComponentAppendDivs = function (item, containerid, symbol) {
  var cR = '';

  if (prx.mask.isActive(item)) {
    //close mask-wrapper, mask-inner
    cR = '</div></div>';
  }

  return cR;
};

prx.items.getComponentBaseAttributes = function (item, containerid, symbol) {
  return ' data-component-type="' + item.type + '" ';
}; // prx.items.updateRotation = function (item, containerid) {
//
// 	if (typeof(item.rotation) == "undefined") {
// 		item.rotation = 0;
// 	}
//
// 	if (typeof(item.scale) == "undefined") {
// 		item.scale = 1;
// 	}
// 	// i can do this because "updaterotation" is only called as soon as the item is rendered, and not to change the rotation from one value to another
// 	// if this was the case, i wouldn't be able to do this because i might need to change the rotation from eg 90 to 0.
// 	if (item.rotation == 0 && item.scale == 1) {
// 		return false;
// 	}
//
// 	if (typeof(containerid) != 'undefined') {
// 		var targetId = '#' + containerid + '-' + item.id
// 	} else {
// 		var targetId = '#' + item.id
// 	}
//
// 	// dont force3d!
// 	TweenMax.set(targetId, {rotation: item.rotation, scale: item.scale});
// 	// to clear rotation if 0 - returning false instead at the moment and not performing rotation at all
// 	/*
// 	 if($(targetId).css('transform') == "matrix(1, 0, 0, 1, 0, 0)") {
// 	 TweenLite.set(targetId, {clearProps:"transform"});
// 	 }*/
// }


prx.items.getFilter = function (item, containerid) {
  if (typeof containerid != 'undefined') {
    var targetId = '#' + containerid + '-' + item.id;
  } else {
    var targetId = '#' + item.id;
  }

  delete prx.items.filters[targetId];

  function _setProp(prop) {
    if (typeof item[prop] !== 'undefined') {
      if (typeof prx.items.filters[targetId] === 'undefined') prx.items.filters[targetId] = {};
      prx.items.filters[targetId][prop] = item[prop];
    }
  }

  prx.items.filters.props.forEach(_setProp);
};

prx.items.updateFilter = function (item, containerid) {
  if (typeof containerid != 'undefined') {
    var targetId = '#' + containerid + '-' + item.id;
  } else {
    var targetId = '#' + item.id;
  }

  prx.items.getFilter(item, containerid);
  prx.items.applyFilters(targetId);
};

prx.items.buildFilter = function (targetId) {
  if (typeof prx.items.filters[targetId] === 'undefined') return 'none';
  var filters = prx.items.filters[targetId]; // the length - 4 is to skip the drop shadow related properties

  var cssFilter = '',
      l = prx.items.filters.props.length - 4,
      i = -1;

  while (++i < l) {
    var prop = prx.items.filters.props[i];

    if (typeof filters[prop] !== 'undefined') {
      var f = prop === 'hueRotate' ? 'hue-rotate' : prop;
      var t = prop === 'hueRotate' ? 'deg' : prop === 'blur' ? 'px' : ''; // limiting blur

      if (prop === 'blur' && parseInt(filters[prop]) > 50) filters[prop] = '50';
      cssFilter += (cssFilter !== '' ? ' ' : '') + f + '(' + filters[prop] + t + ')';
    }
  }

  if (typeof filters.dropShadowX !== 'undefined' || typeof filters.dropShadowY !== 'undefined' || typeof filters.dropShadowBlur !== 'undefined' || typeof filters.dropShadowColor !== 'undefined') {
    if (typeof filters.dropShadowX === 'undefined') filters.dropShadowX = '1';
    if (typeof filters.dropShadowY === 'undefined') filters.dropShadowY = '1';
    if (typeof filters.dropShadowBlur === 'undefined') filters.dropShadowBlur = '3';
    if (typeof filters.dropShadowColor === 'undefined') filters.dropShadowColor = 'rgba(0,0,0,0.5)'; // limiting blur

    filters.dropShadowBlur = parseInt(filters.dropShadowBlur) > 50 ? '50' : filters.dropShadowBlur;
    cssFilter += (cssFilter !== '' ? ' ' : '') + 'drop-shadow(' + filters.dropShadowX + 'px ' + filters.dropShadowY + 'px ' + filters.dropShadowBlur + 'px ' + prx.gradients.prxToCss(filters.dropShadowColor) + ')';
  }

  return cssFilter;
};

prx.items.applyFilters = function (targetId) {
  var cssFilter = prx.items.buildFilter(targetId);
  $(targetId).css({
    '-webkit-filter': cssFilter,
    'filter': cssFilter
  });
};

prx.items.updateMask = function (item, containerid) {
  //this line can be removed when mask goes live
  if (item && item.hasOwnProperty("maskImage")) delete item.maskImage; //check if item has a mask

  if (!prx.mask.isActive(item)) return false;

  if (typeof containerid != 'undefined') {
    var itemid = containerid + '-' + item.id;
  } else {
    var itemid = item.id;
  }

  var $item = $("#" + itemid); //MASK-INNER

  var style = "width: " + item.mask.inner_width + "px; height: " + item.mask.inner_height + "px;";
  if (item.mask.borderPos == "inside") style += "margin:" + -item.mask.borderWidth + "px;";
  $item.addClass("mask-active").wrapInner('<div id="' + itemid + '-mask-inner" class = "mask-inner" style = "' + style + '"></div>'); //position the element using transformation matrix

  prx.items.updateMaskPosition(item, containerid); //MASK-WRAPER

  var classes = "mask-wrapper";
  if (item.mask.borderPos == "inside") classes += " borderPos-inside";else classes += " borderPos-outside";
  style = prx.mask.getBorderCss(item) + prx.mask.getBorderRadiusCss(item);
  if (item.mask.borderPos != "inside") style += "margin:" + -item.mask.borderWidth + "px;";
  $item.wrapInner('<div id="' + itemid + '-mask" class = "' + classes + '" style = "' + style + '"></div>');
};

prx.items.updateMaskPosition = function (item, containerid) {
  //check if item has a mask
  if (!prx.mask.isActive(item)) return false;

  if (typeof containerid != 'undefined') {
    var itemid = containerid + '-' + item.id;
  } else {
    var itemid = item.id;
  } //position the element using transformation matrix


  new TimelineMax().to('#' + itemid + '-mask-inner', 0, {
    x: item.mask.x,
    y: item.mask.y
  });
};

prx.items.updateVisibility = function (item, containerid) {
  var _item = '';

  if (typeof containerid != 'undefined') {
    var itemid = '#' + containerid + '-' + item.id;
  } else {
    var itemid = '#' + item.id;
  }

  _item = $(itemid);
  var itemVisibility = prx.visibility.get(itemid, 'visible-all');

  if (itemVisibility === false) {
    _item.css('opacity', 0);

    _item.addClass('hidden');
  } else {
    _item.removeClass('hidden');

    _item.css('opacity', itemVisibility);
  }

  _item = null;
};

prx.items.updatePosition = function (item, containerid, pageid) {
  var index = prx.stc.screens.getIndexFromId(pageid);
  var dims = prx.items.getRealDimsAndPos(item, 'pages', index, 0);
  var _item = '';

  if (typeof containerid != 'undefined') {
    _item = $('#' + containerid + '-' + item.id);
  } else {
    _item = $('#' + item.id);
  }

  prx.items.updateTransform(_item, item, dims[2], dims[3]);
};

prx.items.updateTransform = function ($item, item, left, top, rotation, scale) {
  if (rotation === undefined) rotation = item.rotation;
  if (scale === undefined) scale = item.scale; // left = 0;
  // top=0;
  // setTimeout(function($item){
  //    $item.css('top', '0').css('left', '0');
  // }, 0, $item);
  // immediateRender seems to wait for nextAnimationFrame to perform the first transition?
  // this is not what we want here where we call updateTransform before most animations to make sure that the position is up to date

  new TimelineMax().to('#' + $item.attr('id'), 0, Object.assign({}, prx.basicGreensockOptions, {
    immediateRender: true
  }, {
    x: left,
    y: top,
    rotation: rotation,
    scale: scale
  })); // if (typeof(item.draggable) != 'undefined' && item.draggable !== null && item.draggable.isdraggable) {
  //     new TimelineMax().to('#' + $item.attr('id'), 0, {x: left, y: top, rotation: item.rotation, scale: item.scale});
  // } else {
  //     $item.css('transform', 'translate(' + left + 'px, ' + top + 'px) scale(' + (item.scale || 1) + ') rotate(' + (item.rotation || 0) + 'deg)');
  // }
};

prx.items.getScale = function (item) {
  var scale = '';
  if (item.rscale !== undefined) scale = 'rscale-' + item.rscale;
  return scale;
};

prx.items.updateScale = function (item, containerid) {
  if (prx.v5x11) {
    return;
  }

  if (item.rscale !== undefined) {
    if (typeof containerid != 'undefined') {
      var $item = $('#' + containerid + '-' + item.id);
    } else {
      var $item = $('#' + item.id);
    }

    $item.addClass('rscale-' + item.rscale);
  }
};

prx.items.getGroups = function (item, containerid, symbolid, symbolstateid) {
  if (item.parentgroups === undefined) item.parentgroups = [];
  if (item.parentgroups.length == 0) return item.parentgroups;

  if (symbolid !== undefined && symbolstateid !== undefined) {
    var type = 'symbols';
    var typeid = symbolid;
    var stateid = symbolstateid;
  }

  var $parent = $('#' + containerid).not('.ghost-component'); // if not parent.length, it means parent is a container that it has never been attached to dom yet. initial dom rendering

  if ($parent.length) {
    var type = $parent.attr('data-role') === 'page' ? 'pages' : 'symbols';
    var typeid = $parent.attr(type === 'pages' ? 'data-id' : 'data-symbol-id');
    var stateid = $parent.attr('data-state-id');
  }

  for (var i = 0; i < prxy[type].length; i++) {
    if (prxy[type][i].id == typeid) {
      for (var y = 0; y < prxy[type][i].states.length; y++) {
        if (prxy[type][i].states[y].id == stateid) {
          var groups = prxy[type][i].states[y].groups;

          for (var gid in groups) {
            /*
            	annam (by request): change setd to set in the following lines,  (using setd does not make sense this was done by michalis)
            	this is a fix for some rare cases that visibility of groups was not working properly when rerendering from a different state we need to change the visibility (in complex implementations)
            	reference: "01 - Mediathek 4.0 Tablet" project id: 3cdc03de-17e9-44c3-8df1-568745ef36ed
             */
            prx.visibility.set('#' + containerid + ' .group-' + gid, 'visible', groups[gid].visible === false ? false : true);
            prx.visibility.set('#' + containerid + ' .group-' + gid, 'opacity', typeof groups[gid].opacity === 'undefined' ? 1 : parseFloat(groups[gid].opacity));
          }
        }
      }
    }
  }

  return item.parentgroups;
};

prx.items.updateGroups = function (item, containerid) {
  if (typeof containerid != 'undefined') {
    var $item = $('#' + containerid + '-' + item.id);
  } else {
    var $item = $('#' + item.id);
  }

  item.parentgroups = prx.items.getGroups(item, containerid);
  item.parentgroups.forEach(function (el) {
    $item.addClass('group-' + el);
  });
};

prx.items.updateComponentType = function (item, containerid) {
  if (typeof containerid != 'undefined') {
    var $item = $('#' + containerid + '-' + item.id);
  } else {
    var $item = $('#' + item.id);
  }

  $item.attr('data-component-type', item.type);
}; // prx.items.updateSymbolItemPosition = function (item, containerid, pageid, symbol, stateid) {
// 	//log("item position container id="+containerid);
//
// 	var _item = '';
// 	var targetId = '';
//
// 	if (typeof (containerid) != 'undefined') {
// 		_item = $('#' + containerid + '-' + item.id);
// 		targetId = '#' + containerid + '-' + item.id
// 	} else {
// 		_item = $('#' + item.id);
// 		targetId = '#' + item.id;
// 	}
//
// 	var stateindex = (stateid === undefined) ? 0 : prx.stc.containers.getStateIndexFromId(stateid, prx.stc.containers.getIndexFromId(symbol.symbolid));
//
// 	//log(pageid);
// 	//log("PAGEID IN UPDATE ITEM POSITION="+pageid);
//
// 	// STATES
// 	var _dims = prxy.symbols[prx.stc.containers.getIndexFromId(symbol.symbolid)].states[stateindex].dimensions;
//
// 	/* CHANGE TO MAKE SYMBOL ITEMS RESPOND TO VARIABLE WIDTH (v3) */
// 	//var _symbol_dims = getRealDims(symbol);
// 	//_dims = [_symbol_dims.width, _symbol_dims.height];
// 	/* /CHANGE TO MAKE SYMBOL ITEMS RESPOND TO VARIABLE WIDTH (v3) */
//
//
// 	var _page = prxy.pages[prx.stc.screens.getIndexFromId(pageid)];
// 	var _orientation = '';
// 	var _OrientationWidth = _dims[0];
// 	var _OrientationHeight = _dims[1];
//
// 	var _leftPos = item.left;
// 	var _topPos = item.top;
// 	var _x = item.left;
// 	var _y = item.top;
// 	var _wi = item.width;
// 	var _hi = item.height;
// 	var _width = item.width;
// 	var _height = item.height;
//
// 	if (item.width != 'full') {
// 		switch (item.wtype) {
// 			case "fixed":
// 				_width = _wi;
// 				break;
//
// 			case "variable":
// 				_width = _OrientationWidth - _wi;
// 				break;
// 		}
//
// 	} else {
// 		_width = _OrientationWidth;
// 	}
//
// 	if (item.height != 'full') {
// 		switch (item.htype) {
// 			case "fixed":
// 				_height = _hi;
// 				break;
//
// 			case "variable":
// 				_height = _OrientationHeight - _hi;
// 				break;
// 		}
// 	} else {
// 		_height = _OrientationHeight
// 	}
//
// 	switch (item.hpos) {
// 		case "left":
// 			_leftPos = _x;
// 			break;
//
// 		case "right":
// 			_leftPos = _OrientationWidth - _x - _width;
// 			break;
//
// 		case "center":
// 			_leftPos = (_OrientationWidth - _width) / 2;
// 			break;
// 	}
//
//
//
// 	switch (item.vpos) {
// 		case "top":
// 			_topPos = _y;
// 			break;
//
// 		case "bottom":
// 			_topPos = _OrientationHeight - _y - _height;
// 			break;
//
// 		case "middle":
// 			_topPos = (_OrientationHeight - _height) / 2;
// 			break;
// 	}
//
// 	_item.css({'height': _height + 'px', 'width': _width + 'px'});
// 	//TweenMax.set(targetId, {x: _leftPos, y: _topPos});
// 	prx.items.updateTransform(_item, item, _leftPos, _topPos);
//
// 	_item = null; // perf+
// }


prx.items.updateTemplateItemPosition = function (item, pageid) {
  var _id = '#' + item.id;

  var _page = prxy.pages[prx.stc.screens.getIndexFromId(pageid)];

  var _orientation = prx.orientation.getPage(_page);

  var _OrientationWidth = 0;
  var _OrientationHeight = 0;
  _OrientationWidth = prx.devices[prx.device][_orientation][0];
  _OrientationHeight = prx.devices[prx.device][_orientation][1];

  if (typeof _page.statusbar == "undefined") {
    _page.statusbar = prx.projectsettings.statusbar;
  }

  if (typeof _page.navigationbar == "undefined") {
    _page.navigationbar = prx.projectsettings.navigationbar;
  }

  if (_page.statusbar == "1") {
    //_OrientationWidth = prx.devices[prx.device]['statusbar'+_orientation][0];
    _OrientationHeight = _OrientationHeight - prx.devices[prx.device]["statusbarheight" + _orientation];
  }

  if (_page.navigationbar == "1") {
    _OrientationHeight = _OrientationHeight - prx.devices[prx.device]["navigationbarheight" + _orientation];
  }

  var _leftPos = item.left;
  var _topPos = item.top;
  var _x = item.left;
  var _y = item.top;
  var _wi = item.width;
  var _hi = item.height;
  var _width = item.width;
  var _height = item.height;

  if (item.width != 'full') {
    switch (item.wtype) {
      case "fixed":
        _width = _wi;
        break;

      case "variable":
        _width = _OrientationWidth - _wi;
        break;
    }

    item.width = _width;
  }

  if (item.height != 'full') {
    switch (item.htype) {
      case "fixed":
        _height = _hi;
        break;

      case "variable":
        _height = _OrientationHeight - _hi;
        break;
    }

    item.height = _height;
  }

  switch (item.hpos) {
    case "left":
      _leftPos = _x;
      break;

    case "right":
      _leftPos = _OrientationWidth - _x - _width;
      break;

    case "center":
      _leftPos = (_OrientationWidth - _width) / 2;
      break;
  }

  item.left = _leftPos;

  switch (item.vpos) {
    case "top":
      _topPos = _y;
      break;

    case "bottom":
      _topPos = _OrientationHeight - _y - _height;
      break;

    case "middle":
      _topPos = (_OrientationHeight - _height) / 2;
      break;
  }

  item.top = _topPos;
  return item;
};

prx.items.addAll = function (pageid, items) {
  var containerid = 'p-' + pageid;
  var cR = '';

  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    if (typeof item.hpos === 'undefined') item.hpos = 'left';
    if (typeof item.vpos === 'undefined') item.vpos = 'top';
    if (typeof item.wtype === 'undefined') item.wtype = 'fixed';
    if (typeof item.htype === 'undefined') item.htype = 'fixed';
    if (typeof item.opacity === 'undefined') item.opacity = '1';
    var tempitem = item;
    item = [item];

    if (typeof tempitem._fromstateid != "undefined") {
      cR += '<div id="' + containerid + '-' + tempitem.id + '" class="ghost-component" style="opacity: 0;"></div>';
      continue;
    }

    prx.visibility.set('#' + containerid + '-' + tempitem.id, 'visible', tempitem.visible === false ? false : true);
    prx.visibility.set('#' + containerid + '-' + tempitem.id, 'opacity', typeof tempitem.opacity === 'undefined' ? 1 : parseFloat(tempitem.opacity));

    if (typeof prx.types[tempitem.type] != 'undefined') {
      if (typeof prx.types[tempitem.type].onDisplay != 'undefined') {
        cR += prx.types[tempitem.type].onDisplay(tempitem, containerid);
      }
    }
  }

  document.getElementById(containerid).innerHTML = cR;

  for (var i = 0; i < items.length; i++) {
    if (typeof items[i]._fromstateid != "undefined") {
      continue;
    } // prx.items.updatePosition(items[i], containerid, pageid);
    // prx.items.updateRotation(items[i], containerid);


    prx.items.addRippleEffect(items[i], containerid);
    prx.items.updateMaskPosition(items[i], containerid);

    if (typeof prx.types[items[i].type] != 'undefined') {
      if (typeof prx.types[items[i].type].afterDisplay != 'undefined') {
        prx.types[items[i].type].afterDisplay(items[i], containerid);
      }
    }

    prx.draggable.ini(items[i], pageid);
  }
}; // not used anymore


prx.items.add = function (pageid, item) {
  var zIndex;

  if (!item.zindex) {
    item.zindex = zIndex + 1;
  }

  if (typeof item.hpos === 'undefined') item.hpos = 'left';
  if (typeof item.vpos === 'undefined') item.vpos = 'top';
  if (typeof item.wtype === 'undefined') item.wtype = 'fixed';
  if (typeof item.htype === 'undefined') item.htype = 'fixed';
  if (typeof item.opacity === 'undefined') item.opacity = '1';
  var tempitem = item;
  item = [item];

  var _containerid = 'p-' + pageid;

  prx.visibility.set('#' + _containerid + '-' + tempitem.id, 'visible', tempitem.visible === false ? false : true);
  prx.visibility.set('#' + _containerid + '-' + tempitem.id, 'opacity', typeof tempitem.opacity === 'undefined' ? 1 : parseFloat(tempitem.opacity));
  /* ANNAM NEW IN v5.11 - hopefully this will work - not adding items on canvas until they are needed! why should I? i'm rerendering them anw before displaying them! */
  // was previously after on display() call, before update visibility

  if (typeof tempitem._fromstateid != "undefined") {
    $('#p-' + pageid).append('<div id="' + _containerid + '-' + tempitem.id + '" class="ghost-component" style="opacity: 0;" />');
    return;
    tempitem.opacity = 0;
    $('#' + _containerid + '-' + tempitem.id).addClass('ghost-component');
  }

  if (typeof prx.types[tempitem.type] != 'undefined') {
    if (typeof prx.types[tempitem.type].onDisplay != 'undefined') {
      $('#p-' + pageid).append(prx.types[tempitem.type].onDisplay(tempitem, _containerid));
    }
  } // prx.items.updatePosition(tempitem, _containerid, pageid);
  // prx.items.updateRotation(tempitem, _containerid);


  prx.items.addRippleEffect(tempitem, _containerid);
  prx.items.updateMaskPosition(tempitem, _containerid);

  if (typeof prx.types[tempitem.type] != 'undefined') {
    if (typeof prx.types[tempitem.type].afterDisplay != 'undefined') {
      prx.types[tempitem.type].afterDisplay(tempitem, _containerid);
    }
  } //draggable


  prx.draggable.ini(tempitem, pageid);
};

prx.items.rerender = function (item, containerid, pageid) {
  //am,gy 12/02/16 tid(14402)
  if ($('#' + containerid + '-' + item.id).length == 0) {
    return;
  }

  if (typeof prx.types[item.type] != 'undefined') {
    if (typeof prx.types[item.type].onDisplay != 'undefined') {
      if (typeof item._fromstateid != "undefined") {
        item.opacity = 0;
      }

      var insymbol = false; // in symbol

      if (containerid.indexOf('box') > -1) {
        var split = containerid.split('box-');
        var attachedsymbolid = 'box-' + split[split.length - 1]; // my item is in a symbol. i need my symbolstate json to use later on. to find that, i need to find the symbol parent, find the symbol parent state id,
        // find in that canvas the symbol so that I can find the symbol ID. then, i can access the symbol contents and get the right state, again from the dom, to get the right state data.
        // get symbolparentstateid

        var symbolparentstateid = $('#' + containerid + '-' + item.id).parents('[data-state-id]').eq(1).attr('data-state-id');
        insymbol = true;

        if (typeof prx.allItems[attachedsymbolid].states != "undefined" && typeof prx.allItems[attachedsymbolid].states[symbolparentstateid] != "undefined") {
          // get symbol parent data.
          var data = JSON.parse(prxy[prx.allItems[attachedsymbolid].containertype][prx.allItems[attachedsymbolid].containerindex].states[prx.allItems[attachedsymbolid].states[symbolparentstateid].stateindex].data); // get symbol from parent

          if (typeof data.items != "undefined") {
            var symbol = data.items[prx.allItems[attachedsymbolid].itemindex];
          } else {
            var symbol = data[prx.allItems[attachedsymbolid].states[symbolparentstateid].itemindex];
          } // now i know my symbol id, i can go into the symbol data and get the state data.


          var symbolindex = prx.stc.containers.getIndexFromId(symbol.symbolid);

          if (prxy.symbols[symbolindex] !== undefined) {
            var symbolstateid = $('#' + containerid).attr('data-state-id');
            var stateindex = prx.stc.containers.getStateIndexFromId(symbolstateid, symbolindex);
            if (stateindex !== -1) var symbolstate = prxy.symbols[symbolindex].states[stateindex];
          }
        } // if a symbol is undefined, will an item ever get to be rerendered? if symbolstateid is deleted, perhaps. what will happen then?


        if (symbol === undefined || symbolstate === undefined) {
          return;
        }
      }

      prx.visibility.set('#' + containerid + '-' + item.id, 'visible', item.visible === false ? false : true);
      prx.visibility.set('#' + containerid + '-' + item.id, 'opacity', typeof item.opacity === 'undefined' ? 1 : parseFloat(item.opacity));
      if (insymbol) $('#' + containerid + '-' + item.id).replaceWith(prx.types[item.type].onDisplay(item, containerid, symbolstate));else $('#' + containerid + '-' + item.id).replaceWith(prx.types[item.type].onDisplay(item, containerid)); // prx.items.updateRotation(item, containerid);

      prx.items.addRippleEffect(item, containerid);
      prx.items.updateMaskPosition(item, containerid);

      if (pageid == -1) {
        pageid = containerid.split('-')[1];
      } // if (insymbol) {
      // 	prx.items.updateSymbolItemPosition(item, containerid, pageid, symbol, $('#' + containerid).attr('data-state-id'));
      // } else {
      // 	prx.items.updatePosition(item, containerid, pageid);
      // }


      if (typeof prx.types[item.type] != 'undefined') {
        if (typeof prx.types[item.type].afterDisplay != 'undefined') {
          if (insymbol) prx.types[item.type].afterDisplay(item, containerid, symbolstate);else prx.types[item.type].afterDisplay(item, containerid);
        }
      } //render item's mask


      prx.actions.parseItemAction(item, containerid, pageid);
      prx.draggable.ini(item, pageid, containerid);
      prx.draggable.refresh('#' + containerid + '-' + item.id);
    }
  }
};

prx.items.getRealDimsAndPos = function (item, parenttype, parentindex, parentstateindex, canvas) {
  // real [width,height,left,top]
  // var _OrientationDims = prx.stc.helper.getDims(parenttype, parentindex, parentstateindex);
  if (canvas) var _OrientationDims = prx.stc.helper.getDims(parenttype, void 0, void 0, canvas);else var _OrientationDims = prx.stc.helper.getDims(parenttype, parentindex, parentstateindex);
  var _width = item.width;
  var _height = item.height;
  var _left = item.left;
  var _top = item.top;

  if (item.wtype == 'variable') {
    _width = _OrientationDims[0] - _width;
  }

  if (item.htype == 'variable') {
    _height = _OrientationDims[1] - _height;
  }

  if (item.hpos == 'right') {
    _left = _OrientationDims[0] - _left - _width;
  }

  if (item.hpos == 'center') {
    _left = (_OrientationDims[0] - _width) / 2;
  }

  if (item.vpos == 'bottom') {
    _top = _OrientationDims[1] - _top - _height;
  }

  if (item.vpos == 'middle') {
    _top = (_OrientationDims[1] - _height) / 2;
  }

  return [parseInt(_width), parseInt(_height), parseInt(_left), parseInt(_top)];
};

prx.items.getRealDimsAndPosWithRotation = function (item, parenttype, parentindex, parentstateindex) {
  // real [width,height,left,top]
  var _dims = prx.items.getRealDimsAndPos(item, parenttype, parentindex, parentstateindex);

  if (typeof item.rotation == "undefined" || item.rotation == 0 || isNaN(parseFloat(item.rotation))) {
    // not is numeric
    return _dims;
  }

  var rw = _dims[0];
  var rh = _dims[1];
  var r = item.rotation * (Math.PI / 180); // radians

  var w = prx.items.getRotatedWidth(rw, rh, r);
  var h = prx.items.getRotatedHeight(rw, rh, r);
  var l = _dims[2] - Math.round((w - rw) / 2);
  var t = _dims[3] - Math.round((h - rh) / 2);
  return [parseInt(w), parseInt(h), parseInt(l), parseInt(t)]; // [width,height,left,top]
};

prx.items.getRotatedWidth = function (width, height, rotation) {
  return Math.abs(width * Math.cos(rotation)) + Math.abs(height * Math.sin(rotation));
};

prx.items.getRotatedHeight = function (width, height, rotation) {
  return Math.abs(width * Math.sin(rotation)) + Math.abs(height * Math.cos(rotation));
};

prx.items.addToAllItemsStruct = function (item, cCanvasType, iCanvasIndex, cStateId, iStateIndex, iItemIndex) {
  if (typeof prx.allItems[item.id] == "undefined") {
    prx.allItems[item.id] = {
      containertype: cCanvasType,
      containerindex: iCanvasIndex,
      states: {}
    };
  }

  prx.allItems[item.id].states[cStateId] = {
    stateindex: iStateIndex,
    itemindex: iItemIndex
  };
};

prx.items.getFromAllItemStruct = function (itemid, stateid) {
  // the prx.allItems struct is not always correct. it sometimes contains wrong data if two different screens/containers have items with the same ids (one prx.allitems[] entry has stateids from two different canvases)
  if (prx.allItems[itemid] === undefined || prxy[prx.allItems[itemid].containertype][prx.allItems[itemid].containerindex] === undefined || prx.allItems[itemid].states[stateid] === undefined || prxy[prx.allItems[itemid].containertype][prx.allItems[itemid].containerindex].states[prx.allItems[itemid].states[stateid].stateindex] === undefined) {
    return false;
  }

  var data = JSON.parse(prxy[prx.allItems[itemid].containertype][prx.allItems[itemid].containerindex].states[prx.allItems[itemid].states[stateid].stateindex].data); // again. maybe prx.allitems has the wrong data.

  if (data[prx.allItems[itemid].states[stateid].itemindex] === undefined || data[prx.allItems[itemid].states[stateid].itemindex].id !== itemid) return false;
  return data[prx.allItems[itemid].states[stateid].itemindex];
};

prx.items.recursivelyFindItemSymbolId = function (itemid, type, index) {
  //var split = ('-' + itemid).split('-box-');
  //split.splice(0,1);
  // v5.8.3 remove p-id from itemid. this is only needed if we use action.targetId instead of action.itemId
  // in the original prx.items.recursivelyFindItemSymbolId() in stopstatetransition()
  // which i decided against. however if you send action.targetId it should work.
  itemid = itemid.replace(/#p-[0-9]+-/, '');
  var singleitemid = itemid.split('-box-')[0];
  var items = prx.items.helper.getAllItems(type, index);

  for (var i = 0; i < items.length; i++) {
    if (items[i].id == singleitemid) {
      if (itemid == singleitemid) {
        if (typeof items[i].symbolid == "undefined") {
          return false;
        }

        return items[i].symbolid;
      } else {
        itemid = itemid.substr((singleitemid + '-').length);

        if (prx.stc.containers.getIndexFromId(items[i].symbolid) == -1) {
          return false;
        }

        return prx.items.recursivelyFindItemSymbolId(itemid, 'symbols', prx.stc.containers.getIndexFromId(items[i].symbolid));
      }
    }
  } // v5.8.3 if we reach here it means that we didnt find the item.
  // but maybe we don't have the complete item id in variable itemid, eg if we are in current container
  // so start looking into containers of screen (or container for that matter) and go at it recursively.
  // this will work exactly the same as passing the action.targetId instead of passing the action.itemId
  // however using this method we will be looking into more containers other then the current container one.
  // it will actually find the first container in screen which has the container we are looking for attached.
  // of course i dont think this matters because all we are looking for is the symbolid which will be the same everywhere
  // so i think i will use this after all because i think its risky to use the action.targetId instead of the action.itemId


  for (var i = 0; i < items.length; i++) {
    if (items[i].type == 'symbol') {
      if (prx.stc.containers.getIndexFromId(items[i].symbolid) == -1) {
        return false;
      }

      var found = prx.items.recursivelyFindItemSymbolId(itemid, 'symbols', prx.stc.containers.getIndexFromId(items[i].symbolid));

      if (typeof found != "undefined") {
        return found;
      } // if not continue looking through original containers.

    }
  }
};

prx.items.addRippleEffect = function (item, containerid) {
  if (typeof item.rippleEffect != "undefined" && item.rippleEffect) {
    if (typeof containerid != 'undefined') {
      var _itemid = '#' + containerid + '-' + item.id;
    } else {
      var _itemid = '#' + item.id;
    }

    if ($(_itemid).find('.prx-material-ripple').length > 0) {
      _itemid += ' .prx-material-ripple';
    }

    var $roundoverflow = $(_itemid).find('.prx-material-ripple-roundoverflow');

    if ($roundoverflow.length > 0) {
      $roundoverflow.addClass('waves-effect waves-circle');
    } else {
      $(_itemid).addClass('waves-effect waves-circle');
    }

    $(_itemid).append('<style>' + _itemid + ' .waves-ripple { background-color: ' + prx.gradients.prxToCss(item.rippleEffectColor) + '; }' + '</style>'); // j

    Waves.displayEffect({
      itemid: _itemid,
      duration: 1000
    });
  }
};

prx.items.getRealDimsAndPosFromDom = function (fullitemid) {
  var item = $(fullitemid);
  if (item.length == 0) return {
    top: 0,
    left: 0,
    width: 0,
    height: 0,
    rotation: 0
  };
  var dims = {
    width: item.width(),
    height: item.height(),
    top: item.position().top,
    left: item.position().left,
    rotation: 0
  };
  var transform = item.get(0).style.msTransform || item.get(0).style.transform || item.get(0).style.WebkitTransform; // if transform is "", i have never applied any animation with greensock so the item is in its original position.
  // even if the item is hidden, the getter above will get the style if it exists.

  if (transform === "" || transform === undefined) {
    // it could be that getRealDimsAndPosFromItem() returns false if the data is corrupted
    return prx.items.getRealDimsAndPosFromItem(fullitemid) || dims;
  } // match numbers possibly negative and possibly floats


  var numbers = transform.match(/-?\d+\.?\d*/g);

  if (transform.match(/matrix\s?\(/)) {
    var a = parseFloat(numbers[0]);
    var b = parseFloat(numbers[1]);
    dims.rotation = Math.round(Math.atan2(b, a) * (180 / Math.PI));
    dims.left = parseFloat(numbers[4]);
    dims.top = parseFloat(numbers[5]);
  } else if (transform.match(/matrix3[dD]\s?\(/)) {
    numbers.shift(); // shift the 3 from the 3d

    var a = parseFloat(numbers[0]);
    var b = parseFloat(numbers[1]);
    dims.rotation = Math.round(Math.atan2(b, a) * (180 / Math.PI));
    dims.left = parseFloat(numbers[12]);
    dims.top = parseFloat(numbers[13]);
  } else {
    if (transform.match(/translate\s?\(/)) {
      dims.left = parseFloat(numbers[0]);
      dims.top = parseFloat(numbers[1]);
    } else if (transform.match(/translate3[dD]\s?\(/)) {
      numbers.shift(); // shift the 3 from the 3d

      dims.left = parseFloat(numbers[0]);
      dims.top = parseFloat(numbers[1]);
    }

    if (numbers = transform.match(/rotate\s?\(/)) {
      dims.rotation = parseFloat(numbers[0]);
    }
  }

  return dims;
};

prx.items.getRealDimsAndPosFromItem = function (fullitemid) {
  var regex = fullitemid.match(/box-[0-9]+$/);

  if (!regex) {
    return false;
  }

  var itemid = regex[0];
  var stateid = $(fullitemid).parents('[data-state-id]').first().attr('data-state-id');
  var item = prx.items.getFromAllItemStruct(itemid, stateid); // error in data, item not found

  if (item === false) return false;
  var realdims;

  if (prx.allItems[itemid].containertype === 'pages') {
    realdims = prx.items.getRealDimsAndPos(item, 'pages', prx.allItems[itemid].containerindex, prx.allItems[itemid].states[stateid].stateindex);
  } else {
    realdims = prx.items.getRealDimsAndPos(item, 'symbols', prx.allItems[itemid].containerindex, prx.allItems[itemid].states[stateid].stateindex);
  }

  return {
    width: realdims[0],
    height: realdims[1],
    left: realdims[2],
    top: realdims[3],
    rotation: item.rotation
  };
};

prx.items.updateTransformIfHidden = function (fullitemid, stateid) {
  var ishidden = prx.visibility.get(fullitemid, 'visible-in-dom', void 0, stateid) === false;
  if (!ishidden) return;
  var dims = prx.items.getRealDimsAndPosFromDom(fullitemid);
  prx.items.updateTransform($(fullitemid), {}, dims.left, dims.top, dims.rotation, 1);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/items/items.js":
/*!*********************************************************!*\
  !*** ./sass/player-engine/js/components/items/items.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.items = {};

/***/ }),

/***/ "./sass/player-engine/js/components/stc/_containers.js":
/*!*************************************************************!*\
  !*** ./sass/player-engine/js/components/stc/_containers.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.stc.containers = {};

prx.stc.containers.getIndexFromId = function (id) {
  var rIndex = -1;

  for (var n = 0; n < prxy.symbols.length; n++) {
    if (prxy.symbols[n].id == id) {
      rIndex = n;
    }
  }

  return rIndex;
};

prx.stc.containers.render = function (item, containerid, stateindex) {
  var _cR = '';
  var pageid;

  if (typeof stateindex == "undefined") {
    stateindex = 0;
  } //if (prx.save != "true") {
  //log('*** RENDER SYMBOL');


  var index = prx.stc.containers.getIndexFromId(item.symbolid);
  var _containerid = ''; // ANNAM v5
  // I cant find a rendersymbol() with pageid.

  /*
   if (typeof(containerid)=='undefined') {
   _containerid = 'p-'+pageid+'-';
   } else {
   if (containerid.length==0){
   containerid = 'p-'+pageid+'-';
   } else {
   containerid = containerid+'-';
   }
   _containerid = containerid + item.id;
   }
   */

  _containerid = containerid + '-' + item.id;
  var _symbol_width = "100%";
  var _symbol_height = "100%";

  if (item.scroll != '' && item.scroll != 'none') {
    // STATES
    if (item.scroll == 'horizontal' || item.scroll == 'omni') {
      _symbol_width = prxy.symbols[index].states[stateindex].dimensions[0] + 'px';
    }

    if (item.scroll == 'vertical' || item.scroll == 'omni') {
      _symbol_height = prxy.symbols[index].states[stateindex].dimensions[1] + 'px';
    }
  }

  if (index > -1) {
    var _items = prx.stc.containers.getAllItems(index, stateindex);

    for (var n = 0; n < _items.length; n++) {
      var tempitem = _items[n];
      prx.visibility.set('#' + _containerid + '-' + tempitem.id, 'visible', tempitem.visible === false ? false : true);
      prx.visibility.set('#' + _containerid + '-' + tempitem.id, 'opacity', typeof tempitem.opacity === 'undefined' ? 1 : parseFloat(tempitem.opacity));

      if (typeof tempitem._fromstateid != "undefined") {
        // annam v5.11
        _cR += '<div id="' + _containerid + '-' + tempitem.id + '" class="ghost-component" style="opacity: 0;"></div>';
        continue;
        tempitem.opacity = 0;
      } //if (prx.save == "true") {


      if (typeof prx.types[tempitem.type] != 'undefined') {
        _cR = _cR + prx.types[tempitem.type].onDisplay(tempitem, _containerid, prxy.symbols[index].states[stateindex]);
      } //}

    }
  } //_cR = _cR + '</div>';
  //}


  return _cR;
};

prx.stc.containers.getStateIndexFromId = function (id, index) {
  return prx.stc.helper.getStateIndexFromId(id, 'symbols', index);
};

prx.stc.containers.loadRecursiveAfterDisplay = function (item, containerid, stateindex) {
  if (typeof stateindex == "undefined") {
    stateindex = 0;
  } //log('*** LOAD RECURSIVE SYMBOL AFTER DISPLAY');
  //prx.types[tempitem.type].afterDisplay(templateid, pageid);


  var index = prx.stc.containers.getIndexFromId(item.symbolid);
  var _containerid = ''; //log('====================================='+item.scroll);

  if (typeof item.scrollsnap == 'undefined') {
    item.scrollsnap = false;
  }

  _containerid = containerid + '-' + item.id;

  var pageid = _containerid.match(/p-(\d+)-.+/)[1];

  if (index > -1) {
    // TODO STATES merge all states components into first
    var _items = prx.stc.containers.getAllItems(index, stateindex);

    for (var n = 0; n < _items.length; n++) {
      var tempitem = _items[n];

      if (typeof tempitem._fromstateid != "undefined") {
        continue;
      } //prx.items.updateSymbolItemPosition(tempitem, _containerid, pageid, item);
      // prx.items.updateRotation(tempitem, _containerid);


      prx.items.addRippleEffect(tempitem, _containerid);
      prx.items.updateMaskPosition(tempitem, _containerid);

      if (typeof prx.types[tempitem.type] != 'undefined') {
        if (typeof prx.types[tempitem.type].afterDisplay != 'undefined') {
          prx.types[tempitem.type].afterDisplay(tempitem, _containerid, prxy.symbols[index].states[stateindex]);
        }
      } // draggable


      prx.draggable.ini(tempitem, pageid, _containerid);
      prx.actions.parseItemAction(tempitem, _containerid, pageid, '', true);
    }

    for (var j = 0; j < prxy.symbols[index].states.length; j++) {
      prx.actions.parseContainerStateAction(index, j, pageid, _containerid, item.id);
    }

    prx.actions.loadGroupActions(prxy.symbols[index].states[stateindex], "symbol", pageid, _containerid);
    prx.scrollable.iniContainer(item, _containerid); // now used in rerender item, to needs to be outside of page show.
  }

  return true;
};

prx.stc.containers.getAllItems = function (index, stateindex) {
  return prx.items.helper.getAllItems('symbols', index, stateindex);
};

/***/ }),

/***/ "./sass/player-engine/js/components/stc/_screens.js":
/*!**********************************************************!*\
  !*** ./sass/player-engine/js/components/stc/_screens.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

prx.stc.screens = {};

prx.stc.screens.getIndexFromId = function (id) {
  var rIndex = -1;

  for (var n = 0; n < prxy.pages.length; n++) {
    if (prxy.pages[n].id == id) {
      rIndex = n;
    }
  }

  return rIndex;
};

prx.stc.screens.getStructFromId = function (pageid) {
  var _id = prx.items.helper.getPageIdFromId(pageid);

  return prxy.pages[prx.stc.screens.getIndexFromId(_id)];
};

prx.stc.screens.getStateIndexFromId = function (id, index) {
  return prx.stc.helper.getStateIndexFromId(id, 'pages', index);
};

prx.stc.screens.getAllItems = function (index, stateindex) {
  return prx.items.helper.getAllItems('pages', index, stateindex);
};

prx.stc.screens.reloadResponsive = function (_page, orientation) {
  if (typeof orientation == "undefined") {
    orientation = prx.orientation.get();
  }

  _page.orientation = orientation;
  prx.stc.screens.load(_page);
  prx.draggable.refresh('#p-' + _page.id);
};

prx.stc.screens.load = function (_page) {
  var _data = prx.stc.screens.getAllItems(prx.stc.screens.getIndexFromId(_page.id));

  var _orientation = prx.orientation.getPage(_page);

  var _OrientationWidth = prx.devices[prx.device][_orientation][0];
  var _OrientationHeight = prx.devices[prx.device][_orientation][1];
  var _actualPageHeight = _OrientationHeight;
  $('#dragarea').width(_OrientationWidth);

  var _currentPage = $('#p-' + _page.id).attr('data-state-id', _page.states[0].id);

  _currentPage.width(_OrientationWidth);

  _currentPage.css('height', _OrientationHeight + 'px');

  _currentPage.unbind('pageshow').bind('pageshow', function (event, ui) {
    _currentPage.height(_OrientationHeight);

    $('.remove-on-pageshow').removeClass('remove-on-pageshow');
    prx.scrollable.refresh('#p-' + _page.id);
    prx.draggable.refresh('#p-' + _page.id);
    prx.vr.refresh('#p-' + _page.id);
    $('#overlay').empty().hide();
    $('#underlay').empty().hide();
    return false;
  });

  if (_page.navigationbar == 'undefined') {
    _page.navigationbar = "0";
  }
  /* STATUSBAR */


  prx.canvas._statusbars[_page.id] = {};
  prx.canvas._statusbars[_page.id].statusbar = _page.statusbar;
  prx.canvas._statusbars[_page.id].orientation = _orientation;

  var _deviceOrientation = $(window).width() < $(window).height() ? "portrait" : "landscape";
  /* NAVIGATIONBAR */


  if (typeof _page.navigationbar == 'undefined') {
    _page.navigationbar = '0';
  }

  prx.canvas._navigationbars[_page.id] = {};
  prx.canvas._navigationbars[_page.id].navigationbar = _page.navigationbar;
  prx.canvas._navigationbars[_page.id].orientation = _orientation;

  if (_page.orientation == _deviceOrientation) {
    var _startscreen = _deviceOrientation == "portrait" ? prx.project.startscreen : prx.project.startscreenlandscape;

    if (_page.statusbar == "1") {
      if (prx.allowstatusbar) {
        try {
          if (_startscreen == _page.id) {
            if (prx.export2html != '1') {
              $('#statusbar').css({
                'background-image': prx.statusNavBar.buildStatusbar(_orientation)
              });
            } else {
              if (prx.projectsettings.statusbarapplies == '1') {
                $('#statusbar').css('background-image', 'url(./images/statusbar_' + _orientation + '.png)');
              } else {
                $('#statusbar').css('background-image', 'none');
              }
            }

            $('#statusbar').css('height', prx.devices[prx.device]['statusbarheight' + _orientation] + 'px');
          }

          _currentPage.css('top', prx.devices[prx.device]['statusbarheight' + _orientation] + 'px');
        } catch (err) {}

        ;
      }

      _actualPageHeight = _actualPageHeight - prx.devices[prx.device]['statusbarheight' + _orientation];
    }

    if (_page.navigationbar == "1") {
      if (prx.allownavigationbar) {
        try {
          if (_startscreen === _page.id) {
            if (prx.export2html != '1') {
              //$('#navigationbar').css('background-image', 'url('+prx.url['static']+'/images/player/'+prx.device+'/'+_orientation+'/navigationbar_'+prx.devices[prx.device][_orientation][0]+'.png)');
              $("#navigationbar").css({
                'background-image': prx.statusNavBar.buildNavbar(_orientation)
              });
            } else {
              if (prx.projectsettings.navigationbarapplies == '1') {
                $('#navigationbar').css('background-image', 'url(./images/navigationbar_' + _orientation + '.png)');
              } else {
                $('#statusbar').css('background-image', 'none');
              }
            }
          }

          $('#navigationbar').css('height', prx.devices[prx.device]['navigationbarheight' + _orientation] + 'px');
          $('#navigationbar').css('top', prx.devices[prx.device][_orientation][1] - prx.devices[prx.device]['navigationbarheight' + _orientation] + 'px');
        } catch (err) {}

        ;
      }

      _actualPageHeight = _actualPageHeight - prx.devices[prx.device]['navigationbarheight' + _orientation];
    }
  }

  $('#dragarea').height(_actualPageHeight);
  /* PAGE BACKGROUND */

  if (typeof _page.states[0].background == "undefined") {
    _page.states[0].background = "none";
  }

  if (_page.states[0].background != "none") {
    var background = _page.states[0].background;

    if (_typeof(background) === 'object') {
      background = prx.gradients.prxToCss(background);
    } else {
      if (/^([0-9a-f]{3}|[0-9a-f]{6})$/i.test(background.trim())) {
        background = prx.gradients.toRgba('#' + background, 1);
      }
    }

    _currentPage.css(prx.gradients.getBgCssPropertyByValue(background), background);
  }
  /* LOAD TEMPLATE */


  if (("" + _page.states[0].template.id).length > 0) {
    var index = prx.stc.templates.getIndexFromId(_page.states[0].template.id);
    var stateindex = prx.stc.templates.getStateIndexFromId(_page.states[0].template.stateid, index);

    if (index > -1 && stateindex > -1) {
      var containerid = '';

      var _cTemplate = prx.stc.templates.render(_page.states[0].template.id, containerid, _page.id, _page.states[0].template.stateid); // ANNAM v4.2.4 , removed overflow:hidden for move screen


      _currentPage.append('<div id="p-' + _page.id + '-template" style="position: absolute; left: 0px; top: 0px; background: none; width: ' + _OrientationWidth + 'px; height: ' + _actualPageHeight + 'px;">' + _cTemplate + '</div>');

      _cTemplate = null; // perf+
      // if no background on page and background on template, use template background

      if (typeof prx.templates[index].states[stateindex].background == "undefined") {
        prx.templates[index].states[stateindex].background = "none";
      }

      if (_page.background == "none" && prx.templates[index].states[stateindex].background != "none") {
        _currentPage.css('background-color', prx.utils.getColor(prx.templates[index].states[stateindex].background));
      }
      /* ADDED THIS FOR AFTERDISPLAY FUNCTION CALLS */


      var _dataFromTemplate = JSON.parse(prx.templates[index].states[stateindex].data);

      var _items = _dataFromTemplate;
      var _templateid = prx.templates[index].states[stateindex].template.id;
      prx.stc.templates.loadRecursiveAfterDisplay(_page.states[0].template, containerid, _page.id);
      _dataFromTemplate = null; // perf+

      _items = null; // perf+
    } else {
      // template was deleted
      _data.templateid = ''; // clear template settings
    }
  }

  prx.items.addAll(_page.id, _data);
  prx.actions.loadScreenActions(_page.id);
  prx.stc.templates.loadRecursiveEvents(_page.states[0].template, _page.id); // prx.bodymovinAnimation.loadBodymovinPageAnimations('#p-' + _page.id);

  $('#p-' + _page.id).trigger('pagebeforecreate');
  $('#p-' + _page.id).trigger('pagecreate');
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/stc/_stc-helper.js":
/*!*************************************************************!*\
  !*** ./sass/player-engine/js/components/stc/_stc-helper.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.stc.helper = {};

prx.stc.helper.getStateIndexFromId = function (id, type, index) {
  if (typeof type == "undefined" || typeof index == "undefined" || index == -1) {
    return -1;
  }

  if (typeof prxy[type][index] == "undefined") {
    return -1;
  }

  for (var i = 0; i < prxy[type][index].states.length; i++) {
    if (prxy[type][index].states[i].id == id) {
      return i;
    }
  }

  return -1;
};

prx.stc.helper.getDims = function (type, index, stateindex, canvas) {
  if (stateindex == -1) {
    return false;
  }

  switch (type) {
    case "symbols":
      if (canvas !== undefined) {
        return [canvas.dimensions[0], canvas.dimensions[1]];
      }

      return [prxy[type][index].states[stateindex].dimensions[0], prxy[type][index].states[stateindex].dimensions[1]];
      break;

    default:
      var _orientation = prxy[type][index].orientation;
      var _OrientationWidth = 0;
      var _statusbarHeight = 0;
      var _statusbar = 0;
      var _navigationbarHeight = 0;
      var _navigationbar = 0;

      if (prx.projectsettings.statusbarapplies && prxy[type][index].statusbar == "1") {
        _statusbar = 1;
        _statusbarHeight = prx.devices[prx.device]['statusbarheight' + _orientation];
      }

      if (prx.projectsettings.navigationbarapplies && prxy[type][index].navigationbar == "1") {
        _navigationbar = 1;
        _navigationbarHeight = prx.devices[prx.device]['navigationbarheight' + _orientation];
      }

      var _deadheight = parseInt(_statusbar) * prx.devices[prx.device]['statusbarheight' + _orientation] + parseInt(_navigationbar) * prx.devices[prx.device]['navigationbarheight' + _orientation];

      var _OrientationWidth = prx.devices[prx.device]['normal' + _orientation][0];

      var _OrientationHeight = prx.devices[prx.device]['normal' + _orientation][1] - _deadheight;

      return [_OrientationWidth, _OrientationHeight];
      break;
  }
};

prx.stc.helper.getIndexFromId = function (id, type) {
  if (typeof type == 'undefined') type = prx.stc.helper.getType();

  for (var i = 0; i < prxy[type].length; i++) {
    if (prxy[type][i].id == id) return i;
  }

  return -1;
};

/***/ }),

/***/ "./sass/player-engine/js/components/stc/_templates.js":
/*!************************************************************!*\
  !*** ./sass/player-engine/js/components/stc/_templates.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {prx.stc.templates = {};

prx.stc.templates.render = function (templateid, containerid, pageid, stateid) {
  var index = prx.stc.templates.getIndexFromId(templateid);
  var stateindex = 0;

  if (typeof stateid == "undefined") {
    stateid = prx.templates[index].states[0].id;
  }

  stateindex = prx.stc.templates.getStateIndexFromId(stateid, index);
  var _cR = '';
  var _containerid = '';

  if (typeof containerid == 'undefined') {
    containerid = 'p-' + pageid + '-';
  } else {
    if (containerid.length == 0) {
      containerid = 'p-' + pageid + '-';
    } else {
      containerid = containerid + '-';
    }

    _containerid = containerid + 't' + templateid;
  }

  _cR = '<div id="' + _containerid + '" data-state-id=' + stateid + '>';

  if (index > -1 && stateindex > -1) {
    //var _tempdata = JSON.parse(prx.templates[index].states[stateindex].data);
    var _tempdata = prx.stc.templates.getAllItems(index, stateindex);

    var _items = _tempdata;
    var _templateid = prx.templates[index].states[stateindex].template.id;

    if (_templateid != undefined) {
      if (eval(_templateid) > -1) {
        _cR = _cR + prx.stc.templates.render(_templateid, _containerid, pageid, prx.templates[index].states[stateindex].template.stateid);
      }
    }

    for (var n = 0; n < _items.length; n++) {
      var tempitem = _items[n];

      if (typeof tempitem._fromstateid != "undefined") {
        // annam v5.11
        _cR += '<div id="' + _containerid + '-' + tempitem.id + '" class="ghost-component" style="opacity: 0;" />';
        continue;
        tempitem.opacity = 0;
        $('#' + _containerid + '-' + tempitem.id).addClass('ghost-component');
      }

      if (typeof prx.types[tempitem.type] != 'undefined') {
        if (typeof prx.types[tempitem.type].onDisplayTemplate != 'undefined') {
          //tempitem = prx.items.updateTemplateItemPosition(tempitem,pageid);
          _cR = _cR + prx.types[tempitem.type].onDisplayTemplate(tempitem, _containerid);
        } else {
          _cR = _cR + prx.types[tempitem.type].onDisplay(tempitem, _containerid);
        }
      }
    }
  }

  _cR = _cR + '</div>';
  return _cR;
};

prx.stc.templates.loadRecursiveEvents = function (template, pageid, containerid) {
  //log('*** LOAD RECURSIVE TEMPLATE EVENTS, TEMPLATEID = '+ templateid);
  if (typeof containerid == "undefined") {
    containerid = '';
  }

  prx.actions.loadTemplateActions(template, pageid, containerid);
  var index = prx.stc.templates.getIndexFromId(template.id);
  var stateindex = prx.stc.templates.getStateIndexFromId(template.stateid, index);

  if (index > -1 && stateindex > -1) {
    var _tempdata = JSON.parse(prx.templates[index].states[stateindex].data);

    var _templateid = prx.templates[index].states[stateindex].template.id;

    if (_templateid != undefined) {
      if (eval(_templateid) > -1) {
        if (containerid.length == 0) {
          containerid = 't' + template.id;
        } else {
          containerid += '-t' + template.id;
        }

        prx.stc.templates.loadRecursiveEvents(prx.templates[index].states[stateindex].template, pageid, containerid);
      }
    }

    _tempdata = null; // perf+
  }

  return true;
};

prx.stc.templates.loadRecursiveAfterDisplay = function (template, containerid, pageid) {
  //log('*** LOAD RECURSIVE TEMPLATE AFTER DISPLAY');
  var index = prx.stc.templates.getIndexFromId(template.id);
  var stateindex = prx.stc.templates.getStateIndexFromId(template.stateid, index);
  var templateid = template.id;
  var _containerid = '';

  if (typeof containerid == 'undefined') {
    containerid = 'p-' + pageid + '-';
  } else {
    if (containerid.length == 0) {
      containerid = 'p-' + pageid + '-';
    } else {
      containerid = containerid + '-';
    }

    _containerid = containerid + 't' + templateid;
  }

  if (index > -1 && stateindex > -1) {
    // this doesnt loop ALL items, ie those who are not in the default state, but perhaps that's ok because they are being rerendered anw?
    // it was not ok after all :)
    var _tempdata = prx.stc.templates.getAllItems(index, stateindex); //JSON.parse(prx.templates[index].states[stateindex].data);


    var _template = prx.templates[index].states[stateindex].template;
    var _items = _tempdata;

    for (var n = 0; n < _items.length; n++) {
      var tempitem = _items[n];

      if (typeof tempitem._fromstateid != "undefined") {
        // annam v5.11
        continue;
        tempitem.opacity = 0;
        $('#' + _containerid + '-' + tempitem.id).addClass('ghost-component');
      }

      prx.visibility.set('#' + _containerid + '-' + tempitem.id, 'visible', tempitem.visible === false ? false : true);
      prx.visibility.set('#' + _containerid + '-' + tempitem.id, 'opacity', typeof tempitem.opacity === 'undefined' ? 1 : tempitem.opacity);
      prx.items.updateGroups(tempitem, _containerid);
      prx.items.updateVisibility(tempitem, _containerid); // prx.items.updatePosition(tempitem, _containerid, pageid);
      // prx.items.updateRotation(tempitem, _containerid);

      prx.items.updateFilter(tempitem, _containerid);
      prx.items.updateScale(tempitem, _containerid);
      prx.items.addRippleEffect(tempitem, _containerid);
      prx.items.updateComponentType(tempitem, _containerid);

      if (typeof prx.types[tempitem.type] != 'undefined') {
        if (typeof prx.types[tempitem.type].afterDisplay != 'undefined') {
          prx.types[tempitem.type].afterDisplay(tempitem, _containerid, pageid);
        }
      }

      prx.draggable.ini(tempitem, pageid, _containerid);
      /* ANNAM v3.0.5 removing this as duplicate actions were binded on template items, one of which was binded on wrong item id so it didnt work anw */
      //prx.actions.parseItemAction(tempitem,_containerid,pageid,_templateid);
    }
    /* PAGE BACKGROUND */


    if (typeof prx.templates[index].states[stateindex].background == "undefined") {
      prx.templates[index].states[stateindex].background = "none";
    }

    if (($('#p-' + pageid).css('background-color') == "transparent" || $('#p-' + pageid).css('background-color') == "rgba(0, 0, 0, 0)") && prx.templates[index].states[stateindex].background != "none") {
      $('#p-' + pageid).css('background-color', prx.utils.getColor(prx.templates[index].states[stateindex].background));
    }

    if (_template.id != undefined) {
      if (eval(_template.id) > -1) {
        prx.stc.templates.loadRecursiveAfterDisplay(_template, _containerid, pageid);
      }
    }

    _tempdata = null; // perf+

    _items = null; // perf+
  }

  return true;
};

prx.stc.templates.getIndexFromId = function (id) {
  var rIndex = -1;

  for (var n = 0; n < prx.templates.length; n++) {
    if (prx.templates[n].id == id) {
      rIndex = n;
    }
  }

  return rIndex;
};

prx.stc.templates.getStateIndexFromId = function (id, index) {
  return prx.stc.helper.getStateIndexFromId(id, 'templates', index);
};

prx.stc.templates.getAllItems = function (index, stateindex) {
  return prx.items.helper.getAllItems('templates', index, stateindex);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/components/stc/stc.js":
/*!*****************************************************!*\
  !*** ./sass/player-engine/js/components/stc/stc.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.stc = {};

/***/ }),

/***/ "./sass/player-engine/js/player-engine-development-min.js":
/*!****************************************************************!*\
  !*** ./sass/player-engine/js/player-engine-development-min.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {var prx = window.prx || {};
prx.editor = false;
prx.project = {};
prxy.pages = [];
prxy.symbols = [];
prx.templates = [];
prx.allItems = {};
prx.types = {};
prx.devices = {};
prx.components = {};
prx.url = {};
prx.greensockForce3D = true; // prx.greensockForce3D = false;

prx.basicGreensockOptions = {
  force3D: prx.greensockForce3D,
  immediateRender: false
};
prx._imgs_version = 0;
prx.dynamicprops = ['listitems', 'buttons', 'options', 'tabs'];
prx.spaces = false;
prx.embed = false;
prx.export2html = false;
prx.prto = false;
prx.device = 'default';
prx.user = {};
prx.user.loggedin = false;
prx.user.editor_access = false;
prx.projectsettings = {};
prx.projectsettings.v = 0;
prx.projectsettings.initialpageid = -1;
prx.projectsettings.flashactions = 1;
$(document).ready(function () {
  prx.iniPlayer.iniDocumentLoad();
  prx.debug.ini();
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./sass/player-engine/js/player-engine-export-min.js":
/*!***********************************************************!*\
  !*** ./sass/player-engine/js/player-engine-export-min.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.componentsHelper.getAssetUrl = function (asset) {
  var url;

  if (typeof asset.targetSrc != "undefined") {
    url = './assets/' + asset.targetSrc;
  } else if (asset.isFont === true) {
    url = "./assets/fonts/custom-font-".concat(asset.fileId, ".").concat(asset.extension);
  } else if (typeof asset.targetSrc == "undefined" && asset.fileId.substring(asset.fileId.lastIndexOf('.') + 1) == "svg" && typeof asset.color != "undefined") {
    url = './assets/generated/' + asset.fileId.slice(0, -4) + "_" + asset.color.toLowerCase() + ".svg";
  } else if (prx.dropboxfs && asset.bucketsource != "static") {
    url = './assets/' + asset.fileId;
  } else {
    url = './assets/' + asset.url;
  } //linked assets


  if (asset.assetType == "project") {
    if (prx.spaces) {
      if (typeof sLinkedAssets[asset.fileId] != "undefined") {
        url = sLinkedAssets[asset.fileId];
      }
    } else if (typeof sLinkedAssets["p" + prx.projectsettings.id + "_" + asset.fileId] != "undefined") {
      url = sLinkedAssets["p" + prx.projectsettings.id + "_" + asset.fileId];
    }
  }

  if (asset.assetType == "account") {
    if (typeof sLinkedAssets["p_" + asset.fileId] != "undefined") {
      url = sLinkedAssets["p_" + asset.fileId];
    }
  }

  return url;
};

/***/ }),

/***/ "./sass/player-engine/js/player-engine-min.js":
/*!****************************************************!*\
  !*** ./sass/player-engine/js/player-engine-min.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

prx.debug.ini = function () {};

/***/ }),

/***/ "./src/Proto.ts":
/*!**********************!*\
  !*** ./src/Proto.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var store_1 = __webpack_require__(/*! ./store */ "./src/store/index.ts");

var Proto = function () {
  function Proto() {
    this.store = store_1.configureStore();
    this.proxy = {};
  }

  Object.defineProperty(Proto.prototype, "state", {
    get: function get() {
      return this.store.getState();
    },
    enumerable: true,
    configurable: true
  });
  return Proto;
}();

exports["default"] = Proto;

/***/ }),

/***/ "./src/features/player/export.ts":
/*!***************************************!*\
  !*** ./src/features/player/export.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./index */ "./src/features/player/index.ts");

__webpack_require__(/*! ~/sass/player-engine/js/player-engine-export-min.js */ "./sass/player-engine/js/player-engine-export-min.js");

__webpack_require__(/*! ~/sass/player-engine/css/player-engine-export-min.scss */ "./sass/player-engine/css/player-engine-export-min.scss");

/***/ }),

/***/ "./src/features/player/index.ts":
/*!**************************************!*\
  !*** ./src/features/player/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(/*! @babel/polyfill */ "./node_modules/@babel/polyfill/lib/index.js");

var jsondiffpatch = __importStar(__webpack_require__(/*! jsondiffpatch */ "./node_modules/jsondiffpatch/dist/jsondiffpatch.umd.js"));

var jquery_1 = __importDefault(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"));

var Proto_1 = __importDefault(__webpack_require__(/*! ~/src/Proto */ "./src/Proto.ts"));

window.$ = __webpack_provided_window_dot_jQuery = jquery_1["default"];
window.jsondiffpatch = jsondiffpatch;
window.proto = new Proto_1["default"]();

__webpack_require__(/*! ~/js/plugins/greensock/ThrowPropsPlugin.js */ "./js/plugins/greensock/ThrowPropsPlugin.js");

__webpack_require__(/*! ~/js/plugins/greensock/Draggable.js */ "./js/plugins/greensock/Draggable.js");

__webpack_require__(/*! ~/js/plugins/greensock/TweenMax.js */ "./js/plugins/greensock/TweenMax.js");

window.BezierEasing = __webpack_require__(/*! ~/js/plugins/bezier-easing/bezier-easing.js */ "./js/plugins/bezier-easing/bezier-easing.js");
window.IScroll = __webpack_require__(/*! ~/js/plugins/iscroll/iscroll-zoom.js */ "./js/plugins/iscroll/iscroll-zoom.js");

__webpack_require__(/*! ~/js/plugins/modernizr/modernizr-2.0.6.min.js */ "./js/plugins/modernizr/modernizr-2.0.6.min.js");

window.Hammer = __webpack_require__(/*! ~/js/plugins/hammer/hammer-custom.js */ "./js/plugins/hammer/hammer-custom.js");
window.propagating = __webpack_require__(/*! ~/js/plugins/hammer/propagating-hammer/propagating.js */ "./js/plugins/hammer/propagating-hammer/propagating.js");

__webpack_require__(/*! ~/js/plugins/hammer/jquery.hammer-custom.js */ "./js/plugins/hammer/jquery.hammer-custom.js");

__webpack_require__(/*! ~/js/plugins/waves/waves-custom.js */ "./js/plugins/waves/waves-custom.js");

__webpack_require__(/*! ~/js/plugins/js-xss/xss_custom.min.js */ "./js/plugins/js-xss/xss_custom.min.js");

window.lottie = __webpack_require__(/*! ~/js/plugins/lottie/lottie.min.js */ "./js/plugins/lottie/lottie.min.js");
window.DOMPurify = __webpack_require__(/*! ~/js/plugins/DOMPurify/purify.min.js */ "./js/plugins/DOMPurify/purify.min.js");

__webpack_require__(/*! ~/js/plugins/lodash/lodash.clonedeep.js */ "./js/plugins/lodash/lodash.clonedeep.js");

window.WebFont = __webpack_require__(/*! ~/js/plugins/webfontloader/webfontloader.1.6.28.js */ "./js/plugins/webfontloader/webfontloader.1.6.28.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_kvs.js */ "./sass/common/js/prx/components/_kvs.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_utils.js */ "./sass/common/js/prx/components/_utils.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_polyfills.js */ "./sass/common/js/prx/components/_polyfills.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_toolbox.js */ "./sass/common/js/prx/components/_toolbox.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_css.js */ "./sass/common/js/prx/components/_css.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_jquery-2-migrate.js */ "./sass/common/js/prx/components/_jquery-2-migrate.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_cross-msg.js */ "./sass/common/js/prx/components/_cross-msg.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_easing.js */ "./sass/common/js/prx/components/_easing.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_mask.js */ "./sass/common/js/prx/components/_mask.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_utils.js */ "./sass/player-engine/js/components/_utils.js");

__webpack_require__(/*! ~/ts/common/gradients/GradientsHelperAPI.ts */ "./ts/common/gradients/GradientsHelperAPI.ts");

__webpack_require__(/*! ~/sass/player-engine/js/components/compatibility/compatibility.js */ "./sass/player-engine/js/components/compatibility/compatibility.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/compatibility/_v5.js */ "./sass/player-engine/js/components/compatibility/_v5.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/compatibility/_responsive-components.js */ "./sass/player-engine/js/components/compatibility/_responsive-components.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/compatibility/_galleryAssetsToStatic.js */ "./sass/player-engine/js/components/compatibility/_galleryAssetsToStatic.js");

__webpack_require__(/*! ~/sass/common/js/compatibility/_state-transitions-to-ms.js */ "./sass/common/js/compatibility/_state-transitions-to-ms.js");

__webpack_require__(/*! ~/sass/common/js/compatibility/_font-style.js */ "./sass/common/js/compatibility/_font-style.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/items/items.js */ "./sass/player-engine/js/components/items/items.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/items/_items.js */ "./sass/player-engine/js/components/items/_items.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/items/_helper.js */ "./sass/player-engine/js/components/items/_helper.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/stc/stc.js */ "./sass/player-engine/js/components/stc/stc.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/stc/_stc-helper.js */ "./sass/player-engine/js/components/stc/_stc-helper.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/stc/_screens.js */ "./sass/player-engine/js/components/stc/_screens.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/stc/_templates.js */ "./sass/player-engine/js/components/stc/_templates.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/stc/_containers.js */ "./sass/player-engine/js/components/stc/_containers.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_actions.js */ "./sass/player-engine/js/components/_actions.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_actions-library.js */ "./sass/player-engine/js/components/_actions-library.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_analytics.js */ "./sass/player-engine/js/components/_analytics.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_canvas.js */ "./sass/player-engine/js/components/_canvas.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_cross-msg.js */ "./sass/player-engine/js/components/_cross-msg.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_click-effect.js */ "./sass/player-engine/js/components/_click-effect.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_debug.js */ "./sass/player-engine/js/components/_debug.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_draggable.js */ "./sass/player-engine/js/components/_draggable.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_easing.js */ "./sass/player-engine/js/components/_easing.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_groups.js */ "./sass/player-engine/js/components/_groups.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_fonts.js */ "./sass/player-engine/js/components/_fonts.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_helper.js */ "./sass/player-engine/js/components/_helper.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_ini-player.js */ "./sass/player-engine/js/components/_ini-player.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_loading.js */ "./sass/player-engine/js/components/_loading.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_navigation.js */ "./sass/player-engine/js/components/_navigation.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_orientation.js */ "./sass/player-engine/js/components/_orientation.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_overlay.js */ "./sass/player-engine/js/components/_overlay.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_quick-audio.js */ "./sass/player-engine/js/components/_quick-audio.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_responsive-components.js */ "./sass/player-engine/js/components/_responsive-components.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_scale.js */ "./sass/player-engine/js/components/_scale.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_screen-transitions.js */ "./sass/player-engine/js/components/_screen-transitions.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_scrollable.js */ "./sass/player-engine/js/components/_scrollable.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_show-actions.js */ "./sass/player-engine/js/components/_show-actions.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_states.js */ "./sass/player-engine/js/components/_states.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_status-nav-bar.js */ "./sass/player-engine/js/components/_status-nav-bar.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_underlay.js */ "./sass/player-engine/js/components/_underlay.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_utils.js */ "./sass/player-engine/js/components/_utils.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_variables.js */ "./sass/player-engine/js/components/_variables.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_vimeo.js */ "./sass/player-engine/js/components/_vimeo.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_visibility.js */ "./sass/player-engine/js/components/_visibility.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_youtube.js */ "./sass/player-engine/js/components/_youtube.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_interface.js */ "./sass/player-engine/js/components/_interface.js");

__webpack_require__(/*! ~/sass/player-engine/js/components/_vr.js */ "./sass/player-engine/js/components/_vr.js");

__webpack_require__(/*! ~/sass/editor/js/components/_html-text-editor.js */ "./sass/editor/js/components/_html-text-editor.js");

__webpack_require__(/*! ~/ts/common/super-dom/superDomAPI.ts */ "./ts/common/super-dom/superDomAPI.ts");

__webpack_require__(/*! ~/ts/common/springrk4/springrk4API.ts */ "./ts/common/springrk4/springrk4API.ts");

__webpack_require__(/*! ~/ts/common/vector-animation/vectorAnimationAPI.ts */ "./ts/common/vector-animation/vectorAnimationAPI.ts");

__webpack_require__(/*! ~/sass/common/js/prx/components/_expandable-properties.js */ "./sass/common/js/prx/components/_expandable-properties.js");

__webpack_require__(/*! ~/sass/common/js/prx/components/_components-helper.js */ "./sass/common/js/prx/components/_components-helper.js");

__webpack_require__(/*! ~/sass/player-engine/js/player-engine-development-min.js */ "./sass/player-engine/js/player-engine-development-min.js");

__webpack_require__(/*! ~/sass/player-engine/js/player-engine-min.js */ "./sass/player-engine/js/player-engine-min.js");

__webpack_require__(/*! ~/sass/player-engine/css/player-engine-min.scss */ "./sass/player-engine/css/player-engine-min.scss");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./src/store/index.ts":
/*!****************************!*\
  !*** ./src/store/index.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var redux_1 = __webpack_require__(/*! redux */ "./node_modules/redux/es/redux.js");

var redux_devtools_extension_1 = __webpack_require__(/*! redux-devtools-extension */ "./node_modules/redux-devtools-extension/index.js");

var items_1 = __webpack_require__(/*! ./items */ "./src/store/items/index.ts");

var screens_1 = __webpack_require__(/*! ./screens */ "./src/store/screens/index.ts");

var states_1 = __webpack_require__(/*! ./states */ "./src/store/states/index.ts");

var symbols_1 = __webpack_require__(/*! ./symbols */ "./src/store/symbols/index.ts");

exports.rootReducer = redux_1.combineReducers({
  items: items_1.itemsReducer,
  screens: screens_1.screensReducer,
  states: states_1.statesReducer,
  symbols: symbols_1.symbolsReducer
});

exports.configureStore = function () {
  return redux_1.createStore(exports.rootReducer, redux_devtools_extension_1.composeWithDevTools());
};

/***/ }),

/***/ "./src/store/items/actions.ts":
/*!************************************!*\
  !*** ./src/store/items/actions.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var typesafe_actions_1 = __webpack_require__(/*! typesafe-actions */ "./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js");

exports.ADD_ITEM = typesafe_actions_1.createAction('items/ADD', function (resolve) {
  return function (item) {
    return resolve(item);
  };
});
exports.EDIT_ITEM = typesafe_actions_1.createAction('items/EDIT', function (resolve) {
  return function (item, index) {
    return resolve(item, index);
  };
});
exports.REMOVE_ITEM = typesafe_actions_1.createAction('items/REMOVE', function (resolve) {
  return function (index) {
    return resolve(index);
  };
});
exports.SET_ITEMS = typesafe_actions_1.createAction('items/SET', function (resolve) {
  return function (items) {
    return resolve(items);
  };
});
exports.SELECT_ITEMS = typesafe_actions_1.createAction('items/SELECT', function (resolve) {
  return function (indices) {
    return resolve(indices);
  };
});
exports.DESELECT_ITEM = typesafe_actions_1.createAction('items/DESELECT', function (resolve) {
  return function (index) {
    return resolve(index);
  };
});

/***/ }),

/***/ "./src/store/items/index.ts":
/*!**********************************!*\
  !*** ./src/store/items/index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sampleItem = {
  id: '1'
};

__export(__webpack_require__(/*! ./actions */ "./src/store/items/actions.ts"));

__export(__webpack_require__(/*! ./reducer */ "./src/store/items/reducer.ts"));

/***/ }),

/***/ "./src/store/items/reducer.ts":
/*!************************************!*\
  !*** ./src/store/items/reducer.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var typesafe_actions_1 = __webpack_require__(/*! typesafe-actions */ "./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js");

var immutability_helper_1 = __importDefault(__webpack_require__(/*! immutability-helper */ "./node_modules/immutability-helper/index.js"));

var utils_1 = __webpack_require__(/*! ../utils */ "./src/store/utils.ts");

var _1 = __webpack_require__(/*! . */ "./src/store/items/index.ts");

exports.initialState = {
  data: [],
  selected: []
};

exports.itemsReducer = function (state, action) {
  var _a;

  if (state === void 0) {
    state = exports.initialState;
  }

  var newState = state;

  switch (action.type) {
    case typesafe_actions_1.getType(_1.ADD_ITEM):
      newState = immutability_helper_1["default"](state, {
        data: {
          $push: [action.payload]
        }
      });
      utils_1.mutate('items', newState.data);
      break;

    case typesafe_actions_1.getType(_1.EDIT_ITEM):
      newState = immutability_helper_1["default"](state, {
        data: (_a = {}, _a[action.meta] = {
          $set: action.payload
        }, _a)
      });
      utils_1.mutate('items', newState.data);
      break;

    case typesafe_actions_1.getType(_1.REMOVE_ITEM):
      newState = immutability_helper_1["default"](state, {
        data: {
          $splice: [[action.payload, 1]]
        }
      });
      utils_1.mutate('items', newState.data);
      break;

    case typesafe_actions_1.getType(_1.SET_ITEMS):
      newState = immutability_helper_1["default"](state, {
        data: {
          $set: action.payload
        }
      });
      utils_1.mutate('items', newState.data);
      break;

    case typesafe_actions_1.getType(_1.SELECT_ITEMS):
      newState = immutability_helper_1["default"](state, {
        selected: {
          $set: action.payload
        }
      });

      if (action.payload.length === 1) {
        utils_1.mutate('iSelectedIndex', action.payload[0]);
        utils_1.mutate('iSelectedIndexes', []);
      } else {
        utils_1.mutate('iSelectedIndex', -1);
        utils_1.mutate('iSelectedIndexes', action.payload);
      }

      break;

    case typesafe_actions_1.getType(_1.DESELECT_ITEM):
      newState = immutability_helper_1["default"](state, {
        selected: {
          $splice: [[action.payload, 1]]
        }
      });

      if (newState.selected.length === 1) {
        utils_1.mutate('iSelectedIndex', newState.selected[0]);
        utils_1.mutate('iSelectedIndexes', []);
      } else {
        utils_1.mutate('iSelectedIndex', -1);
        utils_1.mutate('iSelectedIndexes', newState.selected);
      }

      break;
  }

  return newState;
};

/***/ }),

/***/ "./src/store/screens/actions.ts":
/*!**************************************!*\
  !*** ./src/store/screens/actions.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var typesafe_actions_1 = __webpack_require__(/*! typesafe-actions */ "./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js");

exports.ADD_SCREEN = typesafe_actions_1.createAction('screens/ADD', function (resolve) {
  return function (screen) {
    return resolve(screen);
  };
});
exports.EDIT_SCREEN = typesafe_actions_1.createAction('screens/EDIT', function (resolve) {
  return function (screen, index) {
    return resolve(screen, index);
  };
});
exports.REMOVE_SCREEN = typesafe_actions_1.createAction('screens/REMOVE', function (resolve) {
  return function (index) {
    return resolve(index);
  };
});
exports.SET_SCREENS = typesafe_actions_1.createAction('screens/SET', function (resolve) {
  return function (screens) {
    return resolve(screens);
  };
});
exports.SELECT_SCREEN = typesafe_actions_1.createAction('screens/SELECT', function (resolve) {
  return function (index) {
    return resolve(index);
  };
});
exports.REORDER_SCREEN = typesafe_actions_1.createAction('screens/REORDER', function (resolve) {
  return function (fromIndex, toIndex) {
    return resolve({
      fromIndex: fromIndex,
      toIndex: toIndex
    });
  };
});

/***/ }),

/***/ "./src/store/screens/index.ts":
/*!************************************!*\
  !*** ./src/store/screens/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sampleScreen = {
  id: 1,
  actions: [],
  navigationbar: '0',
  orientation: 'portrait',
  states: [],
  statusbar: '0',
  title: 'Screen 1'
};

__export(__webpack_require__(/*! ./actions */ "./src/store/screens/actions.ts"));

__export(__webpack_require__(/*! ./reducer */ "./src/store/screens/reducer.ts"));

/***/ }),

/***/ "./src/store/screens/reducer.ts":
/*!**************************************!*\
  !*** ./src/store/screens/reducer.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var typesafe_actions_1 = __webpack_require__(/*! typesafe-actions */ "./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js");

var immutability_helper_1 = __importDefault(__webpack_require__(/*! immutability-helper */ "./node_modules/immutability-helper/index.js"));

var utils_1 = __webpack_require__(/*! ../utils */ "./src/store/utils.ts");

var _1 = __webpack_require__(/*! . */ "./src/store/screens/index.ts");

exports.initialState = {
  data: [],
  selected: -1
};

exports.screensReducer = function (state, action) {
  var _a;

  if (state === void 0) {
    state = exports.initialState;
  }

  var newState = state;

  switch (action.type) {
    case typesafe_actions_1.getType(_1.ADD_SCREEN):
      newState = immutability_helper_1["default"](state, {
        data: {
          $push: [action.payload]
        }
      });
      utils_1.mutate('pages', newState.data);
      break;

    case typesafe_actions_1.getType(_1.EDIT_SCREEN):
      newState = immutability_helper_1["default"](state, {
        data: (_a = {}, _a[action.meta] = {
          $set: action.payload
        }, _a)
      });
      utils_1.mutate('pages', newState.data);
      break;

    case typesafe_actions_1.getType(_1.REMOVE_SCREEN):
      newState = immutability_helper_1["default"](state, {
        data: {
          $splice: [[action.payload, 1]]
        }
      });
      utils_1.mutate('pages', newState.data);
      break;

    case typesafe_actions_1.getType(_1.SET_SCREENS):
      newState = immutability_helper_1["default"](state, {
        data: {
          $set: action.payload
        }
      });
      utils_1.mutate('pages', newState.data);
      break;

    case typesafe_actions_1.getType(_1.SELECT_SCREEN):
      newState = immutability_helper_1["default"](state, {
        selected: {
          $set: action.payload
        }
      });
      utils_1.mutate('iSelectedPage', newState.selected);
      break;

    case typesafe_actions_1.getType(_1.REORDER_SCREEN):
      var selectedScreenId_1 = state.data[state.selected].id;
      var movingItem = state.data[action.payload.fromIndex];
      newState = immutability_helper_1["default"](state, {
        data: {
          $splice: [[action.payload.fromIndex, 1], [action.payload.toIndex, 0, movingItem]]
        }
      });
      newState = immutability_helper_1["default"](newState, {
        selected: {
          $set: newState.data.findIndex(function (screen) {
            return screen.id === selectedScreenId_1;
          })
        }
      });
      utils_1.mutate('pages', newState.data);
      utils_1.mutate('iSelectedPage', newState.selected);
      break;
  }

  return newState;
};

/***/ }),

/***/ "./src/store/states/actions.ts":
/*!*************************************!*\
  !*** ./src/store/states/actions.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var typesafe_actions_1 = __webpack_require__(/*! typesafe-actions */ "./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js");

exports.SELECT_STATE = typesafe_actions_1.createAction('states/SELECT', function (resolve) {
  return function (index) {
    return resolve(index);
  };
});

/***/ }),

/***/ "./src/store/states/index.ts":
/*!***********************************!*\
  !*** ./src/store/states/index.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

__export(__webpack_require__(/*! ./actions */ "./src/store/states/actions.ts"));

__export(__webpack_require__(/*! ./reducer */ "./src/store/states/reducer.ts"));

/***/ }),

/***/ "./src/store/states/reducer.ts":
/*!*************************************!*\
  !*** ./src/store/states/reducer.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var typesafe_actions_1 = __webpack_require__(/*! typesafe-actions */ "./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js");

var immutability_helper_1 = __importDefault(__webpack_require__(/*! immutability-helper */ "./node_modules/immutability-helper/index.js"));

var utils_1 = __webpack_require__(/*! ../utils */ "./src/store/utils.ts");

var _1 = __webpack_require__(/*! . */ "./src/store/states/index.ts");

exports.initialState = {
  selected: -1
};

exports.statesReducer = function (state, action) {
  if (state === void 0) {
    state = exports.initialState;
  }

  var newState = state;

  switch (action.type) {
    case typesafe_actions_1.getType(_1.SELECT_STATE):
      newState = immutability_helper_1["default"](state, {
        selected: {
          $set: action.payload
        }
      });
      utils_1.mutate('iSelectedState', newState.selected);
      break;
  }

  return newState;
};

/***/ }),

/***/ "./src/store/symbols/actions.ts":
/*!**************************************!*\
  !*** ./src/store/symbols/actions.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var typesafe_actions_1 = __webpack_require__(/*! typesafe-actions */ "./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js");

exports.ADD_SYMBOL = typesafe_actions_1.createAction('symbols/ADD', function (resolve) {
  return function (symbol) {
    return resolve(symbol);
  };
});
exports.EDIT_SYMBOL = typesafe_actions_1.createAction('symbols/EDIT', function (resolve) {
  return function (symbol, index) {
    return resolve(symbol, index);
  };
});
exports.REMOVE_SYMBOL = typesafe_actions_1.createAction('symbols/REMOVE', function (resolve) {
  return function (index) {
    return resolve(index);
  };
});
exports.SET_SYMBOLS = typesafe_actions_1.createAction('symbols/SET', function (resolve) {
  return function (symbols) {
    return resolve(symbols);
  };
});
exports.SELECT_SYMBOL = typesafe_actions_1.createAction('symbols/SELECT', function (resolve) {
  return function (index) {
    return resolve(index);
  };
});

/***/ }),

/***/ "./src/store/symbols/index.ts":
/*!************************************!*\
  !*** ./src/store/symbols/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sampleSymbol = {
  id: 1,
  actions: [],
  navigationbar: '0',
  orientation: 'portrait',
  states: [],
  statusbar: '0',
  title: 'Symbol 1'
};

__export(__webpack_require__(/*! ./actions */ "./src/store/symbols/actions.ts"));

__export(__webpack_require__(/*! ./reducer */ "./src/store/symbols/reducer.ts"));

/***/ }),

/***/ "./src/store/symbols/reducer.ts":
/*!**************************************!*\
  !*** ./src/store/symbols/reducer.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var typesafe_actions_1 = __webpack_require__(/*! typesafe-actions */ "./node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js");

var immutability_helper_1 = __importDefault(__webpack_require__(/*! immutability-helper */ "./node_modules/immutability-helper/index.js"));

var utils_1 = __webpack_require__(/*! ../utils */ "./src/store/utils.ts");

var _1 = __webpack_require__(/*! . */ "./src/store/symbols/index.ts");

exports.initialState = {
  data: [],
  selected: -1
};

exports.symbolsReducer = function (state, action) {
  var _a;

  if (state === void 0) {
    state = exports.initialState;
  }

  var newState = state;

  switch (action.type) {
    case typesafe_actions_1.getType(_1.ADD_SYMBOL):
      newState = immutability_helper_1["default"](state, {
        data: {
          $push: [action.payload]
        }
      });
      utils_1.mutate('symbols', newState.data);
      break;

    case typesafe_actions_1.getType(_1.EDIT_SYMBOL):
      newState = immutability_helper_1["default"](state, {
        data: (_a = {}, _a[action.meta] = {
          $set: action.payload
        }, _a)
      });
      utils_1.mutate('symbols', newState.data);
      break;

    case typesafe_actions_1.getType(_1.REMOVE_SYMBOL):
      newState = immutability_helper_1["default"](state, {
        data: {
          $splice: [[action.payload, 1]]
        }
      });
      utils_1.mutate('symbols', newState.data);
      break;

    case typesafe_actions_1.getType(_1.SET_SYMBOLS):
      newState = immutability_helper_1["default"](state, {
        data: {
          $set: action.payload
        }
      });
      utils_1.mutate('symbols', newState.data);
      break;

    case typesafe_actions_1.getType(_1.SELECT_SYMBOL):
      newState = immutability_helper_1["default"](state, {
        selected: {
          $set: action.payload
        }
      });
      utils_1.mutate('iSelectedSymbol', action.payload);
      break;
  }

  return newState;
};

/***/ }),

/***/ "./src/store/utils.ts":
/*!****************************!*\
  !*** ./src/store/utils.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var observable_slim_1 = __importDefault(__webpack_require__(/*! observable-slim */ "./node_modules/observable-slim/observable-slim.js"));

exports.mutate = function (path, newState) {
  if (!window.prxy || !window.prxy.__isProxy || window.proto.isMutable) {
    return;
  }

  observable_slim_1["default"].pause(window.prxy);
  window.prxy[path] = newState;
  observable_slim_1["default"].resume(window.prxy);
};

/***/ }),

/***/ "./ts/common/gradients/GradientsHelper.ts":
/*!************************************************!*\
  !*** ./ts/common/gradients/GradientsHelper.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var GradientsHelper = function () {
  function GradientsHelper() {}

  GradientsHelper.toHex = function (col) {
    var opacity = 1;
    var colopacity = {};
    if (col) if (GradientsHelper.getFirstOriginalColor(col).toLowerCase().indexOf('rgb') > -1) {
      var colorString = GradientsHelper.getFirstOriginalColor(col);
      var colorsOnly = colorString.substring(colorString.indexOf('(') + 1, colorString.lastIndexOf(')')).split(/,\s*/);

      if (colorsOnly[3] && !isNaN(parseFloat(colorsOnly[3])) && parseFloat(colorsOnly[3]) >= 0 && parseFloat(colorsOnly[3]) <= 1) {
        opacity = parseFloat(colorsOnly[3]);
      } else {
        opacity = 1;
      }

      var rgb = GradientsHelper.getFirstOriginalColor(col).match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
      col = rgb && rgb.length === 4 ? '#' + ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';
    }
    colopacity.color = col;
    colopacity.opacity = opacity;
    return colopacity;
  };

  GradientsHelper.rgbToHex = function (r, g, b) {
    if (isNaN(parseInt(r)) || parseInt(r) < 0 || parseInt(r) > 255) {
      r = '255';
    }

    if (isNaN(parseInt(g)) || parseInt(g) < 0 || parseInt(g) > 255) {
      g = '255';
    }

    if (isNaN(parseInt(b)) || parseInt(b) < 0 || parseInt(b) > 255) {
      b = '255';
    }

    return ('0' + parseInt(r, 10).toString(16)).slice(-2) + ('0' + parseInt(g, 10).toString(16)).slice(-2) + ('0' + parseInt(b, 10).toString(16)).slice(-2);
  };

  GradientsHelper.toRgba = function (color, opacity) {
    var rgba = '';

    if (color.toLowerCase().indexOf('rgba') === -1) {
      if (color.toLowerCase().indexOf('#') === 0) {
        var alpha = opacity >= 0 && opacity <= 1 ? opacity : 1;
        var R = GradientsHelper.hexToR(color),
            G = GradientsHelper.hexToG(color),
            B = GradientsHelper.hexToB(color);
        return 'rgba(' + R + ',' + G + ',' + B + ',' + alpha + ')';
      }

      if (color.toLowerCase().indexOf('rgb') === 0) {
        return color.toLowerCase().replace('rgb', 'rgba').replace(')', ', 1)');
      }
    }

    return color.toLowerCase();
  };

  GradientsHelper.toColorValue = function (color, opacity) {
    return GradientsHelper.toRgba(color, opacity);
  };

  GradientsHelper.getRgbaValues = function (color) {
    var values;

    if (typeof color === 'string') {
      color = color.replace(/\s/g, '');

      if (color === 'undefined') {
        values = {
          r: 255,
          g: 255,
          b: 255,
          a: 1
        };
      } else if (/^#?([0-9a-f]{3}|[0-9a-f]{6})$/i.test(color)) {
        if (color.indexOf('#') === 0) {
          color = color.substr(1);
        }

        if (color.length == 3) values = {
          r: parseInt(color[0] + color[0], 16),
          g: parseInt(color[1] + color[1], 16),
          b: parseInt(color[2] + color[2], 16),
          a: 1
        };else values = {
          r: parseInt(color.substr(0, 2), 16),
          g: parseInt(color.substr(2, 2), 16),
          b: parseInt(color.substr(4, 2), 16),
          a: 1
        };
      } else if (/^rgb\((\d+),(\d+),(\d+)\)$/i.test(color)) {
        var matches = color.match(/^rgb\((\d+),(\d+),(\d+)\)$/i);

        if (matches) {
          values = {
            r: parseInt(matches[1]),
            g: parseInt(matches[2]),
            b: parseInt(matches[3]),
            a: 1
          };
        }
      } else if (/^rgba\((\d+),(\d+),(\d+),(\d?(\.\d+)?)\)$/i.test(color)) {
        var matches = color.match(/rgba\((\d+),(\d+),(\d+),(\d?(\.\d+)?)\)/i);
        values = {
          r: parseInt(matches[1]),
          g: parseInt(matches[2]),
          b: parseInt(matches[3]),
          a: matches[4] && matches[4].trim().length > 0 ? parseFloat(matches[4]) : 0
        };
      }
    } else if (typeof color === 'undefined') {
      values = {
        r: 255,
        g: 255,
        b: 255,
        a: 1
      };
    }

    return values;
  };

  GradientsHelper.getFirstOriginalColor = function (color) {
    if (typeof color == 'string') {
      return color;
    } else {
      if (color.type == 'solid') {
        return color.color;
      } else {
        return color.colors[0].color;
      }
    }
  };

  GradientsHelper.prxToCss = function (prxColor) {
    var css = '';
    var temp = '';

    if (typeof prxColor === 'string') {
      prxColor = GradientsHelper.cssToPrx(prxColor);
    }

    switch (prxColor.type) {
      case 'solid':
        if (/^([0-9a-f]{3}|[0-9a-f]{6})$/i.test(prxColor.color)) {
          css = '#' + prxColor.color;
        } else {
          css = prxColor.color;
        }

        break;

      case 'linear':
        temp = '';

        for (var i = 0; i < prxColor.colors.length; i++) {
          temp += prxColor.colors[i].color + ' ' + prxColor.colors[i].pos + '%, ';
        }

        temp = temp.replace(/,\s*$/, '');
        var angleStr = '';

        if (prxColor.angle != 180) {
          angleStr = prxColor.angle + 'deg, ';
        } else {
          angleStr = '180.1deg, ';
        }

        css = 'linear-gradient(' + angleStr + temp + ')';
        break;

      case 'radial':
        temp = '';

        for (var i = 0; i < prxColor.colors.length; i++) {
          temp += prxColor.colors[i].color + ' ' + prxColor.colors[i].pos + '%, ';
        }

        temp = temp.replace(/,\s*$/, '');
        css = 'radial-gradient(ellipse at center, ' + temp + ')';
        break;
    }

    return css;
  };

  GradientsHelper.prxSolidToHex = function (prxColor) {
    if (prxColor.type && prxColor.type === 'solid') {
      var rgbaValues = GradientsHelper.getRgbaValues(prxColor.color);
      return GradientsHelper.rgbToHex(rgbaValues.r.toString(), rgbaValues.g.toString(), rgbaValues.b.toString());
    }

    return '000000';
  };

  GradientsHelper.cssToPrx = function (css) {
    var prxColor = {};

    if (typeof css === 'undefined') {
      prxColor.type = 'solid';
      prxColor.color = 'rgba(255,255,255,0)';
    } else if (css.indexOf('gradient') > -1) {
      prxColor.colors = [];
      var indexStart = css.indexOf('(');
      var indexEnd = css.lastIndexOf(')');
      var parts = css.substring(indexStart + 1, indexEnd).split(/,(?![^(]*\))(?![^"']*["'](?:[^"']*["'][^"']*["'])*[^"']*$)/);

      if (parts[0]) {
        if (css.indexOf('linear') > -1) {
          prxColor.type = 'linear';
          var angle = Number(parts[0].trim().replace('deg', ''));

          if (isNaN(angle) || angle === 180) {
            angle = 180.1;
          }

          prxColor.angle = angle;
        } else if (css.indexOf('radial') > -1) {
          prxColor.type = 'radial';
        }
      }

      if (parts.length > 1) {
        for (var i = 0; i < parts.length; i++) {
          var colorDef = parts[i].trim().match(/(#[0-9a-f]{3,6}|(rgb|rgba) ?\([ 0-9\.,]+?\))(\s+[0-9\.]+%)?/i);

          if (colorDef) {
            var posVal = 0;

            if (colorDef[1].match(/#[0-9a-f]{3,6}/i)) {
              if (colorDef[1].substr(0, 1) !== '#') colorDef[1] = '#' + colorDef[1];
              colorDef[1] = GradientsHelper.toRgba(colorDef[1], 1);
            }

            if (colorDef[3] && !isNaN(Number(colorDef[3].replace('%', '').trim()))) {
              posVal = Number(colorDef[3].replace('%', '').trim());
            }

            prxColor.colors.push({
              color: colorDef[1],
              pos: posVal
            });
          }
        }
      } else {
        prxColor.colors.push({
          color: 'rgba(255,255,255,0)',
          pos: 0
        });
        prxColor.colors.push({
          color: 'rgba(255,255,255,0)',
          pos: 100
        });
      }
    } else {
      prxColor.type = 'solid';

      if (/^([0-9a-f]{3}|[0-9a-f]{6})$/i.test(css.trim())) {
        prxColor.color = GradientsHelper.toRgba('#' + css, 1);
      } else {
        var colorDef = css.trim().match(/(#[0-9a-f]{3,6}|(rgb|rgba) ?\([ 0-9\.,]+?\))(\s+[0-9\.]+%)?/i);

        if (colorDef && colorDef[2] === 'rgb') {
          prxColor.color = colorDef[1].replace('rgb', 'rgba').replace(')', ',1)');
        } else if (colorDef && colorDef[1]) {
          if (colorDef[1].match(/#[0-9a-f]{3,6}/i)) {
            if (colorDef[1].substr(0, 1) !== '#') colorDef[1] = '#' + colorDef[1];
            colorDef[1] = GradientsHelper.toRgba(colorDef[1], 1);
          }

          prxColor.color = colorDef[1];
        } else {
          prxColor.color = 'rgba(255,255,255,0)';
        }
      }
    }

    return prxColor;
  };

  GradientsHelper.getBgCss = function (prop) {
    if (typeof prop === 'string') {
      return 'background-color: ' + prx.componentsHelper.getProp(prop, 'color-background');
    } else {
      if (prop !== undefined) {
        return (prop.type === 'solid' ? 'background-color: ' : 'background-image: ') + prx.componentsHelper.getProp(prop, 'color-background');
      }
    }

    return '';
  };

  GradientsHelper.getBgCssByProperty = function (prop, property) {
    if (typeof prop === 'string') {
      return 'background-color: ' + prx.componentsHelper.getProp(prop, property);
    } else {
      if (prop !== undefined) {
        return (prop.type === 'solid' ? 'background-color: ' : 'background-image: ') + prx.componentsHelper.getProp(prop, property);
      }
    }

    return '';
  };

  GradientsHelper.getBgCssByValue = function (val) {
    if (typeof val === 'string') {
      return (val.indexOf('gradient') > -1 ? 'background-image: ' : 'background-color: ') + val;
    } else {
      return (val.type === 'solid' ? 'background-color: ' : 'background-image: ') + GradientsHelper.prxToCss(val);
    }
  };

  GradientsHelper.getBgCssPropertyByValue = function (css) {
    return css.indexOf('gradient') > -1 ? 'background-image' : 'background-color';
  };

  GradientsHelper.stringToPrxData = function (color) {
    var prxColor;

    if (/^(#?[0-9a-f]{3,6}|rgb|rgba|linear-gradient|radial-gradient|none|transparent)/i.test(color)) {
      prxColor = GradientsHelper.cssToPrx(color);
    } else {
      try {
        prxColor = JSON.parse(color);
      } catch (e) {
        return null;
      }
    }

    return prxColor;
  };

  GradientsHelper.calculateWeightedColor = function (color1, color2, weight) {
    return {
      r: Math.round(color1.r + weight * (color2.r - color1.r)),
      g: Math.round(color1.g + weight * (color2.g - color1.g)),
      b: Math.round(color1.b + weight * (color2.b - color1.b)),
      a: color1.a + weight * (color2.a - color1.a)
    };
  };

  GradientsHelper.isColorObject = function (value) {
    if (value !== null && _typeof(value) === 'object') {
      if (value.hasOwnProperty('type')) {
        if (['solid'].indexOf(value.type) > -1 && value.hasOwnProperty('color') && typeof value.color === 'string') {
          return true;
        } else if (['linear', 'radial'].indexOf(value.type) > -1 && value.hasOwnProperty('colors') && Array.isArray(value.colors)) {
          return true;
        }
      }
    }

    return false;
  };

  GradientsHelper.cutHex = function (h) {
    var expandedHex = h;

    if (h.replace('#', '').length === 3) {
      var shorthand = h.substr(-3);
      expandedHex = shorthand.substr(0, 1).repeat(2);
      expandedHex += shorthand.substr(1, 1).repeat(2);
      expandedHex += shorthand.substr(2, 1).repeat(2);
    }

    return expandedHex.charAt(0) == '#' ? expandedHex.substring(1, 7) : expandedHex;
  };

  GradientsHelper.hexToR = function (h) {
    return parseInt(GradientsHelper.cutHex(h).substring(0, 2), 16);
  };

  GradientsHelper.hexToG = function (h) {
    return parseInt(GradientsHelper.cutHex(h).substring(2, 4), 16);
  };

  GradientsHelper.hexToB = function (h) {
    return parseInt(GradientsHelper.cutHex(h).substring(4, 6), 16);
  };

  return GradientsHelper;
}();

exports.GradientsHelper = GradientsHelper;

/***/ }),

/***/ "./ts/common/gradients/GradientsHelperAPI.ts":
/*!***************************************************!*\
  !*** ./ts/common/gradients/GradientsHelperAPI.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var prx_1 = __webpack_require__(/*! ../typings/prx */ "./ts/common/typings/prx.ts");

var GradientsHelper_1 = __webpack_require__(/*! ./GradientsHelper */ "./ts/common/gradients/GradientsHelper.ts");

if (prx_1.prx.gradients === undefined) prx_1.prx.gradients = {};

prx_1.prx.gradients.prxToCss = function (prxColor) {
  return GradientsHelper_1.GradientsHelper.prxToCss(prxColor);
};

prx_1.prx.gradients.cssToPrx = function (css) {
  return GradientsHelper_1.GradientsHelper.cssToPrx(css);
};

prx_1.prx.gradients.getBgCssByProperty = function (prop, property) {
  return GradientsHelper_1.GradientsHelper.getBgCssByProperty(prop, property);
};

prx_1.prx.gradients.getBgCss = function (prop) {
  return GradientsHelper_1.GradientsHelper.getBgCss(prop);
};

prx_1.prx.gradients.getBgCssByValue = function (val) {
  return GradientsHelper_1.GradientsHelper.getBgCssByValue(val);
};

prx_1.prx.gradients.getBgCssPropertyByValue = function (css) {
  return GradientsHelper_1.GradientsHelper.getBgCssPropertyByValue(css);
};

prx_1.prx.gradients.stringToPrxData = function (color) {
  return GradientsHelper_1.GradientsHelper.stringToPrxData(color);
};

prx_1.prx.gradients.prxSolidToHex = function (prxColor) {
  return GradientsHelper_1.GradientsHelper.prxSolidToHex(prxColor);
};

prx_1.prx.gradients.getRgbaValues = function (color) {
  return GradientsHelper_1.GradientsHelper.getRgbaValues(color);
};

prx_1.prx.gradients.isColorObject = function (value) {
  return GradientsHelper_1.GradientsHelper.isColorObject(value);
};

prx_1.prx.gradients.toRgba = function (color, opacity) {
  return GradientsHelper_1.GradientsHelper.toRgba(color, opacity);
};

/***/ }),

/***/ "./ts/common/springrk4/springrk4.ts":
/*!******************************************!*\
  !*** ./ts/common/springrk4/springrk4.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Springrk4 = function (_super) {
  __extends(Springrk4, _super);

  function Springrk4(springrk4Data) {
    var _this = _super.call(this) || this;

    _this.inputData = springrk4Data;
    _this.tension = _this.normaliseInputs(_this.inputData.tension, 'tension');
    _this.friction = _this.normaliseInputs(_this.inputData.friction, 'friction');
    _this.velocity = _this.normaliseInputs(_this.inputData.velocity, 'velocity');
    _this.velocityMultiplier = 1 + _this.velocity * 0.0005;
    _this.speed = 1 / 60.0;
    _this.tolerance = 0.002;
    _this.current = 0;
    _this.progress = 0;
    _this.moving = false;
    _this.time = parseFloat(_this.getduration().toFixed(3));
    _this.duration = _this.time * 1000;
    _this.isSpringrk4 = true;

    _this.reset();

    return _this;
  }

  Springrk4.getDefaultValues = function () {
    return {
      tension: 400,
      friction: 15,
      velocity: 100
    };
  };

  Springrk4.prototype.reset = function () {
    this.moving = true;
    this.velocity = this.velocity * this.velocityMultiplier;
    this.current = 0;
  };

  Springrk4.prototype.getRatio = function (progress) {
    var progressToStepInArray = (progress * this.all().length).toFixed();
    return this.all()[progressToStepInArray];
  };

  Springrk4.prototype.normaliseInputs = function (input, inputType) {
    if (inputType === 'tension') {
      if (isNaN(input)) {
        input = input.toString();
        return input > 0 && input <= 1000 ? input : 200;
      } else if (!isNaN(input)) {
        return input > 0 && input <= 1000 ? input : 200;
      } else {
        return 200;
      }
    }

    if (inputType === 'friction') {
      if (isNaN(input)) {
        input = input.toString();
        return input >= 5 && input <= 100 ? input : 5;
      } else if (!isNaN(input)) {
        return input >= 5 && input <= 100 ? input : 5;
      } else {
        return 5;
      }
    }

    if (inputType === 'velocity') {
      if (isNaN(input)) {
        input = input.toString();
        return input >= 0 && input <= 100 ? input : 100;
      } else if (!isNaN(input)) {
        return input >= 0 && input <= 100 ? input : 100;
      } else {
        return 100;
      }
    }

    return 50;
  };

  Springrk4.prototype.getduration = function () {
    var duration = this.all().length * this.speed;
    this.current = 0;
    return duration;
  };

  Springrk4.prototype.all = function () {
    this.reset();
    var count = 0,
        results = [];

    while (this.moving) {
      if (count > 10000) {
        this.stop();
      }

      count++;
      results.push(this.step());
    }

    return results;
  };

  Springrk4.prototype.stop = function () {
    this.velocity = 0;
  };

  Springrk4.prototype.step = function () {
    var before = {
      x: this.current - 1,
      v: this.velocity * this.velocityMultiplier,
      tension: this.tension,
      friction: this.friction
    };
    var after = this.integrate(before, this.speed);
    this.current = 1 + after.x;
    var finalVelocity = after.v,
        netFloat = after.x,
        net1DVelocity = after.v,
        netValueIsLow = Math.abs(netFloat) < this.tolerance,
        netVelocityIsLow = Math.abs(net1DVelocity) < this.tolerance;
    var stop = netValueIsLow && netVelocityIsLow;
    this.velocity = finalVelocity;
    this.moving = !stop;

    if (stop) {
      this.current = 1;
    }

    return this.current;
  };

  Springrk4.prototype.integrate = function (state, speed) {
    var a = this.evaluate(state),
        b = this.evaluateWithDerivative(state, speed * 0.5, a),
        c = this.evaluateWithDerivative(state, speed * 0.5, b),
        d = this.evaluateWithDerivative(state, speed, c),
        dxdt = 1.0 / 6.0 * (a['dx'] + 2.0 * (b['dx'] + c['dx']) + d['dx']),
        dvdt = 1.0 / 6.0 * (a['dv'] + 2.0 * (b['dv'] + c['dv']) + d['dv']);
    state.x = state.x + dxdt * speed;
    state.v = state.v + dvdt * speed;
    return state;
  };

  Springrk4.prototype.evaluate = function (state) {
    var output = {};
    output['dx'] = state['v'];
    output['dv'] = this.acceleration(state);
    return output;
  };

  Springrk4.prototype.evaluateWithDerivative = function (state, dt, derivative) {
    var output = {},
        _state = {};
    _state['x'] = state.x + derivative.dx * dt;
    _state['v'] = state.v + derivative.dv * dt;
    _state['tension'] = state.tension;
    _state['friction'] = state.friction;
    output['dx'] = _state['v'];
    output['dv'] = this.acceleration(_state);
    return output;
  };

  Springrk4.prototype.acceleration = function (state) {
    return -(state.tension * state.x) - state.friction * state.v;
  };

  Springrk4.isValidInput = function (input, property) {
    switch (property) {
      case 'spring-tension':
        return input > 0 && input <= 1000 ? true : false;

      case 'spring-friction':
        return input >= 5 && input <= 100 ? true : false;

      case 'spring-velocity':
        return input >= 0 && input <= 100 ? true : false;

      default:
        return false;
    }
  };

  return Springrk4;
}(Ease);

exports.Springrk4 = Springrk4;

/***/ }),

/***/ "./ts/common/springrk4/springrk4API.ts":
/*!*********************************************!*\
  !*** ./ts/common/springrk4/springrk4API.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var prx_1 = __webpack_require__(/*! ../../editor/typings/prx */ "./ts/editor/typings/prx.ts");

var springrk4_1 = __webpack_require__(/*! ./springrk4 */ "./ts/common/springrk4/springrk4.ts");

if (prx_1.prx.springrk4 === undefined) prx_1.prx.springrk4 = {};

prx_1.prx.springrk4.init = function (springValues) {
  var newValue = springValues.replace('springrk4(', '').replace(')', '').split(',').map(Number);
  var springrk4 = new springrk4_1.Springrk4({
    tension: Number(newValue[0]),
    friction: Number(newValue[1]),
    velocity: Number(newValue[2])
  });
  return springrk4;
};

prx_1.prx.springrk4.getDuration = function (springValues) {
  var newValue = springValues.replace('springrk4(', '').replace(')', '').split(',').map(Number);
  var springrk4 = new springrk4_1.Springrk4({
    tension: Number(newValue[0]),
    friction: Number(newValue[1]),
    velocity: Number(newValue[2])
  });
  return springrk4.time;
};

prx_1.prx.springrk4.isValidValue = function (input, property) {
  return springrk4_1.Springrk4.isValidInput(input, property);
};

/***/ }),

/***/ "./ts/common/super-dom/Events.ts":
/*!***************************************!*\
  !*** ./ts/common/super-dom/Events.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var SuperDomHelper_1 = __webpack_require__(/*! ./SuperDomHelper */ "./ts/common/super-dom/SuperDomHelper.ts");

var prx_1 = __webpack_require__(/*! ../typings/prx */ "./ts/common/typings/prx.ts");

var Events = function () {
  function Events() {}

  Events.triggerEvent = function (element, event) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(event, false, true);
    element.dispatchEvent(e);
  };

  Events.addListener = function (element, event, func) {
    var eventArr = event.split('.');
    var eventStr = eventArr[0];
    var namespace = eventArr[1] ? eventArr[1] : '';
    var elements = SuperDomHelper_1.SuperDomHelper.getElementsArrayFromElement(element);

    for (var i = 0, len = elements.length; i < len; ++i) {
      if (elements[i] !== null) {
        var UID = void 0;

        if (elements[i].id.length) {
          UID = elements[i].id;
        } else {
          UID = 'listener-' + prx_1.prx.utils.getGuid();
          elements[i].id = UID;
        }

        if (!Events.listenerMap[UID]) Events.listenerMap[UID] = [];
        Events.listenerMap[UID].push({
          event: eventStr,
          namespace: namespace,
          helper: func
        });
        elements[i].addEventListener(eventStr, func);
      }
    }
  };

  Events.removeListener = function (element, event) {
    var eventArr = event.split('.');
    var eventStr = eventArr[0];
    var namespace = eventArr[1] ? eventArr[1] : '';
    var isNameSpaceOnly = eventStr.length === 0 && namespace && namespace.length;
    var elements = SuperDomHelper_1.SuperDomHelper.getElementsArrayFromElement(element);
    var matchedEvents = [];
    var error = false;

    if (isNameSpaceOnly) {
      for (var i = 0, len = elements.length; i < len; ++i) {
        var UID = elements[i].id;

        if (!UID.length) {
          error = true;
          break;
        }

        for (var j = 0, len_1 = Events.listenerMap[UID].length; j < len_1; ++j) {
          if (Events.listenerMap[UID][j].namespace === namespace) {
            matchedEvents.push({
              UID: UID,
              event: Events.listenerMap[UID][j].event,
              helper: Events.listenerMap[UID][j].helper
            });
            Events.listenerMap[UID].splice(j, 1);
            if (Events.listenerMap[UID].length === 0) delete Events.listenerMap[UID];
          }
        }
      }
    } else {
      if (namespace.length === 0) {
        for (var i = 0, len = elements.length; i < len; ++i) {
          var UID = elements[i].id;

          if (!UID.length) {
            error = true;
            break;
          }

          for (var j = 0, len_2 = Events.listenerMap[UID].length; j < len_2; ++j) {
            if (Events.listenerMap[UID][j].event === eventStr) {
              matchedEvents.push({
                UID: UID,
                event: Events.listenerMap[UID][j].event,
                helper: Events.listenerMap[UID][j].helper
              });
              Events.listenerMap[UID].splice(j, 1);
              j--;
              len_2--;
              if (Events.listenerMap[UID].length === 0) delete Events.listenerMap[UID];
            }
          }
        }
      } else {
        for (var i = 0, len = elements.length; i < len; ++i) {
          var UID = elements[i].id;

          if (!UID.length) {
            error = true;
            break;
          }

          for (var j = 0, len_3 = Events.listenerMap[UID].length; j < len_3; ++j) {
            if (Events.listenerMap[UID][j].event === eventStr && Events.listenerMap[UID][j].namespace === namespace) {
              matchedEvents.push({
                UID: UID,
                event: Events.listenerMap[UID][j].event,
                helper: Events.listenerMap[UID][j].helper
              });
              Events.listenerMap[UID].splice(j, 1);
              j--;
              len_3--;
              if (Events.listenerMap[UID].length === 0) delete Events.listenerMap[UID];
            }
          }
        }
      }
    }

    if (!error) {
      for (var i = 0, len = elements.length; i < len; ++i) {
        if (elements[i] !== null) {
          for (var j = 0, len_4 = matchedEvents.length; j < len_4; ++j) {
            if (elements[i].id.length && matchedEvents[j].UID === elements[i].id) {
              elements[i].removeEventListener(matchedEvents[j].event, matchedEvents[j].helper);
            }
          }
        }
      }
    }
  };

  Events.listenerMap = {};
  return Events;
}();

exports.Events = Events;

/***/ }),

/***/ "./ts/common/super-dom/SuperDom.ts":
/*!*****************************************!*\
  !*** ./ts/common/super-dom/SuperDom.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var SuperDomHelper_1 = __webpack_require__(/*! ./SuperDomHelper */ "./ts/common/super-dom/SuperDomHelper.ts");

var SuperDom = function () {
  function SuperDom() {}

  SuperDom.init = function () {
    SuperDom.scrollbarWH = SuperDomHelper_1.SuperDomHelper.getScrollbarWH();
  };

  SuperDom.getById = function (target) {
    if (target.indexOf('#') !== -1) target.replace('#', '');
    return document.getElementById(target);
  };

  SuperDom.getByClass = function (target) {
    if (target.indexOf('.') !== -1) target.replace('.', '');
    return document.getElementsByClassName(target);
  };

  SuperDom.getByName = function (target) {
    return document.getElementsByName(target);
  };

  SuperDom.getByTagName = function (target) {
    return document.getElementsByTagName(target);
  };

  SuperDom.findFirst = function (target, parent) {
    var root;
    if (parent === undefined) root = document;else if (typeof parent === 'string') root = SuperDom.getById(parent);else root = parent;
    return root.querySelector(target);
  };

  SuperDom.find = function (target, parent) {
    var root;
    if (parent === undefined) root = document;else if (typeof parent === 'string') root = SuperDom.getById(parent);else root = parent;
    return root.querySelectorAll(target);
  };

  SuperDom.addClass = function (element, classStr) {
    var classes = classStr.split(' ');
    var elements = SuperDomHelper_1.SuperDomHelper.getElementsArrayFromElement(element);

    for (var i = 0, len = elements.length; i < len; ++i) {
      if (elements[i] !== null) {
        for (var j = 0, len_1 = classes.length; j < len_1; ++j) {
          var rgx = new RegExp('(^|\\s)' + classes[j] + '(\\s|$)', 'g');
          if (rgx.test(elements[i].className)) break;
          elements[i].className = (elements[i].className + ' ' + classes[j]).replace(/\s+/g, ' ').replace(/(^ | $)/g, '');
        }
      }
    }
  };

  SuperDom.removeClass = function (element, classStr) {
    var classes = classStr.split(' ');
    var elements = SuperDomHelper_1.SuperDomHelper.getElementsArrayFromElement(element);

    for (var i = 0, len = elements.length; i < len; ++i) {
      if (elements[i] !== null) {
        for (var j = 0, len_2 = classes.length; j < len_2; ++j) {
          var rgx = new RegExp('(^|\\s)' + classes[j] + '(\\s|$)', 'g');
          if (!rgx.test(elements[i].className)) break;
          elements[i].className = elements[i].className.replace(rgx, '$1').replace(/\s+/g, ' ').replace(/(^ | $)/g, '');
        }
      }
    }
  };

  SuperDom.toggleClass = function (element, classStr, force) {
    var classes = classStr.split(' ');
    var elements = SuperDomHelper_1.SuperDomHelper.getElementsArrayFromElement(element);

    for (var i = 0, len = elements.length; i < len; ++i) {
      if (elements[i] !== null) {
        for (var j = 0, len_3 = classes.length; j < len_3; ++j) {
          var rgx = new RegExp('(^|\\s)' + classes[j] + '(\\s|$)', 'g');

          if (!rgx.test(elements[i].className)) {
            if (force !== false) {
              elements[i].className = (elements[i].className + ' ' + classes[j]).replace(/\s+/g, ' ').replace(/(^ | $)/g, '');
            }
          } else {
            if (force !== true) {
              elements[i].className = elements[i].className.replace(rgx, '$1').replace(/\s+/g, ' ').replace(/(^ | $)/g, '');
            }
          }
        }
      }
    }
  };

  SuperDom.hasClass = function (element, classStr) {
    var classes = classStr.split(' ');
    var elements = SuperDomHelper_1.SuperDomHelper.getElementsArrayFromElement(element);
    var successCounter = 0;

    for (var i = 0, len = classes.length; i < len; ++i) {
      var rgx = new RegExp('(^|\\s)' + classes[i] + '(\\s|$)', 'g');

      for (var j = 0, len_4 = elements.length; j < len_4; ++j) {
        if (elements[i] !== null) {
          if (rgx.test(elements[j].className)) {
            successCounter += 1;
            break;
          }
        }
      }
    }

    return successCounter === classes.length;
  };

  SuperDom.getStyle = function (element, cssStyle, pseudo) {
    if (element) return window.getComputedStyle(element, pseudo).getPropertyValue(cssStyle);else return '';
  };

  SuperDom.css = function (element, cssStyle, pseudo) {
    var cssValue = SuperDom.getStyle(element, cssStyle, pseudo);
    if (!isNaN(parseFloat(cssValue))) cssValue = parseFloat(cssValue);
    return cssValue;
  };

  SuperDom.setStyle = function (element, cssStyle, cssValue) {
    if (typeof cssValue === 'number') cssValue = String(cssValue);
    var elements = SuperDomHelper_1.SuperDomHelper.getElementsArrayFromElement(element);

    for (var i = 0, len = elements.length; i < len; ++i) {
      if (elements[i] !== null) elements[i].style[cssStyle] = cssValue;
    }
  };

  SuperDom.getOffset = function (element, pos) {
    var rect = element.getBoundingClientRect();
    var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

    if (pos) {
      if (pos === 'top') return rect.top + scrollTop;else return rect.left + scrollLeft;
    } else {
      return {
        top: rect.top + scrollTop,
        left: rect.left + scrollLeft
      };
    }
  };

  SuperDom.getPosition = function (element, pos) {
    if (pos) {
      if (pos === 'top') return element.offsetTop;else return element.offsetLeft;
    } else {
      return {
        top: element.offsetTop,
        left: element.offsetLeft
      };
    }
  };

  SuperDom.append = function (toAppend, parent) {
    var root;
    var parser = new DOMParser();
    if (parent === undefined) root = document.body;else if (typeof parent === 'string') root = SuperDom.getById(parent);else root = parent;

    if (typeof toAppend === 'string') {
      var HTMLNodes = parser.parseFromString(toAppend, 'text/html');

      for (var i = 0, len = HTMLNodes.body.children.length; i < len; ++i) {
        var node = HTMLNodes.body.children[i].cloneNode(true);
        root.appendChild(node);
      }
    } else {
      root.appendChild(toAppend);
    }
  };

  SuperDom.prepend = function (toPrepend, parent) {
    var root;
    var parser = new DOMParser();
    if (parent === undefined) root = document.body;else if (typeof parent === 'string') root = SuperDom.getById(parent);else root = parent;

    if (typeof toPrepend === 'string') {
      var HTMLNodes = parser.parseFromString(toPrepend, 'text/html');

      for (var i = HTMLNodes.body.children.length - 1; i >= 0; --i) {
        var node = HTMLNodes.body.children[i].cloneNode(true);
        root.insertBefore(node, root.children[0]);
      }
    } else {
      root.insertBefore(toPrepend, root.children[0]);
    }
  };

  SuperDom.scrollbarWH = null;
  return SuperDom;
}();

exports.SuperDom = SuperDom;

/***/ }),

/***/ "./ts/common/super-dom/SuperDomHelper.ts":
/*!***********************************************!*\
  !*** ./ts/common/super-dom/SuperDomHelper.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var SuperDomHelper = function () {
  function SuperDomHelper() {}

  SuperDomHelper.tgIsHTMLElement = function (element) {
    return element.length === undefined;
  };

  SuperDomHelper.tgIsElement = function (element) {
    return element.length === undefined && element.children === undefined;
  };

  SuperDomHelper.tgIsJQuery = function (element) {
    return element.ajaxError !== undefined;
  };

  SuperDomHelper.getElementsArrayFromElement = function (element) {
    if (element == null) return [];
    var elements = [];

    if (SuperDomHelper.tgIsHTMLElement(element)) {
      elements.push(element);
    } else if (SuperDomHelper.tgIsJQuery(element)) {
      elements = element.get();
    } else {
      for (var i = 0, len = element.length; i < len; ++i) {
        elements.push(element[i]);
      }
    }

    return elements;
  };

  SuperDomHelper.getScrollbarWH = function () {
    var $container = document.createElement('div');
    $container.style.height = '1px';
    $container.style.overflow = 'scroll';
    var $child = document.createElement('div');
    $child.style.height = '2px';
    $container.appendChild($child);
    document.body.appendChild($container);
    var containerWidth = $container.offsetWidth;
    var childWidth = $child.offsetWidth;
    $($container).remove();
    return containerWidth - childWidth;
  };

  return SuperDomHelper;
}();

exports.SuperDomHelper = SuperDomHelper;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./ts/common/super-dom/superDomAPI.ts":
/*!********************************************!*\
  !*** ./ts/common/super-dom/superDomAPI.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var SuperDom_1 = __webpack_require__(/*! ./SuperDom */ "./ts/common/super-dom/SuperDom.ts");

var Events_1 = __webpack_require__(/*! ./Events */ "./ts/common/super-dom/Events.ts");

window.sd = SuperDom_1.SuperDom;
window.evt = Events_1.Events;

/***/ }),

/***/ "./ts/common/typings/prx.ts":
/*!**********************************!*\
  !*** ./ts/common/typings/prx.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var extPrx;

(function (extPrx) {
  extPrx.prx1 = prx;
  extPrx.prxy1 = prxy;
})(extPrx || (extPrx = {}));

exports.prx = extPrx.prx1;
exports.prxy = extPrx.prxy1;

/***/ }),

/***/ "./ts/common/vector-animation/utils.ts":
/*!*********************************************!*\
  !*** ./ts/common/vector-animation/utils.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var VectorAnimationsUtils = function () {
  function VectorAnimationsUtils() {}

  return VectorAnimationsUtils;
}();

exports.VectorAnimationsUtils = VectorAnimationsUtils;

var BodymovinAnimationUtils = function (_super) {
  __extends(BodymovinAnimationUtils, _super);

  function BodymovinAnimationUtils() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  BodymovinAnimationUtils.isValidBodyMovin = function (animationData) {
    var totalFrames;

    if (_typeof(animationData['op']) !== undefined && _typeof(animationData['ip']) !== undefined) {
      totalFrames = Math.floor(animationData.op - animationData.ip);
      if (!isNaN(totalFrames)) return true;
    }

    return false;
  };

  return BodymovinAnimationUtils;
}(VectorAnimationsUtils);

exports.BodymovinAnimationUtils = BodymovinAnimationUtils;

/***/ }),

/***/ "./ts/common/vector-animation/vectorAnimation.ts":
/*!*******************************************************!*\
  !*** ./ts/common/vector-animation/vectorAnimation.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var prx_1 = __webpack_require__(/*! ../../editor/typings/prx */ "./ts/editor/typings/prx.ts");

var Vectoranimation = function () {
  function Vectoranimation(animationData) {
    this.animationData = animationData;
  }

  Vectoranimation.addPlayButtonProperty = function (item) {
    if (item.type !== 'vectoranimation' || $('#' + item.id + ' #playVectorAnimationprop').length > 0 || $('#' + item.id + ' .bodymovin').length != 1 || typeof $('#' + item.id + ' .bodymovin').attr('data-name') == 'undefined') return false;
    var scale = prx_1.prx.canvas.calculateScaleBasedOnZoom();
    var addRightCSS = (6 - 6 * scale) / scale,
        bottomCSS = (6 - 6 * scale) / scale;
    var animationInstance = BodymovinAnimation.getAnimationInstanceByName(item.id);
    var isPlaying = Boolean(animationInstance);

    if (animationInstance) {
      isPlaying = !animationInstance['_idle'];
    }

    $('<div id="playVectorAnimationprop" class="' + (isPlaying ? 'pause' : '') + '" style="-moz-transform:scale(' + scale + ') ' + 'translate(' + addRightCSS + 'px,' + bottomCSS + 'px);' + '-webkit-transform: scale(' + scale + ') ' + 'translate(' + addRightCSS + 'px,' + bottomCSS + 'px);' + 'transform: scale(' + scale + ') ' + 'translate(' + addRightCSS + 'px,' + bottomCSS + 'px);"></div>').appendTo('#' + item.id).mousedown(function (e) {
      e.stopPropagation();
    }).click(function (e) {
      e.stopPropagation();
      var $this = $(this);
      $this.addClass('disabled');
      BodymovinAnimation.playbackConsole({
        playbackType: 'play',
        rewindIfLastFrame: true,
        target: {
          search: true,
          searchElement: '#' + item.id
        },
        onCompleteEvent: function event() {
          $this.removeClass('disabled');
          this.goToAndStop(1, true);
        }
      });
    });
    return true;
  };

  return Vectoranimation;
}();

exports.Vectoranimation = Vectoranimation;

var BodymovinAnimation = function (_super) {
  __extends(BodymovinAnimation, _super);

  function BodymovinAnimation(bodymovinData) {
    return _super.call(this, bodymovinData) || this;
  }

  BodymovinAnimation.playbackConsole = function (action) {
    switch (action.playbackType) {
      case 'play':
        if (action.target.search) {
          var searchElement = action.target.searchElement;
          $(searchElement).find('.bodymovin').each(function () {
            var animationName = $(this).attr('data-name');
            var animationSpeed = Number($(this).attr('data-speed')) || 1;
            BodymovinAnimation.play(animationName, animationSpeed, action.rewind, action.rewindIfLastFrame);

            if (typeof action.onCompleteEvent != 'undefined') {
              BodymovinAnimation.setOnCompleteEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onCompleteEvent);
            }

            if (typeof action.onDomLoadedEvent != 'undefined') {
              BodymovinAnimation.setOnDomLoadedEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onDomLoadedEvent);
            }

            if (typeof action.onDomLoadedFailedEvent != 'undefined') {
              BodymovinAnimation.setOnDomLoadedFailedEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onDomLoadedFailedEvent);
            }
          });
        } else {
          var animationSpeed = action.speed || 1;
          this.play(action.target.dataName, animationSpeed, action.rewind, action.rewindIfLastFrame);

          if (typeof action.onCompleteEvent != 'undefined') {
            BodymovinAnimation.setOnCompleteEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onCompleteEvent);
          }

          if (typeof action.onDomLoadedEvent != 'undefined') {
            BodymovinAnimation.setOnDomLoadedEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onDomLoadedEvent);
          }

          if (typeof action.onDomLoadedFailedEvent != 'undefined') {
            BodymovinAnimation.setOnDomLoadedFailedEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onDomLoadedFailedEvent);
          }
        }

        break;

      case 'pause':
        if (action.target.search) {
          var searchElement = action.target.searchElement;
          $(searchElement).find('.bodymovin').each(function () {
            var animationName = $(this).attr('data-name');
            BodymovinAnimation.pause(animationName);

            if (typeof action.onCompleteEvent != 'undefined') {
              BodymovinAnimation.setOnCompleteEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onCompleteEvent);
            }

            if (typeof action.onDomLoadedEvent != 'undefined') {
              BodymovinAnimation.setOnDomLoadedEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onDomLoadedEvent);
            }

            if (typeof action.onDomLoadedFailedEvent != 'undefined') {
              BodymovinAnimation.setOnDomLoadedFailedEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onDomLoadedFailedEvent);
            }
          });
        } else {
          this.pause(action.target.dataName);

          if (typeof action.onCompleteEvent != 'undefined') {
            BodymovinAnimation.setOnCompleteEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onCompleteEvent);
          }

          if (typeof action.onDomLoadedEvent != 'undefined') {
            BodymovinAnimation.setOnDomLoadedEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onDomLoadedEvent);
          }

          if (typeof action.onDomLoadedFailedEvent != 'undefined') {
            BodymovinAnimation.setOnDomLoadedFailedEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onDomLoadedFailedEvent);
          }
        }

        break;

      case 'stop':
        if (action.target.search) {
          var searchElement = action.target.searchElement;
          $(searchElement).find('.bodymovin').each(function () {
            var animationName = $(this).attr('data-name');
            BodymovinAnimation.stop(animationName);

            if (typeof action.onCompleteEvent != 'undefined') {
              BodymovinAnimation.setOnCompleteEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onCompleteEvent);
            }

            if (typeof action.onDomLoadedEvent != 'undefined') {
              BodymovinAnimation.setOnDomLoadedEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onDomLoadedEvent);
            }

            if (typeof action.onDomLoadedFailedEvent != 'undefined') {
              BodymovinAnimation.setOnDomLoadedFailedEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onDomLoadedFailedEvent);
            }
          });
        } else {
          this.stop(action.target.dataName);

          if (typeof action.onCompleteEvent != 'undefined') {
            BodymovinAnimation.setOnCompleteEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onCompleteEvent);
          }

          if (typeof action.onDomLoadedEvent != 'undefined') {
            BodymovinAnimation.setOnDomLoadedEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onDomLoadedEvent);
          }

          if (typeof action.onDomLoadedFailedEvent != 'undefined') {
            BodymovinAnimation.setOnDomLoadedFailedEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onDomLoadedFailedEvent);
          }
        }

        break;

      case 'togglePause':
        if (action.target.search) {
          var searchElement = action.target.searchElement;
          $(searchElement).find('.bodymovin').each(function () {
            var animationName = $(this).attr('data-name');
            var animationSpeed = Number($(this).attr('data-speed')) || 1;
            BodymovinAnimation.togglePause(animationName, animationSpeed);

            if (typeof action.onCompleteEvent != 'undefined') {
              BodymovinAnimation.setOnCompleteEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onCompleteEvent);
            }

            if (typeof action.onDomLoadedEvent != 'undefined') {
              BodymovinAnimation.setOnDomLoadedEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onDomLoadedEvent);
            }

            if (typeof action.onDomLoadedFailedEvent != 'undefined') {
              BodymovinAnimation.setOnDomLoadedFailedEvent(BodymovinAnimation.getAnimationInstanceByName(animationName), action.onDomLoadedFailedEvent);
            }
          });
        } else {
          var animationSpeed = action.speed || 1;
          this.togglePause(action.target.dataName, animationSpeed);

          if (typeof action.onCompleteEvent != 'undefined') {
            BodymovinAnimation.setOnCompleteEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onCompleteEvent);
          }

          if (typeof action.onDomLoadedEvent != 'undefined') {
            BodymovinAnimation.setOnDomLoadedEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onDomLoadedEvent);
          }

          if (typeof action.onDomLoadedFailedEvent != 'undefined') {
            BodymovinAnimation.setOnDomLoadedFailedEvent(BodymovinAnimation.getAnimationInstanceByName(action.target.dataName), action.onDomLoadedFailedEvent);
          }
        }

        break;
    }
  };

  BodymovinAnimation.togglePause = function (dataName, animationSpeed) {
    if (typeof dataName == 'undefined' || dataName == '') return false;

    if (animationSpeed != undefined) {
      var animation = BodymovinAnimation.getAnimationInstanceByName(dataName);

      if (animation) {
        animation.setSpeed(animationSpeed);
      }
    }

    return lottie.togglePause(dataName);
  };

  BodymovinAnimation.play = function (dataName, animationSpeed, rewind, rewindIfLastFrame) {
    if (typeof dataName == 'undefined' || dataName == '') return false;
    var animation = BodymovinAnimation.getAnimationInstanceByName(dataName);

    if (rewindIfLastFrame !== undefined && rewindIfLastFrame || rewind !== undefined && rewind) {
      if (animation) {
        animation.setSpeed(animationSpeed);

        if (this.isLastFrame(animation) || rewind !== undefined && rewind) {
          lottie.stop(dataName);
          return lottie.play(dataName);
        } else {
          return lottie.play(dataName);
        }
      } else {
        return lottie.play(dataName);
      }
    } else {
      animation.setSpeed(animationSpeed);
      return lottie.play(dataName);
    }
  };

  BodymovinAnimation.pause = function (dataName) {
    if (typeof dataName == 'undefined' || dataName == '') return false;
    return lottie.pause(dataName);
  };

  BodymovinAnimation.stop = function (dataName) {
    if (typeof dataName == 'undefined' || dataName == '') return false;
    return lottie.stop(dataName);
  };

  BodymovinAnimation.goToFrameAndPlay = function (frame, dataName) {
    if (typeof dataName == 'undefined' || dataName == '') return false;
    var anim = BodymovinAnimation.getAnimationInstanceByName(dataName);

    if (anim != undefined && anim) {
      anim = anim;
      return anim.goToAndPlay(frame);
    }

    return false;
  };

  BodymovinAnimation.isLastFrame = function (animation) {
    if (Math.round(animation.totalFrames) - animation.currentFrame < 1.5) return true;
    return false;
  };

  BodymovinAnimation.setOnCompleteEvent = function (animation, action) {
    if (_typeof(animation) !== 'object') return;
    animation.addEventListener('complete', action.bind(animation));
  };

  BodymovinAnimation.setOnDomLoadedEvent = function (animation, action) {
    if (_typeof(animation) !== 'object') return;
    animation.addEventListener('DOMLoaded', action.bind(animation));
  };

  BodymovinAnimation.setOnDomLoadedFailedEvent = function (animation, action) {
    if (_typeof(animation) !== 'object') return;
    animation.addEventListener('data_failed', action.bind(animation));
  };

  BodymovinAnimation.getBodymovinAssetInfoFromIAMData = function (assetFileId) {
    var assetInfo = prx_1.prx.iam.currentData().filter(function (asset) {
      return asset['file-id'] === assetFileId;
    });
    if (assetInfo.length > 0) return assetInfo[0];else return false;
  };

  BodymovinAnimation.resetDimensions = function (item, multiplier, doNotAppendHistory, callback) {
    if (multiplier === void 0) {
      multiplier = 1;
    }

    if (doNotAppendHistory === void 0) {
      doNotAppendHistory = false;
    }

    if (callback === void 0) {
      callback = null;
    }

    item.autoResize = true;
    var assetFileId = item.imgSrc.fileId;
    var itemAssetDetails = BodymovinAnimation.getBodymovinAssetInfoFromIAMData(assetFileId);

    if (itemAssetDetails) {
      item.width = itemAssetDetails['width'];
      item.height = itemAssetDetails['height'];
    } else {
      item.width = 200 * prx_1.prx.devices[prx_1.prx.device].dpr;
      item.height = 200 * prx_1.prx.devices[prx_1.prx.device].dpr;
    }

    if (typeof item.aspectratio != 'undefined' && item.aspectratio !== false) {
      item.aspectratio = true;
    }

    prx_1.prx.items.update(item, false);
    prx_1.prx.editingtools.select.refreshSelection();
    prx_1.prx.itemBrowser.refresh();
    prx_1.prx.states.checkBuildTimeline(item.id, ['width', 'height']);
    prx_1.prx.screenshots.addIconToOutdated();

    if (!doNotAppendHistory) {
      prx_1.prx.history.reset();
      prx_1.prx.history.append();
    }

    try {
      if (callback) {
        callback();
      }
    } catch (ex) {}

    return item;
  };

  BodymovinAnimation.registerAnimationOnItem = function (item) {
    if (item.type === 'vectoranimation' && prx_1.prx.componentsHelper.getProp(item.imgSrc.fileId, 'other') !== 'd310bece0e91b91b485ed62166d1fc2e.svg' && prx_1.prx.componentsHelper.getProp(item.imgSrc.fileId, 'other') !== '') {
      BodymovinAnimation.registerAnimation($('#' + item.id + '-bodymovin')[0]);
    }
  };

  BodymovinAnimation.registerAnimation = function (domElem) {
    lottie.registerAnimation(domElem);
  };

  BodymovinAnimation.destroyAnimation = function (domElem) {
    lottie.destroy(domElem);
  };

  BodymovinAnimation.searchAndRegisterAnimations = function (domSelector) {
    $(domSelector).each(function () {
      BodymovinAnimation.registerAnimation($(this)[0]);
    });
  };

  BodymovinAnimation.loadAnimation = function (animationData) {
    return lottie.loadAnimation(animationData);
  };

  BodymovinAnimation.getAllRegisteredAnimations = function () {
    return lottie.getRegisteredAnimations();
  };

  BodymovinAnimation.getAnimationInstanceByName = function (name) {
    return lottie.getRegisteredAnimations().find(function (instance) {
      return instance.name === name;
    });
  };

  BodymovinAnimation.loadBodymovinPageAnimations = function (pageId) {
    if (pageId.indexOf('#') === -1) {
      pageId = '#' + pageId;
    }

    $(pageId).find('.bodymovin-player').each(function () {
      var $this = $(this);

      if (typeof $this.attr('data-name') != 'undefined' && $this.attr('data-name') != '') {
        var animeData = {
          container: $this[0],
          renderer: 'svg',
          loop: $this.attr('data-anim-loop') == 'true',
          autoplay: $this.attr('data-anim-autoplay') == 'true',
          name: $this.attr('data-name'),
          speed: Number($this.attr('data-speed'))
        };
        var fileId = $this.attr('data-fileid');
        var bmPath = $this.attr('data-bm-path');
        var isValidAnimation = typeof fileId !== 'undefined' && fileId.length > 0 && typeof prx_1.prx.bodymovinAnimation.assets[fileId] !== 'undefined' && prx_1.prx.bodymovinAnimation.assets[fileId] != '' || typeof bmPath != 'undefined' && bmPath.length > 0;
        if (!isValidAnimation) return;

        if (typeof fileId !== 'undefined' && fileId.length > 0 && typeof prx_1.prx.bodymovinAnimation.assets[fileId] !== 'undefined') {
          animeData['animationData'] = JSON.parse(prx_1.prx.bodymovinAnimation.assets[fileId]);
        } else {
          animeData['path'] = $this.attr('data-bm-path');
        }

        lottie.destroy(animeData.name);
        var anim = prx_1.prx.bodymovinAnimation.loadAnimation(animeData);
        anim.setSpeed(Number($this.attr('data-speed')));
        BodymovinAnimation.setOnCompleteEvent(anim, function () {
          $('#' + $this.attr('data-name')).trigger('vectoranimationend');
        });
      }
    });
  };

  BodymovinAnimation.loadBodymovinAnimationsContainedInElement = function (contentClass, autoplay, loop, loopDelay, speed, quality) {
    $(contentClass).find('.bodymovin').each(function () {
      var $this = $(this);
      var dataName = $this.attr('data-name');

      if (typeof dataName != 'undefined' && dataName != '') {
        lottie.destroy(dataName);
        var animeData = {
          container: $this[0],
          renderer: 'svg',
          loop: loop && loopDelay || loop,
          autoplay: autoplay,
          name: dataName,
          speed: speed || 1,
          quality: quality || 'high'
        };
        var fileId = $this.attr('data-fileid');

        if (typeof fileId !== 'undefined' && fileId.length > 0 && typeof prx_1.prx.bodymovinAnimation.assets[fileId] !== 'undefined') {
          animeData['animationData'] = JSON.parse(prx_1.prx.bodymovinAnimation.assets[fileId]);
        } else {
          animeData['path'] = $this.attr('data-bm-path');
        }

        var anim = prx_1.prx.bodymovinAnimation.loadAnimation(animeData);

        if (loopDelay !== undefined) {
          BodymovinAnimation.setOnCompleteEvent(anim, function () {
            BodymovinAnimation.goToFrameAndPlay(1, dataName);
          });
        }
      }
    });
  };

  BodymovinAnimation.destroyBodymovinAnimationsContainedInElement = function (contentClass) {
    $(contentClass).find('.bodymovin').each(function () {
      if (typeof $(this).attr('data-name') != 'undefined' || $(this).attr('data-name') != '') lottie.destroy($(this).attr('data-name'));
    });
  };

  BodymovinAnimation.getCrossDomainURLforBodymovinAsset = function (assetUrl) {
    var prgss = prx_1.prx.editor ? prx_1.prx.prgss : '';

    if (prx_1.prx.editor) {
      if (assetUrl.indexOf('?') === -1) {
        return assetUrl + '?prgss=' + prgss;
      } else {
        return assetUrl + '&prgss=' + prgss;
      }
    } else {
      return assetUrl;
    }
  };

  return BodymovinAnimation;
}(Vectoranimation);

exports.BodymovinAnimation = BodymovinAnimation;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./ts/common/vector-animation/vectorAnimationAPI.ts":
/*!**********************************************************!*\
  !*** ./ts/common/vector-animation/vectorAnimationAPI.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var prx_1 = __webpack_require__(/*! ../../editor/typings/prx */ "./ts/editor/typings/prx.ts");

var utils_1 = __webpack_require__(/*! ./utils */ "./ts/common/vector-animation/utils.ts");

var vectorAnimation_1 = __webpack_require__(/*! ./vectorAnimation */ "./ts/common/vector-animation/vectorAnimation.ts");

if (prx_1.prx.bodymovinAnimation === undefined) prx_1.prx.bodymovinAnimation = {};
if (prx_1.prx.vectoranimation === undefined) prx_1.prx.vectoranimation = {};
if (prx_1.prx.vectorAnimationUtils === undefined) prx_1.prx.vectorAnimationUtils = {};
prx_1.prx.bodymovinAnimation.assets = {};

prx_1.prx.vectorAnimationUtils.isValidBodyMovin = function (data) {
  return utils_1.BodymovinAnimationUtils.isValidBodyMovin(data);
};

prx_1.prx.bodymovinAnimation.resetDimensions = function (item, multiplier, doNotAppendHistory, callback) {
  return vectorAnimation_1.BodymovinAnimation.resetDimensions(item, multiplier, doNotAppendHistory, callback);
};

prx_1.prx.bodymovinAnimation.registerAnimation = function (domElem) {
  return vectorAnimation_1.BodymovinAnimation.registerAnimation(domElem);
};

prx_1.prx.bodymovinAnimation.registerAnimationOnItem = function (item) {
  return vectorAnimation_1.BodymovinAnimation.registerAnimationOnItem(item);
};

prx_1.prx.bodymovinAnimation.destroyAnimation = function (domElem) {
  return vectorAnimation_1.BodymovinAnimation.destroyAnimation(domElem);
};

prx_1.prx.bodymovinAnimation.searchAndRegisterAnimations = function (domSelector) {
  return vectorAnimation_1.BodymovinAnimation.searchAndRegisterAnimations(domSelector);
};

prx_1.prx.bodymovinAnimation.loadAnimation = function (animationData) {
  return vectorAnimation_1.BodymovinAnimation.loadAnimation(animationData);
};

prx_1.prx.bodymovinAnimation.getAllRegisteredAnimations = function () {
  return vectorAnimation_1.BodymovinAnimation.getAllRegisteredAnimations();
};

prx_1.prx.bodymovinAnimation.getAnimationInstanceByName = function (name) {
  return vectorAnimation_1.BodymovinAnimation.getAnimationInstanceByName(name);
};

prx_1.prx.bodymovinAnimation.getBodymovinAssetInfoFromIAMData = function (fileId) {
  return vectorAnimation_1.BodymovinAnimation.getBodymovinAssetInfoFromIAMData(fileId);
};

prx_1.prx.bodymovinAnimation.loadBodymovinPageAnimations = function (pageId) {
  return vectorAnimation_1.BodymovinAnimation.loadBodymovinPageAnimations(pageId);
};

prx_1.prx.bodymovinAnimation.loadBodymovinAnimationsContainedInElement = function (contentClass, autoplay, loop) {
  return vectorAnimation_1.BodymovinAnimation.loadBodymovinAnimationsContainedInElement(contentClass, autoplay, loop);
};

prx_1.prx.bodymovinAnimation.destroyBodymovinAnimationsContainedInElement = function (contentClass) {
  return vectorAnimation_1.BodymovinAnimation.destroyBodymovinAnimationsContainedInElement(contentClass);
};

prx_1.prx.bodymovinAnimation.handleBodymovinAnimationsInRightPanel = function (contentClass, action, loopDelay, speed, quality) {
  if (action === 'enable') {
    return vectorAnimation_1.BodymovinAnimation.loadBodymovinAnimationsContainedInElement(contentClass, true, true, loopDelay, speed, quality);
  } else {
    return vectorAnimation_1.BodymovinAnimation.destroyBodymovinAnimationsContainedInElement(contentClass);
  }
};

prx_1.prx.bodymovinAnimation.getCrossDomainURLforBodymovinAsset = function (assetUrl) {
  return vectorAnimation_1.BodymovinAnimation.getCrossDomainURLforBodymovinAsset(assetUrl);
};

prx_1.prx.vectoranimation.addPlayButtonProperty = function (item) {
  return vectorAnimation_1.Vectoranimation.addPlayButtonProperty(item);
};

prx_1.prx.bodymovinAnimation.playbackConsole = function (action) {
  return vectorAnimation_1.BodymovinAnimation.playbackConsole(action);
};

/***/ }),

/***/ "./ts/editor/typings/prx.ts":
/*!**********************************!*\
  !*** ./ts/editor/typings/prx.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var extPrx;

(function (extPrx) {
  extPrx.prx1 = prx;
  extPrx.prxy1 = prxy;
})(extPrx || (extPrx = {}));

exports.prx = extPrx.prx1;
exports.prxy = extPrx.prxy1;
var extPff;

(function (extPff) {
  if (typeof pff !== 'undefined') {
    extPff.pff1 = pff;
  }
})(extPff || (extPff = {}));

exports.pff = extPff.pff1;
var extPlupload;

(function (extPlupload) {
  if (typeof plupload !== 'undefined') {
    extPlupload.plupload1 = plupload;
  }

  if (typeof mOxie !== 'undefined') {
    extPlupload.moxie1 = mOxie;
  }
})(extPlupload || (extPlupload = {}));

exports.plupload = extPlupload.plupload1;
exports.moxie = extPlupload.moxie1;

/***/ })

/******/ });